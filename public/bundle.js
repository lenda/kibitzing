(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (Buffer){
const PDFJS = require('pdfjs-dist');

var data = new Uint8Array(Buffer("JVBERi0xLjYNJeLjz9MNCjg1MzYgMCBvYmoNPDwvTGluZWFyaXplZCAxL0wgOTgyMzIwL08gODUzOS9FIDM0NzY2L04gMTE5L1QgOTgwNTg5L0ggWyA4MTAgMTgwNF0+Pg1lbmRvYmoNICAgICAgICAgDQo4NTU4IDAgb2JqDTw8L0RlY29kZVBhcm1zPDwvQ29sdW1ucyA0L1ByZWRpY3RvciAxMj4+L0ZpbHRlci9GbGF0ZURlY29kZS9JRFs8MjU1OUU3RTMzREI1MkYzRDNGMDZBODExMzJGRjI5RjY+PDE1NUQxMEUwRTlBRkIyNDk4NUVEODVDMDk1M0QyQTQ4Pl0vSW5kZXhbODUzNiAxNDZdL0luZm8gODUzNSAwIFIvTGVuZ3RoIDExNi9QcmV2IDk4MDU5MC9Sb290IDg1MzcgMCBSL1NpemUgODY4Mi9UeXBlL1hSZWYvV1sxIDIgMV0+PnN0cmVhbQ0KaN5iYmQQYGBi4FIDEow/gASDGZBgugwk2IqBhEAUkBCcAiQ4jYCEeB5IcRtIMUgJy14gwSwD4zJ2gvS2gFjNIEIPSPDkg4xaBzLgG5CoTGNgYlR8AbKIgZFWhMA7mho/SgxCgnEuEvf/o73/AAIMADWQFFMNCmVuZHN0cmVhbQ1lbmRvYmoNc3RhcnR4cmVmDQowDQolJUVPRg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KODY4MSAwIG9iag08PC9DIDMwMDYvRmlsdGVyL0ZsYXRlRGVjb2RlL0kgMzAzMC9MZW5ndGggMTcwMy9PIDI5OTAvUyAyODI3Pj5zdHJlYW0NCmje7FZ7bFP1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cKe5EOiB4XEXB2a5f8Ksb8w6ISr6oNnRoOUp60TOpaEpwXjQ/ap2VVUqWoNI3V28z6sq37CLv5LVumLfL96/zx/YnYRfmJVopqii3+sy+CnPK+ToWEDYOHcFjivnnA+k1b8CDAASbZUDDQplbmRzdHJlYW0NZW5kb2JqDTE3IDAgb2JqDTw8L0xlbmd0aCAyND4+c3RyZWFtDQr09fX29vf4+Pn5+fr6+/v8/Pz9/f3///8NCmVuZHN0cmVhbQ1lbmRvYmoNMTggMCBvYmoNPDwvTGVuZ3RoIDIxPj5zdHJlYW0NCvb29/j4+fn5+vr7+/z8/P39/f///w0KZW5kc3RyZWFtDWVuZG9iag0xOSAwIG9iag08PC9CaXRzUGVyQ29tcG9uZW50IDgvQ29sb3JTcGFjZSA1MTAgMCBSL0ZpbHRlci9GbGF0ZURlY29kZS9IZWlnaHQgNy9MZW5ndGggMjAvU3VidHlwZS9JbWFnZS9UeXBlL1hPYmplY3QvV2lkdGggMzI+PnN0cmVhbQ0KaN5SlldQHkWjaLAigAADAMKwVcENCmVuZHN0cmVhbQ1lbmRvYmoNMjAgMCBvYmoNPDwvQml0c1BlckNvbXBvbmVudCA4L0NvbG9yU3BhY2UgNTM1IDAgUi9GaWx0ZXIvRmxhdGVEZWNvZGUvSGVpZ2h0IDkvTGVuZ3RoIDM0L1N1YnR5cGUvSW1hZ2UvVHlwZS9YT2JqZWN0L1dpZHRoIDM5Pj5zdHJlYW0NCmjeYmAgCjASB5iIA8zEARbiACtxgI04wE5VABBgAF81BVYNCmVuZHN0cmVhbQ1lbmRvYmoNMjEgMCBvYmoNPDwvQml0c1BlckNvbXBvbmVudCA4L0NvbG9yU3BhY2UgNTEwIDAgUi9GaWx0ZXIvRmxhdGVEZWNvZGUvSGVpZ2h0IDMyL0xlbmd0aCAxOS9TdWJ0eXBlL0ltYWdlL1R5cGUvWE9iamVjdC9XaWR0aCA2Pj5zdHJlYW0NCmjeUpZXUB5Fo4hcBBBgAN4OSYENCmVuZHN0cmVhbQ1lbmRvYmoNMjIgMCBvYmoNPDwvQml0c1BlckNvbXBvbmVudCA4L0NvbG9yU3BhY2UgNTA5IDAgUi9GaWx0ZXIvRmxhdGVEZWNvZGUvSGVpZ2h0IDEyOS9MZW5ndGggMTQyMy9TdWJ0eXBlL0lt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iBaL+SwGMB5l/mn9P+CPyx/L3+72Q386WyxXq/V6o8+3Xq9Wy0UMYBL+7Watmr6+b/nj9sTyNzv9YejPF6v1ZrvdqYi22816tZhPb8fDfqcV1z9dn3T8X/jz29NodQej0F+u1tvdfn+nItrvd9vNapn8B912XP/s+rzwf/uWTn/cnma7F8s/W6w2293d3eFeRXQ43O3DfzG7nQzz63M6/mf+7zl/uj1p+WP394F/PD7o8x2P9yf/6e2o34m35+np+Zo/vrzx7ukO0vLH5Un6D3+piGICyX+9nKXrkx//d/zZszPxz5eb3f5wH/iPKqIYQPjvNqv5dDLspqfnx/zx7BxOpnH5d3f3x8B/UhHFAB7uD/ttXJ90/Bu169PL8x1/L/HH5T/E5Xl8+peK6OkxrX9cn/j4XvB/feZPz/5a4s9Of/Dn+v/Wp8v8j/d3u3T8R9nT53f8y3V+e57oF+Sf1j/4N4m//1v+0Wt+cn+Av4MfP378+PHjx48fP378+PHjx48fv/DjF378wo9f+PELP37hxy/8+IUfP378+PHjx48fP378+PHjx48fP378+PHjxy/8+IUfv/DjF378wo9f+PELP37hxy/8+PHjx48fP378+PHjx48fP378+PHjx48fP37hxy/8+IUfv/DjF378wo9f+PELP37hx48fP378+PHjx48fP378+PHjx48fP35y+PELP37hxy/8+IUfv/DjF378wo9f+PHjx48fP378+PHjx48fP378+PHjx48fP378wo9f+PELP37hxy/8+IUfv/DjF378wo8fP378+PHjx48fP378+PHjx48fP378+PHjF378wo9f+PELP37hxy/8+IUfv/Djx48fP378+PHjx48fP378+PHjx48fP378+IUfv/DjF378wo9f+PELP37hxy/8+IUfP378+PHjx48fP378+PHjx48fP378+PHjxy/8+IUfv/DjF378wo9f+PELP37hxy/8+PHjx48fP378+PHjx48fP378+PHjx48fP37hxy/8+IUfv/DjF378wo9f+PELP378+PHjx48fP378+PHjx48fP378+PHjx49f+PELP37hxy/8+IUfv/DjF378wo9f+PHjx48fP378+PHjx48fP378+PHjx48fP378wo9f+PELP37hxy/8+IUfv/DjF378wo8fP378+PHjx48fP378+PHj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n0pOIhmJBEQCIgGRgEhAJCASEIlIEIlIQCQgEhAJiAREAiIBkYBIRIJIRAIiAZGASEAkIBIQCYhEJIhEJCASEAmIBEQCIgGRgEhEgkhEAiIBkYBIQCQgEhAJiAREIhJEIhIQCYgERAIiAZGASEAkIkEkIgGRgEhAJCASEAmIBEQiEkQiEhAJiAREAiIBkYBIQCQgEpGASEAkIBIQCYgERAIiAZGIBJGIBEQCIgGRgEhAJCASEIlIEIlIQCQgEhAJiAREAiIBkYBIRAIiAZGASEAkIBIQCYgERCISRCISEAmIBEQCIgGRgEhAJCJBJCIBkYBIQCQgEhAJiAREAiIRCYgERAIiAZGASEAkIBIQiUgQiUhAJCASEAmIBEQCIgGRiASRiAREAiIBkYBIQCQgEhAJiEQkIBIQCYgERAIiAZGASEAkIkEkIgGRgEhAJCASEAmIBEQiEkQiEhAJiAREAiIBkYBIQCQgEpGASEAkIBIQCYgERAIiAZGIBJGIBEQCIgGRgEhAJCASEIlIEIlIQCQgEhAJiAREAiIBkYBIRAIiAZGASEAkIBIQCYgERCISRCISEAmIBEQCIgGRgEhAJCJBJCIBkYBIQCQgEhAJiARE4sshEpGASEAkIBIQCYgERAIiAZGIBJGIBEQCIgGRgEhAJCASEIlIEIlIQCQgEhAJiAREAiIBkYgEkYgERAIiAZGASEAkIBIQCYhEJIhEJCASEAmIBEQCIgGRgEhEgkhEAiIBkYBIQCQgEhAJiEQkiEQkIBIQCYgERAIiAZGASEAkIkEkIgGRgEhAJCASEAmIBEQiEkQiEhAJiAREAiIBkYBIQCQiQSQiAZGASEAkIBIQCYgERAIiEQkiEQmIBEQCIgGRgEhAJCASkSASkYBIQCQgEhAJiAREAiIRCSIRCYgERAIiAZGASEAkIBIQiUhAJCASEAmIBEQCIgGRgEhEgkhEAiIBkYBIQCQgEhAJiEQkiEQkIBIQCYgERAIiAZGASEAkIgGRgEhAJCASEAmIBEQCIhEJIhEJiAREAiIBkYBIQCQgEpEgEpGASEAkIBIQCYgERAIiAZGIBEQCIgGRgEhAJCASEAmIRCSIRCQgEhAJiAREAiIBkYBIRIJIRAIiAZGASEAkIBIQCYgERCISEAmIBEQCIgGRgEhAJCASkSASkYBIQCQgEhAJiAREAiIRCSIRCYgERAIiAZGASEAkIBIQiUhAJCASEAmIBEQCIgGRgEhEgkhEAiIBkYBIQCQgEhAJiEQkiEQkIBIQCYgERAIiAZGASEAkIgGRgEhAJCASEAmIBEQCIhEJIhEJiAREAiIBkYBIQCQgEpEgEpGASEAkIBIQCYgERAIi8eUQiUhAJCASEAmIBEQCIgGRgEhEgkhEAiIBkYBIQCQgEhAJiEQkiEQkIBIQCYgERAIiAZGASESCSEQCIgGRgEhAJCASEAmIBEQiEkQiEhAJiAREAiIBkYBIQCQiQSQiAZGASEAkIBIQCYgERCISRCISEAmIBEQCIgGRgEhAJCASkSASkYBIQCQgEhAJiAREAiIRCSIRCYgERAIiAZGASEAkIBKRIBKRgEhAJCASEAmIBEQCIgGRiASRiAREAiIBkYBIQCQgEhCJSBCJSEAkIBIQCYgERAIiAZGIBJGIBEQCIgGRgEhAJCASEAmIRCQgEhAJiAREAiIBkYBIQCQiQSQiAZGASEAkIBIQCYgERCISRCISEAmIBEQCIgGRgEhAJCASkYBIQCQgEhAJiAREAiIBkYgEkYgERAIiAZGASEAkIBIQiUgQiUhAJCASEAmIBEQCIgGRgEhEAiIBkYBIQCQgEhAJiAREIhJEIhIQCYgERAIiAZGASEAkIkEkIgGRgEhAJCASEAmIBEQCIhEJiAREAiIBkYBIQCQgEhCJSBCJSEAkIBIQCYgERAIiAZGIBJGIBEQCIgGRgEhAJCASEAmIRCQgEhAJiAREAiIBkYBIQCQiQSQiAZGASEAkIBIQCYgERCISRCISEAmIBEQCIgGRgEhAJCASkYBIQCQgEhAJiAREAiIBkYgEkYgERAIiAZGASEAkIBIQiUgQiUhAJCASEAmIBEQCIgGR+HKIRCQgEhAJiAREAiIBkYBIQCQiQSQiAZGASEAkIBIQCYgERCISRCISEAmIBEQCIgGRgEhAJCJBJCIBkYBIQCQgEhAJiAREAiIRCSIRCYgERAIiAZGASEAkIBKRIBKRgEhAJCASEAmIBEQCIhEJIhEJiAREAiIBkYBIQCQgEhCJSBCJSEAkIBIQCYgERAIiAZGIBJGIBEQCIgGRgEhAJCASEIlIEIlIQCQgEhAJiAREAiIBkYBIRIJIRAIiAZGASEAkIBIQCYhEJIhEJCASEAmIBEQCIgGRgEhEgkhEAiIB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MgGZgExkgkxkAjIBmYBMQCYgE5AJyEQmyEQmIBOQCcgEZAIyAZmATGSCTGQCMgGZgExAJiATkAnIRCYgE5AJyARkAjIBmYBMZIJMZAIyAZmATEAmIBOQCchEJshEJiATkAnIBGQCMgGZgExkgkxkAjIBmYBMQCYgE5AJyEQmyEQmIBOQCcgEZAIyAZmATGQCMgGZgExAJiATkAnIBGQiE5AJyARkAjIBmYBMQCYyQSYyAZmATEAmIBOQCcgEZCITZCITkAnIBGQCMgGZgExAJjJBJjIBmYBMQCYgE5AJyARkIhNkIhOQCcgEZAIyAZmATEAmMgGZgExAJiATkAnIBGQiE2QiE5AJyARkAjIBmYBMQCYyQSYyAZmATEAmIBOQCcgEZCITZCITkAnIBGQCMgGZgExAJjJBJjIBmYBMQCYgE5AJyARkIhOQCcgEZAIyAZmATEAmIBOZgExAJiATkAnIBGQCMpEJMpEJyARkAjIBmYBMQCYgE5kgE5mATEAmIBOQCcgEZAIykQkykQnIBGQCMgGZgExAJiATmSATmYBMQCYgE5AJyARkAjKRCcgEZAIyAZmATEAmIBOZIBOZgExAJiATkAnIBGQCMpEJMpEJyARkAjIBmYBMQCYgE5kgE5mATEAmIBOQCcgEZAIykQkykQnIBGQCMgGZgExAJiATmYBMQCYgE5AJyARkAjIBmcgEZAIyAZmATEAmIBOQiUyQiUxAJiATkAnIBGQCMgGZyASZyARkAjIBmYBMQCYgE5CJTJCJTEAmIBOQCcgEZAIyAZnIBJnIBGQCMgGZgExAJiATkIlMQCYgE5AJyARkAjIBmcgEmcgEZAIyAZmATEAmIBOQiUyQiUxAJiATkAnIBGQCMgGZyASZyARkAjIBmYBMQCYgE5CJTJCJTEAmIBOQCcgEZAIyAZnIBGQCMgGZgExAJiATkAnIRCYgE5AJyARkAjIBmYBMZIJMZAIyAZmATEAmIBOQCchEJshEJiATkAnIBGQCMgGZgExkgkxkAjIBmYBMQCYgE5AJyEQmyEQmIBOQCcgEZAIyAZmATGQCMgGZgExAJiATkAnIRCbIRCYgE5AJyARkAjIBmYBMZIJMZAIyAZmATEAmIBOQCchEJshEJiATkAnIBGQCMgGZgExkgkxkAjIBmYBMQCYgE5AJyEQmIBOQCcgEZAIyAZmATEAmMgGZgExAJiATkAnIBGQiE2QiE5AJyARkAjIBmYBMQCYyQSYyAZmATEAmIBOQCcgEZCITZCITkAnIBGQCMgGZgExAJjJBJjIBmYBMQCYgE5AJyARkIhOQCcgEZAIyAZmATEAmMkEmMgGZgExAJiATkAnIBGQiE2QiE5AJyARkAjIBmYBMQCYyQSYyAZmATEAmIBOQCcgEZCITZCITkAnIBGQCMgGZgExAJjIBmYBMQCYgE5AJyARkAjKRCcgEZAIyAZmATEAmIBOZIBOZgExAJiATkAnIBGQCMpEJMpEJyARkAjIBmYBMQCYgE5kgE5mATEAmIBOQCcgEZAIykQkykQnIBGQCMgGZgExAJiATmYBMQCYgE5AJyARkAjKRCTKRCcgEZAIyAZmATEAmIBOZIBOZgExAJiATkAnIBGQCMpEJMpEJyARkAjIBmYBMQCYgE5kgE5mATEAmIBOQCcgEZAIykQnIBGQCMgGZgExAJiATkIlMQCYgE5AJyARkAjIBmcgEmcgEZAIyAZmATEAmIBOQiUyQiUxAJiATkAnIBGQCMgGZyASZyARkAjIBmYBMQCYgE5CJTJCJTEAmIBOQCcgEZAIyAZnIBGQCMgGZgExAJiATkIlMkIlMQCYgE5AJyARkAjIBmcgEmcgEZAIyAZmATEAmIBOQiUyQiUxAJiATkAnIBGQCMgGZyASZyARkAjIBmYBMQCYgE5CJTEAmIBOQCcgEZAIyAZmATGQCMgGZgExAJiATkAnIRCbIRCYgE5AJyARkAjIBmYBMZIJMZAIyAZmATEAmIBOQCchEJshEJiATkAnIBGQCMgGZgExkgkxkAjIBmYBMQCYgE5AJyEQmIBOQCcgEZAIyAZmATGSCTGQCMgGZgExAJiATkAnIRCbIRCYgE5AJyARkAjIBmYBMZIJMZAIyAZmATEAmIBOQCchEJshEJiATkAnIBGQCMgGZgExkAjIBmYBMQCYgE5AJyARkIhOQCcgEZAIyAZmATEAmMkEmMgGZgExAJiATkAnIBGQiE2QiE5AJyARkAjIBmYBMQCYyQSYyAZmATEAmIBOQCcgEZCITZCITkAnIBGQCMgGZgExAJjIBmYBMQCYgE5AJyARkIhNkIhOQCcgEZAIyAZmATEAmMkEmMgGZgExAJiATkAnIBGQiE2QiE5AJyARkAjIBmYBMQCYyQSYyAZmA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TWL8Pgm/HMUm8bNKYlUl0ZAEkpAESAIkAZIASYAkQBIgCZAESAIkAZIASYAkQBIgCZCEJJCEJJCEJJCEJJCEJEASIAmQBEgCJAGSAEmAJEASIAmQBEgCJAGSAEmAJCSBJCSBJCSBJCQBkgBJgCRAEiAJkARIAiQBkgBJgCRAEiAJkARIAiQBkpAEkpAEkpAEkpAESAIkAZIASYAkQBIgCZAESAIkAZIASYAkQBIgCZAESEISSEISSEISSEISIAmQBEgCJAGSAEmAJEASIAmQBEgCJAGSAEmAJEASIAlJIAlJIAlJIAlJgCRAEiAJkARIAiQBkgBJgCRAEiAJkARIAiQBkgBJgCQkgSQkgSQkgSQkAZIASYAkQBIgCZAESAIkAZIASYAkQBIgCZAESAIkIQkkIQkkIQkkIQkkIQmQBEgCJAGSAEmAJEASIAmQBEgCJAGSAEmAJEASIAlJIAlJIAlJIAlJIAlJgCRAEiAJkARIAiQBkgBJgCRAEiAJkARIAiQBkgBJSAJJSAJJSAJJSAIkAZIASYAkQBIgCZAESAIkAZIASYAkQBIgCZAESAIkIQkkIQkkIQkkIQmQBEgCJAGSAEmAJEASIAmQBEgCJAGSAEmAJEASIAmQhCSQhCSQhCSQhCRAEiAJkARIAiQBkgBJgCRAEiAJkARIAiQBkgBJgCRAEpJAEpJAEpJAEpIASYAkQBIgCZAESAIkAZIASYAkQBIgCZAESAIkAZLwyyEJSSAJSSAJSSAJSYAkQBIgCZAESAIkAZIASYAkQBIgCZAESAIkAZIASUgCSUgCSUgCSUgCSUgCJAGSAEmAJEASIAmQBEgCJAGSAEmAJEASIAmQBEhCEkhCEkhCEkhCEiAJkARIAiQBkgBJgCRAEiAJkARIAiQBkgBJgCRAEiAJSSAJSSAJSSAJSYAkQBIgCZAESAIkAZIASYAkQBIgCZAESAIkAZIASYAkJIEkJIEkJIEkJAGSAEmAJEASIAmQBEgCJAGSAEmAJEASIAmQBEgCJAGSkASSkASSkASSkARIAiQBkgBJgCRAEiAJkARIAiQBkgBJgCRAEiAJkARIQhJIQhJIQhJIQhIgCZAESAIkAZIASYAkQBIgCZAESAIkAZIASYAkQBKSQBKSQBKSQBKSQBKSAEmAJEASIAmQBEgCJAGSAEmAJEASIAmQBEgCJAGSkASSkASSkASSkASSkARIAiQBkgBJgCRAEiAJkARIAiQBkgBJgCRAEiAJkIQkkIQkkIQkkIQkQBIgCZAESAIkAZIASYAkQBIgCZAESAIkAZIASYAkQBKSQBKSQBKSQBKSAEmAJEASIAmQBEgCJAGSAEmAJEASIAmQBEgCJAGSAElIAklIAklIAklIAiQBkgBJgCRAEiAJkARIAiQBkgBJgCRAEiAJkARIAiQhCSQhCSQhCSQhCZAESAIkAZIASYAkQBIgCZAESAIkAZIASYAkQBIgCb8ckpAEkpAEkpAEkpAESAIkAZIASYAkQBIgCZAESAIkAZIASYAkQBIgCZCEJJCEJJCEJJCEJJCEJEASIAmQBEgCJAGSAEmAJEASIAmQBEgCJAGSAEmAJCSBJCSBJCSBJCQBkgBJgCRAEiAJkARIAiQBkgBJgCRAEiAJkARIAiQBkpAEkpAEkpAEkpAESAIkAZIASYAkQBIgCZAESAIkAZIASYAkQBIgCZAESEISSEISSEISSEISIAmQBEgCJAGSAEmAJEASIAmQBEgCJAGSAEmAJEASIAlJIAlJIAlJIAlJgCRAEiAJkARIAiQBkgBJgCRAEiAJkARIAiQBkgBJgCQkgSQkgSQkgSQkAZIASYAkQBIgCZAESAIkAZIASYAkQBIgCZAESAIkIQkkIQkkIQkkIQkkIQmQBEgCJAGSAEmAJEASIAmQBEgCJAGSAEmAJEASIAlJIAlJIAlJIAlJIAlJgCRAEiAJkARIAiQBkgBJgCRAEiAJkARIAiQBkgBJSAJJSAJJSAJJSAIkAZIASYAkQBIgCZAESAIkAZIASYAkQBIgCZAESAIkIQkkIQkkIQkkIQmQBEgCJAGSAEmAJEASIAmQBEgCJAGSAEmAJEASIAmQhCSQhCSQhCSQhCRAEiAJkARIAiQBkgBJgCRAEiAJkARIAiQBkgBJgCRAEpJAEpJAEpJAEpIASYAkQBIgCZAESAIkAZIASYAkQBIgCZAESAIkAZLwyyEJSSAJSSAJSSAJSYAkQBIgCZAESAIkAZIASYAkQBIgCZAESAIkAZIASUgCSUgCSUgCSUgCSUgCJAGSAEmAJEASIAmQBEgCJAGSAEmAJEASIAmQBEhCEkhCEkhCEkhCEiAJkARIAiQBkgBJgCRAEiAJkARIAiQBkgBJgCRAEiAJSSAJSSAJSSAJSYAk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c/R+J3bca+2n1UnbnU7nSen6GHu43i+xuGq30Z5jT1aTmrLX6/uaXq8ns7wtV+6Vti72aH3qyhkEg8Fg6GP07iCQ2LzGddoL7MnqqIGYYThSxt7FXh2GQwP3Tlqr9hJbW0UdyjmOojiOJ/5Fr44jmc3b60p7Va1N8ckaDEJJ40mSpGnmZdI0kTkS12mvqj0W22o76ziaJGk2nc2e/cxsNs3kjccjaZ86GuS62hPWFdvudPuyxqIadL7wM/O5wNMsUbmmrQf5GuuKNWs2Nekyzwsfk+fL5UJcacfhoN9Vtb9itbEqdhRNZJ0v8qIsV6u1f1mtyrLIl/Na66q1OdbSnmE1xSp2OJ6ksi7zcrXebLY+ZrNZr8pC5c6ySRQOmjm+wNZTPAijJJO1KFebbVXtfExVbcUt1O00jUdDm+N6aRvs/b2trKZ4OIpV7CIv15vtbrc/+Jj9fldtnVbVao6vlra5T52uTbEVq14rUV9eXv3Ly8vBact88TxNotAt7TVW90m3OEqsWM2wWV/ffIy8h121UbWa42g0OF6oC6z78Bh2Way31f4g6ruXeTOtVTufaWkH/d9g9eFJZ3Nt7HZ3eBH1w8tIe9irWs1x5i6UzvFNbGxYbexeM/z+8dPHSOuqXRXC6kK5c3yJtc9s37BuZYWtrX97F2mtWs2xlvbP2GJVT/GHj1Zpz7DTI/bhJjY7x/poFfajxpY1NgALFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBggULFixYsGDBgv0TNj3Heqn9+fFeY4sa2zfs999h89Wm2tdYD7U/P7GL5+w29kHYnmFn8xr7Wmv9y8f7++vLfrdd/QkbRsIuy7XNsWl9zLsVu682q1zYeCRs+yY2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MBCGMBCGMEAYIAwQBggDhAHCAGGAMEAYIAwQBghDGAhDGAhDGCAMEAYIA4QBwgBhgDBAGCAMEAYIQxgIQxgIQxggDBAGCAOEAcIAYYAwQBggDBAGCAOEIQyEIQyEIQwQBggDhAHCAGGAMEAYIAwQBggDhCEMhCEMhCEMEAYIA4QBwgBhgDBAGCAMEAYIA4QBwhAGwhAGwhAGCAOEAcIAYYAwQBggDBAGCAOEAcLw5RCGMBCGMEAYIAwQBggDhAHCAGGAMEAYIAwQBghDGAhDGAhDGCAMEAYIA4QBwgBhgDBAGCAMEAYIA4QhDIQhDIQhDBAGCAOEAcIAYYAwQBggDBAGCAOEIQyEIQyEIQwQBggDhAHCAGGAMEAYIAwQBggDhAHCEAbCEAbCEAYIA4QBwgBhgDBAGCAMEAYIA4QBwhAGwhAGwhAGCAOEAcIAYYAwQBggDBAGCAOEAcIAYQgDYQgDYQgDhAHCAGGAMEAYIAwQBggDhAHCAGGAMISBMIQBwgBhgDBAGCAMEAYIA4QBwgBhgDBAGMJAGMJAGMIAYYAwQBggDBAGCAOEAcIAYYAwQBggDGEgDGEgDGGAMEAYIAwQBggDhAHCAGGAMEAYIAxhIAxhIAxhgDBAGCAMEAYIA4QBwgBhgDBAGCAMEIYwEIYwEIYwQBggDBAGCAOEAcIAYYAwQBggDBCGMBCGMBCGMEAYIAwQBggDhAHCAGGAMEAYIAwQBghDGAhDGAhDGCAMEAYIA4QBwgBhgDBAGCAMEAYIA4QhDIQhDIQhDBAGCAOEAcIAYYAwQBggDBAGCAOEIQyEIQyEIQwQBggDhAHCAGGAMEAYIAwQBggDhAHCEAbCEAbCEAYIA4QBwgBhgDBAGCAMEAYIA4QBwhAGwhAGwhAGCAOEAcIAYYAwQBggDBAGCAOEAcIAYQgDYQgDYQgDhAHCAGGAMEAYIAwQBggDhAHCAGH4cghDGAhDGCAMEAYIA4QBwgBhgDBAGCAMEAYIA4QhDIQhDIQhDBAGCAOEAcIAYYAwQBggDBAGCAOEAcIQBsIQBsIQBggDhAHCAGGAMEAYIAwQBggDhAHCEAbCEAbCEAYIA4QBwgBhgDBAGCAMEAYIA4QBwgBhCANhCANhCAOEAcIAYYAwQBggDBAGCAOEAcIAYQgDYQgDYQgDhAHCAGGAMEAYIAwQBggDhAHCAGGAMISBMISBMIQBwgBhgDBAGCAMEAYIA4QBwgBhgDBAGMJAGMIAYYAwQBggDBAGCAOEAcIAYYAwQBggDGEgDGEgDGGAMEAYIAwQBggDhAHCAGGAMEAYIAwQhjAQhjAQhjBAGCAMEAYIA4QBwgBhgDBAGCAMEIYwEIYwEIYwQBggDBAGCAOEAcIAYYAwQBggDBAGCEMYCEMYCEMYIAwQBggDhAHCAGGAMEAYIAwQBghDGAhDGAhDGCAMEAYIA4QBwgBhgDBAGCAMEAYIA4QhDIQhDIQhDBAGCAOEAcIAYYAwQBggDBAGCAOEAcIQBsIQBsIQBggDhAHCAGGAMEAYIAwQBggDhAHCEAbCEAbCEAYIA4QBwgBhgDBAGCAMEAYIA4QBwgBhCANhCANhCAOEAcIAYYAwQBggDBAGCAOEAcIAYQgDYQgDYQgDhAHCAGGAMEAYIAwQBggDhAHCAGGAMISBMISBMIQBwgBhgDBAGCAMEAYIA4QBwgBhgDB8OYQhDIQhDBAGCAOEAcIAYYAwQBggDBAGCAOEAcIQBsIQBsIQBggDhAHCAGGAMEAYIAwQBggDhAHCAGEIA2EIA2EIA4QBwgBhgDBAGCAMEAYIA4QBwgBhCANhCANhCAOEAcIAYYAwQBggDBAGCAOEAcIAYYAwhIEwhIEwhAHCAGGAMEAYIAwQBggDhAHCAGGAMISBMISBMIQBwgBhgDBAGCAMEAYIA4QBwgBhgDBAGMJAGMJAGMIAYYAwQBggDBAGCAOEAcIAYYAwQBggDGEgDGGAMEAYIAwQBggDhAHCAGGAMEAYIAwQhjAQhjAQhjBAGCAMEAYIA4QBwgBhgDBAGCAMEAYIQxgIQxgIQxggDBAGCAOEAcIAYYAwQBggDBAGCEMYCEMYCEMYIAwQBggDhAHCAGGAMEAYIAwQBggDhCEMhCEMhCEMEAYIA4QBwgBhgDBAGCAMEAYIA4QhDIQhDIQhDBAGCAOEAcIAYYAwQBggDBAGCAOEAcIQBsIQBsIQBggDhAHCAGGAMEAYIAwQBggDhAHCAGEIA2EIA2EIA4QBwgBhgDBAGCAMEAYIA4QBwgBhCANhCANhCAOEAcIAYYAwQBggDBAGCAOEAcIAYYAwhIEwhIEwhAHCAGGAMEAYIAwQBggDhAHCAGGAMISBMISBMIQBwgBhgDBAGCAMEAYIA/4fwxgehqEM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ZT4yMDEzLTA0LTE4VDA5OjQzOjI5LTA0OjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6cGRmPSJodHRwOi8vbnMuYWRvYmUuY29tL3BkZi8xLjMvIj4KICAgICAgICAgPHBkZjpQcm9kdWNlcj5BY3JvYmF0IERpc3RpbGxlciAxMC4xLjUgKFdpbmRvd3MpPC9wZGY6UHJvZHVjZXI+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iPgogICAgICAgICA8ZGM6Zm9ybWF0PmFwcGxpY2F0aW9uL3BkZjwvZGM6Zm9ybWF0PgogICAgICAgICA8ZGM6dGl0bGU+CiAgICAgICAgICAgIDxyZGY6QWx0PgogICAgICAgICAgICAgICA8cmRmOmxpIHhtbDpsYW5nPSJ4LWRlZmF1bHQiPkEgR1VJREUgVE8gSE1EQSBSZXBvcnRpbmc8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6QWx0PgogICAgICAgICA8L2RjOnRpdGxlPgogICAgICAgICA8ZGM6Y3JlYXRvcj4KICAgICAgICAgICAgPHJkZjpTZXE+CiAgICAgICAgICAgICAgIDxyZGY6bGk+bTFjbWcwMDwvcmRmOmxpPgogICAgICAgICAgICA8L3JkZjpTZXE+CiAgICAgICAgIDwvZGM6Y3JlYXRvcj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIj4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+dXVpZDpkZmMwMjRmOC1mMjg4LTQ5MzktOWI1NS0wMGI0ODQzYmNmN2U8L3htcE1NOkRvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpJbnN0YW5jZUlEPnV1aWQ6YWI3NWNhMDgtNDU3NC00NjVjLTg2YjQtNzkzN2E0NzFhZTgwPC94bXBNTTpJbnN0YW5jZUlEPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+DQplbmRzdHJlYW0NZW5kb2JqDTQ3OCAwIG9iag08PC9GaWx0ZXIvRmxhdGVEZWNvZGUvRmlyc3QgMjQ1L0xlbmd0aCA1ODUvTiAyNi9UeXBlL09ialN0bT4+c3RyZWFtDQpo3pyVsW5eIQyFX8Vv8GMbA5aiLB27RFG3qkOk/qq6tFWTDn37Aj7cSkmUiDvZ8oWPA/dgmiWnRM04UakjMrG1kQiJzYqS6kwyZZ6JUfaZFLLGI6l9toykUY1ZTq2UnkgitzFGOjnpLAkxZxuZEkvUMrHKHGfEOc1a6VrSoEntmY8FpBEX15E5cZ2ZJuJWh2jta3iZtS4/5VlTEtZZyyTSFd7cXD78/PPjqavwy8fvXx8/z/0nuo89RdJVImkj+XL59PfX9XL38O36eHt7IKQdBF6ENbGfHJK8EgvU3cPva5/c4vTvX0cfZJ2DKPiBgsioxwes9mKJ2NnrS1gsoUAHOwc8x6om+zwLkAWohMwai9S6z2v4OTjGSSCPoud9ngeBEyJ+PuPP8dYZKh8OqOs3t5X48tCyl/CGAyCXwetXBbEgwhj6HBomftNW40rEZBzCclmGnTLq8AEb6qYbi60dwAqjtcxYcOIF9conoBU7qFDaoLCh3uzEsbQFw7YdUAfUDRHjPMZJ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","base64"));
PDFJS.getDocument(data).then(function (pdfDocument) {
  console.log('Number of pages: ' + pdfDocument.numPages);
});

console.log("working")

}).call(this,require("buffer").Buffer)
},{"buffer":6,"pdfjs-dist":2}],2:[function(require,module,exports){
(function (process){
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("pdfjs-dist/build/pdf", [], factory);
	else if(typeof exports === 'object')
		exports["pdfjs-dist/build/pdf"] = factory();
	else
		root["pdfjs-dist/build/pdf"] = root.pdfjsDistBuildPdf = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __w_pdfjs_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__w_pdfjs_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__w_pdfjs_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__w_pdfjs_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__w_pdfjs_require__.d = function(exports, name, getter) {
/******/ 		if(!__w_pdfjs_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__w_pdfjs_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__w_pdfjs_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__w_pdfjs_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__w_pdfjs_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __w_pdfjs_require__(__w_pdfjs_require__.s = 13);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var compatibility = __w_pdfjs_require__(14);
var globalScope = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : undefined;
var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
var TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};
var ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};
var AnnotationType = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
};
var AnnotationFlag = {
  INVISIBLE: 0x01,
  HIDDEN: 0x02,
  PRINT: 0x04,
  NOZOOM: 0x08,
  NOROTATE: 0x10,
  NOVIEW: 0x20,
  READONLY: 0x40,
  LOCKED: 0x80,
  TOGGLENOVIEW: 0x100,
  LOCKEDCONTENTS: 0x200
};
var AnnotationFieldFlag = {
  READONLY: 0x0000001,
  REQUIRED: 0x0000002,
  NOEXPORT: 0x0000004,
  MULTILINE: 0x0001000,
  PASSWORD: 0x0002000,
  NOTOGGLETOOFF: 0x0004000,
  RADIO: 0x0008000,
  PUSHBUTTON: 0x0010000,
  COMBO: 0x0020000,
  EDIT: 0x0040000,
  SORT: 0x0080000,
  FILESELECT: 0x0100000,
  MULTISELECT: 0x0200000,
  DONOTSPELLCHECK: 0x0400000,
  DONOTSCROLL: 0x0800000,
  COMB: 0x1000000,
  RICHTEXT: 0x2000000,
  RADIOSINUNISON: 0x2000000,
  COMMITONSELCHANGE: 0x4000000
};
var AnnotationBorderStyleType = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
};
var StreamType = {
  UNKNOWN: 0,
  FLATE: 1,
  LZW: 2,
  DCT: 3,
  JPX: 4,
  JBIG: 5,
  A85: 6,
  AHX: 7,
  CCF: 8,
  RL: 9
};
var FontType = {
  UNKNOWN: 0,
  TYPE1: 1,
  TYPE1C: 2,
  CIDFONTTYPE0: 3,
  CIDFONTTYPE0C: 4,
  TRUETYPE: 5,
  CIDFONTTYPE2: 6,
  TYPE3: 7,
  OPENTYPE: 8,
  TYPE0: 9,
  MMTYPE1: 10
};
var VERBOSITY_LEVELS = {
  errors: 0,
  warnings: 1,
  infos: 5
};
var CMapCompressionType = {
  NONE: 0,
  BINARY: 1,
  STREAM: 2
};
var OPS = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotations: 78,
  endAnnotations: 79,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintJpegXObject: 82,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
};
var verbosity = VERBOSITY_LEVELS.warnings;
function setVerbosityLevel(level) {
  verbosity = level;
}
function getVerbosityLevel() {
  return verbosity;
}
function info(msg) {
  if (verbosity >= VERBOSITY_LEVELS.infos) {
    console.log('Info: ' + msg);
  }
}
function warn(msg) {
  if (verbosity >= VERBOSITY_LEVELS.warnings) {
    console.log('Warning: ' + msg);
  }
}
function deprecated(details) {
  console.log('Deprecated API usage: ' + details);
}
function error(msg) {
  if (verbosity >= VERBOSITY_LEVELS.errors) {
    console.log('Error: ' + msg);
    console.log(backtrace());
  }
  throw new Error(msg);
}
function backtrace() {
  try {
    throw new Error();
  } catch (e) {
    return e.stack ? e.stack.split('\n').slice(2).join('\n') : '';
  }
}
function assert(cond, msg) {
  if (!cond) {
    error(msg);
  }
}
var UNSUPPORTED_FEATURES = {
  unknown: 'unknown',
  forms: 'forms',
  javaScript: 'javaScript',
  smask: 'smask',
  shadingPattern: 'shadingPattern',
  font: 'font'
};
function isSameOrigin(baseUrl, otherUrl) {
  try {
    var base = new URL(baseUrl);
    if (!base.origin || base.origin === 'null') {
      return false;
    }
  } catch (e) {
    return false;
  }
  var other = new URL(otherUrl, base);
  return base.origin === other.origin;
}
function isValidProtocol(url) {
  if (!url) {
    return false;
  }
  switch (url.protocol) {
    case 'http:':
    case 'https:':
    case 'ftp:':
    case 'mailto:':
    case 'tel:':
      return true;
    default:
      return false;
  }
}
function createValidAbsoluteUrl(url, baseUrl) {
  if (!url) {
    return null;
  }
  try {
    var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
    if (isValidProtocol(absoluteUrl)) {
      return absoluteUrl;
    }
  } catch (ex) {}
  return null;
}
function shadow(obj, prop, value) {
  Object.defineProperty(obj, prop, {
    value: value,
    enumerable: true,
    configurable: true,
    writable: false
  });
  return value;
}
function getLookupTableFactory(initializer) {
  var lookup;
  return function () {
    if (initializer) {
      lookup = Object.create(null);
      initializer(lookup);
      initializer = null;
    }
    return lookup;
  };
}
var PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
var PasswordException = function PasswordExceptionClosure() {
  function PasswordException(msg, code) {
    this.name = 'PasswordException';
    this.message = msg;
    this.code = code;
  }
  PasswordException.prototype = new Error();
  PasswordException.constructor = PasswordException;
  return PasswordException;
}();
var UnknownErrorException = function UnknownErrorExceptionClosure() {
  function UnknownErrorException(msg, details) {
    this.name = 'UnknownErrorException';
    this.message = msg;
    this.details = details;
  }
  UnknownErrorException.prototype = new Error();
  UnknownErrorException.constructor = UnknownErrorException;
  return UnknownErrorException;
}();
var InvalidPDFException = function InvalidPDFExceptionClosure() {
  function InvalidPDFException(msg) {
    this.name = 'InvalidPDFException';
    this.message = msg;
  }
  InvalidPDFException.prototype = new Error();
  InvalidPDFException.constructor = InvalidPDFException;
  return InvalidPDFException;
}();
var MissingPDFException = function MissingPDFExceptionClosure() {
  function MissingPDFException(msg) {
    this.name = 'MissingPDFException';
    this.message = msg;
  }
  MissingPDFException.prototype = new Error();
  MissingPDFException.constructor = MissingPDFException;
  return MissingPDFException;
}();
var UnexpectedResponseException = function UnexpectedResponseExceptionClosure() {
  function UnexpectedResponseException(msg, status) {
    this.name = 'UnexpectedResponseException';
    this.message = msg;
    this.status = status;
  }
  UnexpectedResponseException.prototype = new Error();
  UnexpectedResponseException.constructor = UnexpectedResponseException;
  return UnexpectedResponseException;
}();
var NotImplementedException = function NotImplementedExceptionClosure() {
  function NotImplementedException(msg) {
    this.message = msg;
  }
  NotImplementedException.prototype = new Error();
  NotImplementedException.prototype.name = 'NotImplementedException';
  NotImplementedException.constructor = NotImplementedException;
  return NotImplementedException;
}();
var MissingDataException = function MissingDataExceptionClosure() {
  function MissingDataException(begin, end) {
    this.begin = begin;
    this.end = end;
    this.message = 'Missing data [' + begin + ', ' + end + ')';
  }
  MissingDataException.prototype = new Error();
  MissingDataException.prototype.name = 'MissingDataException';
  MissingDataException.constructor = MissingDataException;
  return MissingDataException;
}();
var XRefParseException = function XRefParseExceptionClosure() {
  function XRefParseException(msg) {
    this.message = msg;
  }
  XRefParseException.prototype = new Error();
  XRefParseException.prototype.name = 'XRefParseException';
  XRefParseException.constructor = XRefParseException;
  return XRefParseException;
}();
var NullCharactersRegExp = /\x00/g;
function removeNullCharacters(str) {
  if (typeof str !== 'string') {
    warn('The argument for removeNullCharacters must be a string.');
    return str;
  }
  return str.replace(NullCharactersRegExp, '');
}
function bytesToString(bytes) {
  assert(bytes !== null && (typeof bytes === 'undefined' ? 'undefined' : _typeof(bytes)) === 'object' && bytes.length !== undefined, 'Invalid argument for bytesToString');
  var length = bytes.length;
  var MAX_ARGUMENT_COUNT = 8192;
  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }
  var strBuf = [];
  for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    var chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }
  return strBuf.join('');
}
function stringToBytes(str) {
  assert(typeof str === 'string', 'Invalid argument for stringToBytes');
  var length = str.length;
  var bytes = new Uint8Array(length);
  for (var i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 0xFF;
  }
  return bytes;
}
function arrayByteLength(arr) {
  if (arr.length !== undefined) {
    return arr.length;
  }
  assert(arr.byteLength !== undefined);
  return arr.byteLength;
}
function arraysToBytes(arr) {
  if (arr.length === 1 && arr[0] instanceof Uint8Array) {
    return arr[0];
  }
  var resultLength = 0;
  var i,
      ii = arr.length;
  var item, itemLength;
  for (i = 0; i < ii; i++) {
    item = arr[i];
    itemLength = arrayByteLength(item);
    resultLength += itemLength;
  }
  var pos = 0;
  var data = new Uint8Array(resultLength);
  for (i = 0; i < ii; i++) {
    item = arr[i];
    if (!(item instanceof Uint8Array)) {
      if (typeof item === 'string') {
        item = stringToBytes(item);
      } else {
        item = new Uint8Array(item);
      }
    }
    itemLength = item.byteLength;
    data.set(item, pos);
    pos += itemLength;
  }
  return data;
}
function string32(value) {
  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
}
function log2(x) {
  var n = 1,
      i = 0;
  while (x > n) {
    n <<= 1;
    i++;
  }
  return i;
}
function readInt8(data, start) {
  return data[start] << 24 >> 24;
}
function readUint16(data, offset) {
  return data[offset] << 8 | data[offset + 1];
}
function readUint32(data, offset) {
  return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
}
function isLittleEndian() {
  var buffer8 = new Uint8Array(4);
  buffer8[0] = 1;
  var view32 = new Uint32Array(buffer8.buffer, 0, 1);
  return view32[0] === 1;
}
function isEvalSupported() {
  try {
    new Function('');
    return true;
  } catch (e) {
    return false;
  }
}
var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
var Util = function UtilClosure() {
  function Util() {}
  var rgbBuf = ['rgb(', 0, ',', 0, ',', 0, ')'];
  Util.makeCssRgb = function Util_makeCssRgb(r, g, b) {
    rgbBuf[1] = r;
    rgbBuf[3] = g;
    rgbBuf[5] = b;
    return rgbBuf.join('');
  };
  Util.transform = function Util_transform(m1, m2) {
    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
  };
  Util.applyTransform = function Util_applyTransform(p, m) {
    var xt = p[0] * m[0] + p[1] * m[2] + m[4];
    var yt = p[0] * m[1] + p[1] * m[3] + m[5];
    return [xt, yt];
  };
  Util.applyInverseTransform = function Util_applyInverseTransform(p, m) {
    var d = m[0] * m[3] - m[1] * m[2];
    var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    return [xt, yt];
  };
  Util.getAxialAlignedBoundingBox = function Util_getAxialAlignedBoundingBox(r, m) {
    var p1 = Util.applyTransform(r, m);
    var p2 = Util.applyTransform(r.slice(2, 4), m);
    var p3 = Util.applyTransform([r[0], r[3]], m);
    var p4 = Util.applyTransform([r[2], r[1]], m);
    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
  };
  Util.inverseTransform = function Util_inverseTransform(m) {
    var d = m[0] * m[3] - m[1] * m[2];
    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  };
  Util.apply3dTransform = function Util_apply3dTransform(m, v) {
    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
  };
  Util.singularValueDecompose2dScale = function Util_singularValueDecompose2dScale(m) {
    var transpose = [m[0], m[2], m[1], m[3]];
    var a = m[0] * transpose[0] + m[1] * transpose[2];
    var b = m[0] * transpose[1] + m[1] * transpose[3];
    var c = m[2] * transpose[0] + m[3] * transpose[2];
    var d = m[2] * transpose[1] + m[3] * transpose[3];
    var first = (a + d) / 2;
    var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
    var sx = first + second || 1;
    var sy = first - second || 1;
    return [Math.sqrt(sx), Math.sqrt(sy)];
  };
  Util.normalizeRect = function Util_normalizeRect(rect) {
    var r = rect.slice(0);
    if (rect[0] > rect[2]) {
      r[0] = rect[2];
      r[2] = rect[0];
    }
    if (rect[1] > rect[3]) {
      r[1] = rect[3];
      r[3] = rect[1];
    }
    return r;
  };
  Util.intersect = function Util_intersect(rect1, rect2) {
    function compare(a, b) {
      return a - b;
    }
    var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare),
        orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare),
        result = [];
    rect1 = Util.normalizeRect(rect1);
    rect2 = Util.normalizeRect(rect2);
    if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
      result[0] = orderedX[1];
      result[2] = orderedX[2];
    } else {
      return false;
    }
    if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
      result[1] = orderedY[1];
      result[3] = orderedY[2];
    } else {
      return false;
    }
    return result;
  };
  Util.sign = function Util_sign(num) {
    return num < 0 ? -1 : 1;
  };
  var ROMAN_NUMBER_MAP = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM', '', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC', '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];
  Util.toRoman = function Util_toRoman(number, lowerCase) {
    assert(isInt(number) && number > 0, 'The number should be a positive integer.');
    var pos,
        romanBuf = [];
    while (number >= 1000) {
      number -= 1000;
      romanBuf.push('M');
    }
    pos = number / 100 | 0;
    number %= 100;
    romanBuf.push(ROMAN_NUMBER_MAP[pos]);
    pos = number / 10 | 0;
    number %= 10;
    romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
    romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
    var romanStr = romanBuf.join('');
    return lowerCase ? romanStr.toLowerCase() : romanStr;
  };
  Util.appendToArray = function Util_appendToArray(arr1, arr2) {
    Array.prototype.push.apply(arr1, arr2);
  };
  Util.prependToArray = function Util_prependToArray(arr1, arr2) {
    Array.prototype.unshift.apply(arr1, arr2);
  };
  Util.extendObj = function extendObj(obj1, obj2) {
    for (var key in obj2) {
      obj1[key] = obj2[key];
    }
  };
  Util.getInheritableProperty = function Util_getInheritableProperty(dict, name, getArray) {
    while (dict && !dict.has(name)) {
      dict = dict.get('Parent');
    }
    if (!dict) {
      return null;
    }
    return getArray ? dict.getArray(name) : dict.get(name);
  };
  Util.inherit = function Util_inherit(sub, base, prototype) {
    sub.prototype = Object.create(base.prototype);
    sub.prototype.constructor = sub;
    for (var prop in prototype) {
      sub.prototype[prop] = prototype[prop];
    }
  };
  Util.loadScript = function Util_loadScript(src, callback) {
    var script = document.createElement('script');
    var loaded = false;
    script.setAttribute('src', src);
    if (callback) {
      script.onload = function () {
        if (!loaded) {
          callback();
        }
        loaded = true;
      };
    }
    document.getElementsByTagName('head')[0].appendChild(script);
  };
  return Util;
}();
var PageViewport = function PageViewportClosure() {
  function PageViewport(viewBox, scale, rotation, offsetX, offsetY, dontFlip) {
    this.viewBox = viewBox;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    var centerX = (viewBox[2] + viewBox[0]) / 2;
    var centerY = (viewBox[3] + viewBox[1]) / 2;
    var rotateA, rotateB, rotateC, rotateD;
    rotation = rotation % 360;
    rotation = rotation < 0 ? rotation + 360 : rotation;
    switch (rotation) {
      case 180:
        rotateA = -1;
        rotateB = 0;
        rotateC = 0;
        rotateD = 1;
        break;
      case 90:
        rotateA = 0;
        rotateB = 1;
        rotateC = 1;
        rotateD = 0;
        break;
      case 270:
        rotateA = 0;
        rotateB = -1;
        rotateC = -1;
        rotateD = 0;
        break;
      default:
        rotateA = 1;
        rotateB = 0;
        rotateC = 0;
        rotateD = -1;
        break;
    }
    if (dontFlip) {
      rotateC = -rotateC;
      rotateD = -rotateD;
    }
    var offsetCanvasX, offsetCanvasY;
    var width, height;
    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = Math.abs(viewBox[3] - viewBox[1]) * scale;
      height = Math.abs(viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = Math.abs(viewBox[2] - viewBox[0]) * scale;
      height = Math.abs(viewBox[3] - viewBox[1]) * scale;
    }
    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
    this.width = width;
    this.height = height;
    this.fontScale = scale;
  }
  PageViewport.prototype = {
    clone: function PageViewPort_clone(args) {
      args = args || {};
      var scale = 'scale' in args ? args.scale : this.scale;
      var rotation = 'rotation' in args ? args.rotation : this.rotation;
      return new PageViewport(this.viewBox.slice(), scale, rotation, this.offsetX, this.offsetY, args.dontFlip);
    },
    convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {
      return Util.applyTransform([x, y], this.transform);
    },
    convertToViewportRectangle: function PageViewport_convertToViewportRectangle(rect) {
      var tl = Util.applyTransform([rect[0], rect[1]], this.transform);
      var br = Util.applyTransform([rect[2], rect[3]], this.transform);
      return [tl[0], tl[1], br[0], br[1]];
    },
    convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {
      return Util.applyInverseTransform([x, y], this.transform);
    }
  };
  return PageViewport;
}();
var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];
function stringToPDFString(str) {
  var i,
      n = str.length,
      strBuf = [];
  if (str[0] === '\xFE' && str[1] === '\xFF') {
    for (i = 2; i < n; i += 2) {
      strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
    }
  } else {
    for (i = 0; i < n; ++i) {
      var code = PDFStringTranslateTable[str.charCodeAt(i)];
      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
    }
  }
  return strBuf.join('');
}
function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}
function utf8StringToString(str) {
  return unescape(encodeURIComponent(str));
}
function isEmptyObj(obj) {
  for (var key in obj) {
    return false;
  }
  return true;
}
function isBool(v) {
  return typeof v === 'boolean';
}
function isInt(v) {
  return typeof v === 'number' && (v | 0) === v;
}
function isNum(v) {
  return typeof v === 'number';
}
function isString(v) {
  return typeof v === 'string';
}
function isArray(v) {
  return v instanceof Array;
}
function isArrayBuffer(v) {
  return (typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object' && v !== null && v.byteLength !== undefined;
}
function isSpace(ch) {
  return ch === 0x20 || ch === 0x09 || ch === 0x0D || ch === 0x0A;
}
function isNodeJS() {
  if (typeof __pdfjsdev_webpack__ === 'undefined') {
    return (typeof process === 'undefined' ? 'undefined' : _typeof(process)) === 'object' && process + '' === '[object process]';
  }
  return false;
}
function createPromiseCapability() {
  var capability = {};
  capability.promise = new Promise(function (resolve, reject) {
    capability.resolve = resolve;
    capability.reject = reject;
  });
  return capability;
}
var StatTimer = function StatTimerClosure() {
  function rpad(str, pad, length) {
    while (str.length < length) {
      str += pad;
    }
    return str;
  }
  function StatTimer() {
    this.started = Object.create(null);
    this.times = [];
    this.enabled = true;
  }
  StatTimer.prototype = {
    time: function StatTimer_time(name) {
      if (!this.enabled) {
        return;
      }
      if (name in this.started) {
        warn('Timer is already running for ' + name);
      }
      this.started[name] = Date.now();
    },
    timeEnd: function StatTimer_timeEnd(name) {
      if (!this.enabled) {
        return;
      }
      if (!(name in this.started)) {
        warn('Timer has not been started for ' + name);
      }
      this.times.push({
        'name': name,
        'start': this.started[name],
        'end': Date.now()
      });
      delete this.started[name];
    },
    toString: function StatTimer_toString() {
      var i, ii;
      var times = this.times;
      var out = '';
      var longest = 0;
      for (i = 0, ii = times.length; i < ii; ++i) {
        var name = times[i]['name'];
        if (name.length > longest) {
          longest = name.length;
        }
      }
      for (i = 0, ii = times.length; i < ii; ++i) {
        var span = times[i];
        var duration = span.end - span.start;
        out += rpad(span['name'], ' ', longest) + ' ' + duration + 'ms\n';
      }
      return out;
    }
  };
  return StatTimer;
}();
var createBlob = function createBlob(data, contentType) {
  if (typeof Blob !== 'undefined') {
    return new Blob([data], { type: contentType });
  }
  warn('The "Blob" constructor is not supported.');
};
var createObjectURL = function createObjectURLClosure() {
  var digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  return function createObjectURL(data, contentType, forceDataSchema) {
    if (!forceDataSchema && typeof URL !== 'undefined' && URL.createObjectURL) {
      var blob = createBlob(data, contentType);
      return URL.createObjectURL(blob);
    }
    var buffer = 'data:' + contentType + ';base64,';
    for (var i = 0, ii = data.length; i < ii; i += 3) {
      var b1 = data[i] & 0xFF;
      var b2 = data[i + 1] & 0xFF;
      var b3 = data[i + 2] & 0xFF;
      var d1 = b1 >> 2,
          d2 = (b1 & 3) << 4 | b2 >> 4;
      var d3 = i + 1 < ii ? (b2 & 0xF) << 2 | b3 >> 6 : 64;
      var d4 = i + 2 < ii ? b3 & 0x3F : 64;
      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
    }
    return buffer;
  };
}();
function MessageHandler(sourceName, targetName, comObj) {
  this.sourceName = sourceName;
  this.targetName = targetName;
  this.comObj = comObj;
  this.callbackIndex = 1;
  this.postMessageTransfers = true;
  var callbacksCapabilities = this.callbacksCapabilities = Object.create(null);
  var ah = this.actionHandler = Object.create(null);
  this._onComObjOnMessage = function messageHandlerComObjOnMessage(event) {
    var data = event.data;
    if (data.targetName !== this.sourceName) {
      return;
    }
    if (data.isReply) {
      var callbackId = data.callbackId;
      if (data.callbackId in callbacksCapabilities) {
        var callback = callbacksCapabilities[callbackId];
        delete callbacksCapabilities[callbackId];
        if ('error' in data) {
          callback.reject(data.error);
        } else {
          callback.resolve(data.data);
        }
      } else {
        error('Cannot resolve callback ' + callbackId);
      }
    } else if (data.action in ah) {
      var action = ah[data.action];
      if (data.callbackId) {
        var sourceName = this.sourceName;
        var targetName = data.sourceName;
        Promise.resolve().then(function () {
          return action[0].call(action[1], data.data);
        }).then(function (result) {
          comObj.postMessage({
            sourceName: sourceName,
            targetName: targetName,
            isReply: true,
            callbackId: data.callbackId,
            data: result
          });
        }, function (reason) {
          if (reason instanceof Error) {
            reason = reason + '';
          }
          comObj.postMessage({
            sourceName: sourceName,
            targetName: targetName,
            isReply: true,
            callbackId: data.callbackId,
            error: reason
          });
        });
      } else {
        action[0].call(action[1], data.data);
      }
    } else {
      error('Unknown action from worker: ' + data.action);
    }
  }.bind(this);
  comObj.addEventListener('message', this._onComObjOnMessage);
}
MessageHandler.prototype = {
  on: function messageHandlerOn(actionName, handler, scope) {
    var ah = this.actionHandler;
    if (ah[actionName]) {
      error('There is already an actionName called "' + actionName + '"');
    }
    ah[actionName] = [handler, scope];
  },
  send: function messageHandlerSend(actionName, data, transfers) {
    var message = {
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data: data
    };
    this.postMessage(message, transfers);
  },
  sendWithPromise: function messageHandlerSendWithPromise(actionName, data, transfers) {
    var callbackId = this.callbackIndex++;
    var message = {
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data: data,
      callbackId: callbackId
    };
    var capability = createPromiseCapability();
    this.callbacksCapabilities[callbackId] = capability;
    try {
      this.postMessage(message, transfers);
    } catch (e) {
      capability.reject(e);
    }
    return capability.promise;
  },
  postMessage: function postMessage(message, transfers) {
    if (transfers && this.postMessageTransfers) {
      this.comObj.postMessage(message, transfers);
    } else {
      this.comObj.postMessage(message);
    }
  },
  destroy: function destroy() {
    this.comObj.removeEventListener('message', this._onComObjOnMessage);
  }
};
function loadJpegStream(id, imageUrl, objs) {
  var img = new Image();
  img.onload = function loadJpegStream_onloadClosure() {
    objs.resolve(id, img);
  };
  img.onerror = function loadJpegStream_onerrorClosure() {
    objs.resolve(id, null);
    warn('Error during JPEG image loading');
  };
  img.src = imageUrl;
}
exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
exports.OPS = OPS;
exports.VERBOSITY_LEVELS = VERBOSITY_LEVELS;
exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
exports.AnnotationFieldFlag = AnnotationFieldFlag;
exports.AnnotationFlag = AnnotationFlag;
exports.AnnotationType = AnnotationType;
exports.FontType = FontType;
exports.ImageKind = ImageKind;
exports.CMapCompressionType = CMapCompressionType;
exports.InvalidPDFException = InvalidPDFException;
exports.MessageHandler = MessageHandler;
exports.MissingDataException = MissingDataException;
exports.MissingPDFException = MissingPDFException;
exports.NotImplementedException = NotImplementedException;
exports.PageViewport = PageViewport;
exports.PasswordException = PasswordException;
exports.PasswordResponses = PasswordResponses;
exports.StatTimer = StatTimer;
exports.StreamType = StreamType;
exports.TextRenderingMode = TextRenderingMode;
exports.UnexpectedResponseException = UnexpectedResponseException;
exports.UnknownErrorException = UnknownErrorException;
exports.Util = Util;
exports.XRefParseException = XRefParseException;
exports.arrayByteLength = arrayByteLength;
exports.arraysToBytes = arraysToBytes;
exports.assert = assert;
exports.bytesToString = bytesToString;
exports.createBlob = createBlob;
exports.createPromiseCapability = createPromiseCapability;
exports.createObjectURL = createObjectURL;
exports.deprecated = deprecated;
exports.error = error;
exports.getLookupTableFactory = getLookupTableFactory;
exports.getVerbosityLevel = getVerbosityLevel;
exports.globalScope = globalScope;
exports.info = info;
exports.isArray = isArray;
exports.isArrayBuffer = isArrayBuffer;
exports.isBool = isBool;
exports.isEmptyObj = isEmptyObj;
exports.isInt = isInt;
exports.isNum = isNum;
exports.isString = isString;
exports.isSpace = isSpace;
exports.isNodeJS = isNodeJS;
exports.isSameOrigin = isSameOrigin;
exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
exports.isLittleEndian = isLittleEndian;
exports.isEvalSupported = isEvalSupported;
exports.loadJpegStream = loadJpegStream;
exports.log2 = log2;
exports.readInt8 = readInt8;
exports.readUint16 = readUint16;
exports.readUint32 = readUint32;
exports.removeNullCharacters = removeNullCharacters;
exports.setVerbosityLevel = setVerbosityLevel;
exports.shadow = shadow;
exports.string32 = string32;
exports.stringToBytes = stringToBytes;
exports.stringToPDFString = stringToPDFString;
exports.stringToUTF8String = stringToUTF8String;
exports.utf8StringToString = utf8StringToString;
exports.warn = warn;
/* WEBPACK VAR INJECTION */}.call(exports, __w_pdfjs_require__(6)))

/***/ }),
/* 1 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DOMCMapReaderFactory = exports.DOMCanvasFactory = exports.DEFAULT_LINK_REL = exports.getDefaultSetting = exports.LinkTarget = exports.getFilenameFromUrl = exports.isValidUrl = exports.isExternalLinkTargetSet = exports.addLinkAttributes = exports.RenderingCancelledException = exports.CustomStyle = undefined;

var _util = __w_pdfjs_require__(0);

var DEFAULT_LINK_REL = 'noopener noreferrer nofollow';
function DOMCanvasFactory() {}
DOMCanvasFactory.prototype = {
  create: function DOMCanvasFactory_create(width, height) {
    (0, _util.assert)(width > 0 && height > 0, 'invalid canvas size');
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    canvas.width = width;
    canvas.height = height;
    return {
      canvas: canvas,
      context: context
    };
  },
  reset: function DOMCanvasFactory_reset(canvasAndContextPair, width, height) {
    (0, _util.assert)(canvasAndContextPair.canvas, 'canvas is not specified');
    (0, _util.assert)(width > 0 && height > 0, 'invalid canvas size');
    canvasAndContextPair.canvas.width = width;
    canvasAndContextPair.canvas.height = height;
  },
  destroy: function DOMCanvasFactory_destroy(canvasAndContextPair) {
    (0, _util.assert)(canvasAndContextPair.canvas, 'canvas is not specified');
    canvasAndContextPair.canvas.width = 0;
    canvasAndContextPair.canvas.height = 0;
    canvasAndContextPair.canvas = null;
    canvasAndContextPair.context = null;
  }
};
var DOMCMapReaderFactory = function DOMCMapReaderFactoryClosure() {
  function DOMCMapReaderFactory(params) {
    this.baseUrl = params.baseUrl || null;
    this.isCompressed = params.isCompressed || false;
  }
  DOMCMapReaderFactory.prototype = {
    fetch: function fetch(params) {
      var name = params.name;
      if (!name) {
        return Promise.reject(new Error('CMap name must be specified.'));
      }
      return new Promise(function (resolve, reject) {
        var url = this.baseUrl + name + (this.isCompressed ? '.bcmap' : '');
        var request = new XMLHttpRequest();
        request.open('GET', url, true);
        if (this.isCompressed) {
          request.responseType = 'arraybuffer';
        }
        request.onreadystatechange = function () {
          if (request.readyState !== XMLHttpRequest.DONE) {
            return;
          }
          if (request.status === 200 || request.status === 0) {
            var data;
            if (this.isCompressed && request.response) {
              data = new Uint8Array(request.response);
            } else if (!this.isCompressed && request.responseText) {
              data = (0, _util.stringToBytes)(request.responseText);
            }
            if (data) {
              resolve({
                cMapData: data,
                compressionType: this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE
              });
              return;
            }
          }
          reject(new Error('Unable to load ' + (this.isCompressed ? 'binary ' : '') + 'CMap at: ' + url));
        }.bind(this);
        request.send(null);
      }.bind(this));
    }
  };
  return DOMCMapReaderFactory;
}();
var CustomStyle = function CustomStyleClosure() {
  var prefixes = ['ms', 'Moz', 'Webkit', 'O'];
  var _cache = Object.create(null);
  function CustomStyle() {}
  CustomStyle.getProp = function get(propName, element) {
    if (arguments.length === 1 && typeof _cache[propName] === 'string') {
      return _cache[propName];
    }
    element = element || document.documentElement;
    var style = element.style,
        prefixed,
        uPropName;
    if (typeof style[propName] === 'string') {
      return _cache[propName] = propName;
    }
    uPropName = propName.charAt(0).toUpperCase() + propName.slice(1);
    for (var i = 0, l = prefixes.length; i < l; i++) {
      prefixed = prefixes[i] + uPropName;
      if (typeof style[prefixed] === 'string') {
        return _cache[propName] = prefixed;
      }
    }
    return _cache[propName] = 'undefined';
  };
  CustomStyle.setProp = function set(propName, element, str) {
    var prop = this.getProp(propName);
    if (prop !== 'undefined') {
      element.style[prop] = str;
    }
  };
  return CustomStyle;
}();
var RenderingCancelledException = function RenderingCancelledException() {
  function RenderingCancelledException(msg, type) {
    this.message = msg;
    this.type = type;
  }
  RenderingCancelledException.prototype = new Error();
  RenderingCancelledException.prototype.name = 'RenderingCancelledException';
  RenderingCancelledException.constructor = RenderingCancelledException;
  return RenderingCancelledException;
}();
var LinkTarget = {
  NONE: 0,
  SELF: 1,
  BLANK: 2,
  PARENT: 3,
  TOP: 4
};
var LinkTargetStringMap = ['', '_self', '_blank', '_parent', '_top'];
function addLinkAttributes(link, params) {
  var url = params && params.url;
  link.href = link.title = url ? (0, _util.removeNullCharacters)(url) : '';
  if (url) {
    var target = params.target;
    if (typeof target === 'undefined') {
      target = getDefaultSetting('externalLinkTarget');
    }
    link.target = LinkTargetStringMap[target];
    var rel = params.rel;
    if (typeof rel === 'undefined') {
      rel = getDefaultSetting('externalLinkRel');
    }
    link.rel = rel;
  }
}
function getFilenameFromUrl(url) {
  var anchor = url.indexOf('#');
  var query = url.indexOf('?');
  var end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
  return url.substring(url.lastIndexOf('/', end) + 1, end);
}
function getDefaultSetting(id) {
  var globalSettings = _util.globalScope.PDFJS;
  switch (id) {
    case 'pdfBug':
      return globalSettings ? globalSettings.pdfBug : false;
    case 'disableAutoFetch':
      return globalSettings ? globalSettings.disableAutoFetch : false;
    case 'disableStream':
      return globalSettings ? globalSettings.disableStream : false;
    case 'disableRange':
      return globalSettings ? globalSettings.disableRange : false;
    case 'disableFontFace':
      return globalSettings ? globalSettings.disableFontFace : false;
    case 'disableCreateObjectURL':
      return globalSettings ? globalSettings.disableCreateObjectURL : false;
    case 'disableWebGL':
      return globalSettings ? globalSettings.disableWebGL : true;
    case 'cMapUrl':
      return globalSettings ? globalSettings.cMapUrl : null;
    case 'cMapPacked':
      return globalSettings ? globalSettings.cMapPacked : false;
    case 'postMessageTransfers':
      return globalSettings ? globalSettings.postMessageTransfers : true;
    case 'workerPort':
      return globalSettings ? globalSettings.workerPort : null;
    case 'workerSrc':
      return globalSettings ? globalSettings.workerSrc : null;
    case 'disableWorker':
      return globalSettings ? globalSettings.disableWorker : false;
    case 'maxImageSize':
      return globalSettings ? globalSettings.maxImageSize : -1;
    case 'imageResourcesPath':
      return globalSettings ? globalSettings.imageResourcesPath : '';
    case 'isEvalSupported':
      return globalSettings ? globalSettings.isEvalSupported : true;
    case 'externalLinkTarget':
      if (!globalSettings) {
        return LinkTarget.NONE;
      }
      switch (globalSettings.externalLinkTarget) {
        case LinkTarget.NONE:
        case LinkTarget.SELF:
        case LinkTarget.BLANK:
        case LinkTarget.PARENT:
        case LinkTarget.TOP:
          return globalSettings.externalLinkTarget;
      }
      (0, _util.warn)('PDFJS.externalLinkTarget is invalid: ' + globalSettings.externalLinkTarget);
      globalSettings.externalLinkTarget = LinkTarget.NONE;
      return LinkTarget.NONE;
    case 'externalLinkRel':
      return globalSettings ? globalSettings.externalLinkRel : DEFAULT_LINK_REL;
    case 'enableStats':
      return !!(globalSettings && globalSettings.enableStats);
    case 'pdfjsNext':
      return !!(globalSettings && globalSettings.pdfjsNext);
    default:
      throw new Error('Unknown default setting: ' + id);
  }
}
function isExternalLinkTargetSet() {
  var externalLinkTarget = getDefaultSetting('externalLinkTarget');
  switch (externalLinkTarget) {
    case LinkTarget.NONE:
      return false;
    case LinkTarget.SELF:
    case LinkTarget.BLANK:
    case LinkTarget.PARENT:
    case LinkTarget.TOP:
      return true;
  }
}
function isValidUrl(url, allowRelative) {
  (0, _util.deprecated)('isValidUrl(), please use createValidAbsoluteUrl() instead.');
  var baseUrl = allowRelative ? 'http://example.com' : null;
  return (0, _util.createValidAbsoluteUrl)(url, baseUrl) !== null;
}
exports.CustomStyle = CustomStyle;
exports.RenderingCancelledException = RenderingCancelledException;
exports.addLinkAttributes = addLinkAttributes;
exports.isExternalLinkTargetSet = isExternalLinkTargetSet;
exports.isValidUrl = isValidUrl;
exports.getFilenameFromUrl = getFilenameFromUrl;
exports.LinkTarget = LinkTarget;
exports.getDefaultSetting = getDefaultSetting;
exports.DEFAULT_LINK_REL = DEFAULT_LINK_REL;
exports.DOMCanvasFactory = DOMCanvasFactory;
exports.DOMCMapReaderFactory = DOMCMapReaderFactory;

/***/ }),
/* 2 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnnotationLayer = undefined;

var _dom_utils = __w_pdfjs_require__(1);

var _util = __w_pdfjs_require__(0);

function AnnotationElementFactory() {}
AnnotationElementFactory.prototype = {
  create: function AnnotationElementFactory_create(parameters) {
    var subtype = parameters.data.annotationType;
    switch (subtype) {
      case _util.AnnotationType.LINK:
        return new LinkAnnotationElement(parameters);
      case _util.AnnotationType.TEXT:
        return new TextAnnotationElement(parameters);
      case _util.AnnotationType.WIDGET:
        var fieldType = parameters.data.fieldType;
        switch (fieldType) {
          case 'Tx':
            return new TextWidgetAnnotationElement(parameters);
          case 'Btn':
            if (parameters.data.radioButton) {
              return new RadioButtonWidgetAnnotationElement(parameters);
            } else if (parameters.data.checkBox) {
              return new CheckboxWidgetAnnotationElement(parameters);
            }
            (0, _util.warn)('Unimplemented button widget annotation: pushbutton');
            break;
          case 'Ch':
            return new ChoiceWidgetAnnotationElement(parameters);
        }
        return new WidgetAnnotationElement(parameters);
      case _util.AnnotationType.POPUP:
        return new PopupAnnotationElement(parameters);
      case _util.AnnotationType.LINE:
        return new LineAnnotationElement(parameters);
      case _util.AnnotationType.HIGHLIGHT:
        return new HighlightAnnotationElement(parameters);
      case _util.AnnotationType.UNDERLINE:
        return new UnderlineAnnotationElement(parameters);
      case _util.AnnotationType.SQUIGGLY:
        return new SquigglyAnnotationElement(parameters);
      case _util.AnnotationType.STRIKEOUT:
        return new StrikeOutAnnotationElement(parameters);
      case _util.AnnotationType.FILEATTACHMENT:
        return new FileAttachmentAnnotationElement(parameters);
      default:
        return new AnnotationElement(parameters);
    }
  }
};
var AnnotationElement = function AnnotationElementClosure() {
  function AnnotationElement(parameters, isRenderable, ignoreBorder) {
    this.isRenderable = isRenderable || false;
    this.data = parameters.data;
    this.layer = parameters.layer;
    this.page = parameters.page;
    this.viewport = parameters.viewport;
    this.linkService = parameters.linkService;
    this.downloadManager = parameters.downloadManager;
    this.imageResourcesPath = parameters.imageResourcesPath;
    this.renderInteractiveForms = parameters.renderInteractiveForms;
    if (isRenderable) {
      this.container = this._createContainer(ignoreBorder);
    }
  }
  AnnotationElement.prototype = {
    _createContainer: function AnnotationElement_createContainer(ignoreBorder) {
      var data = this.data,
          page = this.page,
          viewport = this.viewport;
      var container = document.createElement('section');
      var width = data.rect[2] - data.rect[0];
      var height = data.rect[3] - data.rect[1];
      container.setAttribute('data-annotation-id', data.id);
      var rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
      _dom_utils.CustomStyle.setProp('transform', container, 'matrix(' + viewport.transform.join(',') + ')');
      _dom_utils.CustomStyle.setProp('transformOrigin', container, -rect[0] + 'px ' + -rect[1] + 'px');
      if (!ignoreBorder && data.borderStyle.width > 0) {
        container.style.borderWidth = data.borderStyle.width + 'px';
        if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {
          width = width - 2 * data.borderStyle.width;
          height = height - 2 * data.borderStyle.width;
        }
        var horizontalRadius = data.borderStyle.horizontalCornerRadius;
        var verticalRadius = data.borderStyle.verticalCornerRadius;
        if (horizontalRadius > 0 || verticalRadius > 0) {
          var radius = horizontalRadius + 'px / ' + verticalRadius + 'px';
          _dom_utils.CustomStyle.setProp('borderRadius', container, radius);
        }
        switch (data.borderStyle.style) {
          case _util.AnnotationBorderStyleType.SOLID:
            container.style.borderStyle = 'solid';
            break;
          case _util.AnnotationBorderStyleType.DASHED:
            container.style.borderStyle = 'dashed';
            break;
          case _util.AnnotationBorderStyleType.BEVELED:
            (0, _util.warn)('Unimplemented border style: beveled');
            break;
          case _util.AnnotationBorderStyleType.INSET:
            (0, _util.warn)('Unimplemented border style: inset');
            break;
          case _util.AnnotationBorderStyleType.UNDERLINE:
            container.style.borderBottomStyle = 'solid';
            break;
          default:
            break;
        }
        if (data.color) {
          container.style.borderColor = _util.Util.makeCssRgb(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
        } else {
          container.style.borderWidth = 0;
        }
      }
      container.style.left = rect[0] + 'px';
      container.style.top = rect[1] + 'px';
      container.style.width = width + 'px';
      container.style.height = height + 'px';
      return container;
    },
    _createPopup: function AnnotationElement_createPopup(container, trigger, data) {
      if (!trigger) {
        trigger = document.createElement('div');
        trigger.style.height = container.style.height;
        trigger.style.width = container.style.width;
        container.appendChild(trigger);
      }
      var popupElement = new PopupElement({
        container: container,
        trigger: trigger,
        color: data.color,
        title: data.title,
        contents: data.contents,
        hideWrapper: true
      });
      var popup = popupElement.render();
      popup.style.left = container.style.width;
      container.appendChild(popup);
    },
    render: function AnnotationElement_render() {
      throw new Error('Abstract method AnnotationElement.render called');
    }
  };
  return AnnotationElement;
}();
var LinkAnnotationElement = function LinkAnnotationElementClosure() {
  function LinkAnnotationElement(parameters) {
    AnnotationElement.call(this, parameters, true);
  }
  _util.Util.inherit(LinkAnnotationElement, AnnotationElement, {
    render: function LinkAnnotationElement_render() {
      this.container.className = 'linkAnnotation';
      var link = document.createElement('a');
      (0, _dom_utils.addLinkAttributes)(link, {
        url: this.data.url,
        target: this.data.newWindow ? _dom_utils.LinkTarget.BLANK : undefined
      });
      if (!this.data.url) {
        if (this.data.action) {
          this._bindNamedAction(link, this.data.action);
        } else {
          this._bindLink(link, this.data.dest);
        }
      }
      this.container.appendChild(link);
      return this.container;
    },
    _bindLink: function LinkAnnotationElement_bindLink(link, destination) {
      var self = this;
      link.href = this.linkService.getDestinationHash(destination);
      link.onclick = function () {
        if (destination) {
          self.linkService.navigateTo(destination);
        }
        return false;
      };
      if (destination) {
        link.className = 'internalLink';
      }
    },
    _bindNamedAction: function LinkAnnotationElement_bindNamedAction(link, action) {
      var self = this;
      link.href = this.linkService.getAnchorUrl('');
      link.onclick = function () {
        self.linkService.executeNamedAction(action);
        return false;
      };
      link.className = 'internalLink';
    }
  });
  return LinkAnnotationElement;
}();
var TextAnnotationElement = function TextAnnotationElementClosure() {
  function TextAnnotationElement(parameters) {
    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    AnnotationElement.call(this, parameters, isRenderable);
  }
  _util.Util.inherit(TextAnnotationElement, AnnotationElement, {
    render: function TextAnnotationElement_render() {
      this.container.className = 'textAnnotation';
      var image = document.createElement('img');
      image.style.height = this.container.style.height;
      image.style.width = this.container.style.width;
      image.src = this.imageResourcesPath + 'annotation-' + this.data.name.toLowerCase() + '.svg';
      image.alt = '[{{type}} Annotation]';
      image.dataset.l10nId = 'text_annotation_type';
      image.dataset.l10nArgs = JSON.stringify({ type: this.data.name });
      if (!this.data.hasPopup) {
        this._createPopup(this.container, image, this.data);
      }
      this.container.appendChild(image);
      return this.container;
    }
  });
  return TextAnnotationElement;
}();
var WidgetAnnotationElement = function WidgetAnnotationElementClosure() {
  function WidgetAnnotationElement(parameters, isRenderable) {
    AnnotationElement.call(this, parameters, isRenderable);
  }
  _util.Util.inherit(WidgetAnnotationElement, AnnotationElement, {
    render: function WidgetAnnotationElement_render() {
      return this.container;
    }
  });
  return WidgetAnnotationElement;
}();
var TextWidgetAnnotationElement = function TextWidgetAnnotationElementClosure() {
  var TEXT_ALIGNMENT = ['left', 'center', 'right'];
  function TextWidgetAnnotationElement(parameters) {
    var isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
    WidgetAnnotationElement.call(this, parameters, isRenderable);
  }
  _util.Util.inherit(TextWidgetAnnotationElement, WidgetAnnotationElement, {
    render: function TextWidgetAnnotationElement_render() {
      this.container.className = 'textWidgetAnnotation';
      var element = null;
      if (this.renderInteractiveForms) {
        if (this.data.multiLine) {
          element = document.createElement('textarea');
          element.textContent = this.data.fieldValue;
        } else {
          element = document.createElement('input');
          element.type = 'text';
          element.setAttribute('value', this.data.fieldValue);
        }
        element.disabled = this.data.readOnly;
        if (this.data.maxLen !== null) {
          element.maxLength = this.data.maxLen;
        }
        if (this.data.comb) {
          var fieldWidth = this.data.rect[2] - this.data.rect[0];
          var combWidth = fieldWidth / this.data.maxLen;
          element.classList.add('comb');
          element.style.letterSpacing = 'calc(' + combWidth + 'px - 1ch)';
        }
      } else {
        element = document.createElement('div');
        element.textContent = this.data.fieldValue;
        element.style.verticalAlign = 'middle';
        element.style.display = 'table-cell';
        var font = null;
        if (this.data.fontRefName) {
          font = this.page.commonObjs.getData(this.data.fontRefName);
        }
        this._setTextStyle(element, font);
      }
      if (this.data.textAlignment !== null) {
        element.style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
      }
      this.container.appendChild(element);
      return this.container;
    },
    _setTextStyle: function TextWidgetAnnotationElement_setTextStyle(element, font) {
      var style = element.style;
      style.fontSize = this.data.fontSize + 'px';
      style.direction = this.data.fontDirection < 0 ? 'rtl' : 'ltr';
      if (!font) {
        return;
      }
      style.fontWeight = font.black ? font.bold ? '900' : 'bold' : font.bold ? 'bold' : 'normal';
      style.fontStyle = font.italic ? 'italic' : 'normal';
      var fontFamily = font.loadedName ? '"' + font.loadedName + '", ' : '';
      var fallbackName = font.fallbackName || 'Helvetica, sans-serif';
      style.fontFamily = fontFamily + fallbackName;
    }
  });
  return TextWidgetAnnotationElement;
}();
var CheckboxWidgetAnnotationElement = function CheckboxWidgetAnnotationElementClosure() {
  function CheckboxWidgetAnnotationElement(parameters) {
    WidgetAnnotationElement.call(this, parameters, parameters.renderInteractiveForms);
  }
  _util.Util.inherit(CheckboxWidgetAnnotationElement, WidgetAnnotationElement, {
    render: function CheckboxWidgetAnnotationElement_render() {
      this.container.className = 'buttonWidgetAnnotation checkBox';
      var element = document.createElement('input');
      element.disabled = this.data.readOnly;
      element.type = 'checkbox';
      if (this.data.fieldValue && this.data.fieldValue !== 'Off') {
        element.setAttribute('checked', true);
      }
      this.container.appendChild(element);
      return this.container;
    }
  });
  return CheckboxWidgetAnnotationElement;
}();
var RadioButtonWidgetAnnotationElement = function RadioButtonWidgetAnnotationElementClosure() {
  function RadioButtonWidgetAnnotationElement(parameters) {
    WidgetAnnotationElement.call(this, parameters, parameters.renderInteractiveForms);
  }
  _util.Util.inherit(RadioButtonWidgetAnnotationElement, WidgetAnnotationElement, {
    render: function RadioButtonWidgetAnnotationElement_render() {
      this.container.className = 'buttonWidgetAnnotation radioButton';
      var element = document.createElement('input');
      element.disabled = this.data.readOnly;
      element.type = 'radio';
      element.name = this.data.fieldName;
      if (this.data.fieldValue === this.data.buttonValue) {
        element.setAttribute('checked', true);
      }
      this.container.appendChild(element);
      return this.container;
    }
  });
  return RadioButtonWidgetAnnotationElement;
}();
var ChoiceWidgetAnnotationElement = function ChoiceWidgetAnnotationElementClosure() {
  function ChoiceWidgetAnnotationElement(parameters) {
    WidgetAnnotationElement.call(this, parameters, parameters.renderInteractiveForms);
  }
  _util.Util.inherit(ChoiceWidgetAnnotationElement, WidgetAnnotationElement, {
    render: function ChoiceWidgetAnnotationElement_render() {
      this.container.className = 'choiceWidgetAnnotation';
      var selectElement = document.createElement('select');
      selectElement.disabled = this.data.readOnly;
      if (!this.data.combo) {
        selectElement.size = this.data.options.length;
        if (this.data.multiSelect) {
          selectElement.multiple = true;
        }
      }
      for (var i = 0, ii = this.data.options.length; i < ii; i++) {
        var option = this.data.options[i];
        var optionElement = document.createElement('option');
        optionElement.textContent = option.displayValue;
        optionElement.value = option.exportValue;
        if (this.data.fieldValue.indexOf(option.displayValue) >= 0) {
          optionElement.setAttribute('selected', true);
        }
        selectElement.appendChild(optionElement);
      }
      this.container.appendChild(selectElement);
      return this.container;
    }
  });
  return ChoiceWidgetAnnotationElement;
}();
var PopupAnnotationElement = function PopupAnnotationElementClosure() {
  var IGNORE_TYPES = ['Line'];
  function PopupAnnotationElement(parameters) {
    var isRenderable = !!(parameters.data.title || parameters.data.contents);
    AnnotationElement.call(this, parameters, isRenderable);
  }
  _util.Util.inherit(PopupAnnotationElement, AnnotationElement, {
    render: function PopupAnnotationElement_render() {
      this.container.className = 'popupAnnotation';
      if (IGNORE_TYPES.indexOf(this.data.parentType) >= 0) {
        return this.container;
      }
      var selector = '[data-annotation-id="' + this.data.parentId + '"]';
      var parentElement = this.layer.querySelector(selector);
      if (!parentElement) {
        return this.container;
      }
      var popup = new PopupElement({
        container: this.container,
        trigger: parentElement,
        color: this.data.color,
        title: this.data.title,
        contents: this.data.contents
      });
      var parentLeft = parseFloat(parentElement.style.left);
      var parentWidth = parseFloat(parentElement.style.width);
      _dom_utils.CustomStyle.setProp('transformOrigin', this.container, -(parentLeft + parentWidth) + 'px -' + parentElement.style.top);
      this.container.style.left = parentLeft + parentWidth + 'px';
      this.container.appendChild(popup.render());
      return this.container;
    }
  });
  return PopupAnnotationElement;
}();
var PopupElement = function PopupElementClosure() {
  var BACKGROUND_ENLIGHT = 0.7;
  function PopupElement(parameters) {
    this.container = parameters.container;
    this.trigger = parameters.trigger;
    this.color = parameters.color;
    this.title = parameters.title;
    this.contents = parameters.contents;
    this.hideWrapper = parameters.hideWrapper || false;
    this.pinned = false;
  }
  PopupElement.prototype = {
    render: function PopupElement_render() {
      var wrapper = document.createElement('div');
      wrapper.className = 'popupWrapper';
      this.hideElement = this.hideWrapper ? wrapper : this.container;
      this.hideElement.setAttribute('hidden', true);
      var popup = document.createElement('div');
      popup.className = 'popup';
      var color = this.color;
      if (color) {
        var r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
        var g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
        var b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
        popup.style.backgroundColor = _util.Util.makeCssRgb(r | 0, g | 0, b | 0);
      }
      var contents = this._formatContents(this.contents);
      var title = document.createElement('h1');
      title.textContent = this.title;
      this.trigger.addEventListener('click', this._toggle.bind(this));
      this.trigger.addEventListener('mouseover', this._show.bind(this, false));
      this.trigger.addEventListener('mouseout', this._hide.bind(this, false));
      popup.addEventListener('click', this._hide.bind(this, true));
      popup.appendChild(title);
      popup.appendChild(contents);
      wrapper.appendChild(popup);
      return wrapper;
    },
    _formatContents: function PopupElement_formatContents(contents) {
      var p = document.createElement('p');
      var lines = contents.split(/(?:\r\n?|\n)/);
      for (var i = 0, ii = lines.length; i < ii; ++i) {
        var line = lines[i];
        p.appendChild(document.createTextNode(line));
        if (i < ii - 1) {
          p.appendChild(document.createElement('br'));
        }
      }
      return p;
    },
    _toggle: function PopupElement_toggle() {
      if (this.pinned) {
        this._hide(true);
      } else {
        this._show(true);
      }
    },
    _show: function PopupElement_show(pin) {
      if (pin) {
        this.pinned = true;
      }
      if (this.hideElement.hasAttribute('hidden')) {
        this.hideElement.removeAttribute('hidden');
        this.container.style.zIndex += 1;
      }
    },
    _hide: function PopupElement_hide(unpin) {
      if (unpin) {
        this.pinned = false;
      }
      if (!this.hideElement.hasAttribute('hidden') && !this.pinned) {
        this.hideElement.setAttribute('hidden', true);
        this.container.style.zIndex -= 1;
      }
    }
  };
  return PopupElement;
}();
var LineAnnotationElement = function LineAnnotationElementClosure() {
  var SVG_NS = 'http://www.w3.org/2000/svg';
  function LineAnnotationElement(parameters) {
    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    AnnotationElement.call(this, parameters, isRenderable, true);
  }
  _util.Util.inherit(LineAnnotationElement, AnnotationElement, {
    render: function LineAnnotationElement_render() {
      this.container.className = 'lineAnnotation';
      var data = this.data;
      var width = data.rect[2] - data.rect[0];
      var height = data.rect[3] - data.rect[1];
      var svg = document.createElementNS(SVG_NS, 'svg:svg');
      svg.setAttributeNS(null, 'version', '1.1');
      svg.setAttributeNS(null, 'width', width + 'px');
      svg.setAttributeNS(null, 'height', height + 'px');
      svg.setAttributeNS(null, 'preserveAspectRatio', 'none');
      svg.setAttributeNS(null, 'viewBox', '0 0 ' + width + ' ' + height);
      var line = document.createElementNS(SVG_NS, 'svg:line');
      line.setAttributeNS(null, 'x1', data.rect[2] - data.lineCoordinates[0]);
      line.setAttributeNS(null, 'y1', data.rect[3] - data.lineCoordinates[1]);
      line.setAttributeNS(null, 'x2', data.rect[2] - data.lineCoordinates[2]);
      line.setAttributeNS(null, 'y2', data.rect[3] - data.lineCoordinates[3]);
      line.setAttributeNS(null, 'stroke-width', data.borderStyle.width);
      line.setAttributeNS(null, 'stroke', 'transparent');
      svg.appendChild(line);
      this.container.append(svg);
      this._createPopup(this.container, line, this.data);
      return this.container;
    }
  });
  return LineAnnotationElement;
}();
var HighlightAnnotationElement = function HighlightAnnotationElementClosure() {
  function HighlightAnnotationElement(parameters) {
    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    AnnotationElement.call(this, parameters, isRenderable, true);
  }
  _util.Util.inherit(HighlightAnnotationElement, AnnotationElement, {
    render: function HighlightAnnotationElement_render() {
      this.container.className = 'highlightAnnotation';
      if (!this.data.hasPopup) {
        this._createPopup(this.container, null, this.data);
      }
      return this.container;
    }
  });
  return HighlightAnnotationElement;
}();
var UnderlineAnnotationElement = function UnderlineAnnotationElementClosure() {
  function UnderlineAnnotationElement(parameters) {
    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    AnnotationElement.call(this, parameters, isRenderable, true);
  }
  _util.Util.inherit(UnderlineAnnotationElement, AnnotationElement, {
    render: function UnderlineAnnotationElement_render() {
      this.container.className = 'underlineAnnotation';
      if (!this.data.hasPopup) {
        this._createPopup(this.container, null, this.data);
      }
      return this.container;
    }
  });
  return UnderlineAnnotationElement;
}();
var SquigglyAnnotationElement = function SquigglyAnnotationElementClosure() {
  function SquigglyAnnotationElement(parameters) {
    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    AnnotationElement.call(this, parameters, isRenderable, true);
  }
  _util.Util.inherit(SquigglyAnnotationElement, AnnotationElement, {
    render: function SquigglyAnnotationElement_render() {
      this.container.className = 'squigglyAnnotation';
      if (!this.data.hasPopup) {
        this._createPopup(this.container, null, this.data);
      }
      return this.container;
    }
  });
  return SquigglyAnnotationElement;
}();
var StrikeOutAnnotationElement = function StrikeOutAnnotationElementClosure() {
  function StrikeOutAnnotationElement(parameters) {
    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    AnnotationElement.call(this, parameters, isRenderable, true);
  }
  _util.Util.inherit(StrikeOutAnnotationElement, AnnotationElement, {
    render: function StrikeOutAnnotationElement_render() {
      this.container.className = 'strikeoutAnnotation';
      if (!this.data.hasPopup) {
        this._createPopup(this.container, null, this.data);
      }
      return this.container;
    }
  });
  return StrikeOutAnnotationElement;
}();
var FileAttachmentAnnotationElement = function FileAttachmentAnnotationElementClosure() {
  function FileAttachmentAnnotationElement(parameters) {
    AnnotationElement.call(this, parameters, true);
    var file = this.data.file;
    this.filename = (0, _dom_utils.getFilenameFromUrl)(file.filename);
    this.content = file.content;
    this.linkService.onFileAttachmentAnnotation({
      id: (0, _util.stringToPDFString)(file.filename),
      filename: file.filename,
      content: file.content
    });
  }
  _util.Util.inherit(FileAttachmentAnnotationElement, AnnotationElement, {
    render: function FileAttachmentAnnotationElement_render() {
      this.container.className = 'fileAttachmentAnnotation';
      var trigger = document.createElement('div');
      trigger.style.height = this.container.style.height;
      trigger.style.width = this.container.style.width;
      trigger.addEventListener('dblclick', this._download.bind(this));
      if (!this.data.hasPopup && (this.data.title || this.data.contents)) {
        this._createPopup(this.container, trigger, this.data);
      }
      this.container.appendChild(trigger);
      return this.container;
    },
    _download: function FileAttachmentAnnotationElement_download() {
      if (!this.downloadManager) {
        (0, _util.warn)('Download cannot be started due to unavailable download manager');
        return;
      }
      this.downloadManager.downloadData(this.content, this.filename, '');
    }
  });
  return FileAttachmentAnnotationElement;
}();
var AnnotationLayer = function AnnotationLayerClosure() {
  return {
    render: function AnnotationLayer_render(parameters) {
      var annotationElementFactory = new AnnotationElementFactory();
      for (var i = 0, ii = parameters.annotations.length; i < ii; i++) {
        var data = parameters.annotations[i];
        if (!data) {
          continue;
        }
        var element = annotationElementFactory.create({
          data: data,
          layer: parameters.div,
          page: parameters.page,
          viewport: parameters.viewport,
          linkService: parameters.linkService,
          downloadManager: parameters.downloadManager,
          imageResourcesPath: parameters.imageResourcesPath || (0, _dom_utils.getDefaultSetting)('imageResourcesPath'),
          renderInteractiveForms: parameters.renderInteractiveForms || false
        });
        if (element.isRenderable) {
          parameters.div.appendChild(element.render());
        }
      }
    },
    update: function AnnotationLayer_update(parameters) {
      for (var i = 0, ii = parameters.annotations.length; i < ii; i++) {
        var data = parameters.annotations[i];
        var element = parameters.div.querySelector('[data-annotation-id="' + data.id + '"]');
        if (element) {
          _dom_utils.CustomStyle.setProp('transform', element, 'matrix(' + parameters.viewport.transform.join(',') + ')');
        }
      }
      parameters.div.removeAttribute('hidden');
    }
  };
}();
exports.AnnotationLayer = AnnotationLayer;

/***/ }),
/* 3 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.build = exports.version = exports._UnsupportedManager = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFWorker = exports.PDFDataRangeTransport = exports.getDocument = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _util = __w_pdfjs_require__(0);

var _dom_utils = __w_pdfjs_require__(1);

var _font_loader = __w_pdfjs_require__(11);

var _canvas = __w_pdfjs_require__(10);

var _metadata = __w_pdfjs_require__(7);

var DEFAULT_RANGE_CHUNK_SIZE = 65536;
var isWorkerDisabled = false;
var workerSrc;
var isPostMessageTransfersDisabled = false;
var pdfjsFilePath = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : null;
var fakeWorkerFilesLoader = null;
var useRequireEnsure = false;
if (typeof __pdfjsdev_webpack__ === 'undefined') {
  if (typeof window === 'undefined') {
    isWorkerDisabled = true;
    if (typeof require.ensure === 'undefined') {
      require.ensure = require('node-ensure');
    }
    useRequireEnsure = true;
  } else if (typeof require !== 'undefined' && typeof require.ensure === 'function') {
    useRequireEnsure = true;
  }
  if (typeof requirejs !== 'undefined' && requirejs.toUrl) {
    workerSrc = requirejs.toUrl('pdfjs-dist/build/pdf.worker.js');
  }
  var dynamicLoaderSupported = typeof requirejs !== 'undefined' && requirejs.load;
  fakeWorkerFilesLoader = useRequireEnsure ? function (callback) {
    require.ensure([], function () {
      var worker = require('./pdf.worker.js');
      callback(worker.WorkerMessageHandler);
    });
  } : dynamicLoaderSupported ? function (callback) {
    requirejs(['pdfjs-dist/build/pdf.worker'], function (worker) {
      callback(worker.WorkerMessageHandler);
    });
  } : null;
}
function getDocument(src, pdfDataRangeTransport, passwordCallback, progressCallback) {
  var task = new PDFDocumentLoadingTask();
  if (arguments.length > 1) {
    (0, _util.deprecated)('getDocument is called with pdfDataRangeTransport, ' + 'passwordCallback or progressCallback argument');
  }
  if (pdfDataRangeTransport) {
    if (!(pdfDataRangeTransport instanceof PDFDataRangeTransport)) {
      pdfDataRangeTransport = Object.create(pdfDataRangeTransport);
      pdfDataRangeTransport.length = src.length;
      pdfDataRangeTransport.initialData = src.initialData;
      if (!pdfDataRangeTransport.abort) {
        pdfDataRangeTransport.abort = function () {};
      }
    }
    src = Object.create(src);
    src.range = pdfDataRangeTransport;
  }
  task.onPassword = passwordCallback || null;
  task.onProgress = progressCallback || null;
  var source;
  if (typeof src === 'string') {
    source = { url: src };
  } else if ((0, _util.isArrayBuffer)(src)) {
    source = { data: src };
  } else if (src instanceof PDFDataRangeTransport) {
    source = { range: src };
  } else {
    if ((typeof src === 'undefined' ? 'undefined' : _typeof(src)) !== 'object') {
      (0, _util.error)('Invalid parameter in getDocument, need either Uint8Array, ' + 'string or a parameter object');
    }
    if (!src.url && !src.data && !src.range) {
      (0, _util.error)('Invalid parameter object: need either .data, .range or .url');
    }
    source = src;
  }
  var params = {};
  var rangeTransport = null;
  var worker = null;
  for (var key in source) {
    if (key === 'url' && typeof window !== 'undefined') {
      params[key] = new URL(source[key], window.location).href;
      continue;
    } else if (key === 'range') {
      rangeTransport = source[key];
      continue;
    } else if (key === 'worker') {
      worker = source[key];
      continue;
    } else if (key === 'data' && !(source[key] instanceof Uint8Array)) {
      var pdfBytes = source[key];
      if (typeof pdfBytes === 'string') {
        params[key] = (0, _util.stringToBytes)(pdfBytes);
      } else if ((typeof pdfBytes === 'undefined' ? 'undefined' : _typeof(pdfBytes)) === 'object' && pdfBytes !== null && !isNaN(pdfBytes.length)) {
        params[key] = new Uint8Array(pdfBytes);
      } else if ((0, _util.isArrayBuffer)(pdfBytes)) {
        params[key] = new Uint8Array(pdfBytes);
      } else {
        (0, _util.error)('Invalid PDF binary data: either typed array, string or ' + 'array-like object is expected in the data property.');
      }
      continue;
    }
    params[key] = source[key];
  }
  params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;
  params.disableNativeImageDecoder = params.disableNativeImageDecoder === true;
  params.ignoreErrors = params.stopAtErrors !== true;
  var CMapReaderFactory = params.CMapReaderFactory || _dom_utils.DOMCMapReaderFactory;
  if (!worker) {
    var workerPort = (0, _dom_utils.getDefaultSetting)('workerPort');
    worker = workerPort ? new PDFWorker(null, workerPort) : new PDFWorker();
    task._worker = worker;
  }
  var docId = task.docId;
  worker.promise.then(function () {
    if (task.destroyed) {
      throw new Error('Loading aborted');
    }
    return _fetchDocument(worker, params, rangeTransport, docId).then(function (workerId) {
      if (task.destroyed) {
        throw new Error('Loading aborted');
      }
      var messageHandler = new _util.MessageHandler(docId, workerId, worker.port);
      var transport = new WorkerTransport(messageHandler, task, rangeTransport, CMapReaderFactory);
      task._transport = transport;
      messageHandler.send('Ready', null);
    });
  }).catch(task._capability.reject);
  return task;
}
function _fetchDocument(worker, source, pdfDataRangeTransport, docId) {
  if (worker.destroyed) {
    return Promise.reject(new Error('Worker was destroyed'));
  }
  source.disableAutoFetch = (0, _dom_utils.getDefaultSetting)('disableAutoFetch');
  source.disableStream = (0, _dom_utils.getDefaultSetting)('disableStream');
  source.chunkedViewerLoading = !!pdfDataRangeTransport;
  if (pdfDataRangeTransport) {
    source.length = pdfDataRangeTransport.length;
    source.initialData = pdfDataRangeTransport.initialData;
  }
  return worker.messageHandler.sendWithPromise('GetDocRequest', {
    docId: docId,
    source: source,
    disableRange: (0, _dom_utils.getDefaultSetting)('disableRange'),
    maxImageSize: (0, _dom_utils.getDefaultSetting)('maxImageSize'),
    disableFontFace: (0, _dom_utils.getDefaultSetting)('disableFontFace'),
    disableCreateObjectURL: (0, _dom_utils.getDefaultSetting)('disableCreateObjectURL'),
    postMessageTransfers: (0, _dom_utils.getDefaultSetting)('postMessageTransfers') && !isPostMessageTransfersDisabled,
    docBaseUrl: source.docBaseUrl,
    disableNativeImageDecoder: source.disableNativeImageDecoder,
    ignoreErrors: source.ignoreErrors
  }).then(function (workerId) {
    if (worker.destroyed) {
      throw new Error('Worker was destroyed');
    }
    return workerId;
  });
}
var PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() {
  var nextDocumentId = 0;
  function PDFDocumentLoadingTask() {
    this._capability = (0, _util.createPromiseCapability)();
    this._transport = null;
    this._worker = null;
    this.docId = 'd' + nextDocumentId++;
    this.destroyed = false;
    this.onPassword = null;
    this.onProgress = null;
    this.onUnsupportedFeature = null;
  }
  PDFDocumentLoadingTask.prototype = {
    get promise() {
      return this._capability.promise;
    },
    destroy: function destroy() {
      this.destroyed = true;
      var transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();
      return transportDestroyed.then(function () {
        this._transport = null;
        if (this._worker) {
          this._worker.destroy();
          this._worker = null;
        }
      }.bind(this));
    },
    then: function PDFDocumentLoadingTask_then(onFulfilled, onRejected) {
      return this.promise.then.apply(this.promise, arguments);
    }
  };
  return PDFDocumentLoadingTask;
}();
var PDFDataRangeTransport = function pdfDataRangeTransportClosure() {
  function PDFDataRangeTransport(length, initialData) {
    this.length = length;
    this.initialData = initialData;
    this._rangeListeners = [];
    this._progressListeners = [];
    this._progressiveReadListeners = [];
    this._readyCapability = (0, _util.createPromiseCapability)();
  }
  PDFDataRangeTransport.prototype = {
    addRangeListener: function PDFDataRangeTransport_addRangeListener(listener) {
      this._rangeListeners.push(listener);
    },
    addProgressListener: function PDFDataRangeTransport_addProgressListener(listener) {
      this._progressListeners.push(listener);
    },
    addProgressiveReadListener: function PDFDataRangeTransport_addProgressiveReadListener(listener) {
      this._progressiveReadListeners.push(listener);
    },
    onDataRange: function PDFDataRangeTransport_onDataRange(begin, chunk) {
      var listeners = this._rangeListeners;
      for (var i = 0, n = listeners.length; i < n; ++i) {
        listeners[i](begin, chunk);
      }
    },
    onDataProgress: function PDFDataRangeTransport_onDataProgress(loaded) {
      this._readyCapability.promise.then(function () {
        var listeners = this._progressListeners;
        for (var i = 0, n = listeners.length; i < n; ++i) {
          listeners[i](loaded);
        }
      }.bind(this));
    },
    onDataProgressiveRead: function PDFDataRangeTransport_onDataProgress(chunk) {
      this._readyCapability.promise.then(function () {
        var listeners = this._progressiveReadListeners;
        for (var i = 0, n = listeners.length; i < n; ++i) {
          listeners[i](chunk);
        }
      }.bind(this));
    },
    transportReady: function PDFDataRangeTransport_transportReady() {
      this._readyCapability.resolve();
    },
    requestDataRange: function PDFDataRangeTransport_requestDataRange(begin, end) {
      throw new Error('Abstract method PDFDataRangeTransport.requestDataRange');
    },
    abort: function PDFDataRangeTransport_abort() {}
  };
  return PDFDataRangeTransport;
}();
var PDFDocumentProxy = function PDFDocumentProxyClosure() {
  function PDFDocumentProxy(pdfInfo, transport, loadingTask) {
    this.pdfInfo = pdfInfo;
    this.transport = transport;
    this.loadingTask = loadingTask;
  }
  PDFDocumentProxy.prototype = {
    get numPages() {
      return this.pdfInfo.numPages;
    },
    get fingerprint() {
      return this.pdfInfo.fingerprint;
    },
    getPage: function PDFDocumentProxy_getPage(pageNumber) {
      return this.transport.getPage(pageNumber);
    },
    getPageIndex: function PDFDocumentProxy_getPageIndex(ref) {
      return this.transport.getPageIndex(ref);
    },
    getDestinations: function PDFDocumentProxy_getDestinations() {
      return this.transport.getDestinations();
    },
    getDestination: function PDFDocumentProxy_getDestination(id) {
      return this.transport.getDestination(id);
    },
    getPageLabels: function PDFDocumentProxy_getPageLabels() {
      return this.transport.getPageLabels();
    },
    getAttachments: function PDFDocumentProxy_getAttachments() {
      return this.transport.getAttachments();
    },
    getJavaScript: function PDFDocumentProxy_getJavaScript() {
      return this.transport.getJavaScript();
    },
    getOutline: function PDFDocumentProxy_getOutline() {
      return this.transport.getOutline();
    },
    getMetadata: function PDFDocumentProxy_getMetadata() {
      return this.transport.getMetadata();
    },
    getData: function PDFDocumentProxy_getData() {
      return this.transport.getData();
    },
    getDownloadInfo: function PDFDocumentProxy_getDownloadInfo() {
      return this.transport.downloadInfoCapability.promise;
    },
    getStats: function PDFDocumentProxy_getStats() {
      return this.transport.getStats();
    },
    cleanup: function PDFDocumentProxy_cleanup() {
      this.transport.startCleanup();
    },
    destroy: function PDFDocumentProxy_destroy() {
      return this.loadingTask.destroy();
    }
  };
  return PDFDocumentProxy;
}();
var PDFPageProxy = function PDFPageProxyClosure() {
  function PDFPageProxy(pageIndex, pageInfo, transport) {
    this.pageIndex = pageIndex;
    this.pageInfo = pageInfo;
    this.transport = transport;
    this.stats = new _util.StatTimer();
    this.stats.enabled = (0, _dom_utils.getDefaultSetting)('enableStats');
    this.commonObjs = transport.commonObjs;
    this.objs = new PDFObjects();
    this.cleanupAfterRender = false;
    this.pendingCleanup = false;
    this.intentStates = Object.create(null);
    this.destroyed = false;
  }
  PDFPageProxy.prototype = {
    get pageNumber() {
      return this.pageIndex + 1;
    },
    get rotate() {
      return this.pageInfo.rotate;
    },
    get ref() {
      return this.pageInfo.ref;
    },
    get userUnit() {
      return this.pageInfo.userUnit;
    },
    get view() {
      return this.pageInfo.view;
    },
    getViewport: function PDFPageProxy_getViewport(scale, rotate) {
      if (arguments.length < 2) {
        rotate = this.rotate;
      }
      return new _util.PageViewport(this.view, scale, rotate, 0, 0);
    },
    getAnnotations: function PDFPageProxy_getAnnotations(params) {
      var intent = params && params.intent || null;
      if (!this.annotationsPromise || this.annotationsIntent !== intent) {
        this.annotationsPromise = this.transport.getAnnotations(this.pageIndex, intent);
        this.annotationsIntent = intent;
      }
      return this.annotationsPromise;
    },
    render: function PDFPageProxy_render(params) {
      var stats = this.stats;
      stats.time('Overall');
      this.pendingCleanup = false;
      var renderingIntent = params.intent === 'print' ? 'print' : 'display';
      var canvasFactory = params.canvasFactory || new _dom_utils.DOMCanvasFactory();
      if (!this.intentStates[renderingIntent]) {
        this.intentStates[renderingIntent] = Object.create(null);
      }
      var intentState = this.intentStates[renderingIntent];
      if (!intentState.displayReadyCapability) {
        intentState.receivingOperatorList = true;
        intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
        intentState.operatorList = {
          fnArray: [],
          argsArray: [],
          lastChunk: false
        };
        this.stats.time('Page Request');
        this.transport.messageHandler.send('RenderPageRequest', {
          pageIndex: this.pageNumber - 1,
          intent: renderingIntent,
          renderInteractiveForms: params.renderInteractiveForms === true
        });
      }
      var internalRenderTask = new InternalRenderTask(complete, params, this.objs, this.commonObjs, intentState.operatorList, this.pageNumber, canvasFactory);
      internalRenderTask.useRequestAnimationFrame = renderingIntent !== 'print';
      if (!intentState.renderTasks) {
        intentState.renderTasks = [];
      }
      intentState.renderTasks.push(internalRenderTask);
      var renderTask = internalRenderTask.task;
      if (params.continueCallback) {
        (0, _util.deprecated)('render is used with continueCallback parameter');
        renderTask.onContinue = params.continueCallback;
      }
      var self = this;
      intentState.displayReadyCapability.promise.then(function pageDisplayReadyPromise(transparency) {
        if (self.pendingCleanup) {
          complete();
          return;
        }
        stats.time('Rendering');
        internalRenderTask.initializeGraphics(transparency);
        internalRenderTask.operatorListChanged();
      }, function pageDisplayReadPromiseError(reason) {
        complete(reason);
      });
      function complete(error) {
        var i = intentState.renderTasks.indexOf(internalRenderTask);
        if (i >= 0) {
          intentState.renderTasks.splice(i, 1);
        }
        if (self.cleanupAfterRender) {
          self.pendingCleanup = true;
        }
        self._tryCleanup();
        if (error) {
          internalRenderTask.capability.reject(error);
        } else {
          internalRenderTask.capability.resolve();
        }
        stats.timeEnd('Rendering');
        stats.timeEnd('Overall');
      }
      return renderTask;
    },
    getOperatorList: function PDFPageProxy_getOperatorList() {
      function operatorListChanged() {
        if (intentState.operatorList.lastChunk) {
          intentState.opListReadCapability.resolve(intentState.operatorList);
          var i = intentState.renderTasks.indexOf(opListTask);
          if (i >= 0) {
            intentState.renderTasks.splice(i, 1);
          }
        }
      }
      var renderingIntent = 'oplist';
      if (!this.intentStates[renderingIntent]) {
        this.intentStates[renderingIntent] = Object.create(null);
      }
      var intentState = this.intentStates[renderingIntent];
      var opListTask;
      if (!intentState.opListReadCapability) {
        opListTask = {};
        opListTask.operatorListChanged = operatorListChanged;
        intentState.receivingOperatorList = true;
        intentState.opListReadCapability = (0, _util.createPromiseCapability)();
        intentState.renderTasks = [];
        intentState.renderTasks.push(opListTask);
        intentState.operatorList = {
          fnArray: [],
          argsArray: [],
          lastChunk: false
        };
        this.transport.messageHandler.send('RenderPageRequest', {
          pageIndex: this.pageIndex,
          intent: renderingIntent
        });
      }
      return intentState.opListReadCapability.promise;
    },
    getTextContent: function PDFPageProxy_getTextContent(params) {
      params = params || {};
      return this.transport.messageHandler.sendWithPromise('GetTextContent', {
        pageIndex: this.pageNumber - 1,
        normalizeWhitespace: params.normalizeWhitespace === true,
        combineTextItems: params.disableCombineTextItems !== true
      });
    },
    _destroy: function PDFPageProxy_destroy() {
      this.destroyed = true;
      this.transport.pageCache[this.pageIndex] = null;
      var waitOn = [];
      Object.keys(this.intentStates).forEach(function (intent) {
        if (intent === 'oplist') {
          return;
        }
        var intentState = this.intentStates[intent];
        intentState.renderTasks.forEach(function (renderTask) {
          var renderCompleted = renderTask.capability.promise.catch(function () {});
          waitOn.push(renderCompleted);
          renderTask.cancel();
        });
      }, this);
      this.objs.clear();
      this.annotationsPromise = null;
      this.pendingCleanup = false;
      return Promise.all(waitOn);
    },
    destroy: function destroy() {
      (0, _util.deprecated)('page destroy method, use cleanup() instead');
      this.cleanup();
    },
    cleanup: function PDFPageProxy_cleanup() {
      this.pendingCleanup = true;
      this._tryCleanup();
    },
    _tryCleanup: function PDFPageProxy_tryCleanup() {
      if (!this.pendingCleanup || Object.keys(this.intentStates).some(function (intent) {
        var intentState = this.intentStates[intent];
        return intentState.renderTasks.length !== 0 || intentState.receivingOperatorList;
      }, this)) {
        return;
      }
      Object.keys(this.intentStates).forEach(function (intent) {
        delete this.intentStates[intent];
      }, this);
      this.objs.clear();
      this.annotationsPromise = null;
      this.pendingCleanup = false;
    },
    _startRenderPage: function PDFPageProxy_startRenderPage(transparency, intent) {
      var intentState = this.intentStates[intent];
      if (intentState.displayReadyCapability) {
        intentState.displayReadyCapability.resolve(transparency);
      }
    },
    _renderPageChunk: function PDFPageProxy_renderPageChunk(operatorListChunk, intent) {
      var intentState = this.intentStates[intent];
      var i, ii;
      for (i = 0, ii = operatorListChunk.length; i < ii; i++) {
        intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
        intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
      }
      intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
      for (i = 0; i < intentState.renderTasks.length; i++) {
        intentState.renderTasks[i].operatorListChanged();
      }
      if (operatorListChunk.lastChunk) {
        intentState.receivingOperatorList = false;
        this._tryCleanup();
      }
    }
  };
  return PDFPageProxy;
}();
var PDFWorker = function PDFWorkerClosure() {
  var nextFakeWorkerId = 0;
  function getWorkerSrc() {
    if (typeof workerSrc !== 'undefined') {
      return workerSrc;
    }
    if ((0, _dom_utils.getDefaultSetting)('workerSrc')) {
      return (0, _dom_utils.getDefaultSetting)('workerSrc');
    }
    if (pdfjsFilePath) {
      return pdfjsFilePath.replace(/(\.(?:min\.)?js)$/i, '.worker$1');
    }
    (0, _util.error)('No PDFJS.workerSrc specified');
  }
  var fakeWorkerFilesLoadedCapability;
  function setupFakeWorkerGlobal() {
    var WorkerMessageHandler;
    if (fakeWorkerFilesLoadedCapability) {
      return fakeWorkerFilesLoadedCapability.promise;
    }
    fakeWorkerFilesLoadedCapability = (0, _util.createPromiseCapability)();
    var loader = fakeWorkerFilesLoader || function (callback) {
      _util.Util.loadScript(getWorkerSrc(), function () {
        callback(window.pdfjsDistBuildPdfWorker.WorkerMessageHandler);
      });
    };
    loader(fakeWorkerFilesLoadedCapability.resolve);
    return fakeWorkerFilesLoadedCapability.promise;
  }
  function FakeWorkerPort(defer) {
    this._listeners = [];
    this._defer = defer;
    this._deferred = Promise.resolve(undefined);
  }
  FakeWorkerPort.prototype = {
    postMessage: function postMessage(obj, transfers) {
      function cloneValue(value) {
        if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object' || value === null) {
          return value;
        }
        if (cloned.has(value)) {
          return cloned.get(value);
        }
        var result;
        var buffer;
        if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {
          var transferable = transfers && transfers.indexOf(buffer) >= 0;
          if (value === buffer) {
            result = value;
          } else if (transferable) {
            result = new value.constructor(buffer, value.byteOffset, value.byteLength);
          } else {
            result = new value.constructor(value);
          }
          cloned.set(value, result);
          return result;
        }
        result = (0, _util.isArray)(value) ? [] : {};
        cloned.set(value, result);
        for (var i in value) {
          var desc,
              p = value;
          while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {
            p = Object.getPrototypeOf(p);
          }
          if (typeof desc.value === 'undefined' || typeof desc.value === 'function') {
            continue;
          }
          result[i] = cloneValue(desc.value);
        }
        return result;
      }
      if (!this._defer) {
        this._listeners.forEach(function (listener) {
          listener.call(this, { data: obj });
        }, this);
        return;
      }
      var cloned = new WeakMap();
      var e = { data: cloneValue(obj) };
      this._deferred.then(function () {
        this._listeners.forEach(function (listener) {
          listener.call(this, e);
        }, this);
      }.bind(this));
    },
    addEventListener: function addEventListener(name, listener) {
      this._listeners.push(listener);
    },
    removeEventListener: function removeEventListener(name, listener) {
      var i = this._listeners.indexOf(listener);
      this._listeners.splice(i, 1);
    },
    terminate: function terminate() {
      this._listeners = [];
    }
  };
  function createCDNWrapper(url) {
    var wrapper = 'importScripts(\'' + url + '\');';
    return URL.createObjectURL(new Blob([wrapper]));
  }
  function PDFWorker(name, port) {
    this.name = name;
    this.destroyed = false;
    this._readyCapability = (0, _util.createPromiseCapability)();
    this._port = null;
    this._webWorker = null;
    this._messageHandler = null;
    if (port) {
      this._initializeFromPort(port);
      return;
    }
    this._initialize();
  }
  PDFWorker.prototype = {
    get promise() {
      return this._readyCapability.promise;
    },
    get port() {
      return this._port;
    },
    get messageHandler() {
      return this._messageHandler;
    },
    _initializeFromPort: function PDFWorker_initializeFromPort(port) {
      this._port = port;
      this._messageHandler = new _util.MessageHandler('main', 'worker', port);
      this._messageHandler.on('ready', function () {});
      this._readyCapability.resolve();
    },
    _initialize: function PDFWorker_initialize() {
      if (!isWorkerDisabled && !(0, _dom_utils.getDefaultSetting)('disableWorker') && typeof Worker !== 'undefined') {
        var workerSrc = getWorkerSrc();
        try {
          if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {
            workerSrc = createCDNWrapper(new URL(workerSrc, window.location).href);
          }
          var worker = new Worker(workerSrc);
          var messageHandler = new _util.MessageHandler('main', 'worker', worker);
          var terminateEarly = function () {
            worker.removeEventListener('error', onWorkerError);
            messageHandler.destroy();
            worker.terminate();
            if (this.destroyed) {
              this._readyCapability.reject(new Error('Worker was destroyed'));
            } else {
              this._setupFakeWorker();
            }
          }.bind(this);
          var onWorkerError = function (event) {
            if (!this._webWorker) {
              terminateEarly();
            }
          }.bind(this);
          worker.addEventListener('error', onWorkerError);
          messageHandler.on('test', function PDFWorker_test(data) {
            worker.removeEventListener('error', onWorkerError);
            if (this.destroyed) {
              terminateEarly();
              return;
            }
            var supportTypedArray = data && data.supportTypedArray;
            if (supportTypedArray) {
              this._messageHandler = messageHandler;
              this._port = worker;
              this._webWorker = worker;
              if (!data.supportTransfers) {
                isPostMessageTransfersDisabled = true;
              }
              this._readyCapability.resolve();
              messageHandler.send('configure', { verbosity: (0, _util.getVerbosityLevel)() });
            } else {
              this._setupFakeWorker();
              messageHandler.destroy();
              worker.terminate();
            }
          }.bind(this));
          messageHandler.on('console_log', function (data) {
            console.log.apply(console, data);
          });
          messageHandler.on('console_error', function (data) {
            console.error.apply(console, data);
          });
          messageHandler.on('ready', function (data) {
            worker.removeEventListener('error', onWorkerError);
            if (this.destroyed) {
              terminateEarly();
              return;
            }
            try {
              sendTest();
            } catch (e) {
              this._setupFakeWorker();
            }
          }.bind(this));
          var sendTest = function sendTest() {
            var postMessageTransfers = (0, _dom_utils.getDefaultSetting)('postMessageTransfers') && !isPostMessageTransfersDisabled;
            var testObj = new Uint8Array([postMessageTransfers ? 255 : 0]);
            try {
              messageHandler.send('test', testObj, [testObj.buffer]);
            } catch (ex) {
              (0, _util.info)('Cannot use postMessage transfers');
              testObj[0] = 0;
              messageHandler.send('test', testObj);
            }
          };
          sendTest();
          return;
        } catch (e) {
          (0, _util.info)('The worker has been disabled.');
        }
      }
      this._setupFakeWorker();
    },
    _setupFakeWorker: function PDFWorker_setupFakeWorker() {
      if (!isWorkerDisabled && !(0, _dom_utils.getDefaultSetting)('disableWorker')) {
        (0, _util.warn)('Setting up fake worker.');
        isWorkerDisabled = true;
      }
      setupFakeWorkerGlobal().then(function (WorkerMessageHandler) {
        if (this.destroyed) {
          this._readyCapability.reject(new Error('Worker was destroyed'));
          return;
        }
        var isTypedArraysPresent = Uint8Array !== Float32Array;
        var port = new FakeWorkerPort(isTypedArraysPresent);
        this._port = port;
        var id = 'fake' + nextFakeWorkerId++;
        var workerHandler = new _util.MessageHandler(id + '_worker', id, port);
        WorkerMessageHandler.setup(workerHandler, port);
        var messageHandler = new _util.MessageHandler(id, id + '_worker', port);
        this._messageHandler = messageHandler;
        this._readyCapability.resolve();
      }.bind(this));
    },
    destroy: function PDFWorker_destroy() {
      this.destroyed = true;
      if (this._webWorker) {
        this._webWorker.terminate();
        this._webWorker = null;
      }
      this._port = null;
      if (this._messageHandler) {
        this._messageHandler.destroy();
        this._messageHandler = null;
      }
    }
  };
  return PDFWorker;
}();
var WorkerTransport = function WorkerTransportClosure() {
  function WorkerTransport(messageHandler, loadingTask, pdfDataRangeTransport, CMapReaderFactory) {
    this.messageHandler = messageHandler;
    this.loadingTask = loadingTask;
    this.pdfDataRangeTransport = pdfDataRangeTransport;
    this.commonObjs = new PDFObjects();
    this.fontLoader = new _font_loader.FontLoader(loadingTask.docId);
    this.CMapReaderFactory = new CMapReaderFactory({
      baseUrl: (0, _dom_utils.getDefaultSetting)('cMapUrl'),
      isCompressed: (0, _dom_utils.getDefaultSetting)('cMapPacked')
    });
    this.destroyed = false;
    this.destroyCapability = null;
    this._passwordCapability = null;
    this.pageCache = [];
    this.pagePromises = [];
    this.downloadInfoCapability = (0, _util.createPromiseCapability)();
    this.setupMessageHandler();
  }
  WorkerTransport.prototype = {
    destroy: function WorkerTransport_destroy() {
      if (this.destroyCapability) {
        return this.destroyCapability.promise;
      }
      this.destroyed = true;
      this.destroyCapability = (0, _util.createPromiseCapability)();
      if (this._passwordCapability) {
        this._passwordCapability.reject(new Error('Worker was destroyed during onPassword callback'));
      }
      var waitOn = [];
      this.pageCache.forEach(function (page) {
        if (page) {
          waitOn.push(page._destroy());
        }
      });
      this.pageCache = [];
      this.pagePromises = [];
      var self = this;
      var terminated = this.messageHandler.sendWithPromise('Terminate', null);
      waitOn.push(terminated);
      Promise.all(waitOn).then(function () {
        self.fontLoader.clear();
        if (self.pdfDataRangeTransport) {
          self.pdfDataRangeTransport.abort();
          self.pdfDataRangeTransport = null;
        }
        if (self.messageHandler) {
          self.messageHandler.destroy();
          self.messageHandler = null;
        }
        self.destroyCapability.resolve();
      }, this.destroyCapability.reject);
      return this.destroyCapability.promise;
    },
    setupMessageHandler: function WorkerTransport_setupMessageHandler() {
      var messageHandler = this.messageHandler;
      var loadingTask = this.loadingTask;
      var pdfDataRangeTransport = this.pdfDataRangeTransport;
      if (pdfDataRangeTransport) {
        pdfDataRangeTransport.addRangeListener(function (begin, chunk) {
          messageHandler.send('OnDataRange', {
            begin: begin,
            chunk: chunk
          });
        });
        pdfDataRangeTransport.addProgressListener(function (loaded) {
          messageHandler.send('OnDataProgress', { loaded: loaded });
        });
        pdfDataRangeTransport.addProgressiveReadListener(function (chunk) {
          messageHandler.send('OnDataRange', { chunk: chunk });
        });
        messageHandler.on('RequestDataRange', function transportDataRange(data) {
          pdfDataRangeTransport.requestDataRange(data.begin, data.end);
        }, this);
      }
      messageHandler.on('GetDoc', function transportDoc(data) {
        var pdfInfo = data.pdfInfo;
        this.numPages = data.pdfInfo.numPages;
        var loadingTask = this.loadingTask;
        var pdfDocument = new PDFDocumentProxy(pdfInfo, this, loadingTask);
        this.pdfDocument = pdfDocument;
        loadingTask._capability.resolve(pdfDocument);
      }, this);
      messageHandler.on('PasswordRequest', function transportPasswordRequest(exception) {
        this._passwordCapability = (0, _util.createPromiseCapability)();
        if (loadingTask.onPassword) {
          var updatePassword = function (password) {
            this._passwordCapability.resolve({ password: password });
          }.bind(this);
          loadingTask.onPassword(updatePassword, exception.code);
        } else {
          this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
        }
        return this._passwordCapability.promise;
      }, this);
      messageHandler.on('PasswordException', function transportPasswordException(exception) {
        loadingTask._capability.reject(new _util.PasswordException(exception.message, exception.code));
      }, this);
      messageHandler.on('InvalidPDF', function transportInvalidPDF(exception) {
        this.loadingTask._capability.reject(new _util.InvalidPDFException(exception.message));
      }, this);
      messageHandler.on('MissingPDF', function transportMissingPDF(exception) {
        this.loadingTask._capability.reject(new _util.MissingPDFException(exception.message));
      }, this);
      messageHandler.on('UnexpectedResponse', function transportUnexpectedResponse(exception) {
        this.loadingTask._capability.reject(new _util.UnexpectedResponseException(exception.message, exception.status));
      }, this);
      messageHandler.on('UnknownError', function transportUnknownError(exception) {
        this.loadingTask._capability.reject(new _util.UnknownErrorException(exception.message, exception.details));
      }, this);
      messageHandler.on('DataLoaded', function transportPage(data) {
        this.downloadInfoCapability.resolve(data);
      }, this);
      messageHandler.on('PDFManagerReady', function transportPage(data) {
        if (this.pdfDataRangeTransport) {
          this.pdfDataRangeTransport.transportReady();
        }
      }, this);
      messageHandler.on('StartRenderPage', function transportRender(data) {
        if (this.destroyed) {
          return;
        }
        var page = this.pageCache[data.pageIndex];
        page.stats.timeEnd('Page Request');
        page._startRenderPage(data.transparency, data.intent);
      }, this);
      messageHandler.on('RenderPageChunk', function transportRender(data) {
        if (this.destroyed) {
          return;
        }
        var page = this.pageCache[data.pageIndex];
        page._renderPageChunk(data.operatorList, data.intent);
      }, this);
      messageHandler.on('commonobj', function transportObj(data) {
        if (this.destroyed) {
          return;
        }
        var id = data[0];
        var type = data[1];
        if (this.commonObjs.hasData(id)) {
          return;
        }
        switch (type) {
          case 'Font':
            var exportedData = data[2];
            if ('error' in exportedData) {
              var exportedError = exportedData.error;
              (0, _util.warn)('Error during font loading: ' + exportedError);
              this.commonObjs.resolve(id, exportedError);
              break;
            }
            var fontRegistry = null;
            if ((0, _dom_utils.getDefaultSetting)('pdfBug') && _util.globalScope.FontInspector && _util.globalScope['FontInspector'].enabled) {
              fontRegistry = {
                registerFont: function registerFont(font, url) {
                  _util.globalScope['FontInspector'].fontAdded(font, url);
                }
              };
            }
            var font = new _font_loader.FontFaceObject(exportedData, {
              isEvalSuported: (0, _dom_utils.getDefaultSetting)('isEvalSupported'),
              disableFontFace: (0, _dom_utils.getDefaultSetting)('disableFontFace'),
              fontRegistry: fontRegistry
            });
            this.fontLoader.bind([font], function fontReady(fontObjs) {
              this.commonObjs.resolve(id, font);
            }.bind(this));
            break;
          case 'FontPath':
            this.commonObjs.resolve(id, data[2]);
            break;
          default:
            (0, _util.error)('Got unknown common object type ' + type);
        }
      }, this);
      messageHandler.on('obj', function transportObj(data) {
        if (this.destroyed) {
          return;
        }
        var id = data[0];
        var pageIndex = data[1];
        var type = data[2];
        var pageProxy = this.pageCache[pageIndex];
        var imageData;
        if (pageProxy.objs.hasData(id)) {
          return;
        }
        switch (type) {
          case 'JpegStream':
            imageData = data[3];
            (0, _util.loadJpegStream)(id, imageData, pageProxy.objs);
            break;
          case 'Image':
            imageData = data[3];
            pageProxy.objs.resolve(id, imageData);
            var MAX_IMAGE_SIZE_TO_STORE = 8000000;
            if (imageData && 'data' in imageData && imageData.data.length > MAX_IMAGE_SIZE_TO_STORE) {
              pageProxy.cleanupAfterRender = true;
            }
            break;
          default:
            (0, _util.error)('Got unknown object type ' + type);
        }
      }, this);
      messageHandler.on('DocProgress', function transportDocProgress(data) {
        if (this.destroyed) {
          return;
        }
        var loadingTask = this.loadingTask;
        if (loadingTask.onProgress) {
          loadingTask.onProgress({
            loaded: data.loaded,
            total: data.total
          });
        }
      }, this);
      messageHandler.on('PageError', function transportError(data) {
        if (this.destroyed) {
          return;
        }
        var page = this.pageCache[data.pageNum - 1];
        var intentState = page.intentStates[data.intent];
        if (intentState.displayReadyCapability) {
          intentState.displayReadyCapability.reject(data.error);
        } else {
          (0, _util.error)(data.error);
        }
        if (intentState.operatorList) {
          intentState.operatorList.lastChunk = true;
          for (var i = 0; i < intentState.renderTasks.length; i++) {
            intentState.renderTasks[i].operatorListChanged();
          }
        }
      }, this);
      messageHandler.on('UnsupportedFeature', function transportUnsupportedFeature(data) {
        if (this.destroyed) {
          return;
        }
        var featureId = data.featureId;
        var loadingTask = this.loadingTask;
        if (loadingTask.onUnsupportedFeature) {
          loadingTask.onUnsupportedFeature(featureId);
        }
        _UnsupportedManager.notify(featureId);
      }, this);
      messageHandler.on('JpegDecode', function (data) {
        if (this.destroyed) {
          return Promise.reject(new Error('Worker was destroyed'));
        }
        if (typeof document === 'undefined') {
          return Promise.reject(new Error('"document" is not defined.'));
        }
        var imageUrl = data[0];
        var components = data[1];
        if (components !== 3 && components !== 1) {
          return Promise.reject(new Error('Only 3 components or 1 component can be returned'));
        }
        return new Promise(function (resolve, reject) {
          var img = new Image();
          img.onload = function () {
            var width = img.width;
            var height = img.height;
            var size = width * height;
            var rgbaLength = size * 4;
            var buf = new Uint8Array(size * components);
            var tmpCanvas = document.createElement('canvas');
            tmpCanvas.width = width;
            tmpCanvas.height = height;
            var tmpCtx = tmpCanvas.getContext('2d');
            tmpCtx.drawImage(img, 0, 0);
            var data = tmpCtx.getImageData(0, 0, width, height).data;
            var i, j;
            if (components === 3) {
              for (i = 0, j = 0; i < rgbaLength; i += 4, j += 3) {
                buf[j] = data[i];
                buf[j + 1] = data[i + 1];
                buf[j + 2] = data[i + 2];
              }
            } else if (components === 1) {
              for (i = 0, j = 0; i < rgbaLength; i += 4, j++) {
                buf[j] = data[i];
              }
            }
            resolve({
              data: buf,
              width: width,
              height: height
            });
          };
          img.onerror = function () {
            reject(new Error('JpegDecode failed to load image'));
          };
          img.src = imageUrl;
        });
      }, this);
      messageHandler.on('FetchBuiltInCMap', function (data) {
        if (this.destroyed) {
          return Promise.reject(new Error('Worker was destroyed'));
        }
        return this.CMapReaderFactory.fetch({ name: data.name });
      }, this);
    },
    getData: function WorkerTransport_getData() {
      return this.messageHandler.sendWithPromise('GetData', null);
    },
    getPage: function WorkerTransport_getPage(pageNumber, capability) {
      if (!(0, _util.isInt)(pageNumber) || pageNumber <= 0 || pageNumber > this.numPages) {
        return Promise.reject(new Error('Invalid page request'));
      }
      var pageIndex = pageNumber - 1;
      if (pageIndex in this.pagePromises) {
        return this.pagePromises[pageIndex];
      }
      var promise = this.messageHandler.sendWithPromise('GetPage', { pageIndex: pageIndex }).then(function (pageInfo) {
        if (this.destroyed) {
          throw new Error('Transport destroyed');
        }
        var page = new PDFPageProxy(pageIndex, pageInfo, this);
        this.pageCache[pageIndex] = page;
        return page;
      }.bind(this));
      this.pagePromises[pageIndex] = promise;
      return promise;
    },
    getPageIndex: function WorkerTransport_getPageIndexByRef(ref) {
      return this.messageHandler.sendWithPromise('GetPageIndex', { ref: ref }).catch(function (reason) {
        return Promise.reject(new Error(reason));
      });
    },
    getAnnotations: function WorkerTransport_getAnnotations(pageIndex, intent) {
      return this.messageHandler.sendWithPromise('GetAnnotations', {
        pageIndex: pageIndex,
        intent: intent
      });
    },
    getDestinations: function WorkerTransport_getDestinations() {
      return this.messageHandler.sendWithPromise('GetDestinations', null);
    },
    getDestination: function WorkerTransport_getDestination(id) {
      return this.messageHandler.sendWithPromise('GetDestination', { id: id });
    },
    getPageLabels: function WorkerTransport_getPageLabels() {
      return this.messageHandler.sendWithPromise('GetPageLabels', null);
    },
    getAttachments: function WorkerTransport_getAttachments() {
      return this.messageHandler.sendWithPromise('GetAttachments', null);
    },
    getJavaScript: function WorkerTransport_getJavaScript() {
      return this.messageHandler.sendWithPromise('GetJavaScript', null);
    },
    getOutline: function WorkerTransport_getOutline() {
      return this.messageHandler.sendWithPromise('GetOutline', null);
    },
    getMetadata: function WorkerTransport_getMetadata() {
      return this.messageHandler.sendWithPromise('GetMetadata', null).then(function transportMetadata(results) {
        return {
          info: results[0],
          metadata: results[1] ? new _metadata.Metadata(results[1]) : null
        };
      });
    },
    getStats: function WorkerTransport_getStats() {
      return this.messageHandler.sendWithPromise('GetStats', null);
    },
    startCleanup: function WorkerTransport_startCleanup() {
      this.messageHandler.sendWithPromise('Cleanup', null).then(function endCleanup() {
        for (var i = 0, ii = this.pageCache.length; i < ii; i++) {
          var page = this.pageCache[i];
          if (page) {
            page.cleanup();
          }
        }
        this.commonObjs.clear();
        this.fontLoader.clear();
      }.bind(this));
    }
  };
  return WorkerTransport;
}();
var PDFObjects = function PDFObjectsClosure() {
  function PDFObjects() {
    this.objs = Object.create(null);
  }
  PDFObjects.prototype = {
    ensureObj: function PDFObjects_ensureObj(objId) {
      if (this.objs[objId]) {
        return this.objs[objId];
      }
      var obj = {
        capability: (0, _util.createPromiseCapability)(),
        data: null,
        resolved: false
      };
      this.objs[objId] = obj;
      return obj;
    },
    get: function PDFObjects_get(objId, callback) {
      if (callback) {
        this.ensureObj(objId).capability.promise.then(callback);
        return null;
      }
      var obj = this.objs[objId];
      if (!obj || !obj.resolved) {
        (0, _util.error)('Requesting object that isn\'t resolved yet ' + objId);
      }
      return obj.data;
    },
    resolve: function PDFObjects_resolve(objId, data) {
      var obj = this.ensureObj(objId);
      obj.resolved = true;
      obj.data = data;
      obj.capability.resolve(data);
    },
    isResolved: function PDFObjects_isResolved(objId) {
      var objs = this.objs;
      if (!objs[objId]) {
        return false;
      }
      return objs[objId].resolved;
    },
    hasData: function PDFObjects_hasData(objId) {
      return this.isResolved(objId);
    },
    getData: function PDFObjects_getData(objId) {
      var objs = this.objs;
      if (!objs[objId] || !objs[objId].resolved) {
        return null;
      }
      return objs[objId].data;
    },
    clear: function PDFObjects_clear() {
      this.objs = Object.create(null);
    }
  };
  return PDFObjects;
}();
var RenderTask = function RenderTaskClosure() {
  function RenderTask(internalRenderTask) {
    this._internalRenderTask = internalRenderTask;
    this.onContinue = null;
  }
  RenderTask.prototype = {
    get promise() {
      return this._internalRenderTask.capability.promise;
    },
    cancel: function RenderTask_cancel() {
      this._internalRenderTask.cancel();
    },
    then: function RenderTask_then(onFulfilled, onRejected) {
      return this.promise.then.apply(this.promise, arguments);
    }
  };
  return RenderTask;
}();
var InternalRenderTask = function InternalRenderTaskClosure() {
  function InternalRenderTask(callback, params, objs, commonObjs, operatorList, pageNumber, canvasFactory) {
    this.callback = callback;
    this.params = params;
    this.objs = objs;
    this.commonObjs = commonObjs;
    this.operatorListIdx = null;
    this.operatorList = operatorList;
    this.pageNumber = pageNumber;
    this.canvasFactory = canvasFactory;
    this.running = false;
    this.graphicsReadyCallback = null;
    this.graphicsReady = false;
    this.useRequestAnimationFrame = false;
    this.cancelled = false;
    this.capability = (0, _util.createPromiseCapability)();
    this.task = new RenderTask(this);
    this._continueBound = this._continue.bind(this);
    this._scheduleNextBound = this._scheduleNext.bind(this);
    this._nextBound = this._next.bind(this);
  }
  InternalRenderTask.prototype = {
    initializeGraphics: function InternalRenderTask_initializeGraphics(transparency) {
      if (this.cancelled) {
        return;
      }
      if ((0, _dom_utils.getDefaultSetting)('pdfBug') && _util.globalScope.StepperManager && _util.globalScope.StepperManager.enabled) {
        this.stepper = _util.globalScope.StepperManager.create(this.pageNumber - 1);
        this.stepper.init(this.operatorList);
        this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
      }
      var params = this.params;
      this.gfx = new _canvas.CanvasGraphics(params.canvasContext, this.commonObjs, this.objs, this.canvasFactory, params.imageLayer);
      this.gfx.beginDrawing(params.transform, params.viewport, transparency);
      this.operatorListIdx = 0;
      this.graphicsReady = true;
      if (this.graphicsReadyCallback) {
        this.graphicsReadyCallback();
      }
    },
    cancel: function InternalRenderTask_cancel() {
      this.running = false;
      this.cancelled = true;
      if ((0, _dom_utils.getDefaultSetting)('pdfjsNext')) {
        this.callback(new _dom_utils.RenderingCancelledException('Rendering cancelled, page ' + this.pageNumber, 'canvas'));
      } else {
        this.callback('cancelled');
      }
    },
    operatorListChanged: function InternalRenderTask_operatorListChanged() {
      if (!this.graphicsReady) {
        if (!this.graphicsReadyCallback) {
          this.graphicsReadyCallback = this._continueBound;
        }
        return;
      }
      if (this.stepper) {
        this.stepper.updateOperatorList(this.operatorList);
      }
      if (this.running) {
        return;
      }
      this._continue();
    },
    _continue: function InternalRenderTask__continue() {
      this.running = true;
      if (this.cancelled) {
        return;
      }
      if (this.task.onContinue) {
        this.task.onContinue(this._scheduleNextBound);
      } else {
        this._scheduleNext();
      }
    },
    _scheduleNext: function InternalRenderTask__scheduleNext() {
      if (this.useRequestAnimationFrame && typeof window !== 'undefined') {
        window.requestAnimationFrame(this._nextBound);
      } else {
        Promise.resolve(undefined).then(this._nextBound);
      }
    },
    _next: function InternalRenderTask__next() {
      if (this.cancelled) {
        return;
      }
      this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
      if (this.operatorListIdx === this.operatorList.argsArray.length) {
        this.running = false;
        if (this.operatorList.lastChunk) {
          this.gfx.endDrawing();
          this.callback();
        }
      }
    }
  };
  return InternalRenderTask;
}();
var _UnsupportedManager = function UnsupportedManagerClosure() {
  var listeners = [];
  return {
    listen: function listen(cb) {
      (0, _util.deprecated)('Global UnsupportedManager.listen is used: ' + ' use PDFDocumentLoadingTask.onUnsupportedFeature instead');
      listeners.push(cb);
    },
    notify: function notify(featureId) {
      for (var i = 0, ii = listeners.length; i < ii; i++) {
        listeners[i](featureId);
      }
    }
  };
}();
var version, build;
{
  exports.version = version = '1.8.233';
  exports.build = build = '19321937';
}
exports.getDocument = getDocument;
exports.PDFDataRangeTransport = PDFDataRangeTransport;
exports.PDFWorker = PDFWorker;
exports.PDFDocumentProxy = PDFDocumentProxy;
exports.PDFPageProxy = PDFPageProxy;
exports._UnsupportedManager = _UnsupportedManager;
exports.version = version;
exports.build = build;

/***/ }),
/* 4 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SVGGraphics = undefined;

var _util = __w_pdfjs_require__(0);

var SVGGraphics = function SVGGraphics() {
  throw new Error('Not implemented: SVGGraphics');
};
{
  var SVG_DEFAULTS = {
    fontStyle: 'normal',
    fontWeight: 'normal',
    fillColor: '#000000'
  };
  var convertImgDataToPng = function convertImgDataToPngClosure() {
    var PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
    var CHUNK_WRAPPER_SIZE = 12;
    var crcTable = new Int32Array(256);
    for (var i = 0; i < 256; i++) {
      var c = i;
      for (var h = 0; h < 8; h++) {
        if (c & 1) {
          c = 0xedB88320 ^ c >> 1 & 0x7fffffff;
        } else {
          c = c >> 1 & 0x7fffffff;
        }
      }
      crcTable[i] = c;
    }
    function crc32(data, start, end) {
      var crc = -1;
      for (var i = start; i < end; i++) {
        var a = (crc ^ data[i]) & 0xff;
        var b = crcTable[a];
        crc = crc >>> 8 ^ b;
      }
      return crc ^ -1;
    }
    function writePngChunk(type, body, data, offset) {
      var p = offset;
      var len = body.length;
      data[p] = len >> 24 & 0xff;
      data[p + 1] = len >> 16 & 0xff;
      data[p + 2] = len >> 8 & 0xff;
      data[p + 3] = len & 0xff;
      p += 4;
      data[p] = type.charCodeAt(0) & 0xff;
      data[p + 1] = type.charCodeAt(1) & 0xff;
      data[p + 2] = type.charCodeAt(2) & 0xff;
      data[p + 3] = type.charCodeAt(3) & 0xff;
      p += 4;
      data.set(body, p);
      p += body.length;
      var crc = crc32(data, offset + 4, p);
      data[p] = crc >> 24 & 0xff;
      data[p + 1] = crc >> 16 & 0xff;
      data[p + 2] = crc >> 8 & 0xff;
      data[p + 3] = crc & 0xff;
    }
    function adler32(data, start, end) {
      var a = 1;
      var b = 0;
      for (var i = start; i < end; ++i) {
        a = (a + (data[i] & 0xff)) % 65521;
        b = (b + a) % 65521;
      }
      return b << 16 | a;
    }
    function encode(imgData, kind, forceDataSchema) {
      var width = imgData.width;
      var height = imgData.height;
      var bitDepth, colorType, lineSize;
      var bytes = imgData.data;
      switch (kind) {
        case _util.ImageKind.GRAYSCALE_1BPP:
          colorType = 0;
          bitDepth = 1;
          lineSize = width + 7 >> 3;
          break;
        case _util.ImageKind.RGB_24BPP:
          colorType = 2;
          bitDepth = 8;
          lineSize = width * 3;
          break;
        case _util.ImageKind.RGBA_32BPP:
          colorType = 6;
          bitDepth = 8;
          lineSize = width * 4;
          break;
        default:
          throw new Error('invalid format');
      }
      var literals = new Uint8Array((1 + lineSize) * height);
      var offsetLiterals = 0,
          offsetBytes = 0;
      var y, i;
      for (y = 0; y < height; ++y) {
        literals[offsetLiterals++] = 0;
        literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
        offsetBytes += lineSize;
        offsetLiterals += lineSize;
      }
      if (kind === _util.ImageKind.GRAYSCALE_1BPP) {
        offsetLiterals = 0;
        for (y = 0; y < height; y++) {
          offsetLiterals++;
          for (i = 0; i < lineSize; i++) {
            literals[offsetLiterals++] ^= 0xFF;
          }
        }
      }
      var ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);
      var len = literals.length;
      var maxBlockLength = 0xFFFF;
      var deflateBlocks = Math.ceil(len / maxBlockLength);
      var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
      var pi = 0;
      idat[pi++] = 0x78;
      idat[pi++] = 0x9c;
      var pos = 0;
      while (len > maxBlockLength) {
        idat[pi++] = 0x00;
        idat[pi++] = 0xff;
        idat[pi++] = 0xff;
        idat[pi++] = 0x00;
        idat[pi++] = 0x00;
        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
        pi += maxBlockLength;
        pos += maxBlockLength;
        len -= maxBlockLength;
      }
      idat[pi++] = 0x01;
      idat[pi++] = len & 0xff;
      idat[pi++] = len >> 8 & 0xff;
      idat[pi++] = ~len & 0xffff & 0xff;
      idat[pi++] = (~len & 0xffff) >> 8 & 0xff;
      idat.set(literals.subarray(pos), pi);
      pi += literals.length - pos;
      var adler = adler32(literals, 0, literals.length);
      idat[pi++] = adler >> 24 & 0xff;
      idat[pi++] = adler >> 16 & 0xff;
      idat[pi++] = adler >> 8 & 0xff;
      idat[pi++] = adler & 0xff;
      var pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
      var data = new Uint8Array(pngLength);
      var offset = 0;
      data.set(PNG_HEADER, offset);
      offset += PNG_HEADER.length;
      writePngChunk('IHDR', ihdr, data, offset);
      offset += CHUNK_WRAPPER_SIZE + ihdr.length;
      writePngChunk('IDATA', idat, data, offset);
      offset += CHUNK_WRAPPER_SIZE + idat.length;
      writePngChunk('IEND', new Uint8Array(0), data, offset);
      return (0, _util.createObjectURL)(data, 'image/png', forceDataSchema);
    }
    return function convertImgDataToPng(imgData, forceDataSchema) {
      var kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;
      return encode(imgData, kind, forceDataSchema);
    };
  }();
  var SVGExtraState = function SVGExtraStateClosure() {
    function SVGExtraState() {
      this.fontSizeScale = 1;
      this.fontWeight = SVG_DEFAULTS.fontWeight;
      this.fontSize = 0;
      this.textMatrix = _util.IDENTITY_MATRIX;
      this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
      this.leading = 0;
      this.x = 0;
      this.y = 0;
      this.lineX = 0;
      this.lineY = 0;
      this.charSpacing = 0;
      this.wordSpacing = 0;
      this.textHScale = 1;
      this.textRise = 0;
      this.fillColor = SVG_DEFAULTS.fillColor;
      this.strokeColor = '#000000';
      this.fillAlpha = 1;
      this.strokeAlpha = 1;
      this.lineWidth = 1;
      this.lineJoin = '';
      this.lineCap = '';
      this.miterLimit = 0;
      this.dashArray = [];
      this.dashPhase = 0;
      this.dependencies = [];
      this.activeClipUrl = null;
      this.clipGroup = null;
      this.maskId = '';
    }
    SVGExtraState.prototype = {
      clone: function SVGExtraState_clone() {
        return Object.create(this);
      },
      setCurrentPoint: function SVGExtraState_setCurrentPoint(x, y) {
        this.x = x;
        this.y = y;
      }
    };
    return SVGExtraState;
  }();
  exports.SVGGraphics = SVGGraphics = function SVGGraphicsClosure() {
    function opListToTree(opList) {
      var opTree = [];
      var tmp = [];
      var opListLen = opList.length;
      for (var x = 0; x < opListLen; x++) {
        if (opList[x].fn === 'save') {
          opTree.push({
            'fnId': 92,
            'fn': 'group',
            'items': []
          });
          tmp.push(opTree);
          opTree = opTree[opTree.length - 1].items;
          continue;
        }
        if (opList[x].fn === 'restore') {
          opTree = tmp.pop();
        } else {
          opTree.push(opList[x]);
        }
      }
      return opTree;
    }
    function pf(value) {
      if (value === (value | 0)) {
        return value.toString();
      }
      var s = value.toFixed(10);
      var i = s.length - 1;
      if (s[i] !== '0') {
        return s;
      }
      do {
        i--;
      } while (s[i] === '0');
      return s.substr(0, s[i] === '.' ? i : i + 1);
    }
    function pm(m) {
      if (m[4] === 0 && m[5] === 0) {
        if (m[1] === 0 && m[2] === 0) {
          if (m[0] === 1 && m[3] === 1) {
            return '';
          }
          return 'scale(' + pf(m[0]) + ' ' + pf(m[3]) + ')';
        }
        if (m[0] === m[3] && m[1] === -m[2]) {
          var a = Math.acos(m[0]) * 180 / Math.PI;
          return 'rotate(' + pf(a) + ')';
        }
      } else {
        if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
          return 'translate(' + pf(m[4]) + ' ' + pf(m[5]) + ')';
        }
      }
      return 'matrix(' + pf(m[0]) + ' ' + pf(m[1]) + ' ' + pf(m[2]) + ' ' + pf(m[3]) + ' ' + pf(m[4]) + ' ' + pf(m[5]) + ')';
    }
    function SVGGraphics(commonObjs, objs, forceDataSchema) {
      this.current = new SVGExtraState();
      this.transformMatrix = _util.IDENTITY_MATRIX;
      this.transformStack = [];
      this.extraStack = [];
      this.commonObjs = commonObjs;
      this.objs = objs;
      this.pendingEOFill = false;
      this.embedFonts = false;
      this.embeddedFonts = Object.create(null);
      this.cssStyle = null;
      this.forceDataSchema = !!forceDataSchema;
    }
    var NS = 'http://www.w3.org/2000/svg';
    var XML_NS = 'http://www.w3.org/XML/1998/namespace';
    var XLINK_NS = 'http://www.w3.org/1999/xlink';
    var LINE_CAP_STYLES = ['butt', 'round', 'square'];
    var LINE_JOIN_STYLES = ['miter', 'round', 'bevel'];
    var clipCount = 0;
    var maskCount = 0;
    SVGGraphics.prototype = {
      save: function SVGGraphics_save() {
        this.transformStack.push(this.transformMatrix);
        var old = this.current;
        this.extraStack.push(old);
        this.current = old.clone();
      },
      restore: function SVGGraphics_restore() {
        this.transformMatrix = this.transformStack.pop();
        this.current = this.extraStack.pop();
        this.tgrp = null;
      },
      group: function SVGGraphics_group(items) {
        this.save();
        this.executeOpTree(items);
        this.restore();
      },
      loadDependencies: function SVGGraphics_loadDependencies(operatorList) {
        var fnArray = operatorList.fnArray;
        var fnArrayLen = fnArray.length;
        var argsArray = operatorList.argsArray;
        var self = this;
        for (var i = 0; i < fnArrayLen; i++) {
          if (_util.OPS.dependency === fnArray[i]) {
            var deps = argsArray[i];
            for (var n = 0, nn = deps.length; n < nn; n++) {
              var obj = deps[n];
              var common = obj.substring(0, 2) === 'g_';
              var promise;
              if (common) {
                promise = new Promise(function (resolve) {
                  self.commonObjs.get(obj, resolve);
                });
              } else {
                promise = new Promise(function (resolve) {
                  self.objs.get(obj, resolve);
                });
              }
              this.current.dependencies.push(promise);
            }
          }
        }
        return Promise.all(this.current.dependencies);
      },
      transform: function SVGGraphics_transform(a, b, c, d, e, f) {
        var transformMatrix = [a, b, c, d, e, f];
        this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);
        this.tgrp = null;
      },
      getSVG: function SVGGraphics_getSVG(operatorList, viewport) {
        this.viewport = viewport;
        var svgElement = this._initialize(viewport);
        return this.loadDependencies(operatorList).then(function () {
          this.transformMatrix = _util.IDENTITY_MATRIX;
          var opTree = this.convertOpList(operatorList);
          this.executeOpTree(opTree);
          return svgElement;
        }.bind(this));
      },
      convertOpList: function SVGGraphics_convertOpList(operatorList) {
        var argsArray = operatorList.argsArray;
        var fnArray = operatorList.fnArray;
        var fnArrayLen = fnArray.length;
        var REVOPS = [];
        var opList = [];
        for (var op in _util.OPS) {
          REVOPS[_util.OPS[op]] = op;
        }
        for (var x = 0; x < fnArrayLen; x++) {
          var fnId = fnArray[x];
          opList.push({
            'fnId': fnId,
            'fn': REVOPS[fnId],
            'args': argsArray[x]
          });
        }
        return opListToTree(opList);
      },
      executeOpTree: function SVGGraphics_executeOpTree(opTree) {
        var opTreeLen = opTree.length;
        for (var x = 0; x < opTreeLen; x++) {
          var fn = opTree[x].fn;
          var fnId = opTree[x].fnId;
          var args = opTree[x].args;
          switch (fnId | 0) {
            case _util.OPS.beginText:
              this.beginText();
              break;
            case _util.OPS.setLeading:
              this.setLeading(args);
              break;
            case _util.OPS.setLeadingMoveText:
              this.setLeadingMoveText(args[0], args[1]);
              break;
            case _util.OPS.setFont:
              this.setFont(args);
              break;
            case _util.OPS.showText:
              this.showText(args[0]);
              break;
            case _util.OPS.showSpacedText:
              this.showText(args[0]);
              break;
            case _util.OPS.endText:
              this.endText();
              break;
            case _util.OPS.moveText:
              this.moveText(args[0], args[1]);
              break;
            case _util.OPS.setCharSpacing:
              this.setCharSpacing(args[0]);
              break;
            case _util.OPS.setWordSpacing:
              this.setWordSpacing(args[0]);
              break;
            case _util.OPS.setHScale:
              this.setHScale(args[0]);
              break;
            case _util.OPS.setTextMatrix:
              this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
              break;
            case _util.OPS.setLineWidth:
              this.setLineWidth(args[0]);
              break;
            case _util.OPS.setLineJoin:
              this.setLineJoin(args[0]);
              break;
            case _util.OPS.setLineCap:
              this.setLineCap(args[0]);
              break;
            case _util.OPS.setMiterLimit:
              this.setMiterLimit(args[0]);
              break;
            case _util.OPS.setFillRGBColor:
              this.setFillRGBColor(args[0], args[1], args[2]);
              break;
            case _util.OPS.setStrokeRGBColor:
              this.setStrokeRGBColor(args[0], args[1], args[2]);
              break;
            case _util.OPS.setDash:
              this.setDash(args[0], args[1]);
              break;
            case _util.OPS.setGState:
              this.setGState(args[0]);
              break;
            case _util.OPS.fill:
              this.fill();
              break;
            case _util.OPS.eoFill:
              this.eoFill();
              break;
            case _util.OPS.stroke:
              this.stroke();
              break;
            case _util.OPS.fillStroke:
              this.fillStroke();
              break;
            case _util.OPS.eoFillStroke:
              this.eoFillStroke();
              break;
            case _util.OPS.clip:
              this.clip('nonzero');
              break;
            case _util.OPS.eoClip:
              this.clip('evenodd');
              break;
            case _util.OPS.paintSolidColorImageMask:
              this.paintSolidColorImageMask();
              break;
            case _util.OPS.paintJpegXObject:
              this.paintJpegXObject(args[0], args[1], args[2]);
              break;
            case _util.OPS.paintImageXObject:
              this.paintImageXObject(args[0]);
              break;
            case _util.OPS.paintInlineImageXObject:
              this.paintInlineImageXObject(args[0]);
              break;
            case _util.OPS.paintImageMaskXObject:
              this.paintImageMaskXObject(args[0]);
              break;
            case _util.OPS.paintFormXObjectBegin:
              this.paintFormXObjectBegin(args[0], args[1]);
              break;
            case _util.OPS.paintFormXObjectEnd:
              this.paintFormXObjectEnd();
              break;
            case _util.OPS.closePath:
              this.closePath();
              break;
            case _util.OPS.closeStroke:
              this.closeStroke();
              break;
            case _util.OPS.closeFillStroke:
              this.closeFillStroke();
              break;
            case _util.OPS.nextLine:
              this.nextLine();
              break;
            case _util.OPS.transform:
              this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
              break;
            case _util.OPS.constructPath:
              this.constructPath(args[0], args[1]);
              break;
            case _util.OPS.endPath:
              this.endPath();
              break;
            case 92:
              this.group(opTree[x].items);
              break;
            default:
              (0, _util.warn)('Unimplemented operator ' + fn);
              break;
          }
        }
      },
      setWordSpacing: function SVGGraphics_setWordSpacing(wordSpacing) {
        this.current.wordSpacing = wordSpacing;
      },
      setCharSpacing: function SVGGraphics_setCharSpacing(charSpacing) {
        this.current.charSpacing = charSpacing;
      },
      nextLine: function SVGGraphics_nextLine() {
        this.moveText(0, this.current.leading);
      },
      setTextMatrix: function SVGGraphics_setTextMatrix(a, b, c, d, e, f) {
        var current = this.current;
        this.current.textMatrix = this.current.lineMatrix = [a, b, c, d, e, f];
        this.current.x = this.current.lineX = 0;
        this.current.y = this.current.lineY = 0;
        current.xcoords = [];
        current.tspan = document.createElementNS(NS, 'svg:tspan');
        current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);
        current.tspan.setAttributeNS(null, 'font-size', pf(current.fontSize) + 'px');
        current.tspan.setAttributeNS(null, 'y', pf(-current.y));
        current.txtElement = document.createElementNS(NS, 'svg:text');
        current.txtElement.appendChild(current.tspan);
      },
      beginText: function SVGGraphics_beginText() {
        this.current.x = this.current.lineX = 0;
        this.current.y = this.current.lineY = 0;
        this.current.textMatrix = _util.IDENTITY_MATRIX;
        this.current.lineMatrix = _util.IDENTITY_MATRIX;
        this.current.tspan = document.createElementNS(NS, 'svg:tspan');
        this.current.txtElement = document.createElementNS(NS, 'svg:text');
        this.current.txtgrp = document.createElementNS(NS, 'svg:g');
        this.current.xcoords = [];
      },
      moveText: function SVGGraphics_moveText(x, y) {
        var current = this.current;
        this.current.x = this.current.lineX += x;
        this.current.y = this.current.lineY += y;
        current.xcoords = [];
        current.tspan = document.createElementNS(NS, 'svg:tspan');
        current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);
        current.tspan.setAttributeNS(null, 'font-size', pf(current.fontSize) + 'px');
        current.tspan.setAttributeNS(null, 'y', pf(-current.y));
      },
      showText: function SVGGraphics_showText(glyphs) {
        var current = this.current;
        var font = current.font;
        var fontSize = current.fontSize;
        if (fontSize === 0) {
          return;
        }
        var charSpacing = current.charSpacing;
        var wordSpacing = current.wordSpacing;
        var fontDirection = current.fontDirection;
        var textHScale = current.textHScale * fontDirection;
        var glyphsLength = glyphs.length;
        var vertical = font.vertical;
        var widthAdvanceScale = fontSize * current.fontMatrix[0];
        var x = 0,
            i;
        for (i = 0; i < glyphsLength; ++i) {
          var glyph = glyphs[i];
          if (glyph === null) {
            x += fontDirection * wordSpacing;
            continue;
          } else if ((0, _util.isNum)(glyph)) {
            x += -glyph * fontSize * 0.001;
            continue;
          }
          current.xcoords.push(current.x + x * textHScale);
          var width = glyph.width;
          var character = glyph.fontChar;
          var charWidth = width * widthAdvanceScale + charSpacing * fontDirection;
          x += charWidth;
          current.tspan.textContent += character;
        }
        if (vertical) {
          current.y -= x * textHScale;
        } else {
          current.x += x * textHScale;
        }
        current.tspan.setAttributeNS(null, 'x', current.xcoords.map(pf).join(' '));
        current.tspan.setAttributeNS(null, 'y', pf(-current.y));
        current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);
        current.tspan.setAttributeNS(null, 'font-size', pf(current.fontSize) + 'px');
        if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
          current.tspan.setAttributeNS(null, 'font-style', current.fontStyle);
        }
        if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
          current.tspan.setAttributeNS(null, 'font-weight', current.fontWeight);
        }
        if (current.fillColor !== SVG_DEFAULTS.fillColor) {
          current.tspan.setAttributeNS(null, 'fill', current.fillColor);
        }
        current.txtElement.setAttributeNS(null, 'transform', pm(current.textMatrix) + ' scale(1, -1)');
        current.txtElement.setAttributeNS(XML_NS, 'xml:space', 'preserve');
        current.txtElement.appendChild(current.tspan);
        current.txtgrp.appendChild(current.txtElement);
        this._ensureTransformGroup().appendChild(current.txtElement);
      },
      setLeadingMoveText: function SVGGraphics_setLeadingMoveText(x, y) {
        this.setLeading(-y);
        this.moveText(x, y);
      },
      addFontStyle: function SVGGraphics_addFontStyle(fontObj) {
        if (!this.cssStyle) {
          this.cssStyle = document.createElementNS(NS, 'svg:style');
          this.cssStyle.setAttributeNS(null, 'type', 'text/css');
          this.defs.appendChild(this.cssStyle);
        }
        var url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);
        this.cssStyle.textContent += '@font-face { font-family: "' + fontObj.loadedName + '";' + ' src: url(' + url + '); }\n';
      },
      setFont: function SVGGraphics_setFont(details) {
        var current = this.current;
        var fontObj = this.commonObjs.get(details[0]);
        var size = details[1];
        this.current.font = fontObj;
        if (this.embedFonts && fontObj.data && !this.embeddedFonts[fontObj.loadedName]) {
          this.addFontStyle(fontObj);
          this.embeddedFonts[fontObj.loadedName] = fontObj;
        }
        current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util.FONT_IDENTITY_MATRIX;
        var bold = fontObj.black ? fontObj.bold ? 'bolder' : 'bold' : fontObj.bold ? 'bold' : 'normal';
        var italic = fontObj.italic ? 'italic' : 'normal';
        if (size < 0) {
          size = -size;
          current.fontDirection = -1;
        } else {
          current.fontDirection = 1;
        }
        current.fontSize = size;
        current.fontFamily = fontObj.loadedName;
        current.fontWeight = bold;
        current.fontStyle = italic;
        current.tspan = document.createElementNS(NS, 'svg:tspan');
        current.tspan.setAttributeNS(null, 'y', pf(-current.y));
        current.xcoords = [];
      },
      endText: function SVGGraphics_endText() {},
      setLineWidth: function SVGGraphics_setLineWidth(width) {
        this.current.lineWidth = width;
      },
      setLineCap: function SVGGraphics_setLineCap(style) {
        this.current.lineCap = LINE_CAP_STYLES[style];
      },
      setLineJoin: function SVGGraphics_setLineJoin(style) {
        this.current.lineJoin = LINE_JOIN_STYLES[style];
      },
      setMiterLimit: function SVGGraphics_setMiterLimit(limit) {
        this.current.miterLimit = limit;
      },
      setStrokeRGBColor: function SVGGraphics_setStrokeRGBColor(r, g, b) {
        var color = _util.Util.makeCssRgb(r, g, b);
        this.current.strokeColor = color;
      },
      setFillRGBColor: function SVGGraphics_setFillRGBColor(r, g, b) {
        var color = _util.Util.makeCssRgb(r, g, b);
        this.current.fillColor = color;
        this.current.tspan = document.createElementNS(NS, 'svg:tspan');
        this.current.xcoords = [];
      },
      setDash: function SVGGraphics_setDash(dashArray, dashPhase) {
        this.current.dashArray = dashArray;
        this.current.dashPhase = dashPhase;
      },
      constructPath: function SVGGraphics_constructPath(ops, args) {
        var current = this.current;
        var x = current.x,
            y = current.y;
        current.path = document.createElementNS(NS, 'svg:path');
        var d = [];
        var opLength = ops.length;
        for (var i = 0, j = 0; i < opLength; i++) {
          switch (ops[i] | 0) {
            case _util.OPS.rectangle:
              x = args[j++];
              y = args[j++];
              var width = args[j++];
              var height = args[j++];
              var xw = x + width;
              var yh = y + height;
              d.push('M', pf(x), pf(y), 'L', pf(xw), pf(y), 'L', pf(xw), pf(yh), 'L', pf(x), pf(yh), 'Z');
              break;
            case _util.OPS.moveTo:
              x = args[j++];
              y = args[j++];
              d.push('M', pf(x), pf(y));
              break;
            case _util.OPS.lineTo:
              x = args[j++];
              y = args[j++];
              d.push('L', pf(x), pf(y));
              break;
            case _util.OPS.curveTo:
              x = args[j + 4];
              y = args[j + 5];
              d.push('C', pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
              j += 6;
              break;
            case _util.OPS.curveTo2:
              x = args[j + 2];
              y = args[j + 3];
              d.push('C', pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
              j += 4;
              break;
            case _util.OPS.curveTo3:
              x = args[j + 2];
              y = args[j + 3];
              d.push('C', pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
              j += 4;
              break;
            case _util.OPS.closePath:
              d.push('Z');
              break;
          }
        }
        current.path.setAttributeNS(null, 'd', d.join(' '));
        current.path.setAttributeNS(null, 'stroke-miterlimit', pf(current.miterLimit));
        current.path.setAttributeNS(null, 'stroke-linecap', current.lineCap);
        current.path.setAttributeNS(null, 'stroke-linejoin', current.lineJoin);
        current.path.setAttributeNS(null, 'stroke-width', pf(current.lineWidth) + 'px');
        current.path.setAttributeNS(null, 'stroke-dasharray', current.dashArray.map(pf).join(' '));
        current.path.setAttributeNS(null, 'stroke-dashoffset', pf(current.dashPhase) + 'px');
        current.path.setAttributeNS(null, 'fill', 'none');
        this._ensureTransformGroup().appendChild(current.path);
        current.element = current.path;
        current.setCurrentPoint(x, y);
      },
      endPath: function SVGGraphics_endPath() {},
      clip: function SVGGraphics_clip(type) {
        var current = this.current;
        var clipId = 'clippath' + clipCount;
        clipCount++;
        var clipPath = document.createElementNS(NS, 'svg:clipPath');
        clipPath.setAttributeNS(null, 'id', clipId);
        clipPath.setAttributeNS(null, 'transform', pm(this.transformMatrix));
        var clipElement = current.element.cloneNode();
        if (type === 'evenodd') {
          clipElement.setAttributeNS(null, 'clip-rule', 'evenodd');
        } else {
          clipElement.setAttributeNS(null, 'clip-rule', 'nonzero');
        }
        clipPath.appendChild(clipElement);
        this.defs.appendChild(clipPath);
        if (current.activeClipUrl) {
          current.clipGroup = null;
          this.extraStack.forEach(function (prev) {
            prev.clipGroup = null;
          });
        }
        current.activeClipUrl = 'url(#' + clipId + ')';
        this.tgrp = null;
      },
      closePath: function SVGGraphics_closePath() {
        var current = this.current;
        var d = current.path.getAttributeNS(null, 'd');
        d += 'Z';
        current.path.setAttributeNS(null, 'd', d);
      },
      setLeading: function SVGGraphics_setLeading(leading) {
        this.current.leading = -leading;
      },
      setTextRise: function SVGGraphics_setTextRise(textRise) {
        this.current.textRise = textRise;
      },
      setHScale: function SVGGraphics_setHScale(scale) {
        this.current.textHScale = scale / 100;
      },
      setGState: function SVGGraphics_setGState(states) {
        for (var i = 0, ii = states.length; i < ii; i++) {
          var state = states[i];
          var key = state[0];
          var value = state[1];
          switch (key) {
            case 'LW':
              this.setLineWidth(value);
              break;
            case 'LC':
              this.setLineCap(value);
              break;
            case 'LJ':
              this.setLineJoin(value);
              break;
            case 'ML':
              this.setMiterLimit(value);
              break;
            case 'D':
              this.setDash(value[0], value[1]);
              break;
            case 'Font':
              this.setFont(value);
              break;
            default:
              (0, _util.warn)('Unimplemented graphic state ' + key);
              break;
          }
        }
      },
      fill: function SVGGraphics_fill() {
        var current = this.current;
        current.element.setAttributeNS(null, 'fill', current.fillColor);
      },
      stroke: function SVGGraphics_stroke() {
        var current = this.current;
        current.element.setAttributeNS(null, 'stroke', current.strokeColor);
        current.element.setAttributeNS(null, 'fill', 'none');
      },
      eoFill: function SVGGraphics_eoFill() {
        var current = this.current;
        current.element.setAttributeNS(null, 'fill', current.fillColor);
        current.element.setAttributeNS(null, 'fill-rule', 'evenodd');
      },
      fillStroke: function SVGGraphics_fillStroke() {
        this.stroke();
        this.fill();
      },
      eoFillStroke: function SVGGraphics_eoFillStroke() {
        this.current.element.setAttributeNS(null, 'fill-rule', 'evenodd');
        this.fillStroke();
      },
      closeStroke: function SVGGraphics_closeStroke() {
        this.closePath();
        this.stroke();
      },
      closeFillStroke: function SVGGraphics_closeFillStroke() {
        this.closePath();
        this.fillStroke();
      },
      paintSolidColorImageMask: function SVGGraphics_paintSolidColorImageMask() {
        var current = this.current;
        var rect = document.createElementNS(NS, 'svg:rect');
        rect.setAttributeNS(null, 'x', '0');
        rect.setAttributeNS(null, 'y', '0');
        rect.setAttributeNS(null, 'width', '1px');
        rect.setAttributeNS(null, 'height', '1px');
        rect.setAttributeNS(null, 'fill', current.fillColor);
        this._ensureTransformGroup().appendChild(rect);
      },
      paintJpegXObject: function SVGGraphics_paintJpegXObject(objId, w, h) {
        var imgObj = this.objs.get(objId);
        var imgEl = document.createElementNS(NS, 'svg:image');
        imgEl.setAttributeNS(XLINK_NS, 'xlink:href', imgObj.src);
        imgEl.setAttributeNS(null, 'width', imgObj.width + 'px');
        imgEl.setAttributeNS(null, 'height', imgObj.height + 'px');
        imgEl.setAttributeNS(null, 'x', '0');
        imgEl.setAttributeNS(null, 'y', pf(-h));
        imgEl.setAttributeNS(null, 'transform', 'scale(' + pf(1 / w) + ' ' + pf(-1 / h) + ')');
        this._ensureTransformGroup().appendChild(imgEl);
      },
      paintImageXObject: function SVGGraphics_paintImageXObject(objId) {
        var imgData = this.objs.get(objId);
        if (!imgData) {
          (0, _util.warn)('Dependent image isn\'t ready yet');
          return;
        }
        this.paintInlineImageXObject(imgData);
      },
      paintInlineImageXObject: function SVGGraphics_paintInlineImageXObject(imgData, mask) {
        var width = imgData.width;
        var height = imgData.height;
        var imgSrc = convertImgDataToPng(imgData, this.forceDataSchema);
        var cliprect = document.createElementNS(NS, 'svg:rect');
        cliprect.setAttributeNS(null, 'x', '0');
        cliprect.setAttributeNS(null, 'y', '0');
        cliprect.setAttributeNS(null, 'width', pf(width));
        cliprect.setAttributeNS(null, 'height', pf(height));
        this.current.element = cliprect;
        this.clip('nonzero');
        var imgEl = document.createElementNS(NS, 'svg:image');
        imgEl.setAttributeNS(XLINK_NS, 'xlink:href', imgSrc);
        imgEl.setAttributeNS(null, 'x', '0');
        imgEl.setAttributeNS(null, 'y', pf(-height));
        imgEl.setAttributeNS(null, 'width', pf(width) + 'px');
        imgEl.setAttributeNS(null, 'height', pf(height) + 'px');
        imgEl.setAttributeNS(null, 'transform', 'scale(' + pf(1 / width) + ' ' + pf(-1 / height) + ')');
        if (mask) {
          mask.appendChild(imgEl);
        } else {
          this._ensureTransformGroup().appendChild(imgEl);
        }
      },
      paintImageMaskXObject: function SVGGraphics_paintImageMaskXObject(imgData) {
        var current = this.current;
        var width = imgData.width;
        var height = imgData.height;
        var fillColor = current.fillColor;
        current.maskId = 'mask' + maskCount++;
        var mask = document.createElementNS(NS, 'svg:mask');
        mask.setAttributeNS(null, 'id', current.maskId);
        var rect = document.createElementNS(NS, 'svg:rect');
        rect.setAttributeNS(null, 'x', '0');
        rect.setAttributeNS(null, 'y', '0');
        rect.setAttributeNS(null, 'width', pf(width));
        rect.setAttributeNS(null, 'height', pf(height));
        rect.setAttributeNS(null, 'fill', fillColor);
        rect.setAttributeNS(null, 'mask', 'url(#' + current.maskId + ')');
        this.defs.appendChild(mask);
        this._ensureTransformGroup().appendChild(rect);
        this.paintInlineImageXObject(imgData, mask);
      },
      paintFormXObjectBegin: function SVGGraphics_paintFormXObjectBegin(matrix, bbox) {
        if ((0, _util.isArray)(matrix) && matrix.length === 6) {
          this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
        }
        if ((0, _util.isArray)(bbox) && bbox.length === 4) {
          var width = bbox[2] - bbox[0];
          var height = bbox[3] - bbox[1];
          var cliprect = document.createElementNS(NS, 'svg:rect');
          cliprect.setAttributeNS(null, 'x', bbox[0]);
          cliprect.setAttributeNS(null, 'y', bbox[1]);
          cliprect.setAttributeNS(null, 'width', pf(width));
          cliprect.setAttributeNS(null, 'height', pf(height));
          this.current.element = cliprect;
          this.clip('nonzero');
          this.endPath();
        }
      },
      paintFormXObjectEnd: function SVGGraphics_paintFormXObjectEnd() {},
      _initialize: function SVGGraphics_initialize(viewport) {
        var svg = document.createElementNS(NS, 'svg:svg');
        svg.setAttributeNS(null, 'version', '1.1');
        svg.setAttributeNS(null, 'width', viewport.width + 'px');
        svg.setAttributeNS(null, 'height', viewport.height + 'px');
        svg.setAttributeNS(null, 'preserveAspectRatio', 'none');
        svg.setAttributeNS(null, 'viewBox', '0 0 ' + viewport.width + ' ' + viewport.height);
        var definitions = document.createElementNS(NS, 'svg:defs');
        svg.appendChild(definitions);
        this.defs = definitions;
        var rootGroup = document.createElementNS(NS, 'svg:g');
        rootGroup.setAttributeNS(null, 'transform', pm(viewport.transform));
        svg.appendChild(rootGroup);
        this.svg = rootGroup;
        return svg;
      },
      _ensureClipGroup: function SVGGraphics_ensureClipGroup() {
        if (!this.current.clipGroup) {
          var clipGroup = document.createElementNS(NS, 'svg:g');
          clipGroup.setAttributeNS(null, 'clip-path', this.current.activeClipUrl);
          this.svg.appendChild(clipGroup);
          this.current.clipGroup = clipGroup;
        }
        return this.current.clipGroup;
      },
      _ensureTransformGroup: function SVGGraphics_ensureTransformGroup() {
        if (!this.tgrp) {
          this.tgrp = document.createElementNS(NS, 'svg:g');
          this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));
          if (this.current.activeClipUrl) {
            this._ensureClipGroup().appendChild(this.tgrp);
          } else {
            this.svg.appendChild(this.tgrp);
          }
        }
        return this.tgrp;
      }
    };
    return SVGGraphics;
  }();
}
exports.SVGGraphics = SVGGraphics;

/***/ }),
/* 5 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderTextLayer = undefined;

var _util = __w_pdfjs_require__(0);

var _dom_utils = __w_pdfjs_require__(1);

var renderTextLayer = function renderTextLayerClosure() {
  var MAX_TEXT_DIVS_TO_RENDER = 100000;
  var NonWhitespaceRegexp = /\S/;
  function isAllWhitespace(str) {
    return !NonWhitespaceRegexp.test(str);
  }
  var styleBuf = ['left: ', 0, 'px; top: ', 0, 'px; font-size: ', 0, 'px; font-family: ', '', ';'];
  function appendText(task, geom, styles) {
    var textDiv = document.createElement('div');
    var textDivProperties = {
      style: null,
      angle: 0,
      canvasWidth: 0,
      isWhitespace: false,
      originalTransform: null,
      paddingBottom: 0,
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      scale: 1
    };
    task._textDivs.push(textDiv);
    if (isAllWhitespace(geom.str)) {
      textDivProperties.isWhitespace = true;
      task._textDivProperties.set(textDiv, textDivProperties);
      return;
    }
    var tx = _util.Util.transform(task._viewport.transform, geom.transform);
    var angle = Math.atan2(tx[1], tx[0]);
    var style = styles[geom.fontName];
    if (style.vertical) {
      angle += Math.PI / 2;
    }
    var fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]);
    var fontAscent = fontHeight;
    if (style.ascent) {
      fontAscent = style.ascent * fontAscent;
    } else if (style.descent) {
      fontAscent = (1 + style.descent) * fontAscent;
    }
    var left;
    var top;
    if (angle === 0) {
      left = tx[4];
      top = tx[5] - fontAscent;
    } else {
      left = tx[4] + fontAscent * Math.sin(angle);
      top = tx[5] - fontAscent * Math.cos(angle);
    }
    styleBuf[1] = left;
    styleBuf[3] = top;
    styleBuf[5] = fontHeight;
    styleBuf[7] = style.fontFamily;
    textDivProperties.style = styleBuf.join('');
    textDiv.setAttribute('style', textDivProperties.style);
    textDiv.textContent = geom.str;
    if ((0, _dom_utils.getDefaultSetting)('pdfBug')) {
      textDiv.dataset.fontName = geom.fontName;
    }
    if (angle !== 0) {
      textDivProperties.angle = angle * (180 / Math.PI);
    }
    if (geom.str.length > 1) {
      if (style.vertical) {
        textDivProperties.canvasWidth = geom.height * task._viewport.scale;
      } else {
        textDivProperties.canvasWidth = geom.width * task._viewport.scale;
      }
    }
    task._textDivProperties.set(textDiv, textDivProperties);
    if (task._enhanceTextSelection) {
      var angleCos = 1,
          angleSin = 0;
      if (angle !== 0) {
        angleCos = Math.cos(angle);
        angleSin = Math.sin(angle);
      }
      var divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
      var divHeight = fontHeight;
      var m, b;
      if (angle !== 0) {
        m = [angleCos, angleSin, -angleSin, angleCos, left, top];
        b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
      } else {
        b = [left, top, left + divWidth, top + divHeight];
      }
      task._bounds.push({
        left: b[0],
        top: b[1],
        right: b[2],
        bottom: b[3],
        div: textDiv,
        size: [divWidth, divHeight],
        m: m
      });
    }
  }
  function render(task) {
    if (task._canceled) {
      return;
    }
    var textLayerFrag = task._container;
    var textDivs = task._textDivs;
    var capability = task._capability;
    var textDivsLength = textDivs.length;
    if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
      task._renderingDone = true;
      capability.resolve();
      return;
    }
    var canvas = document.createElement('canvas');
    canvas.mozOpaque = true;
    var ctx = canvas.getContext('2d', { alpha: false });
    var lastFontSize;
    var lastFontFamily;
    for (var i = 0; i < textDivsLength; i++) {
      var textDiv = textDivs[i];
      var textDivProperties = task._textDivProperties.get(textDiv);
      if (textDivProperties.isWhitespace) {
        continue;
      }
      var fontSize = textDiv.style.fontSize;
      var fontFamily = textDiv.style.fontFamily;
      if (fontSize !== lastFontSize || fontFamily !== lastFontFamily) {
        ctx.font = fontSize + ' ' + fontFamily;
        lastFontSize = fontSize;
        lastFontFamily = fontFamily;
      }
      var width = ctx.measureText(textDiv.textContent).width;
      textLayerFrag.appendChild(textDiv);
      var transform = '';
      if (textDivProperties.canvasWidth !== 0 && width > 0) {
        textDivProperties.scale = textDivProperties.canvasWidth / width;
        transform = 'scaleX(' + textDivProperties.scale + ')';
      }
      if (textDivProperties.angle !== 0) {
        transform = 'rotate(' + textDivProperties.angle + 'deg) ' + transform;
      }
      if (transform !== '') {
        textDivProperties.originalTransform = transform;
        _dom_utils.CustomStyle.setProp('transform', textDiv, transform);
      }
      task._textDivProperties.set(textDiv, textDivProperties);
    }
    task._renderingDone = true;
    capability.resolve();
  }
  function expand(task) {
    var bounds = task._bounds;
    var viewport = task._viewport;
    var expanded = expandBounds(viewport.width, viewport.height, bounds);
    for (var i = 0; i < expanded.length; i++) {
      var div = bounds[i].div;
      var divProperties = task._textDivProperties.get(div);
      if (divProperties.angle === 0) {
        divProperties.paddingLeft = bounds[i].left - expanded[i].left;
        divProperties.paddingTop = bounds[i].top - expanded[i].top;
        divProperties.paddingRight = expanded[i].right - bounds[i].right;
        divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;
        task._textDivProperties.set(div, divProperties);
        continue;
      }
      var e = expanded[i],
          b = bounds[i];
      var m = b.m,
          c = m[0],
          s = m[1];
      var points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
      var ts = new Float64Array(64);
      points.forEach(function (p, i) {
        var t = _util.Util.applyTransform(p, m);
        ts[i + 0] = c && (e.left - t[0]) / c;
        ts[i + 4] = s && (e.top - t[1]) / s;
        ts[i + 8] = c && (e.right - t[0]) / c;
        ts[i + 12] = s && (e.bottom - t[1]) / s;
        ts[i + 16] = s && (e.left - t[0]) / -s;
        ts[i + 20] = c && (e.top - t[1]) / c;
        ts[i + 24] = s && (e.right - t[0]) / -s;
        ts[i + 28] = c && (e.bottom - t[1]) / c;
        ts[i + 32] = c && (e.left - t[0]) / -c;
        ts[i + 36] = s && (e.top - t[1]) / -s;
        ts[i + 40] = c && (e.right - t[0]) / -c;
        ts[i + 44] = s && (e.bottom - t[1]) / -s;
        ts[i + 48] = s && (e.left - t[0]) / s;
        ts[i + 52] = c && (e.top - t[1]) / -c;
        ts[i + 56] = s && (e.right - t[0]) / s;
        ts[i + 60] = c && (e.bottom - t[1]) / -c;
      });
      var findPositiveMin = function findPositiveMin(ts, offset, count) {
        var result = 0;
        for (var i = 0; i < count; i++) {
          var t = ts[offset++];
          if (t > 0) {
            result = result ? Math.min(t, result) : t;
          }
        }
        return result;
      };
      var boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
      divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
      divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
      divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
      divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;
      task._textDivProperties.set(div, divProperties);
    }
  }
  function expandBounds(width, height, boxes) {
    var bounds = boxes.map(function (box, i) {
      return {
        x1: box.left,
        y1: box.top,
        x2: box.right,
        y2: box.bottom,
        index: i,
        x1New: undefined,
        x2New: undefined
      };
    });
    expandBoundsLTR(width, bounds);
    var expanded = new Array(boxes.length);
    bounds.forEach(function (b) {
      var i = b.index;
      expanded[i] = {
        left: b.x1New,
        top: 0,
        right: b.x2New,
        bottom: 0
      };
    });
    boxes.map(function (box, i) {
      var e = expanded[i],
          b = bounds[i];
      b.x1 = box.top;
      b.y1 = width - e.right;
      b.x2 = box.bottom;
      b.y2 = width - e.left;
      b.index = i;
      b.x1New = undefined;
      b.x2New = undefined;
    });
    expandBoundsLTR(height, bounds);
    bounds.forEach(function (b) {
      var i = b.index;
      expanded[i].top = b.x1New;
      expanded[i].bottom = b.x2New;
    });
    return expanded;
  }
  function expandBoundsLTR(width, bounds) {
    bounds.sort(function (a, b) {
      return a.x1 - b.x1 || a.index - b.index;
    });
    var fakeBoundary = {
      x1: -Infinity,
      y1: -Infinity,
      x2: 0,
      y2: Infinity,
      index: -1,
      x1New: 0,
      x2New: 0
    };
    var horizon = [{
      start: -Infinity,
      end: Infinity,
      boundary: fakeBoundary
    }];
    bounds.forEach(function (boundary) {
      var i = 0;
      while (i < horizon.length && horizon[i].end <= boundary.y1) {
        i++;
      }
      var j = horizon.length - 1;
      while (j >= 0 && horizon[j].start >= boundary.y2) {
        j--;
      }
      var horizonPart, affectedBoundary;
      var q,
          k,
          maxXNew = -Infinity;
      for (q = i; q <= j; q++) {
        horizonPart = horizon[q];
        affectedBoundary = horizonPart.boundary;
        var xNew;
        if (affectedBoundary.x2 > boundary.x1) {
          xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
        } else if (affectedBoundary.x2New === undefined) {
          xNew = (affectedBoundary.x2 + boundary.x1) / 2;
        } else {
          xNew = affectedBoundary.x2New;
        }
        if (xNew > maxXNew) {
          maxXNew = xNew;
        }
      }
      boundary.x1New = maxXNew;
      for (q = i; q <= j; q++) {
        horizonPart = horizon[q];
        affectedBoundary = horizonPart.boundary;
        if (affectedBoundary.x2New === undefined) {
          if (affectedBoundary.x2 > boundary.x1) {
            if (affectedBoundary.index > boundary.index) {
              affectedBoundary.x2New = affectedBoundary.x2;
            }
          } else {
            affectedBoundary.x2New = maxXNew;
          }
        } else if (affectedBoundary.x2New > maxXNew) {
          affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
        }
      }
      var changedHorizon = [],
          lastBoundary = null;
      for (q = i; q <= j; q++) {
        horizonPart = horizon[q];
        affectedBoundary = horizonPart.boundary;
        var useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;
        if (lastBoundary === useBoundary) {
          changedHorizon[changedHorizon.length - 1].end = horizonPart.end;
        } else {
          changedHorizon.push({
            start: horizonPart.start,
            end: horizonPart.end,
            boundary: useBoundary
          });
          lastBoundary = useBoundary;
        }
      }
      if (horizon[i].start < boundary.y1) {
        changedHorizon[0].start = boundary.y1;
        changedHorizon.unshift({
          start: horizon[i].start,
          end: boundary.y1,
          boundary: horizon[i].boundary
        });
      }
      if (boundary.y2 < horizon[j].end) {
        changedHorizon[changedHorizon.length - 1].end = boundary.y2;
        changedHorizon.push({
          start: boundary.y2,
          end: horizon[j].end,
          boundary: horizon[j].boundary
        });
      }
      for (q = i; q <= j; q++) {
        horizonPart = horizon[q];
        affectedBoundary = horizonPart.boundary;
        if (affectedBoundary.x2New !== undefined) {
          continue;
        }
        var used = false;
        for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
          used = horizon[k].boundary === affectedBoundary;
        }
        for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
          used = horizon[k].boundary === affectedBoundary;
        }
        for (k = 0; !used && k < changedHorizon.length; k++) {
          used = changedHorizon[k].boundary === affectedBoundary;
        }
        if (!used) {
          affectedBoundary.x2New = maxXNew;
        }
      }
      Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));
    });
    horizon.forEach(function (horizonPart) {
      var affectedBoundary = horizonPart.boundary;
      if (affectedBoundary.x2New === undefined) {
        affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
      }
    });
  }
  function TextLayerRenderTask(textContent, container, viewport, textDivs, enhanceTextSelection) {
    this._textContent = textContent;
    this._container = container;
    this._viewport = viewport;
    this._textDivs = textDivs || [];
    this._textDivProperties = new WeakMap();
    this._renderingDone = false;
    this._canceled = false;
    this._capability = (0, _util.createPromiseCapability)();
    this._renderTimer = null;
    this._bounds = [];
    this._enhanceTextSelection = !!enhanceTextSelection;
  }
  TextLayerRenderTask.prototype = {
    get promise() {
      return this._capability.promise;
    },
    cancel: function TextLayer_cancel() {
      this._canceled = true;
      if (this._renderTimer !== null) {
        clearTimeout(this._renderTimer);
        this._renderTimer = null;
      }
      this._capability.reject('canceled');
    },
    _render: function TextLayer_render(timeout) {
      var textItems = this._textContent.items;
      var textStyles = this._textContent.styles;
      for (var i = 0, len = textItems.length; i < len; i++) {
        appendText(this, textItems[i], textStyles);
      }
      if (!timeout) {
        render(this);
      } else {
        var self = this;
        this._renderTimer = setTimeout(function () {
          render(self);
          self._renderTimer = null;
        }, timeout);
      }
    },
    expandTextDivs: function TextLayer_expandTextDivs(expandDivs) {
      if (!this._enhanceTextSelection || !this._renderingDone) {
        return;
      }
      if (this._bounds !== null) {
        expand(this);
        this._bounds = null;
      }
      for (var i = 0, ii = this._textDivs.length; i < ii; i++) {
        var div = this._textDivs[i];
        var divProperties = this._textDivProperties.get(div);
        if (divProperties.isWhitespace) {
          continue;
        }
        if (expandDivs) {
          var transform = '',
              padding = '';
          if (divProperties.scale !== 1) {
            transform = 'scaleX(' + divProperties.scale + ')';
          }
          if (divProperties.angle !== 0) {
            transform = 'rotate(' + divProperties.angle + 'deg) ' + transform;
          }
          if (divProperties.paddingLeft !== 0) {
            padding += ' padding-left: ' + divProperties.paddingLeft / divProperties.scale + 'px;';
            transform += ' translateX(' + -divProperties.paddingLeft / divProperties.scale + 'px)';
          }
          if (divProperties.paddingTop !== 0) {
            padding += ' padding-top: ' + divProperties.paddingTop + 'px;';
            transform += ' translateY(' + -divProperties.paddingTop + 'px)';
          }
          if (divProperties.paddingRight !== 0) {
            padding += ' padding-right: ' + divProperties.paddingRight / divProperties.scale + 'px;';
          }
          if (divProperties.paddingBottom !== 0) {
            padding += ' padding-bottom: ' + divProperties.paddingBottom + 'px;';
          }
          if (padding !== '') {
            div.setAttribute('style', divProperties.style + padding);
          }
          if (transform !== '') {
            _dom_utils.CustomStyle.setProp('transform', div, transform);
          }
        } else {
          div.style.padding = 0;
          _dom_utils.CustomStyle.setProp('transform', div, divProperties.originalTransform || '');
        }
      }
    }
  };
  function renderTextLayer(renderParameters) {
    var task = new TextLayerRenderTask(renderParameters.textContent, renderParameters.container, renderParameters.viewport, renderParameters.textDivs, renderParameters.enhanceTextSelection);
    task._render(renderParameters.timeout);
    return task;
  }
  return renderTextLayer;
}();
exports.renderTextLayer = renderTextLayer;

/***/ }),
/* 6 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;
g = function () {
  return this;
}();
try {
  g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}
module.exports = g;

/***/ }),
/* 7 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Metadata = undefined;

var _util = __w_pdfjs_require__(0);

function fixMetadata(meta) {
  return meta.replace(/>\\376\\377([^<]+)/g, function (all, codes) {
    var bytes = codes.replace(/\\([0-3])([0-7])([0-7])/g, function (code, d1, d2, d3) {
      return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);
    });
    var chars = '';
    for (var i = 0; i < bytes.length; i += 2) {
      var code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);
      chars += code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38 ? String.fromCharCode(code) : '&#x' + (0x10000 + code).toString(16).substring(1) + ';';
    }
    return '>' + chars;
  });
}
function Metadata(meta) {
  if (typeof meta === 'string') {
    meta = fixMetadata(meta);
    var parser = new DOMParser();
    meta = parser.parseFromString(meta, 'application/xml');
  } else if (!(meta instanceof Document)) {
    (0, _util.error)('Metadata: Invalid metadata object');
  }
  this.metaDocument = meta;
  this.metadata = Object.create(null);
  this.parse();
}
Metadata.prototype = {
  parse: function Metadata_parse() {
    var doc = this.metaDocument;
    var rdf = doc.documentElement;
    if (rdf.nodeName.toLowerCase() !== 'rdf:rdf') {
      rdf = rdf.firstChild;
      while (rdf && rdf.nodeName.toLowerCase() !== 'rdf:rdf') {
        rdf = rdf.nextSibling;
      }
    }
    var nodeName = rdf ? rdf.nodeName.toLowerCase() : null;
    if (!rdf || nodeName !== 'rdf:rdf' || !rdf.hasChildNodes()) {
      return;
    }
    var children = rdf.childNodes,
        desc,
        entry,
        name,
        i,
        ii,
        length,
        iLength;
    for (i = 0, length = children.length; i < length; i++) {
      desc = children[i];
      if (desc.nodeName.toLowerCase() !== 'rdf:description') {
        continue;
      }
      for (ii = 0, iLength = desc.childNodes.length; ii < iLength; ii++) {
        if (desc.childNodes[ii].nodeName.toLowerCase() !== '#text') {
          entry = desc.childNodes[ii];
          name = entry.nodeName.toLowerCase();
          this.metadata[name] = entry.textContent.trim();
        }
      }
    }
  },
  get: function Metadata_get(name) {
    return this.metadata[name] || null;
  },
  has: function Metadata_has(name) {
    return typeof this.metadata[name] !== 'undefined';
  }
};
exports.Metadata = Metadata;

/***/ }),
/* 8 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebGLUtils = undefined;

var _dom_utils = __w_pdfjs_require__(1);

var _util = __w_pdfjs_require__(0);

var WebGLUtils = function WebGLUtilsClosure() {
  function loadShader(gl, code, shaderType) {
    var shader = gl.createShader(shaderType);
    gl.shaderSource(shader, code);
    gl.compileShader(shader);
    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (!compiled) {
      var errorMsg = gl.getShaderInfoLog(shader);
      throw new Error('Error during shader compilation: ' + errorMsg);
    }
    return shader;
  }
  function createVertexShader(gl, code) {
    return loadShader(gl, code, gl.VERTEX_SHADER);
  }
  function createFragmentShader(gl, code) {
    return loadShader(gl, code, gl.FRAGMENT_SHADER);
  }
  function createProgram(gl, shaders) {
    var program = gl.createProgram();
    for (var i = 0, ii = shaders.length; i < ii; ++i) {
      gl.attachShader(program, shaders[i]);
    }
    gl.linkProgram(program);
    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!linked) {
      var errorMsg = gl.getProgramInfoLog(program);
      throw new Error('Error during program linking: ' + errorMsg);
    }
    return program;
  }
  function createTexture(gl, image, textureId) {
    gl.activeTexture(textureId);
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    return texture;
  }
  var currentGL, currentCanvas;
  function generateGL() {
    if (currentGL) {
      return;
    }
    currentCanvas = document.createElement('canvas');
    currentGL = currentCanvas.getContext('webgl', { premultipliedalpha: false });
  }
  var smaskVertexShaderCode = '\
  attribute vec2 a_position;                                    \
  attribute vec2 a_texCoord;                                    \
                                                                \
  uniform vec2 u_resolution;                                    \
                                                                \
  varying vec2 v_texCoord;                                      \
                                                                \
  void main() {                                                 \
    vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;   \
    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \
                                                                \
    v_texCoord = a_texCoord;                                    \
  }                                                             ';
  var smaskFragmentShaderCode = '\
  precision mediump float;                                      \
                                                                \
  uniform vec4 u_backdrop;                                      \
  uniform int u_subtype;                                        \
  uniform sampler2D u_image;                                    \
  uniform sampler2D u_mask;                                     \
                                                                \
  varying vec2 v_texCoord;                                      \
                                                                \
  void main() {                                                 \
    vec4 imageColor = texture2D(u_image, v_texCoord);           \
    vec4 maskColor = texture2D(u_mask, v_texCoord);             \
    if (u_backdrop.a > 0.0) {                                   \
      maskColor.rgb = maskColor.rgb * maskColor.a +             \
                      u_backdrop.rgb * (1.0 - maskColor.a);     \
    }                                                           \
    float lum;                                                  \
    if (u_subtype == 0) {                                       \
      lum = maskColor.a;                                        \
    } else {                                                    \
      lum = maskColor.r * 0.3 + maskColor.g * 0.59 +            \
            maskColor.b * 0.11;                                 \
    }                                                           \
    imageColor.a *= lum;                                        \
    imageColor.rgb *= imageColor.a;                             \
    gl_FragColor = imageColor;                                  \
  }                                                             ';
  var smaskCache = null;
  function initSmaskGL() {
    var canvas, gl;
    generateGL();
    canvas = currentCanvas;
    currentCanvas = null;
    gl = currentGL;
    currentGL = null;
    var vertexShader = createVertexShader(gl, smaskVertexShaderCode);
    var fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);
    var program = createProgram(gl, [vertexShader, fragmentShader]);
    gl.useProgram(program);
    var cache = {};
    cache.gl = gl;
    cache.canvas = canvas;
    cache.resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
    cache.positionLocation = gl.getAttribLocation(program, 'a_position');
    cache.backdropLocation = gl.getUniformLocation(program, 'u_backdrop');
    cache.subtypeLocation = gl.getUniformLocation(program, 'u_subtype');
    var texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
    var texLayerLocation = gl.getUniformLocation(program, 'u_image');
    var texMaskLocation = gl.getUniformLocation(program, 'u_mask');
    var texCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(texCoordLocation);
    gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
    gl.uniform1i(texLayerLocation, 0);
    gl.uniform1i(texMaskLocation, 1);
    smaskCache = cache;
  }
  function composeSMask(layer, mask, properties) {
    var width = layer.width,
        height = layer.height;
    if (!smaskCache) {
      initSmaskGL();
    }
    var cache = smaskCache,
        canvas = cache.canvas,
        gl = cache.gl;
    canvas.width = width;
    canvas.height = height;
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.uniform2f(cache.resolutionLocation, width, height);
    if (properties.backdrop) {
      gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1);
    } else {
      gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);
    }
    gl.uniform1i(cache.subtypeLocation, properties.subtype === 'Luminosity' ? 1 : 0);
    var texture = createTexture(gl, layer, gl.TEXTURE0);
    var maskTexture = createTexture(gl, mask, gl.TEXTURE1);
    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(cache.positionLocation);
    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
    gl.clearColor(0, 0, 0, 0);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.flush();
    gl.deleteTexture(texture);
    gl.deleteTexture(maskTexture);
    gl.deleteBuffer(buffer);
    return canvas;
  }
  var figuresVertexShaderCode = '\
  attribute vec2 a_position;                                    \
  attribute vec3 a_color;                                       \
                                                                \
  uniform vec2 u_resolution;                                    \
  uniform vec2 u_scale;                                         \
  uniform vec2 u_offset;                                        \
                                                                \
  varying vec4 v_color;                                         \
                                                                \
  void main() {                                                 \
    vec2 position = (a_position + u_offset) * u_scale;          \
    vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;     \
    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \
                                                                \
    v_color = vec4(a_color / 255.0, 1.0);                       \
  }                                                             ';
  var figuresFragmentShaderCode = '\
  precision mediump float;                                      \
                                                                \
  varying vec4 v_color;                                         \
                                                                \
  void main() {                                                 \
    gl_FragColor = v_color;                                     \
  }                                                             ';
  var figuresCache = null;
  function initFiguresGL() {
    var canvas, gl;
    generateGL();
    canvas = currentCanvas;
    currentCanvas = null;
    gl = currentGL;
    currentGL = null;
    var vertexShader = createVertexShader(gl, figuresVertexShaderCode);
    var fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);
    var program = createProgram(gl, [vertexShader, fragmentShader]);
    gl.useProgram(program);
    var cache = {};
    cache.gl = gl;
    cache.canvas = canvas;
    cache.resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
    cache.scaleLocation = gl.getUniformLocation(program, 'u_scale');
    cache.offsetLocation = gl.getUniformLocation(program, 'u_offset');
    cache.positionLocation = gl.getAttribLocation(program, 'a_position');
    cache.colorLocation = gl.getAttribLocation(program, 'a_color');
    figuresCache = cache;
  }
  function drawFigures(width, height, backgroundColor, figures, context) {
    if (!figuresCache) {
      initFiguresGL();
    }
    var cache = figuresCache,
        canvas = cache.canvas,
        gl = cache.gl;
    canvas.width = width;
    canvas.height = height;
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.uniform2f(cache.resolutionLocation, width, height);
    var count = 0;
    var i, ii, rows;
    for (i = 0, ii = figures.length; i < ii; i++) {
      switch (figures[i].type) {
        case 'lattice':
          rows = figures[i].coords.length / figures[i].verticesPerRow | 0;
          count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;
          break;
        case 'triangles':
          count += figures[i].coords.length;
          break;
      }
    }
    var coords = new Float32Array(count * 2);
    var colors = new Uint8Array(count * 3);
    var coordsMap = context.coords,
        colorsMap = context.colors;
    var pIndex = 0,
        cIndex = 0;
    for (i = 0, ii = figures.length; i < ii; i++) {
      var figure = figures[i],
          ps = figure.coords,
          cs = figure.colors;
      switch (figure.type) {
        case 'lattice':
          var cols = figure.verticesPerRow;
          rows = ps.length / cols | 0;
          for (var row = 1; row < rows; row++) {
            var offset = row * cols + 1;
            for (var col = 1; col < cols; col++, offset++) {
              coords[pIndex] = coordsMap[ps[offset - cols - 1]];
              coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];
              coords[pIndex + 2] = coordsMap[ps[offset - cols]];
              coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];
              coords[pIndex + 4] = coordsMap[ps[offset - 1]];
              coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];
              colors[cIndex] = colorsMap[cs[offset - cols - 1]];
              colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];
              colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];
              colors[cIndex + 3] = colorsMap[cs[offset - cols]];
              colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];
              colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];
              colors[cIndex + 6] = colorsMap[cs[offset - 1]];
              colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];
              colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];
              coords[pIndex + 6] = coords[pIndex + 2];
              coords[pIndex + 7] = coords[pIndex + 3];
              coords[pIndex + 8] = coords[pIndex + 4];
              coords[pIndex + 9] = coords[pIndex + 5];
              coords[pIndex + 10] = coordsMap[ps[offset]];
              coords[pIndex + 11] = coordsMap[ps[offset] + 1];
              colors[cIndex + 9] = colors[cIndex + 3];
              colors[cIndex + 10] = colors[cIndex + 4];
              colors[cIndex + 11] = colors[cIndex + 5];
              colors[cIndex + 12] = colors[cIndex + 6];
              colors[cIndex + 13] = colors[cIndex + 7];
              colors[cIndex + 14] = colors[cIndex + 8];
              colors[cIndex + 15] = colorsMap[cs[offset]];
              colors[cIndex + 16] = colorsMap[cs[offset] + 1];
              colors[cIndex + 17] = colorsMap[cs[offset] + 2];
              pIndex += 12;
              cIndex += 18;
            }
          }
          break;
        case 'triangles':
          for (var j = 0, jj = ps.length; j < jj; j++) {
            coords[pIndex] = coordsMap[ps[j]];
            coords[pIndex + 1] = coordsMap[ps[j] + 1];
            colors[cIndex] = colorsMap[cs[j]];
            colors[cIndex + 1] = colorsMap[cs[j] + 1];
            colors[cIndex + 2] = colorsMap[cs[j] + 2];
            pIndex += 2;
            cIndex += 3;
          }
          break;
      }
    }
    if (backgroundColor) {
      gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1.0);
    } else {
      gl.clearColor(0, 0, 0, 0);
    }
    gl.clear(gl.COLOR_BUFFER_BIT);
    var coordsBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(cache.positionLocation);
    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
    var colorsBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(cache.colorLocation);
    gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0);
    gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);
    gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);
    gl.drawArrays(gl.TRIANGLES, 0, count);
    gl.flush();
    gl.deleteBuffer(coordsBuffer);
    gl.deleteBuffer(colorsBuffer);
    return canvas;
  }
  function cleanup() {
    if (smaskCache && smaskCache.canvas) {
      smaskCache.canvas.width = 0;
      smaskCache.canvas.height = 0;
    }
    if (figuresCache && figuresCache.canvas) {
      figuresCache.canvas.width = 0;
      figuresCache.canvas.height = 0;
    }
    smaskCache = null;
    figuresCache = null;
  }
  return {
    get isEnabled() {
      if ((0, _dom_utils.getDefaultSetting)('disableWebGL')) {
        return false;
      }
      var enabled = false;
      try {
        generateGL();
        enabled = !!currentGL;
      } catch (e) {}
      return (0, _util.shadow)(this, 'isEnabled', enabled);
    },
    composeSMask: composeSMask,
    drawFigures: drawFigures,
    clear: cleanup
  };
}();
exports.WebGLUtils = WebGLUtils;

/***/ }),
/* 9 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PDFJS = exports.isWorker = exports.globalScope = undefined;

var _api = __w_pdfjs_require__(3);

var _dom_utils = __w_pdfjs_require__(1);

var _util = __w_pdfjs_require__(0);

var _annotation_layer = __w_pdfjs_require__(2);

var _metadata = __w_pdfjs_require__(7);

var _text_layer = __w_pdfjs_require__(5);

var _svg = __w_pdfjs_require__(4);

var isWorker = typeof window === 'undefined';
if (!_util.globalScope.PDFJS) {
  _util.globalScope.PDFJS = {};
}
var PDFJS = _util.globalScope.PDFJS;
{
  PDFJS.version = '1.8.233';
  PDFJS.build = '19321937';
}
PDFJS.pdfBug = false;
if (PDFJS.verbosity !== undefined) {
  (0, _util.setVerbosityLevel)(PDFJS.verbosity);
}
delete PDFJS.verbosity;
Object.defineProperty(PDFJS, 'verbosity', {
  get: function get() {
    return (0, _util.getVerbosityLevel)();
  },
  set: function set(level) {
    (0, _util.setVerbosityLevel)(level);
  },
  enumerable: true,
  configurable: true
});
PDFJS.VERBOSITY_LEVELS = _util.VERBOSITY_LEVELS;
PDFJS.OPS = _util.OPS;
PDFJS.UNSUPPORTED_FEATURES = _util.UNSUPPORTED_FEATURES;
PDFJS.isValidUrl = _dom_utils.isValidUrl;
PDFJS.shadow = _util.shadow;
PDFJS.createBlob = _util.createBlob;
PDFJS.createObjectURL = function PDFJS_createObjectURL(data, contentType) {
  return (0, _util.createObjectURL)(data, contentType, PDFJS.disableCreateObjectURL);
};
Object.defineProperty(PDFJS, 'isLittleEndian', {
  configurable: true,
  get: function PDFJS_isLittleEndian() {
    return (0, _util.shadow)(PDFJS, 'isLittleEndian', (0, _util.isLittleEndian)());
  }
});
PDFJS.removeNullCharacters = _util.removeNullCharacters;
PDFJS.PasswordResponses = _util.PasswordResponses;
PDFJS.PasswordException = _util.PasswordException;
PDFJS.UnknownErrorException = _util.UnknownErrorException;
PDFJS.InvalidPDFException = _util.InvalidPDFException;
PDFJS.MissingPDFException = _util.MissingPDFException;
PDFJS.UnexpectedResponseException = _util.UnexpectedResponseException;
PDFJS.Util = _util.Util;
PDFJS.PageViewport = _util.PageViewport;
PDFJS.createPromiseCapability = _util.createPromiseCapability;
PDFJS.maxImageSize = PDFJS.maxImageSize === undefined ? -1 : PDFJS.maxImageSize;
PDFJS.cMapUrl = PDFJS.cMapUrl === undefined ? null : PDFJS.cMapUrl;
PDFJS.cMapPacked = PDFJS.cMapPacked === undefined ? false : PDFJS.cMapPacked;
PDFJS.disableFontFace = PDFJS.disableFontFace === undefined ? false : PDFJS.disableFontFace;
PDFJS.imageResourcesPath = PDFJS.imageResourcesPath === undefined ? '' : PDFJS.imageResourcesPath;
PDFJS.disableWorker = PDFJS.disableWorker === undefined ? false : PDFJS.disableWorker;
PDFJS.workerSrc = PDFJS.workerSrc === undefined ? null : PDFJS.workerSrc;
PDFJS.workerPort = PDFJS.workerPort === undefined ? null : PDFJS.workerPort;
PDFJS.disableRange = PDFJS.disableRange === undefined ? false : PDFJS.disableRange;
PDFJS.disableStream = PDFJS.disableStream === undefined ? false : PDFJS.disableStream;
PDFJS.disableAutoFetch = PDFJS.disableAutoFetch === undefined ? false : PDFJS.disableAutoFetch;
PDFJS.pdfBug = PDFJS.pdfBug === undefined ? false : PDFJS.pdfBug;
PDFJS.postMessageTransfers = PDFJS.postMessageTransfers === undefined ? true : PDFJS.postMessageTransfers;
PDFJS.disableCreateObjectURL = PDFJS.disableCreateObjectURL === undefined ? false : PDFJS.disableCreateObjectURL;
PDFJS.disableWebGL = PDFJS.disableWebGL === undefined ? true : PDFJS.disableWebGL;
PDFJS.externalLinkTarget = PDFJS.externalLinkTarget === undefined ? _dom_utils.LinkTarget.NONE : PDFJS.externalLinkTarget;
PDFJS.externalLinkRel = PDFJS.externalLinkRel === undefined ? _dom_utils.DEFAULT_LINK_REL : PDFJS.externalLinkRel;
PDFJS.isEvalSupported = PDFJS.isEvalSupported === undefined ? true : PDFJS.isEvalSupported;
PDFJS.pdfjsNext = PDFJS.pdfjsNext === undefined ? false : PDFJS.pdfjsNext;
{
  var savedOpenExternalLinksInNewWindow = PDFJS.openExternalLinksInNewWindow;
  delete PDFJS.openExternalLinksInNewWindow;
  Object.defineProperty(PDFJS, 'openExternalLinksInNewWindow', {
    get: function get() {
      return PDFJS.externalLinkTarget === _dom_utils.LinkTarget.BLANK;
    },
    set: function set(value) {
      if (value) {
        (0, _util.deprecated)('PDFJS.openExternalLinksInNewWindow, please use ' + '"PDFJS.externalLinkTarget = PDFJS.LinkTarget.BLANK" instead.');
      }
      if (PDFJS.externalLinkTarget !== _dom_utils.LinkTarget.NONE) {
        (0, _util.warn)('PDFJS.externalLinkTarget is already initialized');
        return;
      }
      PDFJS.externalLinkTarget = value ? _dom_utils.LinkTarget.BLANK : _dom_utils.LinkTarget.NONE;
    },
    enumerable: true,
    configurable: true
  });
  if (savedOpenExternalLinksInNewWindow) {
    PDFJS.openExternalLinksInNewWindow = savedOpenExternalLinksInNewWindow;
  }
}
PDFJS.getDocument = _api.getDocument;
PDFJS.PDFDataRangeTransport = _api.PDFDataRangeTransport;
PDFJS.PDFWorker = _api.PDFWorker;
PDFJS.hasCanvasTypedArrays = true;
PDFJS.CustomStyle = _dom_utils.CustomStyle;
PDFJS.LinkTarget = _dom_utils.LinkTarget;
PDFJS.addLinkAttributes = _dom_utils.addLinkAttributes;
PDFJS.getFilenameFromUrl = _dom_utils.getFilenameFromUrl;
PDFJS.isExternalLinkTargetSet = _dom_utils.isExternalLinkTargetSet;
PDFJS.AnnotationLayer = _annotation_layer.AnnotationLayer;
PDFJS.renderTextLayer = _text_layer.renderTextLayer;
PDFJS.Metadata = _metadata.Metadata;
PDFJS.SVGGraphics = _svg.SVGGraphics;
PDFJS.UnsupportedManager = _api._UnsupportedManager;
exports.globalScope = _util.globalScope;
exports.isWorker = isWorker;
exports.PDFJS = PDFJS;

/***/ }),
/* 10 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CanvasGraphics = undefined;

var _util = __w_pdfjs_require__(0);

var _pattern_helper = __w_pdfjs_require__(12);

var _webgl = __w_pdfjs_require__(8);

var MIN_FONT_SIZE = 16;
var MAX_FONT_SIZE = 100;
var MAX_GROUP_SIZE = 4096;
var MIN_WIDTH_FACTOR = 0.65;
var COMPILE_TYPE3_GLYPHS = true;
var MAX_SIZE_TO_COMPILE = 1000;
var FULL_CHUNK_HEIGHT = 16;
var IsLittleEndianCached = {
  get value() {
    return (0, _util.shadow)(IsLittleEndianCached, 'value', (0, _util.isLittleEndian)());
  }
};
function addContextCurrentTransform(ctx) {
  if (!ctx.mozCurrentTransform) {
    ctx._originalSave = ctx.save;
    ctx._originalRestore = ctx.restore;
    ctx._originalRotate = ctx.rotate;
    ctx._originalScale = ctx.scale;
    ctx._originalTranslate = ctx.translate;
    ctx._originalTransform = ctx.transform;
    ctx._originalSetTransform = ctx.setTransform;
    ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
    ctx._transformStack = [];
    Object.defineProperty(ctx, 'mozCurrentTransform', {
      get: function getCurrentTransform() {
        return this._transformMatrix;
      }
    });
    Object.defineProperty(ctx, 'mozCurrentTransformInverse', {
      get: function getCurrentTransformInverse() {
        var m = this._transformMatrix;
        var a = m[0],
            b = m[1],
            c = m[2],
            d = m[3],
            e = m[4],
            f = m[5];
        var ad_bc = a * d - b * c;
        var bc_ad = b * c - a * d;
        return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
      }
    });
    ctx.save = function ctxSave() {
      var old = this._transformMatrix;
      this._transformStack.push(old);
      this._transformMatrix = old.slice(0, 6);
      this._originalSave();
    };
    ctx.restore = function ctxRestore() {
      var prev = this._transformStack.pop();
      if (prev) {
        this._transformMatrix = prev;
        this._originalRestore();
      }
    };
    ctx.translate = function ctxTranslate(x, y) {
      var m = this._transformMatrix;
      m[4] = m[0] * x + m[2] * y + m[4];
      m[5] = m[1] * x + m[3] * y + m[5];
      this._originalTranslate(x, y);
    };
    ctx.scale = function ctxScale(x, y) {
      var m = this._transformMatrix;
      m[0] = m[0] * x;
      m[1] = m[1] * x;
      m[2] = m[2] * y;
      m[3] = m[3] * y;
      this._originalScale(x, y);
    };
    ctx.transform = function ctxTransform(a, b, c, d, e, f) {
      var m = this._transformMatrix;
      this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];
      ctx._originalTransform(a, b, c, d, e, f);
    };
    ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
      this._transformMatrix = [a, b, c, d, e, f];
      ctx._originalSetTransform(a, b, c, d, e, f);
    };
    ctx.rotate = function ctxRotate(angle) {
      var cosValue = Math.cos(angle);
      var sinValue = Math.sin(angle);
      var m = this._transformMatrix;
      this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];
      this._originalRotate(angle);
    };
  }
}
var CachedCanvases = function CachedCanvasesClosure() {
  function CachedCanvases(canvasFactory) {
    this.canvasFactory = canvasFactory;
    this.cache = Object.create(null);
  }
  CachedCanvases.prototype = {
    getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) {
      var canvasEntry;
      if (this.cache[id] !== undefined) {
        canvasEntry = this.cache[id];
        this.canvasFactory.reset(canvasEntry, width, height);
        canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
      } else {
        canvasEntry = this.canvasFactory.create(width, height);
        this.cache[id] = canvasEntry;
      }
      if (trackTransform) {
        addContextCurrentTransform(canvasEntry.context);
      }
      return canvasEntry;
    },
    clear: function clear() {
      for (var id in this.cache) {
        var canvasEntry = this.cache[id];
        this.canvasFactory.destroy(canvasEntry);
        delete this.cache[id];
      }
    }
  };
  return CachedCanvases;
}();
function compileType3Glyph(imgData) {
  var POINT_TO_PROCESS_LIMIT = 1000;
  var width = imgData.width,
      height = imgData.height;
  var i,
      j,
      j0,
      width1 = width + 1;
  var points = new Uint8Array(width1 * (height + 1));
  var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
  var lineSize = width + 7 & ~7,
      data0 = imgData.data;
  var data = new Uint8Array(lineSize * height),
      pos = 0,
      ii;
  for (i = 0, ii = data0.length; i < ii; i++) {
    var mask = 128,
        elem = data0[i];
    while (mask > 0) {
      data[pos++] = elem & mask ? 0 : 255;
      mask >>= 1;
    }
  }
  var count = 0;
  pos = 0;
  if (data[pos] !== 0) {
    points[0] = 1;
    ++count;
  }
  for (j = 1; j < width; j++) {
    if (data[pos] !== data[pos + 1]) {
      points[j] = data[pos] ? 2 : 1;
      ++count;
    }
    pos++;
  }
  if (data[pos] !== 0) {
    points[j] = 2;
    ++count;
  }
  for (i = 1; i < height; i++) {
    pos = i * lineSize;
    j0 = i * width1;
    if (data[pos - lineSize] !== data[pos]) {
      points[j0] = data[pos] ? 1 : 8;
      ++count;
    }
    var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
    for (j = 1; j < width; j++) {
      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
      if (POINT_TYPES[sum]) {
        points[j0 + j] = POINT_TYPES[sum];
        ++count;
      }
      pos++;
    }
    if (data[pos - lineSize] !== data[pos]) {
      points[j0 + j] = data[pos] ? 2 : 4;
      ++count;
    }
    if (count > POINT_TO_PROCESS_LIMIT) {
      return null;
    }
  }
  pos = lineSize * (height - 1);
  j0 = i * width1;
  if (data[pos] !== 0) {
    points[j0] = 8;
    ++count;
  }
  for (j = 1; j < width; j++) {
    if (data[pos] !== data[pos + 1]) {
      points[j0 + j] = data[pos] ? 4 : 8;
      ++count;
    }
    pos++;
  }
  if (data[pos] !== 0) {
    points[j0 + j] = 4;
    ++count;
  }
  if (count > POINT_TO_PROCESS_LIMIT) {
    return null;
  }
  var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
  var outlines = [];
  for (i = 0; count && i <= height; i++) {
    var p = i * width1;
    var end = p + width;
    while (p < end && !points[p]) {
      p++;
    }
    if (p === end) {
      continue;
    }
    var coords = [p % width1, i];
    var type = points[p],
        p0 = p,
        pp;
    do {
      var step = steps[type];
      do {
        p += step;
      } while (!points[p]);
      pp = points[p];
      if (pp !== 5 && pp !== 10) {
        type = pp;
        points[p] = 0;
      } else {
        type = pp & 0x33 * type >> 4;
        points[p] &= type >> 2 | type << 2;
      }
      coords.push(p % width1);
      coords.push(p / width1 | 0);
      --count;
    } while (p0 !== p);
    outlines.push(coords);
    --i;
  }
  var drawOutline = function drawOutline(c) {
    c.save();
    c.scale(1 / width, -1 / height);
    c.translate(0, -height);
    c.beginPath();
    for (var i = 0, ii = outlines.length; i < ii; i++) {
      var o = outlines[i];
      c.moveTo(o[0], o[1]);
      for (var j = 2, jj = o.length; j < jj; j += 2) {
        c.lineTo(o[j], o[j + 1]);
      }
    }
    c.fill();
    c.beginPath();
    c.restore();
  };
  return drawOutline;
}
var CanvasExtraState = function CanvasExtraStateClosure() {
  function CanvasExtraState(old) {
    this.alphaIsShape = false;
    this.fontSize = 0;
    this.fontSizeScale = 1;
    this.textMatrix = _util.IDENTITY_MATRIX;
    this.textMatrixScale = 1;
    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
    this.leading = 0;
    this.x = 0;
    this.y = 0;
    this.lineX = 0;
    this.lineY = 0;
    this.charSpacing = 0;
    this.wordSpacing = 0;
    this.textHScale = 1;
    this.textRenderingMode = _util.TextRenderingMode.FILL;
    this.textRise = 0;
    this.fillColor = '#000000';
    this.strokeColor = '#000000';
    this.patternFill = false;
    this.fillAlpha = 1;
    this.strokeAlpha = 1;
    this.lineWidth = 1;
    this.activeSMask = null;
    this.resumeSMaskCtx = null;
    this.old = old;
  }
  CanvasExtraState.prototype = {
    clone: function CanvasExtraState_clone() {
      return Object.create(this);
    },
    setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {
      this.x = x;
      this.y = y;
    }
  };
  return CanvasExtraState;
}();
var CanvasGraphics = function CanvasGraphicsClosure() {
  var EXECUTION_TIME = 15;
  var EXECUTION_STEPS = 10;
  function CanvasGraphics(canvasCtx, commonObjs, objs, canvasFactory, imageLayer) {
    this.ctx = canvasCtx;
    this.current = new CanvasExtraState();
    this.stateStack = [];
    this.pendingClip = null;
    this.pendingEOFill = false;
    this.res = null;
    this.xobjs = null;
    this.commonObjs = commonObjs;
    this.objs = objs;
    this.canvasFactory = canvasFactory;
    this.imageLayer = imageLayer;
    this.groupStack = [];
    this.processingType3 = null;
    this.baseTransform = null;
    this.baseTransformStack = [];
    this.groupLevel = 0;
    this.smaskStack = [];
    this.smaskCounter = 0;
    this.tempSMask = null;
    this.cachedCanvases = new CachedCanvases(this.canvasFactory);
    if (canvasCtx) {
      addContextCurrentTransform(canvasCtx);
    }
    this.cachedGetSinglePixelWidth = null;
  }
  function putBinaryImageData(ctx, imgData) {
    if (typeof ImageData !== 'undefined' && imgData instanceof ImageData) {
      ctx.putImageData(imgData, 0, 0);
      return;
    }
    var height = imgData.height,
        width = imgData.width;
    var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
    var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
    var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
    var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
    var srcPos = 0,
        destPos;
    var src = imgData.data;
    var dest = chunkImgData.data;
    var i, j, thisChunkHeight, elemsInThisChunk;
    if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {
      var srcLength = src.byteLength;
      var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
      var dest32DataLength = dest32.length;
      var fullSrcDiff = width + 7 >> 3;
      var white = 0xFFFFFFFF;
      var black = IsLittleEndianCached.value ? 0xFF000000 : 0x000000FF;
      for (i = 0; i < totalChunks; i++) {
        thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
        destPos = 0;
        for (j = 0; j < thisChunkHeight; j++) {
          var srcDiff = srcLength - srcPos;
          var k = 0;
          var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
          var kEndUnrolled = kEnd & ~7;
          var mask = 0;
          var srcByte = 0;
          for (; k < kEndUnrolled; k += 8) {
            srcByte = src[srcPos++];
            dest32[destPos++] = srcByte & 128 ? white : black;
            dest32[destPos++] = srcByte & 64 ? white : black;
            dest32[destPos++] = srcByte & 32 ? white : black;
            dest32[destPos++] = srcByte & 16 ? white : black;
            dest32[destPos++] = srcByte & 8 ? white : black;
            dest32[destPos++] = srcByte & 4 ? white : black;
            dest32[destPos++] = srcByte & 2 ? white : black;
            dest32[destPos++] = srcByte & 1 ? white : black;
          }
          for (; k < kEnd; k++) {
            if (mask === 0) {
              srcByte = src[srcPos++];
              mask = 128;
            }
            dest32[destPos++] = srcByte & mask ? white : black;
            mask >>= 1;
          }
        }
        while (destPos < dest32DataLength) {
          dest32[destPos++] = 0;
        }
        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
      }
    } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {
      j = 0;
      elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
      for (i = 0; i < fullChunks; i++) {
        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
        srcPos += elemsInThisChunk;
        ctx.putImageData(chunkImgData, 0, j);
        j += FULL_CHUNK_HEIGHT;
      }
      if (i < totalChunks) {
        elemsInThisChunk = width * partialChunkHeight * 4;
        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
        ctx.putImageData(chunkImgData, 0, j);
      }
    } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {
      thisChunkHeight = FULL_CHUNK_HEIGHT;
      elemsInThisChunk = width * thisChunkHeight;
      for (i = 0; i < totalChunks; i++) {
        if (i >= fullChunks) {
          thisChunkHeight = partialChunkHeight;
          elemsInThisChunk = width * thisChunkHeight;
        }
        destPos = 0;
        for (j = elemsInThisChunk; j--;) {
          dest[destPos++] = src[srcPos++];
          dest[destPos++] = src[srcPos++];
          dest[destPos++] = src[srcPos++];
          dest[destPos++] = 255;
        }
        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
      }
    } else {
      (0, _util.error)('bad image kind: ' + imgData.kind);
    }
  }
  function putBinaryImageMask(ctx, imgData) {
    var height = imgData.height,
        width = imgData.width;
    var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
    var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
    var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
    var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
    var srcPos = 0;
    var src = imgData.data;
    var dest = chunkImgData.data;
    for (var i = 0; i < totalChunks; i++) {
      var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
      var destPos = 3;
      for (var j = 0; j < thisChunkHeight; j++) {
        var mask = 0;
        for (var k = 0; k < width; k++) {
          if (!mask) {
            var elem = src[srcPos++];
            mask = 128;
          }
          dest[destPos] = elem & mask ? 0 : 255;
          destPos += 4;
          mask >>= 1;
        }
      }
      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
  }
  function copyCtxState(sourceCtx, destCtx) {
    var properties = ['strokeStyle', 'fillStyle', 'fillRule', 'globalAlpha', 'lineWidth', 'lineCap', 'lineJoin', 'miterLimit', 'globalCompositeOperation', 'font'];
    for (var i = 0, ii = properties.length; i < ii; i++) {
      var property = properties[i];
      if (sourceCtx[property] !== undefined) {
        destCtx[property] = sourceCtx[property];
      }
    }
    if (sourceCtx.setLineDash !== undefined) {
      destCtx.setLineDash(sourceCtx.getLineDash());
      destCtx.lineDashOffset = sourceCtx.lineDashOffset;
    }
  }
  function composeSMaskBackdrop(bytes, r0, g0, b0) {
    var length = bytes.length;
    for (var i = 3; i < length; i += 4) {
      var alpha = bytes[i];
      if (alpha === 0) {
        bytes[i - 3] = r0;
        bytes[i - 2] = g0;
        bytes[i - 1] = b0;
      } else if (alpha < 255) {
        var alpha_ = 255 - alpha;
        bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
        bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
        bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
      }
    }
  }
  function composeSMaskAlpha(maskData, layerData, transferMap) {
    var length = maskData.length;
    var scale = 1 / 255;
    for (var i = 3; i < length; i += 4) {
      var alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
      layerData[i] = layerData[i] * alpha * scale | 0;
    }
  }
  function composeSMaskLuminosity(maskData, layerData, transferMap) {
    var length = maskData.length;
    for (var i = 3; i < length; i += 4) {
      var y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
      layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
    }
  }
  function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {
    var hasBackdrop = !!backdrop;
    var r0 = hasBackdrop ? backdrop[0] : 0;
    var g0 = hasBackdrop ? backdrop[1] : 0;
    var b0 = hasBackdrop ? backdrop[2] : 0;
    var composeFn;
    if (subtype === 'Luminosity') {
      composeFn = composeSMaskLuminosity;
    } else {
      composeFn = composeSMaskAlpha;
    }
    var PIXELS_TO_PROCESS = 1048576;
    var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
    for (var row = 0; row < height; row += chunkSize) {
      var chunkHeight = Math.min(chunkSize, height - row);
      var maskData = maskCtx.getImageData(0, row, width, chunkHeight);
      var layerData = layerCtx.getImageData(0, row, width, chunkHeight);
      if (hasBackdrop) {
        composeSMaskBackdrop(maskData.data, r0, g0, b0);
      }
      composeFn(maskData.data, layerData.data, transferMap);
      maskCtx.putImageData(layerData, 0, row);
    }
  }
  function composeSMask(ctx, smask, layerCtx) {
    var mask = smask.canvas;
    var maskCtx = smask.context;
    ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);
    var backdrop = smask.backdrop || null;
    if (!smask.transferMap && _webgl.WebGLUtils.isEnabled) {
      var composed = _webgl.WebGLUtils.composeSMask(layerCtx.canvas, mask, {
        subtype: smask.subtype,
        backdrop: backdrop
      });
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.drawImage(composed, smask.offsetX, smask.offsetY);
      return;
    }
    genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap);
    ctx.drawImage(mask, 0, 0);
  }
  var LINE_CAP_STYLES = ['butt', 'round', 'square'];
  var LINE_JOIN_STYLES = ['miter', 'round', 'bevel'];
  var NORMAL_CLIP = {};
  var EO_CLIP = {};
  CanvasGraphics.prototype = {
    beginDrawing: function CanvasGraphics_beginDrawing(transform, viewport, transparency) {
      var width = this.ctx.canvas.width;
      var height = this.ctx.canvas.height;
      this.ctx.save();
      this.ctx.fillStyle = 'rgb(255, 255, 255)';
      this.ctx.fillRect(0, 0, width, height);
      this.ctx.restore();
      if (transparency) {
        var transparentCanvas = this.cachedCanvases.getCanvas('transparent', width, height, true);
        this.compositeCtx = this.ctx;
        this.transparentCanvas = transparentCanvas.canvas;
        this.ctx = transparentCanvas.context;
        this.ctx.save();
        this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
      }
      this.ctx.save();
      if (transform) {
        this.ctx.transform.apply(this.ctx, transform);
      }
      this.ctx.transform.apply(this.ctx, viewport.transform);
      this.baseTransform = this.ctx.mozCurrentTransform.slice();
      if (this.imageLayer) {
        this.imageLayer.beginLayout();
      }
    },
    executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
      var argsArray = operatorList.argsArray;
      var fnArray = operatorList.fnArray;
      var i = executionStartIdx || 0;
      var argsArrayLen = argsArray.length;
      if (argsArrayLen === i) {
        return i;
      }
      var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === 'function';
      var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
      var steps = 0;
      var commonObjs = this.commonObjs;
      var objs = this.objs;
      var fnId;
      while (true) {
        if (stepper !== undefined && i === stepper.nextBreakPoint) {
          stepper.breakIt(i, continueCallback);
          return i;
        }
        fnId = fnArray[i];
        if (fnId !== _util.OPS.dependency) {
          this[fnId].apply(this, argsArray[i]);
        } else {
          var deps = argsArray[i];
          for (var n = 0, nn = deps.length; n < nn; n++) {
            var depObjId = deps[n];
            var common = depObjId[0] === 'g' && depObjId[1] === '_';
            var objsPool = common ? commonObjs : objs;
            if (!objsPool.isResolved(depObjId)) {
              objsPool.get(depObjId, continueCallback);
              return i;
            }
          }
        }
        i++;
        if (i === argsArrayLen) {
          return i;
        }
        if (chunkOperations && ++steps > EXECUTION_STEPS) {
          if (Date.now() > endTime) {
            continueCallback();
            return i;
          }
          steps = 0;
        }
      }
    },
    endDrawing: function CanvasGraphics_endDrawing() {
      if (this.current.activeSMask !== null) {
        this.endSMaskGroup();
      }
      this.ctx.restore();
      if (this.transparentCanvas) {
        this.ctx = this.compositeCtx;
        this.ctx.save();
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.drawImage(this.transparentCanvas, 0, 0);
        this.ctx.restore();
        this.transparentCanvas = null;
      }
      this.cachedCanvases.clear();
      _webgl.WebGLUtils.clear();
      if (this.imageLayer) {
        this.imageLayer.endLayout();
      }
    },
    setLineWidth: function CanvasGraphics_setLineWidth(width) {
      this.current.lineWidth = width;
      this.ctx.lineWidth = width;
    },
    setLineCap: function CanvasGraphics_setLineCap(style) {
      this.ctx.lineCap = LINE_CAP_STYLES[style];
    },
    setLineJoin: function CanvasGraphics_setLineJoin(style) {
      this.ctx.lineJoin = LINE_JOIN_STYLES[style];
    },
    setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {
      this.ctx.miterLimit = limit;
    },
    setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {
      var ctx = this.ctx;
      if (ctx.setLineDash !== undefined) {
        ctx.setLineDash(dashArray);
        ctx.lineDashOffset = dashPhase;
      }
    },
    setRenderingIntent: function CanvasGraphics_setRenderingIntent(intent) {},
    setFlatness: function CanvasGraphics_setFlatness(flatness) {},
    setGState: function CanvasGraphics_setGState(states) {
      for (var i = 0, ii = states.length; i < ii; i++) {
        var state = states[i];
        var key = state[0];
        var value = state[1];
        switch (key) {
          case 'LW':
            this.setLineWidth(value);
            break;
          case 'LC':
            this.setLineCap(value);
            break;
          case 'LJ':
            this.setLineJoin(value);
            break;
          case 'ML':
            this.setMiterLimit(value);
            break;
          case 'D':
            this.setDash(value[0], value[1]);
            break;
          case 'RI':
            this.setRenderingIntent(value);
            break;
          case 'FL':
            this.setFlatness(value);
            break;
          case 'Font':
            this.setFont(value[0], value[1]);
            break;
          case 'CA':
            this.current.strokeAlpha = state[1];
            break;
          case 'ca':
            this.current.fillAlpha = state[1];
            this.ctx.globalAlpha = state[1];
            break;
          case 'BM':
            this.ctx.globalCompositeOperation = value;
            break;
          case 'SMask':
            if (this.current.activeSMask) {
              if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {
                this.suspendSMaskGroup();
              } else {
                this.endSMaskGroup();
              }
            }
            this.current.activeSMask = value ? this.tempSMask : null;
            if (this.current.activeSMask) {
              this.beginSMaskGroup();
            }
            this.tempSMask = null;
            break;
        }
      }
    },
    beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {
      var activeSMask = this.current.activeSMask;
      var drawnWidth = activeSMask.canvas.width;
      var drawnHeight = activeSMask.canvas.height;
      var cacheId = 'smaskGroupAt' + this.groupLevel;
      var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
      var currentCtx = this.ctx;
      var currentTransform = currentCtx.mozCurrentTransform;
      this.ctx.save();
      var groupCtx = scratchCanvas.context;
      groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);
      groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);
      groupCtx.transform.apply(groupCtx, currentTransform);
      activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;
      copyCtxState(currentCtx, groupCtx);
      this.ctx = groupCtx;
      this.setGState([['BM', 'source-over'], ['ca', 1], ['CA', 1]]);
      this.groupStack.push(currentCtx);
      this.groupLevel++;
    },
    suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() {
      var groupCtx = this.ctx;
      this.groupLevel--;
      this.ctx = this.groupStack.pop();
      composeSMask(this.ctx, this.current.activeSMask, groupCtx);
      this.ctx.restore();
      this.ctx.save();
      copyCtxState(groupCtx, this.ctx);
      this.current.resumeSMaskCtx = groupCtx;
      var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);
      this.ctx.transform.apply(this.ctx, deltaTransform);
      groupCtx.save();
      groupCtx.setTransform(1, 0, 0, 1, 0, 0);
      groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);
      groupCtx.restore();
    },
    resumeSMaskGroup: function CanvasGraphics_endSMaskGroup() {
      var groupCtx = this.current.resumeSMaskCtx;
      var currentCtx = this.ctx;
      this.ctx = groupCtx;
      this.groupStack.push(currentCtx);
      this.groupLevel++;
    },
    endSMaskGroup: function CanvasGraphics_endSMaskGroup() {
      var groupCtx = this.ctx;
      this.groupLevel--;
      this.ctx = this.groupStack.pop();
      composeSMask(this.ctx, this.current.activeSMask, groupCtx);
      this.ctx.restore();
      copyCtxState(groupCtx, this.ctx);
      var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);
      this.ctx.transform.apply(this.ctx, deltaTransform);
    },
    save: function CanvasGraphics_save() {
      this.ctx.save();
      var old = this.current;
      this.stateStack.push(old);
      this.current = old.clone();
      this.current.resumeSMaskCtx = null;
    },
    restore: function CanvasGraphics_restore() {
      if (this.current.resumeSMaskCtx) {
        this.resumeSMaskGroup();
      }
      if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {
        this.endSMaskGroup();
      }
      if (this.stateStack.length !== 0) {
        this.current = this.stateStack.pop();
        this.ctx.restore();
        this.pendingClip = null;
        this.cachedGetSinglePixelWidth = null;
      }
    },
    transform: function CanvasGraphics_transform(a, b, c, d, e, f) {
      this.ctx.transform(a, b, c, d, e, f);
      this.cachedGetSinglePixelWidth = null;
    },
    constructPath: function CanvasGraphics_constructPath(ops, args) {
      var ctx = this.ctx;
      var current = this.current;
      var x = current.x,
          y = current.y;
      for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {
        switch (ops[i] | 0) {
          case _util.OPS.rectangle:
            x = args[j++];
            y = args[j++];
            var width = args[j++];
            var height = args[j++];
            if (width === 0) {
              width = this.getSinglePixelWidth();
            }
            if (height === 0) {
              height = this.getSinglePixelWidth();
            }
            var xw = x + width;
            var yh = y + height;
            this.ctx.moveTo(x, y);
            this.ctx.lineTo(xw, y);
            this.ctx.lineTo(xw, yh);
            this.ctx.lineTo(x, yh);
            this.ctx.lineTo(x, y);
            this.ctx.closePath();
            break;
          case _util.OPS.moveTo:
            x = args[j++];
            y = args[j++];
            ctx.moveTo(x, y);
            break;
          case _util.OPS.lineTo:
            x = args[j++];
            y = args[j++];
            ctx.lineTo(x, y);
            break;
          case _util.OPS.curveTo:
            x = args[j + 4];
            y = args[j + 5];
            ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
            j += 6;
            break;
          case _util.OPS.curveTo2:
            ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
            x = args[j + 2];
            y = args[j + 3];
            j += 4;
            break;
          case _util.OPS.curveTo3:
            x = args[j + 2];
            y = args[j + 3];
            ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
            j += 4;
            break;
          case _util.OPS.closePath:
            ctx.closePath();
            break;
        }
      }
      current.setCurrentPoint(x, y);
    },
    closePath: function CanvasGraphics_closePath() {
      this.ctx.closePath();
    },
    stroke: function CanvasGraphics_stroke(consumePath) {
      consumePath = typeof consumePath !== 'undefined' ? consumePath : true;
      var ctx = this.ctx;
      var strokeColor = this.current.strokeColor;
      ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth);
      ctx.globalAlpha = this.current.strokeAlpha;
      if (strokeColor && strokeColor.hasOwnProperty('type') && strokeColor.type === 'Pattern') {
        ctx.save();
        ctx.strokeStyle = strokeColor.getPattern(ctx, this);
        ctx.stroke();
        ctx.restore();
      } else {
        ctx.stroke();
      }
      if (consumePath) {
        this.consumePath();
      }
      ctx.globalAlpha = this.current.fillAlpha;
    },
    closeStroke: function CanvasGraphics_closeStroke() {
      this.closePath();
      this.stroke();
    },
    fill: function CanvasGraphics_fill(consumePath) {
      consumePath = typeof consumePath !== 'undefined' ? consumePath : true;
      var ctx = this.ctx;
      var fillColor = this.current.fillColor;
      var isPatternFill = this.current.patternFill;
      var needRestore = false;
      if (isPatternFill) {
        ctx.save();
        if (this.baseTransform) {
          ctx.setTransform.apply(ctx, this.baseTransform);
        }
        ctx.fillStyle = fillColor.getPattern(ctx, this);
        needRestore = true;
      }
      if (this.pendingEOFill) {
        ctx.fill('evenodd');
        this.pendingEOFill = false;
      } else {
        ctx.fill();
      }
      if (needRestore) {
        ctx.restore();
      }
      if (consumePath) {
        this.consumePath();
      }
    },
    eoFill: function CanvasGraphics_eoFill() {
      this.pendingEOFill = true;
      this.fill();
    },
    fillStroke: function CanvasGraphics_fillStroke() {
      this.fill(false);
      this.stroke(false);
      this.consumePath();
    },
    eoFillStroke: function CanvasGraphics_eoFillStroke() {
      this.pendingEOFill = true;
      this.fillStroke();
    },
    closeFillStroke: function CanvasGraphics_closeFillStroke() {
      this.closePath();
      this.fillStroke();
    },
    closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {
      this.pendingEOFill = true;
      this.closePath();
      this.fillStroke();
    },
    endPath: function CanvasGraphics_endPath() {
      this.consumePath();
    },
    clip: function CanvasGraphics_clip() {
      this.pendingClip = NORMAL_CLIP;
    },
    eoClip: function CanvasGraphics_eoClip() {
      this.pendingClip = EO_CLIP;
    },
    beginText: function CanvasGraphics_beginText() {
      this.current.textMatrix = _util.IDENTITY_MATRIX;
      this.current.textMatrixScale = 1;
      this.current.x = this.current.lineX = 0;
      this.current.y = this.current.lineY = 0;
    },
    endText: function CanvasGraphics_endText() {
      var paths = this.pendingTextPaths;
      var ctx = this.ctx;
      if (paths === undefined) {
        ctx.beginPath();
        return;
      }
      ctx.save();
      ctx.beginPath();
      for (var i = 0; i < paths.length; i++) {
        var path = paths[i];
        ctx.setTransform.apply(ctx, path.transform);
        ctx.translate(path.x, path.y);
        path.addToPath(ctx, path.fontSize);
      }
      ctx.restore();
      ctx.clip();
      ctx.beginPath();
      delete this.pendingTextPaths;
    },
    setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {
      this.current.charSpacing = spacing;
    },
    setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {
      this.current.wordSpacing = spacing;
    },
    setHScale: function CanvasGraphics_setHScale(scale) {
      this.current.textHScale = scale / 100;
    },
    setLeading: function CanvasGraphics_setLeading(leading) {
      this.current.leading = -leading;
    },
    setFont: function CanvasGraphics_setFont(fontRefName, size) {
      var fontObj = this.commonObjs.get(fontRefName);
      var current = this.current;
      if (!fontObj) {
        (0, _util.error)('Can\'t find font for ' + fontRefName);
      }
      current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util.FONT_IDENTITY_MATRIX;
      if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
        (0, _util.warn)('Invalid font matrix for font ' + fontRefName);
      }
      if (size < 0) {
        size = -size;
        current.fontDirection = -1;
      } else {
        current.fontDirection = 1;
      }
      this.current.font = fontObj;
      this.current.fontSize = size;
      if (fontObj.isType3Font) {
        return;
      }
      var name = fontObj.loadedName || 'sans-serif';
      var bold = fontObj.black ? '900' : fontObj.bold ? 'bold' : 'normal';
      var italic = fontObj.italic ? 'italic' : 'normal';
      var typeface = '"' + name + '", ' + fontObj.fallbackName;
      var browserFontSize = size < MIN_FONT_SIZE ? MIN_FONT_SIZE : size > MAX_FONT_SIZE ? MAX_FONT_SIZE : size;
      this.current.fontSizeScale = size / browserFontSize;
      var rule = italic + ' ' + bold + ' ' + browserFontSize + 'px ' + typeface;
      this.ctx.font = rule;
    },
    setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {
      this.current.textRenderingMode = mode;
    },
    setTextRise: function CanvasGraphics_setTextRise(rise) {
      this.current.textRise = rise;
    },
    moveText: function CanvasGraphics_moveText(x, y) {
      this.current.x = this.current.lineX += x;
      this.current.y = this.current.lineY += y;
    },
    setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {
      this.setLeading(-y);
      this.moveText(x, y);
    },
    setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {
      this.current.textMatrix = [a, b, c, d, e, f];
      this.current.textMatrixScale = Math.sqrt(a * a + b * b);
      this.current.x = this.current.lineX = 0;
      this.current.y = this.current.lineY = 0;
    },
    nextLine: function CanvasGraphics_nextLine() {
      this.moveText(0, this.current.leading);
    },
    paintChar: function CanvasGraphics_paintChar(character, x, y) {
      var ctx = this.ctx;
      var current = this.current;
      var font = current.font;
      var textRenderingMode = current.textRenderingMode;
      var fontSize = current.fontSize / current.fontSizeScale;
      var fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
      var isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
      var addToPath;
      if (font.disableFontFace || isAddToPathSet) {
        addToPath = font.getPathGenerator(this.commonObjs, character);
      }
      if (font.disableFontFace) {
        ctx.save();
        ctx.translate(x, y);
        ctx.beginPath();
        addToPath(ctx, fontSize);
        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
          ctx.fill();
        }
        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
          ctx.stroke();
        }
        ctx.restore();
      } else {
        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
          ctx.fillText(character, x, y);
        }
        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
          ctx.strokeText(character, x, y);
        }
      }
      if (isAddToPathSet) {
        var paths = this.pendingTextPaths || (this.pendingTextPaths = []);
        paths.push({
          transform: ctx.mozCurrentTransform,
          x: x,
          y: y,
          fontSize: fontSize,
          addToPath: addToPath
        });
      }
    },
    get isFontSubpixelAAEnabled() {
      var ctx = this.canvasFactory.create(10, 10).context;
      ctx.scale(1.5, 1);
      ctx.fillText('I', 0, 10);
      var data = ctx.getImageData(0, 0, 10, 10).data;
      var enabled = false;
      for (var i = 3; i < data.length; i += 4) {
        if (data[i] > 0 && data[i] < 255) {
          enabled = true;
          break;
        }
      }
      return (0, _util.shadow)(this, 'isFontSubpixelAAEnabled', enabled);
    },
    showText: function CanvasGraphics_showText(glyphs) {
      var current = this.current;
      var font = current.font;
      if (font.isType3Font) {
        return this.showType3Text(glyphs);
      }
      var fontSize = current.fontSize;
      if (fontSize === 0) {
        return;
      }
      var ctx = this.ctx;
      var fontSizeScale = current.fontSizeScale;
      var charSpacing = current.charSpacing;
      var wordSpacing = current.wordSpacing;
      var fontDirection = current.fontDirection;
      var textHScale = current.textHScale * fontDirection;
      var glyphsLength = glyphs.length;
      var vertical = font.vertical;
      var spacingDir = vertical ? 1 : -1;
      var defaultVMetrics = font.defaultVMetrics;
      var widthAdvanceScale = fontSize * current.fontMatrix[0];
      var simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace;
      ctx.save();
      ctx.transform.apply(ctx, current.textMatrix);
      ctx.translate(current.x, current.y + current.textRise);
      if (current.patternFill) {
        ctx.fillStyle = current.fillColor.getPattern(ctx, this);
      }
      if (fontDirection > 0) {
        ctx.scale(textHScale, -1);
      } else {
        ctx.scale(textHScale, 1);
      }
      var lineWidth = current.lineWidth;
      var scale = current.textMatrixScale;
      if (scale === 0 || lineWidth === 0) {
        var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
          this.cachedGetSinglePixelWidth = null;
          lineWidth = this.getSinglePixelWidth() * MIN_WIDTH_FACTOR;
        }
      } else {
        lineWidth /= scale;
      }
      if (fontSizeScale !== 1.0) {
        ctx.scale(fontSizeScale, fontSizeScale);
        lineWidth /= fontSizeScale;
      }
      ctx.lineWidth = lineWidth;
      var x = 0,
          i;
      for (i = 0; i < glyphsLength; ++i) {
        var glyph = glyphs[i];
        if ((0, _util.isNum)(glyph)) {
          x += spacingDir * glyph * fontSize / 1000;
          continue;
        }
        var restoreNeeded = false;
        var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
        var character = glyph.fontChar;
        var accent = glyph.accent;
        var scaledX, scaledY, scaledAccentX, scaledAccentY;
        var width = glyph.width;
        if (vertical) {
          var vmetric, vx, vy;
          vmetric = glyph.vmetric || defaultVMetrics;
          vx = glyph.vmetric ? vmetric[1] : width * 0.5;
          vx = -vx * widthAdvanceScale;
          vy = vmetric[2] * widthAdvanceScale;
          width = vmetric ? -vmetric[0] : width;
          scaledX = vx / fontSizeScale;
          scaledY = (x + vy) / fontSizeScale;
        } else {
          scaledX = x / fontSizeScale;
          scaledY = 0;
        }
        if (font.remeasure && width > 0) {
          var measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;
          if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
            var characterScaleX = width / measuredWidth;
            restoreNeeded = true;
            ctx.save();
            ctx.scale(characterScaleX, 1);
            scaledX /= characterScaleX;
          } else if (width !== measuredWidth) {
            scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;
          }
        }
        if (glyph.isInFont || font.missingFile) {
          if (simpleFillText && !accent) {
            ctx.fillText(character, scaledX, scaledY);
          } else {
            this.paintChar(character, scaledX, scaledY);
            if (accent) {
              scaledAccentX = scaledX + accent.offset.x / fontSizeScale;
              scaledAccentY = scaledY - accent.offset.y / fontSizeScale;
              this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY);
            }
          }
        }
        var charWidth = width * widthAdvanceScale + spacing * fontDirection;
        x += charWidth;
        if (restoreNeeded) {
          ctx.restore();
        }
      }
      if (vertical) {
        current.y -= x * textHScale;
      } else {
        current.x += x * textHScale;
      }
      ctx.restore();
    },
    showType3Text: function CanvasGraphics_showType3Text(glyphs) {
      var ctx = this.ctx;
      var current = this.current;
      var font = current.font;
      var fontSize = current.fontSize;
      var fontDirection = current.fontDirection;
      var spacingDir = font.vertical ? 1 : -1;
      var charSpacing = current.charSpacing;
      var wordSpacing = current.wordSpacing;
      var textHScale = current.textHScale * fontDirection;
      var fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;
      var glyphsLength = glyphs.length;
      var isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;
      var i, glyph, width, spacingLength;
      if (isTextInvisible || fontSize === 0) {
        return;
      }
      this.cachedGetSinglePixelWidth = null;
      ctx.save();
      ctx.transform.apply(ctx, current.textMatrix);
      ctx.translate(current.x, current.y);
      ctx.scale(textHScale, fontDirection);
      for (i = 0; i < glyphsLength; ++i) {
        glyph = glyphs[i];
        if ((0, _util.isNum)(glyph)) {
          spacingLength = spacingDir * glyph * fontSize / 1000;
          this.ctx.translate(spacingLength, 0);
          current.x += spacingLength * textHScale;
          continue;
        }
        var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
        var operatorList = font.charProcOperatorList[glyph.operatorListId];
        if (!operatorList) {
          (0, _util.warn)('Type3 character \"' + glyph.operatorListId + '\" is not available');
          continue;
        }
        this.processingType3 = glyph;
        this.save();
        ctx.scale(fontSize, fontSize);
        ctx.transform.apply(ctx, fontMatrix);
        this.executeOperatorList(operatorList);
        this.restore();
        var transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);
        width = transformed[0] * fontSize + spacing;
        ctx.translate(width, 0);
        current.x += width * textHScale;
      }
      ctx.restore();
      this.processingType3 = null;
    },
    setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {},
    setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
      this.ctx.rect(llx, lly, urx - llx, ury - lly);
      this.clip();
      this.endPath();
    },
    getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {
      var pattern;
      if (IR[0] === 'TilingPattern') {
        var color = IR[1];
        var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
        var self = this;
        var canvasGraphicsFactory = {
          createCanvasGraphics: function createCanvasGraphics(ctx) {
            return new CanvasGraphics(ctx, self.commonObjs, self.objs, self.canvasFactory);
          }
        };
        pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
      } else {
        pattern = (0, _pattern_helper.getShadingPatternFromIR)(IR);
      }
      return pattern;
    },
    setStrokeColorN: function CanvasGraphics_setStrokeColorN() {
      this.current.strokeColor = this.getColorN_Pattern(arguments);
    },
    setFillColorN: function CanvasGraphics_setFillColorN() {
      this.current.fillColor = this.getColorN_Pattern(arguments);
      this.current.patternFill = true;
    },
    setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {
      var color = _util.Util.makeCssRgb(r, g, b);
      this.ctx.strokeStyle = color;
      this.current.strokeColor = color;
    },
    setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {
      var color = _util.Util.makeCssRgb(r, g, b);
      this.ctx.fillStyle = color;
      this.current.fillColor = color;
      this.current.patternFill = false;
    },
    shadingFill: function CanvasGraphics_shadingFill(patternIR) {
      var ctx = this.ctx;
      this.save();
      var pattern = (0, _pattern_helper.getShadingPatternFromIR)(patternIR);
      ctx.fillStyle = pattern.getPattern(ctx, this, true);
      var inv = ctx.mozCurrentTransformInverse;
      if (inv) {
        var canvas = ctx.canvas;
        var width = canvas.width;
        var height = canvas.height;
        var bl = _util.Util.applyTransform([0, 0], inv);
        var br = _util.Util.applyTransform([0, height], inv);
        var ul = _util.Util.applyTransform([width, 0], inv);
        var ur = _util.Util.applyTransform([width, height], inv);
        var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
        var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
        var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
        var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
        this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
      } else {
        this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
      }
      this.restore();
    },
    beginInlineImage: function CanvasGraphics_beginInlineImage() {
      (0, _util.error)('Should not call beginInlineImage');
    },
    beginImageData: function CanvasGraphics_beginImageData() {
      (0, _util.error)('Should not call beginImageData');
    },
    paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) {
      this.save();
      this.baseTransformStack.push(this.baseTransform);
      if ((0, _util.isArray)(matrix) && matrix.length === 6) {
        this.transform.apply(this, matrix);
      }
      this.baseTransform = this.ctx.mozCurrentTransform;
      if ((0, _util.isArray)(bbox) && bbox.length === 4) {
        var width = bbox[2] - bbox[0];
        var height = bbox[3] - bbox[1];
        this.ctx.rect(bbox[0], bbox[1], width, height);
        this.clip();
        this.endPath();
      }
    },
    paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {
      this.restore();
      this.baseTransform = this.baseTransformStack.pop();
    },
    beginGroup: function CanvasGraphics_beginGroup(group) {
      this.save();
      var currentCtx = this.ctx;
      if (!group.isolated) {
        (0, _util.info)('TODO: Support non-isolated groups.');
      }
      if (group.knockout) {
        (0, _util.warn)('Knockout groups not supported.');
      }
      var currentTransform = currentCtx.mozCurrentTransform;
      if (group.matrix) {
        currentCtx.transform.apply(currentCtx, group.matrix);
      }
      (0, _util.assert)(group.bbox, 'Bounding box is required.');
      var bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);
      var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
      bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
      var offsetX = Math.floor(bounds[0]);
      var offsetY = Math.floor(bounds[1]);
      var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
      var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
      var scaleX = 1,
          scaleY = 1;
      if (drawnWidth > MAX_GROUP_SIZE) {
        scaleX = drawnWidth / MAX_GROUP_SIZE;
        drawnWidth = MAX_GROUP_SIZE;
      }
      if (drawnHeight > MAX_GROUP_SIZE) {
        scaleY = drawnHeight / MAX_GROUP_SIZE;
        drawnHeight = MAX_GROUP_SIZE;
      }
      var cacheId = 'groupAt' + this.groupLevel;
      if (group.smask) {
        cacheId += '_smask_' + this.smaskCounter++ % 2;
      }
      var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
      var groupCtx = scratchCanvas.context;
      groupCtx.scale(1 / scaleX, 1 / scaleY);
      groupCtx.translate(-offsetX, -offsetY);
      groupCtx.transform.apply(groupCtx, currentTransform);
      if (group.smask) {
        this.smaskStack.push({
          canvas: scratchCanvas.canvas,
          context: groupCtx,
          offsetX: offsetX,
          offsetY: offsetY,
          scaleX: scaleX,
          scaleY: scaleY,
          subtype: group.smask.subtype,
          backdrop: group.smask.backdrop,
          transferMap: group.smask.transferMap || null,
          startTransformInverse: null
        });
      } else {
        currentCtx.setTransform(1, 0, 0, 1, 0, 0);
        currentCtx.translate(offsetX, offsetY);
        currentCtx.scale(scaleX, scaleY);
      }
      copyCtxState(currentCtx, groupCtx);
      this.ctx = groupCtx;
      this.setGState([['BM', 'source-over'], ['ca', 1], ['CA', 1]]);
      this.groupStack.push(currentCtx);
      this.groupLevel++;
      this.current.activeSMask = null;
    },
    endGroup: function CanvasGraphics_endGroup(group) {
      this.groupLevel--;
      var groupCtx = this.ctx;
      this.ctx = this.groupStack.pop();
      if (this.ctx.imageSmoothingEnabled !== undefined) {
        this.ctx.imageSmoothingEnabled = false;
      } else {
        this.ctx.mozImageSmoothingEnabled = false;
      }
      if (group.smask) {
        this.tempSMask = this.smaskStack.pop();
      } else {
        this.ctx.drawImage(groupCtx.canvas, 0, 0);
      }
      this.restore();
    },
    beginAnnotations: function CanvasGraphics_beginAnnotations() {
      this.save();
      this.current = new CanvasExtraState();
      if (this.baseTransform) {
        this.ctx.setTransform.apply(this.ctx, this.baseTransform);
      }
    },
    endAnnotations: function CanvasGraphics_endAnnotations() {
      this.restore();
    },
    beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) {
      this.save();
      if ((0, _util.isArray)(rect) && rect.length === 4) {
        var width = rect[2] - rect[0];
        var height = rect[3] - rect[1];
        this.ctx.rect(rect[0], rect[1], width, height);
        this.clip();
        this.endPath();
      }
      this.transform.apply(this, transform);
      this.transform.apply(this, matrix);
    },
    endAnnotation: function CanvasGraphics_endAnnotation() {
      this.restore();
    },
    paintJpegXObject: function CanvasGraphics_paintJpegXObject(objId, w, h) {
      var domImage = this.objs.get(objId);
      if (!domImage) {
        (0, _util.warn)('Dependent image isn\'t ready yet');
        return;
      }
      this.save();
      var ctx = this.ctx;
      ctx.scale(1 / w, -1 / h);
      ctx.drawImage(domImage, 0, 0, domImage.width, domImage.height, 0, -h, w, h);
      if (this.imageLayer) {
        var currentTransform = ctx.mozCurrentTransformInverse;
        var position = this.getCanvasPosition(0, 0);
        this.imageLayer.appendImage({
          objId: objId,
          left: position[0],
          top: position[1],
          width: w / currentTransform[0],
          height: h / currentTransform[3]
        });
      }
      this.restore();
    },
    paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {
      var ctx = this.ctx;
      var width = img.width,
          height = img.height;
      var fillColor = this.current.fillColor;
      var isPatternFill = this.current.patternFill;
      var glyph = this.processingType3;
      if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {
        if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {
          glyph.compiled = compileType3Glyph({
            data: img.data,
            width: width,
            height: height
          });
        } else {
          glyph.compiled = null;
        }
      }
      if (glyph && glyph.compiled) {
        glyph.compiled(ctx);
        return;
      }
      var maskCanvas = this.cachedCanvases.getCanvas('maskCanvas', width, height);
      var maskCtx = maskCanvas.context;
      maskCtx.save();
      putBinaryImageMask(maskCtx, img);
      maskCtx.globalCompositeOperation = 'source-in';
      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
      maskCtx.fillRect(0, 0, width, height);
      maskCtx.restore();
      this.paintInlineImageXObject(maskCanvas.canvas);
    },
    paintImageMaskXObjectRepeat: function CanvasGraphics_paintImageMaskXObjectRepeat(imgData, scaleX, scaleY, positions) {
      var width = imgData.width;
      var height = imgData.height;
      var fillColor = this.current.fillColor;
      var isPatternFill = this.current.patternFill;
      var maskCanvas = this.cachedCanvases.getCanvas('maskCanvas', width, height);
      var maskCtx = maskCanvas.context;
      maskCtx.save();
      putBinaryImageMask(maskCtx, imgData);
      maskCtx.globalCompositeOperation = 'source-in';
      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
      maskCtx.fillRect(0, 0, width, height);
      maskCtx.restore();
      var ctx = this.ctx;
      for (var i = 0, ii = positions.length; i < ii; i += 2) {
        ctx.save();
        ctx.transform(scaleX, 0, 0, scaleY, positions[i], positions[i + 1]);
        ctx.scale(1, -1);
        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
        ctx.restore();
      }
    },
    paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) {
      var ctx = this.ctx;
      var fillColor = this.current.fillColor;
      var isPatternFill = this.current.patternFill;
      for (var i = 0, ii = images.length; i < ii; i++) {
        var image = images[i];
        var width = image.width,
            height = image.height;
        var maskCanvas = this.cachedCanvases.getCanvas('maskCanvas', width, height);
        var maskCtx = maskCanvas.context;
        maskCtx.save();
        putBinaryImageMask(maskCtx, image);
        maskCtx.globalCompositeOperation = 'source-in';
        maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
        maskCtx.fillRect(0, 0, width, height);
        maskCtx.restore();
        ctx.save();
        ctx.transform.apply(ctx, image.transform);
        ctx.scale(1, -1);
        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
        ctx.restore();
      }
    },
    paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {
      var imgData = this.objs.get(objId);
      if (!imgData) {
        (0, _util.warn)('Dependent image isn\'t ready yet');
        return;
      }
      this.paintInlineImageXObject(imgData);
    },
    paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
      var imgData = this.objs.get(objId);
      if (!imgData) {
        (0, _util.warn)('Dependent image isn\'t ready yet');
        return;
      }
      var width = imgData.width;
      var height = imgData.height;
      var map = [];
      for (var i = 0, ii = positions.length; i < ii; i += 2) {
        map.push({
          transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
          x: 0,
          y: 0,
          w: width,
          h: height
        });
      }
      this.paintInlineImageXObjectGroup(imgData, map);
    },
    paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) {
      var width = imgData.width;
      var height = imgData.height;
      var ctx = this.ctx;
      this.save();
      ctx.scale(1 / width, -1 / height);
      var currentTransform = ctx.mozCurrentTransformInverse;
      var a = currentTransform[0],
          b = currentTransform[1];
      var widthScale = Math.max(Math.sqrt(a * a + b * b), 1);
      var c = currentTransform[2],
          d = currentTransform[3];
      var heightScale = Math.max(Math.sqrt(c * c + d * d), 1);
      var imgToPaint, tmpCanvas;
      if (imgData instanceof HTMLElement || !imgData.data) {
        imgToPaint = imgData;
      } else {
        tmpCanvas = this.cachedCanvases.getCanvas('inlineImage', width, height);
        var tmpCtx = tmpCanvas.context;
        putBinaryImageData(tmpCtx, imgData);
        imgToPaint = tmpCanvas.canvas;
      }
      var paintWidth = width,
          paintHeight = height;
      var tmpCanvasId = 'prescale1';
      while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
        var newWidth = paintWidth,
            newHeight = paintHeight;
        if (widthScale > 2 && paintWidth > 1) {
          newWidth = Math.ceil(paintWidth / 2);
          widthScale /= paintWidth / newWidth;
        }
        if (heightScale > 2 && paintHeight > 1) {
          newHeight = Math.ceil(paintHeight / 2);
          heightScale /= paintHeight / newHeight;
        }
        tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
        tmpCtx = tmpCanvas.context;
        tmpCtx.clearRect(0, 0, newWidth, newHeight);
        tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
        imgToPaint = tmpCanvas.canvas;
        paintWidth = newWidth;
        paintHeight = newHeight;
        tmpCanvasId = tmpCanvasId === 'prescale1' ? 'prescale2' : 'prescale1';
      }
      ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);
      if (this.imageLayer) {
        var position = this.getCanvasPosition(0, -height);
        this.imageLayer.appendImage({
          imgData: imgData,
          left: position[0],
          top: position[1],
          width: width / currentTransform[0],
          height: height / currentTransform[3]
        });
      }
      this.restore();
    },
    paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {
      var ctx = this.ctx;
      var w = imgData.width;
      var h = imgData.height;
      var tmpCanvas = this.cachedCanvases.getCanvas('inlineImage', w, h);
      var tmpCtx = tmpCanvas.context;
      putBinaryImageData(tmpCtx, imgData);
      for (var i = 0, ii = map.length; i < ii; i++) {
        var entry = map[i];
        ctx.save();
        ctx.transform.apply(ctx, entry.transform);
        ctx.scale(1, -1);
        ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
        if (this.imageLayer) {
          var position = this.getCanvasPosition(entry.x, entry.y);
          this.imageLayer.appendImage({
            imgData: imgData,
            left: position[0],
            top: position[1],
            width: w,
            height: h
          });
        }
        ctx.restore();
      }
    },
    paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() {
      this.ctx.fillRect(0, 0, 1, 1);
    },
    paintXObject: function CanvasGraphics_paintXObject() {
      (0, _util.warn)('Unsupported \'paintXObject\' command.');
    },
    markPoint: function CanvasGraphics_markPoint(tag) {},
    markPointProps: function CanvasGraphics_markPointProps(tag, properties) {},
    beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {},
    beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {},
    endMarkedContent: function CanvasGraphics_endMarkedContent() {},
    beginCompat: function CanvasGraphics_beginCompat() {},
    endCompat: function CanvasGraphics_endCompat() {},
    consumePath: function CanvasGraphics_consumePath() {
      var ctx = this.ctx;
      if (this.pendingClip) {
        if (this.pendingClip === EO_CLIP) {
          ctx.clip('evenodd');
        } else {
          ctx.clip();
        }
        this.pendingClip = null;
      }
      ctx.beginPath();
    },
    getSinglePixelWidth: function CanvasGraphics_getSinglePixelWidth(scale) {
      if (this.cachedGetSinglePixelWidth === null) {
        this.ctx.save();
        var inverse = this.ctx.mozCurrentTransformInverse;
        this.ctx.restore();
        this.cachedGetSinglePixelWidth = Math.sqrt(Math.max(inverse[0] * inverse[0] + inverse[1] * inverse[1], inverse[2] * inverse[2] + inverse[3] * inverse[3]));
      }
      return this.cachedGetSinglePixelWidth;
    },
    getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {
      var transform = this.ctx.mozCurrentTransform;
      return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];
    }
  };
  for (var op in _util.OPS) {
    CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];
  }
  return CanvasGraphics;
}();
exports.CanvasGraphics = CanvasGraphics;

/***/ }),
/* 11 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FontLoader = exports.FontFaceObject = undefined;

var _util = __w_pdfjs_require__(0);

function FontLoader(docId) {
  this.docId = docId;
  this.styleElement = null;
  this.nativeFontFaces = [];
  this.loadTestFontId = 0;
  this.loadingContext = {
    requests: [],
    nextRequestId: 0
  };
}
FontLoader.prototype = {
  insertRule: function fontLoaderInsertRule(rule) {
    var styleElement = this.styleElement;
    if (!styleElement) {
      styleElement = this.styleElement = document.createElement('style');
      styleElement.id = 'PDFJS_FONT_STYLE_TAG_' + this.docId;
      document.documentElement.getElementsByTagName('head')[0].appendChild(styleElement);
    }
    var styleSheet = styleElement.sheet;
    styleSheet.insertRule(rule, styleSheet.cssRules.length);
  },
  clear: function fontLoaderClear() {
    if (this.styleElement) {
      this.styleElement.remove();
      this.styleElement = null;
    }
    this.nativeFontFaces.forEach(function (nativeFontFace) {
      document.fonts.delete(nativeFontFace);
    });
    this.nativeFontFaces.length = 0;
  }
};
{
  var getLoadTestFont = function getLoadTestFont() {
    return atob('T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQ' + 'AABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwA' + 'AAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbm' + 'FtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAA' + 'AADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6A' + 'ABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAA' + 'MQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAA' + 'AAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAA' + 'AAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQ' + 'AAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMA' + 'AQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAA' + 'EAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAA' + 'AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAA' + 'AAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgc' + 'A/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWF' + 'hYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQA' + 'AAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAg' + 'ABAAAAAAAAAAAD6AAAAAAAAA==');
  };
  Object.defineProperty(FontLoader.prototype, 'loadTestFont', {
    get: function get() {
      return (0, _util.shadow)(this, 'loadTestFont', getLoadTestFont());
    },
    configurable: true
  });
  FontLoader.prototype.addNativeFontFace = function fontLoader_addNativeFontFace(nativeFontFace) {
    this.nativeFontFaces.push(nativeFontFace);
    document.fonts.add(nativeFontFace);
  };
  FontLoader.prototype.bind = function fontLoaderBind(fonts, callback) {
    var rules = [];
    var fontsToLoad = [];
    var fontLoadPromises = [];
    var getNativeFontPromise = function getNativeFontPromise(nativeFontFace) {
      return nativeFontFace.loaded.catch(function (e) {
        (0, _util.warn)('Failed to load font "' + nativeFontFace.family + '": ' + e);
      });
    };
    var isFontLoadingAPISupported = FontLoader.isFontLoadingAPISupported && !FontLoader.isSyncFontLoadingSupported;
    for (var i = 0, ii = fonts.length; i < ii; i++) {
      var font = fonts[i];
      if (font.attached || font.loading === false) {
        continue;
      }
      font.attached = true;
      if (isFontLoadingAPISupported) {
        var nativeFontFace = font.createNativeFontFace();
        if (nativeFontFace) {
          this.addNativeFontFace(nativeFontFace);
          fontLoadPromises.push(getNativeFontPromise(nativeFontFace));
        }
      } else {
        var rule = font.createFontFaceRule();
        if (rule) {
          this.insertRule(rule);
          rules.push(rule);
          fontsToLoad.push(font);
        }
      }
    }
    var request = this.queueLoadingCallback(callback);
    if (isFontLoadingAPISupported) {
      Promise.all(fontLoadPromises).then(function () {
        request.complete();
      });
    } else if (rules.length > 0 && !FontLoader.isSyncFontLoadingSupported) {
      this.prepareFontLoadEvent(rules, fontsToLoad, request);
    } else {
      request.complete();
    }
  };
  FontLoader.prototype.queueLoadingCallback = function FontLoader_queueLoadingCallback(callback) {
    function LoadLoader_completeRequest() {
      (0, _util.assert)(!request.end, 'completeRequest() cannot be called twice');
      request.end = Date.now();
      while (context.requests.length > 0 && context.requests[0].end) {
        var otherRequest = context.requests.shift();
        setTimeout(otherRequest.callback, 0);
      }
    }
    var context = this.loadingContext;
    var requestId = 'pdfjs-font-loading-' + context.nextRequestId++;
    var request = {
      id: requestId,
      complete: LoadLoader_completeRequest,
      callback: callback,
      started: Date.now()
    };
    context.requests.push(request);
    return request;
  };
  FontLoader.prototype.prepareFontLoadEvent = function fontLoaderPrepareFontLoadEvent(rules, fonts, request) {
    function int32(data, offset) {
      return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;
    }
    function spliceString(s, offset, remove, insert) {
      var chunk1 = s.substr(0, offset);
      var chunk2 = s.substr(offset + remove);
      return chunk1 + insert + chunk2;
    }
    var i, ii;
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    var ctx = canvas.getContext('2d');
    var called = 0;
    function isFontReady(name, callback) {
      called++;
      if (called > 30) {
        (0, _util.warn)('Load test font never loaded.');
        callback();
        return;
      }
      ctx.font = '30px ' + name;
      ctx.fillText('.', 0, 20);
      var imageData = ctx.getImageData(0, 0, 1, 1);
      if (imageData.data[3] > 0) {
        callback();
        return;
      }
      setTimeout(isFontReady.bind(null, name, callback));
    }
    var loadTestFontId = 'lt' + Date.now() + this.loadTestFontId++;
    var data = this.loadTestFont;
    var COMMENT_OFFSET = 976;
    data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
    var CFF_CHECKSUM_OFFSET = 16;
    var XXXX_VALUE = 0x58585858;
    var checksum = int32(data, CFF_CHECKSUM_OFFSET);
    for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
      checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
    }
    if (i < loadTestFontId.length) {
      checksum = checksum - XXXX_VALUE + int32(loadTestFontId + 'XXX', i) | 0;
    }
    data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));
    var url = 'url(data:font/opentype;base64,' + btoa(data) + ');';
    var rule = '@font-face { font-family:"' + loadTestFontId + '";src:' + url + '}';
    this.insertRule(rule);
    var names = [];
    for (i = 0, ii = fonts.length; i < ii; i++) {
      names.push(fonts[i].loadedName);
    }
    names.push(loadTestFontId);
    var div = document.createElement('div');
    div.setAttribute('style', 'visibility: hidden;' + 'width: 10px; height: 10px;' + 'position: absolute; top: 0px; left: 0px;');
    for (i = 0, ii = names.length; i < ii; ++i) {
      var span = document.createElement('span');
      span.textContent = 'Hi';
      span.style.fontFamily = names[i];
      div.appendChild(span);
    }
    document.body.appendChild(div);
    isFontReady(loadTestFontId, function () {
      document.body.removeChild(div);
      request.complete();
    });
  };
}
{
  FontLoader.isFontLoadingAPISupported = typeof document !== 'undefined' && !!document.fonts;
}
{
  var isSyncFontLoadingSupported = function isSyncFontLoadingSupported() {
    if (typeof navigator === 'undefined') {
      return true;
    }
    var supported = false;
    var m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
    if (m && m[1] >= 14) {
      supported = true;
    }
    return supported;
  };
  Object.defineProperty(FontLoader, 'isSyncFontLoadingSupported', {
    get: function get() {
      return (0, _util.shadow)(FontLoader, 'isSyncFontLoadingSupported', isSyncFontLoadingSupported());
    },
    enumerable: true,
    configurable: true
  });
}
var IsEvalSupportedCached = {
  get value() {
    return (0, _util.shadow)(this, 'value', (0, _util.isEvalSupported)());
  }
};
var FontFaceObject = function FontFaceObjectClosure() {
  function FontFaceObject(translatedData, options) {
    this.compiledGlyphs = Object.create(null);
    for (var i in translatedData) {
      this[i] = translatedData[i];
    }
    this.options = options;
  }
  FontFaceObject.prototype = {
    createNativeFontFace: function FontFaceObject_createNativeFontFace() {
      if (!this.data) {
        return null;
      }
      if (this.options.disableFontFace) {
        this.disableFontFace = true;
        return null;
      }
      var nativeFontFace = new FontFace(this.loadedName, this.data, {});
      if (this.options.fontRegistry) {
        this.options.fontRegistry.registerFont(this);
      }
      return nativeFontFace;
    },
    createFontFaceRule: function FontFaceObject_createFontFaceRule() {
      if (!this.data) {
        return null;
      }
      if (this.options.disableFontFace) {
        this.disableFontFace = true;
        return null;
      }
      var data = (0, _util.bytesToString)(new Uint8Array(this.data));
      var fontName = this.loadedName;
      var url = 'url(data:' + this.mimetype + ';base64,' + btoa(data) + ');';
      var rule = '@font-face { font-family:"' + fontName + '";src:' + url + '}';
      if (this.options.fontRegistry) {
        this.options.fontRegistry.registerFont(this, url);
      }
      return rule;
    },
    getPathGenerator: function FontFaceObject_getPathGenerator(objs, character) {
      if (!(character in this.compiledGlyphs)) {
        var cmds = objs.get(this.loadedName + '_path_' + character);
        var current, i, len;
        if (this.options.isEvalSupported && IsEvalSupportedCached.value) {
          var args,
              js = '';
          for (i = 0, len = cmds.length; i < len; i++) {
            current = cmds[i];
            if (current.args !== undefined) {
              args = current.args.join(',');
            } else {
              args = '';
            }
            js += 'c.' + current.cmd + '(' + args + ');\n';
          }
          this.compiledGlyphs[character] = new Function('c', 'size', js);
        } else {
          this.compiledGlyphs[character] = function (c, size) {
            for (i = 0, len = cmds.length; i < len; i++) {
              current = cmds[i];
              if (current.cmd === 'scale') {
                current.args = [size, -size];
              }
              c[current.cmd].apply(c, current.args);
            }
          };
        }
      }
      return this.compiledGlyphs[character];
    }
  };
  return FontFaceObject;
}();
exports.FontFaceObject = FontFaceObject;
exports.FontLoader = FontLoader;

/***/ }),
/* 12 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TilingPattern = exports.getShadingPatternFromIR = undefined;

var _util = __w_pdfjs_require__(0);

var _webgl = __w_pdfjs_require__(8);

var ShadingIRs = {};
ShadingIRs.RadialAxial = {
  fromIR: function RadialAxial_fromIR(raw) {
    var type = raw[1];
    var colorStops = raw[2];
    var p0 = raw[3];
    var p1 = raw[4];
    var r0 = raw[5];
    var r1 = raw[6];
    return {
      type: 'Pattern',
      getPattern: function RadialAxial_getPattern(ctx) {
        var grad;
        if (type === 'axial') {
          grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);
        } else if (type === 'radial') {
          grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);
        }
        for (var i = 0, ii = colorStops.length; i < ii; ++i) {
          var c = colorStops[i];
          grad.addColorStop(c[0], c[1]);
        }
        return grad;
      }
    };
  }
};
var createMeshCanvas = function createMeshCanvasClosure() {
  function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
    var coords = context.coords,
        colors = context.colors;
    var bytes = data.data,
        rowSize = data.width * 4;
    var tmp;
    if (coords[p1 + 1] > coords[p2 + 1]) {
      tmp = p1;
      p1 = p2;
      p2 = tmp;
      tmp = c1;
      c1 = c2;
      c2 = tmp;
    }
    if (coords[p2 + 1] > coords[p3 + 1]) {
      tmp = p2;
      p2 = p3;
      p3 = tmp;
      tmp = c2;
      c2 = c3;
      c3 = tmp;
    }
    if (coords[p1 + 1] > coords[p2 + 1]) {
      tmp = p1;
      p1 = p2;
      p2 = tmp;
      tmp = c1;
      c1 = c2;
      c2 = tmp;
    }
    var x1 = (coords[p1] + context.offsetX) * context.scaleX;
    var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
    var x2 = (coords[p2] + context.offsetX) * context.scaleX;
    var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
    var x3 = (coords[p3] + context.offsetX) * context.scaleX;
    var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
    if (y1 >= y3) {
      return;
    }
    var c1r = colors[c1],
        c1g = colors[c1 + 1],
        c1b = colors[c1 + 2];
    var c2r = colors[c2],
        c2g = colors[c2 + 1],
        c2b = colors[c2 + 2];
    var c3r = colors[c3],
        c3g = colors[c3 + 1],
        c3b = colors[c3 + 2];
    var minY = Math.round(y1),
        maxY = Math.round(y3);
    var xa, car, cag, cab;
    var xb, cbr, cbg, cbb;
    var k;
    for (var y = minY; y <= maxY; y++) {
      if (y < y2) {
        k = y < y1 ? 0 : y1 === y2 ? 1 : (y1 - y) / (y1 - y2);
        xa = x1 - (x1 - x2) * k;
        car = c1r - (c1r - c2r) * k;
        cag = c1g - (c1g - c2g) * k;
        cab = c1b - (c1b - c2b) * k;
      } else {
        k = y > y3 ? 1 : y2 === y3 ? 0 : (y2 - y) / (y2 - y3);
        xa = x2 - (x2 - x3) * k;
        car = c2r - (c2r - c3r) * k;
        cag = c2g - (c2g - c3g) * k;
        cab = c2b - (c2b - c3b) * k;
      }
      k = y < y1 ? 0 : y > y3 ? 1 : (y1 - y) / (y1 - y3);
      xb = x1 - (x1 - x3) * k;
      cbr = c1r - (c1r - c3r) * k;
      cbg = c1g - (c1g - c3g) * k;
      cbb = c1b - (c1b - c3b) * k;
      var x1_ = Math.round(Math.min(xa, xb));
      var x2_ = Math.round(Math.max(xa, xb));
      var j = rowSize * y + x1_ * 4;
      for (var x = x1_; x <= x2_; x++) {
        k = (xa - x) / (xa - xb);
        k = k < 0 ? 0 : k > 1 ? 1 : k;
        bytes[j++] = car - (car - cbr) * k | 0;
        bytes[j++] = cag - (cag - cbg) * k | 0;
        bytes[j++] = cab - (cab - cbb) * k | 0;
        bytes[j++] = 255;
      }
    }
  }
  function drawFigure(data, figure, context) {
    var ps = figure.coords;
    var cs = figure.colors;
    var i, ii;
    switch (figure.type) {
      case 'lattice':
        var verticesPerRow = figure.verticesPerRow;
        var rows = Math.floor(ps.length / verticesPerRow) - 1;
        var cols = verticesPerRow - 1;
        for (i = 0; i < rows; i++) {
          var q = i * verticesPerRow;
          for (var j = 0; j < cols; j++, q++) {
            drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
            drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
          }
        }
        break;
      case 'triangles':
        for (i = 0, ii = ps.length; i < ii; i += 3) {
          drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
        }
        break;
      default:
        (0, _util.error)('illigal figure');
        break;
    }
  }
  function createMeshCanvas(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases) {
    var EXPECTED_SCALE = 1.1;
    var MAX_PATTERN_SIZE = 3000;
    var BORDER_SIZE = 2;
    var offsetX = Math.floor(bounds[0]);
    var offsetY = Math.floor(bounds[1]);
    var boundsWidth = Math.ceil(bounds[2]) - offsetX;
    var boundsHeight = Math.ceil(bounds[3]) - offsetY;
    var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    var scaleX = boundsWidth / width;
    var scaleY = boundsHeight / height;
    var context = {
      coords: coords,
      colors: colors,
      offsetX: -offsetX,
      offsetY: -offsetY,
      scaleX: 1 / scaleX,
      scaleY: 1 / scaleY
    };
    var paddedWidth = width + BORDER_SIZE * 2;
    var paddedHeight = height + BORDER_SIZE * 2;
    var canvas, tmpCanvas, i, ii;
    if (_webgl.WebGLUtils.isEnabled) {
      canvas = _webgl.WebGLUtils.drawFigures(width, height, backgroundColor, figures, context);
      tmpCanvas = cachedCanvases.getCanvas('mesh', paddedWidth, paddedHeight, false);
      tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE);
      canvas = tmpCanvas.canvas;
    } else {
      tmpCanvas = cachedCanvases.getCanvas('mesh', paddedWidth, paddedHeight, false);
      var tmpCtx = tmpCanvas.context;
      var data = tmpCtx.createImageData(width, height);
      if (backgroundColor) {
        var bytes = data.data;
        for (i = 0, ii = bytes.length; i < ii; i += 4) {
          bytes[i] = backgroundColor[0];
          bytes[i + 1] = backgroundColor[1];
          bytes[i + 2] = backgroundColor[2];
          bytes[i + 3] = 255;
        }
      }
      for (i = 0; i < figures.length; i++) {
        drawFigure(data, figures[i], context);
      }
      tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
      canvas = tmpCanvas.canvas;
    }
    return {
      canvas: canvas,
      offsetX: offsetX - BORDER_SIZE * scaleX,
      offsetY: offsetY - BORDER_SIZE * scaleY,
      scaleX: scaleX,
      scaleY: scaleY
    };
  }
  return createMeshCanvas;
}();
ShadingIRs.Mesh = {
  fromIR: function Mesh_fromIR(raw) {
    var coords = raw[2];
    var colors = raw[3];
    var figures = raw[4];
    var bounds = raw[5];
    var matrix = raw[6];
    var background = raw[8];
    return {
      type: 'Pattern',
      getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {
        var scale;
        if (shadingFill) {
          scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
        } else {
          scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);
          if (matrix) {
            var matrixScale = _util.Util.singularValueDecompose2dScale(matrix);
            scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
          }
        }
        var temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases);
        if (!shadingFill) {
          ctx.setTransform.apply(ctx, owner.baseTransform);
          if (matrix) {
            ctx.transform.apply(ctx, matrix);
          }
        }
        ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
        ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
        return ctx.createPattern(temporaryPatternCanvas.canvas, 'no-repeat');
      }
    };
  }
};
ShadingIRs.Dummy = {
  fromIR: function Dummy_fromIR() {
    return {
      type: 'Pattern',
      getPattern: function Dummy_fromIR_getPattern() {
        return 'hotpink';
      }
    };
  }
};
function getShadingPatternFromIR(raw) {
  var shadingIR = ShadingIRs[raw[0]];
  if (!shadingIR) {
    (0, _util.error)('Unknown IR type: ' + raw[0]);
  }
  return shadingIR.fromIR(raw);
}
var TilingPattern = function TilingPatternClosure() {
  var PaintType = {
    COLORED: 1,
    UNCOLORED: 2
  };
  var MAX_PATTERN_SIZE = 3000;
  function TilingPattern(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
    this.operatorList = IR[2];
    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
    this.bbox = _util.Util.normalizeRect(IR[4]);
    this.xstep = IR[5];
    this.ystep = IR[6];
    this.paintType = IR[7];
    this.tilingType = IR[8];
    this.color = color;
    this.canvasGraphicsFactory = canvasGraphicsFactory;
    this.baseTransform = baseTransform;
    this.type = 'Pattern';
    this.ctx = ctx;
  }
  TilingPattern.prototype = {
    createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {
      var operatorList = this.operatorList;
      var bbox = this.bbox;
      var xstep = this.xstep;
      var ystep = this.ystep;
      var paintType = this.paintType;
      var tilingType = this.tilingType;
      var color = this.color;
      var canvasGraphicsFactory = this.canvasGraphicsFactory;
      (0, _util.info)('TilingType: ' + tilingType);
      var x0 = bbox[0],
          y0 = bbox[1],
          x1 = bbox[2],
          y1 = bbox[3];
      var topLeft = [x0, y0];
      var botRight = [x0 + xstep, y0 + ystep];
      var width = botRight[0] - topLeft[0];
      var height = botRight[1] - topLeft[1];
      var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);
      var curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);
      var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
      width = Math.min(Math.ceil(Math.abs(width * combinedScale[0])), MAX_PATTERN_SIZE);
      height = Math.min(Math.ceil(Math.abs(height * combinedScale[1])), MAX_PATTERN_SIZE);
      var tmpCanvas = owner.cachedCanvases.getCanvas('pattern', width, height, true);
      var tmpCtx = tmpCanvas.context;
      var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
      graphics.groupLevel = owner.groupLevel;
      this.setFillAndStrokeStyleToContext(tmpCtx, paintType, color);
      this.setScale(width, height, xstep, ystep);
      this.transformToScale(graphics);
      var tmpTranslate = [1, 0, 0, 1, -topLeft[0], -topLeft[1]];
      graphics.transform.apply(graphics, tmpTranslate);
      this.clipBbox(graphics, bbox, x0, y0, x1, y1);
      graphics.executeOperatorList(operatorList);
      return tmpCanvas.canvas;
    },
    setScale: function TilingPattern_setScale(width, height, xstep, ystep) {
      this.scale = [width / xstep, height / ystep];
    },
    transformToScale: function TilingPattern_transformToScale(graphics) {
      var scale = this.scale;
      var tmpScale = [scale[0], 0, 0, scale[1], 0, 0];
      graphics.transform.apply(graphics, tmpScale);
    },
    scaleToContext: function TilingPattern_scaleToContext() {
      var scale = this.scale;
      this.ctx.scale(1 / scale[0], 1 / scale[1]);
    },
    clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {
      if ((0, _util.isArray)(bbox) && bbox.length === 4) {
        var bboxWidth = x1 - x0;
        var bboxHeight = y1 - y0;
        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
        graphics.clip();
        graphics.endPath();
      }
    },
    setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(context, paintType, color) {
      switch (paintType) {
        case PaintType.COLORED:
          var ctx = this.ctx;
          context.fillStyle = ctx.fillStyle;
          context.strokeStyle = ctx.strokeStyle;
          break;
        case PaintType.UNCOLORED:
          var cssColor = _util.Util.makeCssRgb(color[0], color[1], color[2]);
          context.fillStyle = cssColor;
          context.strokeStyle = cssColor;
          break;
        default:
          (0, _util.error)('Unsupported paint type: ' + paintType);
      }
    },
    getPattern: function TilingPattern_getPattern(ctx, owner) {
      var temporaryPatternCanvas = this.createPatternCanvas(owner);
      ctx = this.ctx;
      ctx.setTransform.apply(ctx, this.baseTransform);
      ctx.transform.apply(ctx, this.matrix);
      this.scaleToContext();
      return ctx.createPattern(temporaryPatternCanvas, 'repeat');
    }
  };
  return TilingPattern;
}();
exports.getShadingPatternFromIR = getShadingPatternFromIR;
exports.TilingPattern = TilingPattern;

/***/ }),
/* 13 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var pdfjsVersion = '1.8.233';
var pdfjsBuild = '19321937';
var pdfjsSharedUtil = __w_pdfjs_require__(0);
var pdfjsDisplayGlobal = __w_pdfjs_require__(9);
var pdfjsDisplayAPI = __w_pdfjs_require__(3);
var pdfjsDisplayTextLayer = __w_pdfjs_require__(5);
var pdfjsDisplayAnnotationLayer = __w_pdfjs_require__(2);
var pdfjsDisplayDOMUtils = __w_pdfjs_require__(1);
var pdfjsDisplaySVG = __w_pdfjs_require__(4);
exports.PDFJS = pdfjsDisplayGlobal.PDFJS;
exports.build = pdfjsDisplayAPI.build;
exports.version = pdfjsDisplayAPI.version;
exports.getDocument = pdfjsDisplayAPI.getDocument;
exports.PDFDataRangeTransport = pdfjsDisplayAPI.PDFDataRangeTransport;
exports.PDFWorker = pdfjsDisplayAPI.PDFWorker;
exports.renderTextLayer = pdfjsDisplayTextLayer.renderTextLayer;
exports.AnnotationLayer = pdfjsDisplayAnnotationLayer.AnnotationLayer;
exports.CustomStyle = pdfjsDisplayDOMUtils.CustomStyle;
exports.createPromiseCapability = pdfjsSharedUtil.createPromiseCapability;
exports.PasswordResponses = pdfjsSharedUtil.PasswordResponses;
exports.InvalidPDFException = pdfjsSharedUtil.InvalidPDFException;
exports.MissingPDFException = pdfjsSharedUtil.MissingPDFException;
exports.SVGGraphics = pdfjsDisplaySVG.SVGGraphics;
exports.UnexpectedResponseException = pdfjsSharedUtil.UnexpectedResponseException;
exports.OPS = pdfjsSharedUtil.OPS;
exports.UNSUPPORTED_FEATURES = pdfjsSharedUtil.UNSUPPORTED_FEATURES;
exports.isValidUrl = pdfjsDisplayDOMUtils.isValidUrl;
exports.createValidAbsoluteUrl = pdfjsSharedUtil.createValidAbsoluteUrl;
exports.createObjectURL = pdfjsSharedUtil.createObjectURL;
exports.removeNullCharacters = pdfjsSharedUtil.removeNullCharacters;
exports.shadow = pdfjsSharedUtil.shadow;
exports.createBlob = pdfjsSharedUtil.createBlob;
exports.RenderingCancelledException = pdfjsDisplayDOMUtils.RenderingCancelledException;
exports.getFilenameFromUrl = pdfjsDisplayDOMUtils.getFilenameFromUrl;
exports.addLinkAttributes = pdfjsDisplayDOMUtils.addLinkAttributes;

/***/ }),
/* 14 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (typeof PDFJS === 'undefined' || !PDFJS.compatibilityChecked) {
  var globalScope = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : undefined;
  var userAgent = typeof navigator !== 'undefined' && navigator.userAgent || '';
  var isAndroid = /Android/.test(userAgent);
  var isAndroidPre3 = /Android\s[0-2][^\d]/.test(userAgent);
  var isAndroidPre5 = /Android\s[0-4][^\d]/.test(userAgent);
  var isChrome = userAgent.indexOf('Chrom') >= 0;
  var isChromeWithRangeBug = /Chrome\/(39|40)\./.test(userAgent);
  var isIOSChrome = userAgent.indexOf('CriOS') >= 0;
  var isIE = userAgent.indexOf('Trident') >= 0;
  var isIOS = /\b(iPad|iPhone|iPod)(?=;)/.test(userAgent);
  var isOpera = userAgent.indexOf('Opera') >= 0;
  var isSafari = /Safari\//.test(userAgent) && !/(Chrome\/|Android\s)/.test(userAgent);
  var hasDOM = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && (typeof document === 'undefined' ? 'undefined' : _typeof(document)) === 'object';
  if (typeof PDFJS === 'undefined') {
    globalScope.PDFJS = {};
  }
  PDFJS.compatibilityChecked = true;
  (function checkTypedArrayCompatibility() {
    if (typeof Uint8Array !== 'undefined') {
      if (typeof Uint8Array.prototype.subarray === 'undefined') {
        Uint8Array.prototype.subarray = function subarray(start, end) {
          return new Uint8Array(this.slice(start, end));
        };
        Float32Array.prototype.subarray = function subarray(start, end) {
          return new Float32Array(this.slice(start, end));
        };
      }
      if (typeof Float64Array === 'undefined') {
        globalScope.Float64Array = Float32Array;
      }
      return;
    }
    function subarray(start, end) {
      return new TypedArray(this.slice(start, end));
    }
    function setArrayOffset(array, offset) {
      if (arguments.length < 2) {
        offset = 0;
      }
      for (var i = 0, n = array.length; i < n; ++i, ++offset) {
        this[offset] = array[i] & 0xFF;
      }
    }
    function Uint32ArrayView(buffer, length) {
      this.buffer = buffer;
      this.byteLength = buffer.length;
      this.length = length;
      ensureUint32ArrayViewProps(this.length);
    }
    Uint32ArrayView.prototype = Object.create(null);
    var uint32ArrayViewSetters = 0;
    function createUint32ArrayProp(index) {
      return {
        get: function get() {
          var buffer = this.buffer,
              offset = index << 2;
          return (buffer[offset] | buffer[offset + 1] << 8 | buffer[offset + 2] << 16 | buffer[offset + 3] << 24) >>> 0;
        },
        set: function set(value) {
          var buffer = this.buffer,
              offset = index << 2;
          buffer[offset] = value & 255;
          buffer[offset + 1] = value >> 8 & 255;
          buffer[offset + 2] = value >> 16 & 255;
          buffer[offset + 3] = value >>> 24 & 255;
        }
      };
    }
    function ensureUint32ArrayViewProps(length) {
      while (uint32ArrayViewSetters < length) {
        Object.defineProperty(Uint32ArrayView.prototype, uint32ArrayViewSetters, createUint32ArrayProp(uint32ArrayViewSetters));
        uint32ArrayViewSetters++;
      }
    }
    function TypedArray(arg1) {
      var result, i, n;
      if (typeof arg1 === 'number') {
        result = [];
        for (i = 0; i < arg1; ++i) {
          result[i] = 0;
        }
      } else if ('slice' in arg1) {
        result = arg1.slice(0);
      } else {
        result = [];
        for (i = 0, n = arg1.length; i < n; ++i) {
          result[i] = arg1[i];
        }
      }
      result.subarray = subarray;
      result.buffer = result;
      result.byteLength = result.length;
      result.set = setArrayOffset;
      if ((typeof arg1 === 'undefined' ? 'undefined' : _typeof(arg1)) === 'object' && arg1.buffer) {
        result.buffer = arg1.buffer;
      }
      return result;
    }
    globalScope.Uint8Array = TypedArray;
    globalScope.Int8Array = TypedArray;
    globalScope.Int32Array = TypedArray;
    globalScope.Uint16Array = TypedArray;
    globalScope.Float32Array = TypedArray;
    globalScope.Float64Array = TypedArray;
    globalScope.Uint32Array = function () {
      if (arguments.length === 3) {
        if (arguments[1] !== 0) {
          throw new Error('offset !== 0 is not supported');
        }
        return new Uint32ArrayView(arguments[0], arguments[2]);
      }
      return TypedArray.apply(this, arguments);
    };
  })();
  (function canvasPixelArrayBuffer() {
    if (!hasDOM || !window.CanvasPixelArray) {
      return;
    }
    var cpaProto = window.CanvasPixelArray.prototype;
    if ('buffer' in cpaProto) {
      return;
    }
    Object.defineProperty(cpaProto, 'buffer', {
      get: function get() {
        return this;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(cpaProto, 'byteLength', {
      get: function get() {
        return this.length;
      },
      enumerable: false,
      configurable: true
    });
  })();
  (function normalizeURLObject() {
    if (!globalScope.URL) {
      globalScope.URL = globalScope.webkitURL;
    }
  })();
  (function checkObjectDefinePropertyCompatibility() {
    if (typeof Object.defineProperty !== 'undefined') {
      var definePropertyPossible = true;
      try {
        if (hasDOM) {
          Object.defineProperty(new Image(), 'id', { value: 'test' });
        }
        var Test = function Test() {};
        Test.prototype = {
          get id() {}
        };
        Object.defineProperty(new Test(), 'id', {
          value: '',
          configurable: true,
          enumerable: true,
          writable: false
        });
      } catch (e) {
        definePropertyPossible = false;
      }
      if (definePropertyPossible) {
        return;
      }
    }
    Object.defineProperty = function objectDefineProperty(obj, name, def) {
      delete obj[name];
      if ('get' in def) {
        obj.__defineGetter__(name, def['get']);
      }
      if ('set' in def) {
        obj.__defineSetter__(name, def['set']);
      }
      if ('value' in def) {
        obj.__defineSetter__(name, function objectDefinePropertySetter(value) {
          this.__defineGetter__(name, function objectDefinePropertyGetter() {
            return value;
          });
          return value;
        });
        obj[name] = def.value;
      }
    };
  })();
  (function checkXMLHttpRequestResponseCompatibility() {
    if (typeof XMLHttpRequest === 'undefined') {
      return;
    }
    var xhrPrototype = XMLHttpRequest.prototype;
    var xhr = new XMLHttpRequest();
    if (!('overrideMimeType' in xhr)) {
      Object.defineProperty(xhrPrototype, 'overrideMimeType', {
        value: function xmlHttpRequestOverrideMimeType(mimeType) {}
      });
    }
    if ('responseType' in xhr) {
      return;
    }
    Object.defineProperty(xhrPrototype, 'responseType', {
      get: function xmlHttpRequestGetResponseType() {
        return this._responseType || 'text';
      },
      set: function xmlHttpRequestSetResponseType(value) {
        if (value === 'text' || value === 'arraybuffer') {
          this._responseType = value;
          if (value === 'arraybuffer' && typeof this.overrideMimeType === 'function') {
            this.overrideMimeType('text/plain; charset=x-user-defined');
          }
        }
      }
    });
    if (typeof VBArray !== 'undefined') {
      Object.defineProperty(xhrPrototype, 'response', {
        get: function xmlHttpRequestResponseGet() {
          if (this.responseType === 'arraybuffer') {
            return new Uint8Array(new VBArray(this.responseBody).toArray());
          }
          return this.responseText;
        }
      });
      return;
    }
    Object.defineProperty(xhrPrototype, 'response', {
      get: function xmlHttpRequestResponseGet() {
        if (this.responseType !== 'arraybuffer') {
          return this.responseText;
        }
        var text = this.responseText;
        var i,
            n = text.length;
        var result = new Uint8Array(n);
        for (i = 0; i < n; ++i) {
          result[i] = text.charCodeAt(i) & 0xFF;
        }
        return result.buffer;
      }
    });
  })();
  (function checkWindowBtoaCompatibility() {
    if ('btoa' in globalScope) {
      return;
    }
    var digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    globalScope.btoa = function (chars) {
      var buffer = '';
      var i, n;
      for (i = 0, n = chars.length; i < n; i += 3) {
        var b1 = chars.charCodeAt(i) & 0xFF;
        var b2 = chars.charCodeAt(i + 1) & 0xFF;
        var b3 = chars.charCodeAt(i + 2) & 0xFF;
        var d1 = b1 >> 2,
            d2 = (b1 & 3) << 4 | b2 >> 4;
        var d3 = i + 1 < n ? (b2 & 0xF) << 2 | b3 >> 6 : 64;
        var d4 = i + 2 < n ? b3 & 0x3F : 64;
        buffer += digits.charAt(d1) + digits.charAt(d2) + digits.charAt(d3) + digits.charAt(d4);
      }
      return buffer;
    };
  })();
  (function checkWindowAtobCompatibility() {
    if ('atob' in globalScope) {
      return;
    }
    var digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    globalScope.atob = function (input) {
      input = input.replace(/=+$/, '');
      if (input.length % 4 === 1) {
        throw new Error('bad atob input');
      }
      for (var bc = 0, bs, buffer, idx = 0, output = ''; buffer = input.charAt(idx++); ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
        buffer = digits.indexOf(buffer);
      }
      return output;
    };
  })();
  (function checkFunctionPrototypeBindCompatibility() {
    if (typeof Function.prototype.bind !== 'undefined') {
      return;
    }
    Function.prototype.bind = function functionPrototypeBind(obj) {
      var fn = this,
          headArgs = Array.prototype.slice.call(arguments, 1);
      var bound = function functionPrototypeBindBound() {
        var args = headArgs.concat(Array.prototype.slice.call(arguments));
        return fn.apply(obj, args);
      };
      return bound;
    };
  })();
  (function checkDatasetProperty() {
    if (!hasDOM) {
      return;
    }
    var div = document.createElement('div');
    if ('dataset' in div) {
      return;
    }
    Object.defineProperty(HTMLElement.prototype, 'dataset', {
      get: function get() {
        if (this._dataset) {
          return this._dataset;
        }
        var dataset = {};
        for (var j = 0, jj = this.attributes.length; j < jj; j++) {
          var attribute = this.attributes[j];
          if (attribute.name.substring(0, 5) !== 'data-') {
            continue;
          }
          var key = attribute.name.substring(5).replace(/\-([a-z])/g, function (all, ch) {
            return ch.toUpperCase();
          });
          dataset[key] = attribute.value;
        }
        Object.defineProperty(this, '_dataset', {
          value: dataset,
          writable: false,
          enumerable: false
        });
        return dataset;
      },
      enumerable: true
    });
  })();
  (function checkClassListProperty() {
    function changeList(element, itemName, add, remove) {
      var s = element.className || '';
      var list = s.split(/\s+/g);
      if (list[0] === '') {
        list.shift();
      }
      var index = list.indexOf(itemName);
      if (index < 0 && add) {
        list.push(itemName);
      }
      if (index >= 0 && remove) {
        list.splice(index, 1);
      }
      element.className = list.join(' ');
      return index >= 0;
    }
    if (!hasDOM) {
      return;
    }
    var div = document.createElement('div');
    if ('classList' in div) {
      return;
    }
    var classListPrototype = {
      add: function add(name) {
        changeList(this.element, name, true, false);
      },
      contains: function contains(name) {
        return changeList(this.element, name, false, false);
      },
      remove: function remove(name) {
        changeList(this.element, name, false, true);
      },
      toggle: function toggle(name) {
        changeList(this.element, name, true, true);
      }
    };
    Object.defineProperty(HTMLElement.prototype, 'classList', {
      get: function get() {
        if (this._classList) {
          return this._classList;
        }
        var classList = Object.create(classListPrototype, {
          element: {
            value: this,
            writable: false,
            enumerable: true
          }
        });
        Object.defineProperty(this, '_classList', {
          value: classList,
          writable: false,
          enumerable: false
        });
        return classList;
      },
      enumerable: true
    });
  })();
  (function checkWorkerConsoleCompatibility() {
    if (typeof importScripts === 'undefined' || 'console' in globalScope) {
      return;
    }
    var consoleTimer = {};
    var workerConsole = {
      log: function log() {
        var args = Array.prototype.slice.call(arguments);
        globalScope.postMessage({
          targetName: 'main',
          action: 'console_log',
          data: args
        });
      },
      error: function error() {
        var args = Array.prototype.slice.call(arguments);
        globalScope.postMessage({
          targetName: 'main',
          action: 'console_error',
          data: args
        });
      },
      time: function time(name) {
        consoleTimer[name] = Date.now();
      },
      timeEnd: function timeEnd(name) {
        var time = consoleTimer[name];
        if (!time) {
          throw new Error('Unknown timer name ' + name);
        }
        this.log('Timer:', name, Date.now() - time);
      }
    };
    globalScope.console = workerConsole;
  })();
  (function checkConsoleCompatibility() {
    if (!hasDOM) {
      return;
    }
    if (!('console' in window)) {
      window.console = {
        log: function log() {},
        error: function error() {},
        warn: function warn() {}
      };
      return;
    }
    if (!('bind' in console.log)) {
      console.log = function (fn) {
        return function (msg) {
          return fn(msg);
        };
      }(console.log);
      console.error = function (fn) {
        return function (msg) {
          return fn(msg);
        };
      }(console.error);
      console.warn = function (fn) {
        return function (msg) {
          return fn(msg);
        };
      }(console.warn);
      return;
    }
  })();
  (function checkOnClickCompatibility() {
    function ignoreIfTargetDisabled(event) {
      if (isDisabled(event.target)) {
        event.stopPropagation();
      }
    }
    function isDisabled(node) {
      return node.disabled || node.parentNode && isDisabled(node.parentNode);
    }
    if (isOpera) {
      document.addEventListener('click', ignoreIfTargetDisabled, true);
    }
  })();
  (function checkOnBlobSupport() {
    if (isIE || isIOSChrome) {
      PDFJS.disableCreateObjectURL = true;
    }
  })();
  (function checkNavigatorLanguage() {
    if (typeof navigator === 'undefined') {
      return;
    }
    if ('language' in navigator) {
      return;
    }
    PDFJS.locale = navigator.userLanguage || 'en-US';
  })();
  (function checkRangeRequests() {
    if (isSafari || isAndroidPre3 || isChromeWithRangeBug || isIOS) {
      PDFJS.disableRange = true;
      PDFJS.disableStream = true;
    }
  })();
  (function checkHistoryManipulation() {
    if (!hasDOM) {
      return;
    }
    if (!history.pushState || isAndroidPre3) {
      PDFJS.disableHistory = true;
    }
  })();
  (function checkSetPresenceInImageData() {
    if (!hasDOM) {
      return;
    }
    if (window.CanvasPixelArray) {
      if (typeof window.CanvasPixelArray.prototype.set !== 'function') {
        window.CanvasPixelArray.prototype.set = function (arr) {
          for (var i = 0, ii = this.length; i < ii; i++) {
            this[i] = arr[i];
          }
        };
      }
    } else {
      var polyfill = false,
          versionMatch;
      if (isChrome) {
        versionMatch = userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
        polyfill = versionMatch && parseInt(versionMatch[2]) < 21;
      } else if (isAndroid) {
        polyfill = isAndroidPre5;
      } else if (isSafari) {
        versionMatch = userAgent.match(/Version\/([0-9]+)\.([0-9]+)\.([0-9]+) Safari\//);
        polyfill = versionMatch && parseInt(versionMatch[1]) < 6;
      }
      if (polyfill) {
        var contextPrototype = window.CanvasRenderingContext2D.prototype;
        var createImageData = contextPrototype.createImageData;
        contextPrototype.createImageData = function (w, h) {
          var imageData = createImageData.call(this, w, h);
          imageData.data.set = function (arr) {
            for (var i = 0, ii = this.length; i < ii; i++) {
              this[i] = arr[i];
            }
          };
          return imageData;
        };
        contextPrototype = null;
      }
    }
  })();
  (function checkRequestAnimationFrame() {
    function installFakeAnimationFrameFunctions() {
      window.requestAnimationFrame = function (callback) {
        return window.setTimeout(callback, 20);
      };
      window.cancelAnimationFrame = function (timeoutID) {
        window.clearTimeout(timeoutID);
      };
    }
    if (!hasDOM) {
      return;
    }
    if (isIOS) {
      installFakeAnimationFrameFunctions();
      return;
    }
    if ('requestAnimationFrame' in window) {
      return;
    }
    window.requestAnimationFrame = window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
    if (window.requestAnimationFrame) {
      return;
    }
    installFakeAnimationFrameFunctions();
  })();
  (function checkCanvasSizeLimitation() {
    if (isIOS || isAndroid) {
      PDFJS.maxCanvasPixels = 5242880;
    }
  })();
  (function checkFullscreenSupport() {
    if (!hasDOM) {
      return;
    }
    if (isIE && window.parent !== window) {
      PDFJS.disableFullscreen = true;
    }
  })();
  (function checkCurrentScript() {
    if (!hasDOM) {
      return;
    }
    if ('currentScript' in document) {
      return;
    }
    Object.defineProperty(document, 'currentScript', {
      get: function get() {
        var scripts = document.getElementsByTagName('script');
        return scripts[scripts.length - 1];
      },
      enumerable: true,
      configurable: true
    });
  })();
  (function checkInputTypeNumberAssign() {
    if (!hasDOM) {
      return;
    }
    var el = document.createElement('input');
    try {
      el.type = 'number';
    } catch (ex) {
      var inputProto = el.constructor.prototype;
      var typeProperty = Object.getOwnPropertyDescriptor(inputProto, 'type');
      Object.defineProperty(inputProto, 'type', {
        get: function get() {
          return typeProperty.get.call(this);
        },
        set: function set(value) {
          typeProperty.set.call(this, value === 'number' ? 'text' : value);
        },
        enumerable: true,
        configurable: true
      });
    }
  })();
  (function checkDocumentReadyState() {
    if (!hasDOM) {
      return;
    }
    if (!document.attachEvent) {
      return;
    }
    var documentProto = document.constructor.prototype;
    var readyStateProto = Object.getOwnPropertyDescriptor(documentProto, 'readyState');
    Object.defineProperty(documentProto, 'readyState', {
      get: function get() {
        var value = readyStateProto.get.call(this);
        return value === 'interactive' ? 'loading' : value;
      },
      set: function set(value) {
        readyStateProto.set.call(this, value);
      },
      enumerable: true,
      configurable: true
    });
  })();
  (function checkChildNodeRemove() {
    if (!hasDOM) {
      return;
    }
    if (typeof Element.prototype.remove !== 'undefined') {
      return;
    }
    Element.prototype.remove = function () {
      if (this.parentNode) {
        this.parentNode.removeChild(this);
      }
    };
  })();
  (function checkPromise() {
    if (globalScope.Promise) {
      if (typeof globalScope.Promise.all !== 'function') {
        globalScope.Promise.all = function (iterable) {
          var count = 0,
              results = [],
              resolve,
              reject;
          var promise = new globalScope.Promise(function (resolve_, reject_) {
            resolve = resolve_;
            reject = reject_;
          });
          iterable.forEach(function (p, i) {
            count++;
            p.then(function (result) {
              results[i] = result;
              count--;
              if (count === 0) {
                resolve(results);
              }
            }, reject);
          });
          if (count === 0) {
            resolve(results);
          }
          return promise;
        };
      }
      if (typeof globalScope.Promise.resolve !== 'function') {
        globalScope.Promise.resolve = function (value) {
          return new globalScope.Promise(function (resolve) {
            resolve(value);
          });
        };
      }
      if (typeof globalScope.Promise.reject !== 'function') {
        globalScope.Promise.reject = function (reason) {
          return new globalScope.Promise(function (resolve, reject) {
            reject(reason);
          });
        };
      }
      if (typeof globalScope.Promise.prototype.catch !== 'function') {
        globalScope.Promise.prototype.catch = function (onReject) {
          return globalScope.Promise.prototype.then(undefined, onReject);
        };
      }
      return;
    }
    var STATUS_PENDING = 0;
    var STATUS_RESOLVED = 1;
    var STATUS_REJECTED = 2;
    var REJECTION_TIMEOUT = 500;
    var HandlerManager = {
      handlers: [],
      running: false,
      unhandledRejections: [],
      pendingRejectionCheck: false,
      scheduleHandlers: function scheduleHandlers(promise) {
        if (promise._status === STATUS_PENDING) {
          return;
        }
        this.handlers = this.handlers.concat(promise._handlers);
        promise._handlers = [];
        if (this.running) {
          return;
        }
        this.running = true;
        setTimeout(this.runHandlers.bind(this), 0);
      },
      runHandlers: function runHandlers() {
        var RUN_TIMEOUT = 1;
        var timeoutAt = Date.now() + RUN_TIMEOUT;
        while (this.handlers.length > 0) {
          var handler = this.handlers.shift();
          var nextStatus = handler.thisPromise._status;
          var nextValue = handler.thisPromise._value;
          try {
            if (nextStatus === STATUS_RESOLVED) {
              if (typeof handler.onResolve === 'function') {
                nextValue = handler.onResolve(nextValue);
              }
            } else if (typeof handler.onReject === 'function') {
              nextValue = handler.onReject(nextValue);
              nextStatus = STATUS_RESOLVED;
              if (handler.thisPromise._unhandledRejection) {
                this.removeUnhandeledRejection(handler.thisPromise);
              }
            }
          } catch (ex) {
            nextStatus = STATUS_REJECTED;
            nextValue = ex;
          }
          handler.nextPromise._updateStatus(nextStatus, nextValue);
          if (Date.now() >= timeoutAt) {
            break;
          }
        }
        if (this.handlers.length > 0) {
          setTimeout(this.runHandlers.bind(this), 0);
          return;
        }
        this.running = false;
      },
      addUnhandledRejection: function addUnhandledRejection(promise) {
        this.unhandledRejections.push({
          promise: promise,
          time: Date.now()
        });
        this.scheduleRejectionCheck();
      },
      removeUnhandeledRejection: function removeUnhandeledRejection(promise) {
        promise._unhandledRejection = false;
        for (var i = 0; i < this.unhandledRejections.length; i++) {
          if (this.unhandledRejections[i].promise === promise) {
            this.unhandledRejections.splice(i);
            i--;
          }
        }
      },
      scheduleRejectionCheck: function scheduleRejectionCheck() {
        if (this.pendingRejectionCheck) {
          return;
        }
        this.pendingRejectionCheck = true;
        setTimeout(function rejectionCheck() {
          this.pendingRejectionCheck = false;
          var now = Date.now();
          for (var i = 0; i < this.unhandledRejections.length; i++) {
            if (now - this.unhandledRejections[i].time > REJECTION_TIMEOUT) {
              var unhandled = this.unhandledRejections[i].promise._value;
              var msg = 'Unhandled rejection: ' + unhandled;
              if (unhandled.stack) {
                msg += '\n' + unhandled.stack;
              }
              try {
                throw new Error(msg);
              } catch (_) {
                console.warn(msg);
              }
              this.unhandledRejections.splice(i);
              i--;
            }
          }
          if (this.unhandledRejections.length) {
            this.scheduleRejectionCheck();
          }
        }.bind(this), REJECTION_TIMEOUT);
      }
    };
    var Promise = function Promise(resolver) {
      this._status = STATUS_PENDING;
      this._handlers = [];
      try {
        resolver.call(this, this._resolve.bind(this), this._reject.bind(this));
      } catch (e) {
        this._reject(e);
      }
    };
    Promise.all = function Promise_all(promises) {
      var resolveAll, rejectAll;
      var deferred = new Promise(function (resolve, reject) {
        resolveAll = resolve;
        rejectAll = reject;
      });
      var unresolved = promises.length;
      var results = [];
      if (unresolved === 0) {
        resolveAll(results);
        return deferred;
      }
      function reject(reason) {
        if (deferred._status === STATUS_REJECTED) {
          return;
        }
        results = [];
        rejectAll(reason);
      }
      for (var i = 0, ii = promises.length; i < ii; ++i) {
        var promise = promises[i];
        var resolve = function (i) {
          return function (value) {
            if (deferred._status === STATUS_REJECTED) {
              return;
            }
            results[i] = value;
            unresolved--;
            if (unresolved === 0) {
              resolveAll(results);
            }
          };
        }(i);
        if (Promise.isPromise(promise)) {
          promise.then(resolve, reject);
        } else {
          resolve(promise);
        }
      }
      return deferred;
    };
    Promise.isPromise = function Promise_isPromise(value) {
      return value && typeof value.then === 'function';
    };
    Promise.resolve = function Promise_resolve(value) {
      return new Promise(function (resolve) {
        resolve(value);
      });
    };
    Promise.reject = function Promise_reject(reason) {
      return new Promise(function (resolve, reject) {
        reject(reason);
      });
    };
    Promise.prototype = {
      _status: null,
      _value: null,
      _handlers: null,
      _unhandledRejection: null,
      _updateStatus: function Promise__updateStatus(status, value) {
        if (this._status === STATUS_RESOLVED || this._status === STATUS_REJECTED) {
          return;
        }
        if (status === STATUS_RESOLVED && Promise.isPromise(value)) {
          value.then(this._updateStatus.bind(this, STATUS_RESOLVED), this._updateStatus.bind(this, STATUS_REJECTED));
          return;
        }
        this._status = status;
        this._value = value;
        if (status === STATUS_REJECTED && this._handlers.length === 0) {
          this._unhandledRejection = true;
          HandlerManager.addUnhandledRejection(this);
        }
        HandlerManager.scheduleHandlers(this);
      },
      _resolve: function Promise_resolve(value) {
        this._updateStatus(STATUS_RESOLVED, value);
      },
      _reject: function Promise_reject(reason) {
        this._updateStatus(STATUS_REJECTED, reason);
      },
      then: function Promise_then(onResolve, onReject) {
        var nextPromise = new Promise(function (resolve, reject) {
          this.resolve = resolve;
          this.reject = reject;
        });
        this._handlers.push({
          thisPromise: this,
          onResolve: onResolve,
          onReject: onReject,
          nextPromise: nextPromise
        });
        HandlerManager.scheduleHandlers(this);
        return nextPromise;
      },
      catch: function Promise_catch(onReject) {
        return this.then(undefined, onReject);
      }
    };
    globalScope.Promise = Promise;
  })();
  (function checkWeakMap() {
    if (globalScope.WeakMap) {
      return;
    }
    var id = 0;
    function WeakMap() {
      this.id = '$weakmap' + id++;
    }
    WeakMap.prototype = {
      has: function has(obj) {
        return !!Object.getOwnPropertyDescriptor(obj, this.id);
      },
      get: function get(obj, defaultValue) {
        return this.has(obj) ? obj[this.id] : defaultValue;
      },
      set: function set(obj, value) {
        Object.defineProperty(obj, this.id, {
          value: value,
          enumerable: false,
          configurable: true
        });
      },
      delete: function _delete(obj) {
        delete obj[this.id];
      }
    };
    globalScope.WeakMap = WeakMap;
  })();
  (function checkURLConstructor() {
    var hasWorkingUrl = false;
    try {
      if (typeof URL === 'function' && _typeof(URL.prototype) === 'object' && 'origin' in URL.prototype) {
        var u = new URL('b', 'http://a');
        u.pathname = 'c%20d';
        hasWorkingUrl = u.href === 'http://a/c%20d';
      }
    } catch (e) {}
    if (hasWorkingUrl) {
      return;
    }
    var relative = Object.create(null);
    relative['ftp'] = 21;
    relative['file'] = 0;
    relative['gopher'] = 70;
    relative['http'] = 80;
    relative['https'] = 443;
    relative['ws'] = 80;
    relative['wss'] = 443;
    var relativePathDotMapping = Object.create(null);
    relativePathDotMapping['%2e'] = '.';
    relativePathDotMapping['.%2e'] = '..';
    relativePathDotMapping['%2e.'] = '..';
    relativePathDotMapping['%2e%2e'] = '..';
    function isRelativeScheme(scheme) {
      return relative[scheme] !== undefined;
    }
    function invalid() {
      clear.call(this);
      this._isInvalid = true;
    }
    function IDNAToASCII(h) {
      if (h === '') {
        invalid.call(this);
      }
      return h.toLowerCase();
    }
    function percentEscape(c) {
      var unicode = c.charCodeAt(0);
      if (unicode > 0x20 && unicode < 0x7F && [0x22, 0x23, 0x3C, 0x3E, 0x3F, 0x60].indexOf(unicode) === -1) {
        return c;
      }
      return encodeURIComponent(c);
    }
    function percentEscapeQuery(c) {
      var unicode = c.charCodeAt(0);
      if (unicode > 0x20 && unicode < 0x7F && [0x22, 0x23, 0x3C, 0x3E, 0x60].indexOf(unicode) === -1) {
        return c;
      }
      return encodeURIComponent(c);
    }
    var EOF,
        ALPHA = /[a-zA-Z]/,
        ALPHANUMERIC = /[a-zA-Z0-9\+\-\.]/;
    function parse(input, stateOverride, base) {
      function err(message) {
        errors.push(message);
      }
      var state = stateOverride || 'scheme start',
          cursor = 0,
          buffer = '',
          seenAt = false,
          seenBracket = false,
          errors = [];
      loop: while ((input[cursor - 1] !== EOF || cursor === 0) && !this._isInvalid) {
        var c = input[cursor];
        switch (state) {
          case 'scheme start':
            if (c && ALPHA.test(c)) {
              buffer += c.toLowerCase();
              state = 'scheme';
            } else if (!stateOverride) {
              buffer = '';
              state = 'no scheme';
              continue;
            } else {
              err('Invalid scheme.');
              break loop;
            }
            break;
          case 'scheme':
            if (c && ALPHANUMERIC.test(c)) {
              buffer += c.toLowerCase();
            } else if (c === ':') {
              this._scheme = buffer;
              buffer = '';
              if (stateOverride) {
                break loop;
              }
              if (isRelativeScheme(this._scheme)) {
                this._isRelative = true;
              }
              if (this._scheme === 'file') {
                state = 'relative';
              } else if (this._isRelative && base && base._scheme === this._scheme) {
                state = 'relative or authority';
              } else if (this._isRelative) {
                state = 'authority first slash';
              } else {
                state = 'scheme data';
              }
            } else if (!stateOverride) {
              buffer = '';
              cursor = 0;
              state = 'no scheme';
              continue;
            } else if (c === EOF) {
              break loop;
            } else {
              err('Code point not allowed in scheme: ' + c);
              break loop;
            }
            break;
          case 'scheme data':
            if (c === '?') {
              this._query = '?';
              state = 'query';
            } else if (c === '#') {
              this._fragment = '#';
              state = 'fragment';
            } else {
              if (c !== EOF && c !== '\t' && c !== '\n' && c !== '\r') {
                this._schemeData += percentEscape(c);
              }
            }
            break;
          case 'no scheme':
            if (!base || !isRelativeScheme(base._scheme)) {
              err('Missing scheme.');
              invalid.call(this);
            } else {
              state = 'relative';
              continue;
            }
            break;
          case 'relative or authority':
            if (c === '/' && input[cursor + 1] === '/') {
              state = 'authority ignore slashes';
            } else {
              err('Expected /, got: ' + c);
              state = 'relative';
              continue;
            }
            break;
          case 'relative':
            this._isRelative = true;
            if (this._scheme !== 'file') {
              this._scheme = base._scheme;
            }
            if (c === EOF) {
              this._host = base._host;
              this._port = base._port;
              this._path = base._path.slice();
              this._query = base._query;
              this._username = base._username;
              this._password = base._password;
              break loop;
            } else if (c === '/' || c === '\\') {
              if (c === '\\') {
                err('\\ is an invalid code point.');
              }
              state = 'relative slash';
            } else if (c === '?') {
              this._host = base._host;
              this._port = base._port;
              this._path = base._path.slice();
              this._query = '?';
              this._username = base._username;
              this._password = base._password;
              state = 'query';
            } else if (c === '#') {
              this._host = base._host;
              this._port = base._port;
              this._path = base._path.slice();
              this._query = base._query;
              this._fragment = '#';
              this._username = base._username;
              this._password = base._password;
              state = 'fragment';
            } else {
              var nextC = input[cursor + 1];
              var nextNextC = input[cursor + 2];
              if (this._scheme !== 'file' || !ALPHA.test(c) || nextC !== ':' && nextC !== '|' || nextNextC !== EOF && nextNextC !== '/' && nextNextC !== '\\' && nextNextC !== '?' && nextNextC !== '#') {
                this._host = base._host;
                this._port = base._port;
                this._username = base._username;
                this._password = base._password;
                this._path = base._path.slice();
                this._path.pop();
              }
              state = 'relative path';
              continue;
            }
            break;
          case 'relative slash':
            if (c === '/' || c === '\\') {
              if (c === '\\') {
                err('\\ is an invalid code point.');
              }
              if (this._scheme === 'file') {
                state = 'file host';
              } else {
                state = 'authority ignore slashes';
              }
            } else {
              if (this._scheme !== 'file') {
                this._host = base._host;
                this._port = base._port;
                this._username = base._username;
                this._password = base._password;
              }
              state = 'relative path';
              continue;
            }
            break;
          case 'authority first slash':
            if (c === '/') {
              state = 'authority second slash';
            } else {
              err('Expected \'/\', got: ' + c);
              state = 'authority ignore slashes';
              continue;
            }
            break;
          case 'authority second slash':
            state = 'authority ignore slashes';
            if (c !== '/') {
              err('Expected \'/\', got: ' + c);
              continue;
            }
            break;
          case 'authority ignore slashes':
            if (c !== '/' && c !== '\\') {
              state = 'authority';
              continue;
            } else {
              err('Expected authority, got: ' + c);
            }
            break;
          case 'authority':
            if (c === '@') {
              if (seenAt) {
                err('@ already seen.');
                buffer += '%40';
              }
              seenAt = true;
              for (var i = 0; i < buffer.length; i++) {
                var cp = buffer[i];
                if (cp === '\t' || cp === '\n' || cp === '\r') {
                  err('Invalid whitespace in authority.');
                  continue;
                }
                if (cp === ':' && this._password === null) {
                  this._password = '';
                  continue;
                }
                var tempC = percentEscape(cp);
                if (this._password !== null) {
                  this._password += tempC;
                } else {
                  this._username += tempC;
                }
              }
              buffer = '';
            } else if (c === EOF || c === '/' || c === '\\' || c === '?' || c === '#') {
              cursor -= buffer.length;
              buffer = '';
              state = 'host';
              continue;
            } else {
              buffer += c;
            }
            break;
          case 'file host':
            if (c === EOF || c === '/' || c === '\\' || c === '?' || c === '#') {
              if (buffer.length === 2 && ALPHA.test(buffer[0]) && (buffer[1] === ':' || buffer[1] === '|')) {
                state = 'relative path';
              } else if (buffer.length === 0) {
                state = 'relative path start';
              } else {
                this._host = IDNAToASCII.call(this, buffer);
                buffer = '';
                state = 'relative path start';
              }
              continue;
            } else if (c === '\t' || c === '\n' || c === '\r') {
              err('Invalid whitespace in file host.');
            } else {
              buffer += c;
            }
            break;
          case 'host':
          case 'hostname':
            if (c === ':' && !seenBracket) {
              this._host = IDNAToASCII.call(this, buffer);
              buffer = '';
              state = 'port';
              if (stateOverride === 'hostname') {
                break loop;
              }
            } else if (c === EOF || c === '/' || c === '\\' || c === '?' || c === '#') {
              this._host = IDNAToASCII.call(this, buffer);
              buffer = '';
              state = 'relative path start';
              if (stateOverride) {
                break loop;
              }
              continue;
            } else if (c !== '\t' && c !== '\n' && c !== '\r') {
              if (c === '[') {
                seenBracket = true;
              } else if (c === ']') {
                seenBracket = false;
              }
              buffer += c;
            } else {
              err('Invalid code point in host/hostname: ' + c);
            }
            break;
          case 'port':
            if (/[0-9]/.test(c)) {
              buffer += c;
            } else if (c === EOF || c === '/' || c === '\\' || c === '?' || c === '#' || stateOverride) {
              if (buffer !== '') {
                var temp = parseInt(buffer, 10);
                if (temp !== relative[this._scheme]) {
                  this._port = temp + '';
                }
                buffer = '';
              }
              if (stateOverride) {
                break loop;
              }
              state = 'relative path start';
              continue;
            } else if (c === '\t' || c === '\n' || c === '\r') {
              err('Invalid code point in port: ' + c);
            } else {
              invalid.call(this);
            }
            break;
          case 'relative path start':
            if (c === '\\') {
              err('\'\\\' not allowed in path.');
            }
            state = 'relative path';
            if (c !== '/' && c !== '\\') {
              continue;
            }
            break;
          case 'relative path':
            if (c === EOF || c === '/' || c === '\\' || !stateOverride && (c === '?' || c === '#')) {
              if (c === '\\') {
                err('\\ not allowed in relative path.');
              }
              var tmp;
              if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {
                buffer = tmp;
              }
              if (buffer === '..') {
                this._path.pop();
                if (c !== '/' && c !== '\\') {
                  this._path.push('');
                }
              } else if (buffer === '.' && c !== '/' && c !== '\\') {
                this._path.push('');
              } else if (buffer !== '.') {
                if (this._scheme === 'file' && this._path.length === 0 && buffer.length === 2 && ALPHA.test(buffer[0]) && buffer[1] === '|') {
                  buffer = buffer[0] + ':';
                }
                this._path.push(buffer);
              }
              buffer = '';
              if (c === '?') {
                this._query = '?';
                state = 'query';
              } else if (c === '#') {
                this._fragment = '#';
                state = 'fragment';
              }
            } else if (c !== '\t' && c !== '\n' && c !== '\r') {
              buffer += percentEscape(c);
            }
            break;
          case 'query':
            if (!stateOverride && c === '#') {
              this._fragment = '#';
              state = 'fragment';
            } else if (c !== EOF && c !== '\t' && c !== '\n' && c !== '\r') {
              this._query += percentEscapeQuery(c);
            }
            break;
          case 'fragment':
            if (c !== EOF && c !== '\t' && c !== '\n' && c !== '\r') {
              this._fragment += c;
            }
            break;
        }
        cursor++;
      }
    }
    function clear() {
      this._scheme = '';
      this._schemeData = '';
      this._username = '';
      this._password = null;
      this._host = '';
      this._port = '';
      this._path = [];
      this._query = '';
      this._fragment = '';
      this._isInvalid = false;
      this._isRelative = false;
    }
    function JURL(url, base) {
      if (base !== undefined && !(base instanceof JURL)) {
        base = new JURL(String(base));
      }
      this._url = url;
      clear.call(this);
      var input = url.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, '');
      parse.call(this, input, null, base);
    }
    JURL.prototype = {
      toString: function toString() {
        return this.href;
      },
      get href() {
        if (this._isInvalid) {
          return this._url;
        }
        var authority = '';
        if (this._username !== '' || this._password !== null) {
          authority = this._username + (this._password !== null ? ':' + this._password : '') + '@';
        }
        return this.protocol + (this._isRelative ? '//' + authority + this.host : '') + this.pathname + this._query + this._fragment;
      },
      set href(href) {
        clear.call(this);
        parse.call(this, href);
      },
      get protocol() {
        return this._scheme + ':';
      },
      set protocol(protocol) {
        if (this._isInvalid) {
          return;
        }
        parse.call(this, protocol + ':', 'scheme start');
      },
      get host() {
        return this._isInvalid ? '' : this._port ? this._host + ':' + this._port : this._host;
      },
      set host(host) {
        if (this._isInvalid || !this._isRelative) {
          return;
        }
        parse.call(this, host, 'host');
      },
      get hostname() {
        return this._host;
      },
      set hostname(hostname) {
        if (this._isInvalid || !this._isRelative) {
          return;
        }
        parse.call(this, hostname, 'hostname');
      },
      get port() {
        return this._port;
      },
      set port(port) {
        if (this._isInvalid || !this._isRelative) {
          return;
        }
        parse.call(this, port, 'port');
      },
      get pathname() {
        return this._isInvalid ? '' : this._isRelative ? '/' + this._path.join('/') : this._schemeData;
      },
      set pathname(pathname) {
        if (this._isInvalid || !this._isRelative) {
          return;
        }
        this._path = [];
        parse.call(this, pathname, 'relative path start');
      },
      get search() {
        return this._isInvalid || !this._query || this._query === '?' ? '' : this._query;
      },
      set search(search) {
        if (this._isInvalid || !this._isRelative) {
          return;
        }
        this._query = '?';
        if (search[0] === '?') {
          search = search.slice(1);
        }
        parse.call(this, search, 'query');
      },
      get hash() {
        return this._isInvalid || !this._fragment || this._fragment === '#' ? '' : this._fragment;
      },
      set hash(hash) {
        if (this._isInvalid) {
          return;
        }
        this._fragment = '#';
        if (hash[0] === '#') {
          hash = hash.slice(1);
        }
        parse.call(this, hash, 'fragment');
      },
      get origin() {
        var host;
        if (this._isInvalid || !this._scheme) {
          return '';
        }
        switch (this._scheme) {
          case 'data':
          case 'file':
          case 'javascript':
          case 'mailto':
            return 'null';
        }
        host = this.host;
        if (!host) {
          return '';
        }
        return this._scheme + '://' + host;
      }
    };
    var OriginalURL = globalScope.URL;
    if (OriginalURL) {
      JURL.createObjectURL = function (blob) {
        return OriginalURL.createObjectURL.apply(OriginalURL, arguments);
      };
      JURL.revokeObjectURL = function (url) {
        OriginalURL.revokeObjectURL(url);
      };
    }
    globalScope.URL = JURL;
  })();
}
/* WEBPACK VAR INJECTION */}.call(exports, __w_pdfjs_require__(6)))

/***/ })
/******/ ]);
});
}).call(this,require('_process'))
},{"./pdf.worker.js":3,"_process":8,"node-ensure":5}],3:[function(require,module,exports){
(function (process){
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("pdfjs-dist/build/pdf.worker", [], factory);
	else if(typeof exports === 'object')
		exports["pdfjs-dist/build/pdf.worker"] = factory();
	else
		root["pdfjs-dist/build/pdf.worker"] = root.pdfjsDistBuildPdfWorker = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __w_pdfjs_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__w_pdfjs_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__w_pdfjs_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__w_pdfjs_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__w_pdfjs_require__.d = function(exports, name, getter) {
/******/ 		if(!__w_pdfjs_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__w_pdfjs_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__w_pdfjs_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__w_pdfjs_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__w_pdfjs_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __w_pdfjs_require__(__w_pdfjs_require__.s = 36);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var compatibility = __w_pdfjs_require__(37);
var globalScope = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : undefined;
var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
var TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};
var ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};
var AnnotationType = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
};
var AnnotationFlag = {
  INVISIBLE: 0x01,
  HIDDEN: 0x02,
  PRINT: 0x04,
  NOZOOM: 0x08,
  NOROTATE: 0x10,
  NOVIEW: 0x20,
  READONLY: 0x40,
  LOCKED: 0x80,
  TOGGLENOVIEW: 0x100,
  LOCKEDCONTENTS: 0x200
};
var AnnotationFieldFlag = {
  READONLY: 0x0000001,
  REQUIRED: 0x0000002,
  NOEXPORT: 0x0000004,
  MULTILINE: 0x0001000,
  PASSWORD: 0x0002000,
  NOTOGGLETOOFF: 0x0004000,
  RADIO: 0x0008000,
  PUSHBUTTON: 0x0010000,
  COMBO: 0x0020000,
  EDIT: 0x0040000,
  SORT: 0x0080000,
  FILESELECT: 0x0100000,
  MULTISELECT: 0x0200000,
  DONOTSPELLCHECK: 0x0400000,
  DONOTSCROLL: 0x0800000,
  COMB: 0x1000000,
  RICHTEXT: 0x2000000,
  RADIOSINUNISON: 0x2000000,
  COMMITONSELCHANGE: 0x4000000
};
var AnnotationBorderStyleType = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
};
var StreamType = {
  UNKNOWN: 0,
  FLATE: 1,
  LZW: 2,
  DCT: 3,
  JPX: 4,
  JBIG: 5,
  A85: 6,
  AHX: 7,
  CCF: 8,
  RL: 9
};
var FontType = {
  UNKNOWN: 0,
  TYPE1: 1,
  TYPE1C: 2,
  CIDFONTTYPE0: 3,
  CIDFONTTYPE0C: 4,
  TRUETYPE: 5,
  CIDFONTTYPE2: 6,
  TYPE3: 7,
  OPENTYPE: 8,
  TYPE0: 9,
  MMTYPE1: 10
};
var VERBOSITY_LEVELS = {
  errors: 0,
  warnings: 1,
  infos: 5
};
var CMapCompressionType = {
  NONE: 0,
  BINARY: 1,
  STREAM: 2
};
var OPS = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotations: 78,
  endAnnotations: 79,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintJpegXObject: 82,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
};
var verbosity = VERBOSITY_LEVELS.warnings;
function setVerbosityLevel(level) {
  verbosity = level;
}
function getVerbosityLevel() {
  return verbosity;
}
function info(msg) {
  if (verbosity >= VERBOSITY_LEVELS.infos) {
    console.log('Info: ' + msg);
  }
}
function warn(msg) {
  if (verbosity >= VERBOSITY_LEVELS.warnings) {
    console.log('Warning: ' + msg);
  }
}
function deprecated(details) {
  console.log('Deprecated API usage: ' + details);
}
function error(msg) {
  if (verbosity >= VERBOSITY_LEVELS.errors) {
    console.log('Error: ' + msg);
    console.log(backtrace());
  }
  throw new Error(msg);
}
function backtrace() {
  try {
    throw new Error();
  } catch (e) {
    return e.stack ? e.stack.split('\n').slice(2).join('\n') : '';
  }
}
function assert(cond, msg) {
  if (!cond) {
    error(msg);
  }
}
var UNSUPPORTED_FEATURES = {
  unknown: 'unknown',
  forms: 'forms',
  javaScript: 'javaScript',
  smask: 'smask',
  shadingPattern: 'shadingPattern',
  font: 'font'
};
function isSameOrigin(baseUrl, otherUrl) {
  try {
    var base = new URL(baseUrl);
    if (!base.origin || base.origin === 'null') {
      return false;
    }
  } catch (e) {
    return false;
  }
  var other = new URL(otherUrl, base);
  return base.origin === other.origin;
}
function isValidProtocol(url) {
  if (!url) {
    return false;
  }
  switch (url.protocol) {
    case 'http:':
    case 'https:':
    case 'ftp:':
    case 'mailto:':
    case 'tel:':
      return true;
    default:
      return false;
  }
}
function createValidAbsoluteUrl(url, baseUrl) {
  if (!url) {
    return null;
  }
  try {
    var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
    if (isValidProtocol(absoluteUrl)) {
      return absoluteUrl;
    }
  } catch (ex) {}
  return null;
}
function shadow(obj, prop, value) {
  Object.defineProperty(obj, prop, {
    value: value,
    enumerable: true,
    configurable: true,
    writable: false
  });
  return value;
}
function getLookupTableFactory(initializer) {
  var lookup;
  return function () {
    if (initializer) {
      lookup = Object.create(null);
      initializer(lookup);
      initializer = null;
    }
    return lookup;
  };
}
var PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
var PasswordException = function PasswordExceptionClosure() {
  function PasswordException(msg, code) {
    this.name = 'PasswordException';
    this.message = msg;
    this.code = code;
  }
  PasswordException.prototype = new Error();
  PasswordException.constructor = PasswordException;
  return PasswordException;
}();
var UnknownErrorException = function UnknownErrorExceptionClosure() {
  function UnknownErrorException(msg, details) {
    this.name = 'UnknownErrorException';
    this.message = msg;
    this.details = details;
  }
  UnknownErrorException.prototype = new Error();
  UnknownErrorException.constructor = UnknownErrorException;
  return UnknownErrorException;
}();
var InvalidPDFException = function InvalidPDFExceptionClosure() {
  function InvalidPDFException(msg) {
    this.name = 'InvalidPDFException';
    this.message = msg;
  }
  InvalidPDFException.prototype = new Error();
  InvalidPDFException.constructor = InvalidPDFException;
  return InvalidPDFException;
}();
var MissingPDFException = function MissingPDFExceptionClosure() {
  function MissingPDFException(msg) {
    this.name = 'MissingPDFException';
    this.message = msg;
  }
  MissingPDFException.prototype = new Error();
  MissingPDFException.constructor = MissingPDFException;
  return MissingPDFException;
}();
var UnexpectedResponseException = function UnexpectedResponseExceptionClosure() {
  function UnexpectedResponseException(msg, status) {
    this.name = 'UnexpectedResponseException';
    this.message = msg;
    this.status = status;
  }
  UnexpectedResponseException.prototype = new Error();
  UnexpectedResponseException.constructor = UnexpectedResponseException;
  return UnexpectedResponseException;
}();
var NotImplementedException = function NotImplementedExceptionClosure() {
  function NotImplementedException(msg) {
    this.message = msg;
  }
  NotImplementedException.prototype = new Error();
  NotImplementedException.prototype.name = 'NotImplementedException';
  NotImplementedException.constructor = NotImplementedException;
  return NotImplementedException;
}();
var MissingDataException = function MissingDataExceptionClosure() {
  function MissingDataException(begin, end) {
    this.begin = begin;
    this.end = end;
    this.message = 'Missing data [' + begin + ', ' + end + ')';
  }
  MissingDataException.prototype = new Error();
  MissingDataException.prototype.name = 'MissingDataException';
  MissingDataException.constructor = MissingDataException;
  return MissingDataException;
}();
var XRefParseException = function XRefParseExceptionClosure() {
  function XRefParseException(msg) {
    this.message = msg;
  }
  XRefParseException.prototype = new Error();
  XRefParseException.prototype.name = 'XRefParseException';
  XRefParseException.constructor = XRefParseException;
  return XRefParseException;
}();
var NullCharactersRegExp = /\x00/g;
function removeNullCharacters(str) {
  if (typeof str !== 'string') {
    warn('The argument for removeNullCharacters must be a string.');
    return str;
  }
  return str.replace(NullCharactersRegExp, '');
}
function bytesToString(bytes) {
  assert(bytes !== null && (typeof bytes === 'undefined' ? 'undefined' : _typeof(bytes)) === 'object' && bytes.length !== undefined, 'Invalid argument for bytesToString');
  var length = bytes.length;
  var MAX_ARGUMENT_COUNT = 8192;
  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }
  var strBuf = [];
  for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    var chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }
  return strBuf.join('');
}
function stringToBytes(str) {
  assert(typeof str === 'string', 'Invalid argument for stringToBytes');
  var length = str.length;
  var bytes = new Uint8Array(length);
  for (var i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 0xFF;
  }
  return bytes;
}
function arrayByteLength(arr) {
  if (arr.length !== undefined) {
    return arr.length;
  }
  assert(arr.byteLength !== undefined);
  return arr.byteLength;
}
function arraysToBytes(arr) {
  if (arr.length === 1 && arr[0] instanceof Uint8Array) {
    return arr[0];
  }
  var resultLength = 0;
  var i,
      ii = arr.length;
  var item, itemLength;
  for (i = 0; i < ii; i++) {
    item = arr[i];
    itemLength = arrayByteLength(item);
    resultLength += itemLength;
  }
  var pos = 0;
  var data = new Uint8Array(resultLength);
  for (i = 0; i < ii; i++) {
    item = arr[i];
    if (!(item instanceof Uint8Array)) {
      if (typeof item === 'string') {
        item = stringToBytes(item);
      } else {
        item = new Uint8Array(item);
      }
    }
    itemLength = item.byteLength;
    data.set(item, pos);
    pos += itemLength;
  }
  return data;
}
function string32(value) {
  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
}
function log2(x) {
  var n = 1,
      i = 0;
  while (x > n) {
    n <<= 1;
    i++;
  }
  return i;
}
function readInt8(data, start) {
  return data[start] << 24 >> 24;
}
function readUint16(data, offset) {
  return data[offset] << 8 | data[offset + 1];
}
function readUint32(data, offset) {
  return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
}
function isLittleEndian() {
  var buffer8 = new Uint8Array(4);
  buffer8[0] = 1;
  var view32 = new Uint32Array(buffer8.buffer, 0, 1);
  return view32[0] === 1;
}
function isEvalSupported() {
  try {
    new Function('');
    return true;
  } catch (e) {
    return false;
  }
}
var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
var Util = function UtilClosure() {
  function Util() {}
  var rgbBuf = ['rgb(', 0, ',', 0, ',', 0, ')'];
  Util.makeCssRgb = function Util_makeCssRgb(r, g, b) {
    rgbBuf[1] = r;
    rgbBuf[3] = g;
    rgbBuf[5] = b;
    return rgbBuf.join('');
  };
  Util.transform = function Util_transform(m1, m2) {
    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
  };
  Util.applyTransform = function Util_applyTransform(p, m) {
    var xt = p[0] * m[0] + p[1] * m[2] + m[4];
    var yt = p[0] * m[1] + p[1] * m[3] + m[5];
    return [xt, yt];
  };
  Util.applyInverseTransform = function Util_applyInverseTransform(p, m) {
    var d = m[0] * m[3] - m[1] * m[2];
    var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    return [xt, yt];
  };
  Util.getAxialAlignedBoundingBox = function Util_getAxialAlignedBoundingBox(r, m) {
    var p1 = Util.applyTransform(r, m);
    var p2 = Util.applyTransform(r.slice(2, 4), m);
    var p3 = Util.applyTransform([r[0], r[3]], m);
    var p4 = Util.applyTransform([r[2], r[1]], m);
    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
  };
  Util.inverseTransform = function Util_inverseTransform(m) {
    var d = m[0] * m[3] - m[1] * m[2];
    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  };
  Util.apply3dTransform = function Util_apply3dTransform(m, v) {
    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
  };
  Util.singularValueDecompose2dScale = function Util_singularValueDecompose2dScale(m) {
    var transpose = [m[0], m[2], m[1], m[3]];
    var a = m[0] * transpose[0] + m[1] * transpose[2];
    var b = m[0] * transpose[1] + m[1] * transpose[3];
    var c = m[2] * transpose[0] + m[3] * transpose[2];
    var d = m[2] * transpose[1] + m[3] * transpose[3];
    var first = (a + d) / 2;
    var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
    var sx = first + second || 1;
    var sy = first - second || 1;
    return [Math.sqrt(sx), Math.sqrt(sy)];
  };
  Util.normalizeRect = function Util_normalizeRect(rect) {
    var r = rect.slice(0);
    if (rect[0] > rect[2]) {
      r[0] = rect[2];
      r[2] = rect[0];
    }
    if (rect[1] > rect[3]) {
      r[1] = rect[3];
      r[3] = rect[1];
    }
    return r;
  };
  Util.intersect = function Util_intersect(rect1, rect2) {
    function compare(a, b) {
      return a - b;
    }
    var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare),
        orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare),
        result = [];
    rect1 = Util.normalizeRect(rect1);
    rect2 = Util.normalizeRect(rect2);
    if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
      result[0] = orderedX[1];
      result[2] = orderedX[2];
    } else {
      return false;
    }
    if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
      result[1] = orderedY[1];
      result[3] = orderedY[2];
    } else {
      return false;
    }
    return result;
  };
  Util.sign = function Util_sign(num) {
    return num < 0 ? -1 : 1;
  };
  var ROMAN_NUMBER_MAP = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM', '', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC', '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];
  Util.toRoman = function Util_toRoman(number, lowerCase) {
    assert(isInt(number) && number > 0, 'The number should be a positive integer.');
    var pos,
        romanBuf = [];
    while (number >= 1000) {
      number -= 1000;
      romanBuf.push('M');
    }
    pos = number / 100 | 0;
    number %= 100;
    romanBuf.push(ROMAN_NUMBER_MAP[pos]);
    pos = number / 10 | 0;
    number %= 10;
    romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
    romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
    var romanStr = romanBuf.join('');
    return lowerCase ? romanStr.toLowerCase() : romanStr;
  };
  Util.appendToArray = function Util_appendToArray(arr1, arr2) {
    Array.prototype.push.apply(arr1, arr2);
  };
  Util.prependToArray = function Util_prependToArray(arr1, arr2) {
    Array.prototype.unshift.apply(arr1, arr2);
  };
  Util.extendObj = function extendObj(obj1, obj2) {
    for (var key in obj2) {
      obj1[key] = obj2[key];
    }
  };
  Util.getInheritableProperty = function Util_getInheritableProperty(dict, name, getArray) {
    while (dict && !dict.has(name)) {
      dict = dict.get('Parent');
    }
    if (!dict) {
      return null;
    }
    return getArray ? dict.getArray(name) : dict.get(name);
  };
  Util.inherit = function Util_inherit(sub, base, prototype) {
    sub.prototype = Object.create(base.prototype);
    sub.prototype.constructor = sub;
    for (var prop in prototype) {
      sub.prototype[prop] = prototype[prop];
    }
  };
  Util.loadScript = function Util_loadScript(src, callback) {
    var script = document.createElement('script');
    var loaded = false;
    script.setAttribute('src', src);
    if (callback) {
      script.onload = function () {
        if (!loaded) {
          callback();
        }
        loaded = true;
      };
    }
    document.getElementsByTagName('head')[0].appendChild(script);
  };
  return Util;
}();
var PageViewport = function PageViewportClosure() {
  function PageViewport(viewBox, scale, rotation, offsetX, offsetY, dontFlip) {
    this.viewBox = viewBox;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    var centerX = (viewBox[2] + viewBox[0]) / 2;
    var centerY = (viewBox[3] + viewBox[1]) / 2;
    var rotateA, rotateB, rotateC, rotateD;
    rotation = rotation % 360;
    rotation = rotation < 0 ? rotation + 360 : rotation;
    switch (rotation) {
      case 180:
        rotateA = -1;
        rotateB = 0;
        rotateC = 0;
        rotateD = 1;
        break;
      case 90:
        rotateA = 0;
        rotateB = 1;
        rotateC = 1;
        rotateD = 0;
        break;
      case 270:
        rotateA = 0;
        rotateB = -1;
        rotateC = -1;
        rotateD = 0;
        break;
      default:
        rotateA = 1;
        rotateB = 0;
        rotateC = 0;
        rotateD = -1;
        break;
    }
    if (dontFlip) {
      rotateC = -rotateC;
      rotateD = -rotateD;
    }
    var offsetCanvasX, offsetCanvasY;
    var width, height;
    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = Math.abs(viewBox[3] - viewBox[1]) * scale;
      height = Math.abs(viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = Math.abs(viewBox[2] - viewBox[0]) * scale;
      height = Math.abs(viewBox[3] - viewBox[1]) * scale;
    }
    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
    this.width = width;
    this.height = height;
    this.fontScale = scale;
  }
  PageViewport.prototype = {
    clone: function PageViewPort_clone(args) {
      args = args || {};
      var scale = 'scale' in args ? args.scale : this.scale;
      var rotation = 'rotation' in args ? args.rotation : this.rotation;
      return new PageViewport(this.viewBox.slice(), scale, rotation, this.offsetX, this.offsetY, args.dontFlip);
    },
    convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {
      return Util.applyTransform([x, y], this.transform);
    },
    convertToViewportRectangle: function PageViewport_convertToViewportRectangle(rect) {
      var tl = Util.applyTransform([rect[0], rect[1]], this.transform);
      var br = Util.applyTransform([rect[2], rect[3]], this.transform);
      return [tl[0], tl[1], br[0], br[1]];
    },
    convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {
      return Util.applyInverseTransform([x, y], this.transform);
    }
  };
  return PageViewport;
}();
var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];
function stringToPDFString(str) {
  var i,
      n = str.length,
      strBuf = [];
  if (str[0] === '\xFE' && str[1] === '\xFF') {
    for (i = 2; i < n; i += 2) {
      strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
    }
  } else {
    for (i = 0; i < n; ++i) {
      var code = PDFStringTranslateTable[str.charCodeAt(i)];
      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
    }
  }
  return strBuf.join('');
}
function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}
function utf8StringToString(str) {
  return unescape(encodeURIComponent(str));
}
function isEmptyObj(obj) {
  for (var key in obj) {
    return false;
  }
  return true;
}
function isBool(v) {
  return typeof v === 'boolean';
}
function isInt(v) {
  return typeof v === 'number' && (v | 0) === v;
}
function isNum(v) {
  return typeof v === 'number';
}
function isString(v) {
  return typeof v === 'string';
}
function isArray(v) {
  return v instanceof Array;
}
function isArrayBuffer(v) {
  return (typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object' && v !== null && v.byteLength !== undefined;
}
function isSpace(ch) {
  return ch === 0x20 || ch === 0x09 || ch === 0x0D || ch === 0x0A;
}
function isNodeJS() {
  if (typeof __pdfjsdev_webpack__ === 'undefined') {
    return (typeof process === 'undefined' ? 'undefined' : _typeof(process)) === 'object' && process + '' === '[object process]';
  }
  return false;
}
function createPromiseCapability() {
  var capability = {};
  capability.promise = new Promise(function (resolve, reject) {
    capability.resolve = resolve;
    capability.reject = reject;
  });
  return capability;
}
var StatTimer = function StatTimerClosure() {
  function rpad(str, pad, length) {
    while (str.length < length) {
      str += pad;
    }
    return str;
  }
  function StatTimer() {
    this.started = Object.create(null);
    this.times = [];
    this.enabled = true;
  }
  StatTimer.prototype = {
    time: function StatTimer_time(name) {
      if (!this.enabled) {
        return;
      }
      if (name in this.started) {
        warn('Timer is already running for ' + name);
      }
      this.started[name] = Date.now();
    },
    timeEnd: function StatTimer_timeEnd(name) {
      if (!this.enabled) {
        return;
      }
      if (!(name in this.started)) {
        warn('Timer has not been started for ' + name);
      }
      this.times.push({
        'name': name,
        'start': this.started[name],
        'end': Date.now()
      });
      delete this.started[name];
    },
    toString: function StatTimer_toString() {
      var i, ii;
      var times = this.times;
      var out = '';
      var longest = 0;
      for (i = 0, ii = times.length; i < ii; ++i) {
        var name = times[i]['name'];
        if (name.length > longest) {
          longest = name.length;
        }
      }
      for (i = 0, ii = times.length; i < ii; ++i) {
        var span = times[i];
        var duration = span.end - span.start;
        out += rpad(span['name'], ' ', longest) + ' ' + duration + 'ms\n';
      }
      return out;
    }
  };
  return StatTimer;
}();
var createBlob = function createBlob(data, contentType) {
  if (typeof Blob !== 'undefined') {
    return new Blob([data], { type: contentType });
  }
  warn('The "Blob" constructor is not supported.');
};
var createObjectURL = function createObjectURLClosure() {
  var digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  return function createObjectURL(data, contentType, forceDataSchema) {
    if (!forceDataSchema && typeof URL !== 'undefined' && URL.createObjectURL) {
      var blob = createBlob(data, contentType);
      return URL.createObjectURL(blob);
    }
    var buffer = 'data:' + contentType + ';base64,';
    for (var i = 0, ii = data.length; i < ii; i += 3) {
      var b1 = data[i] & 0xFF;
      var b2 = data[i + 1] & 0xFF;
      var b3 = data[i + 2] & 0xFF;
      var d1 = b1 >> 2,
          d2 = (b1 & 3) << 4 | b2 >> 4;
      var d3 = i + 1 < ii ? (b2 & 0xF) << 2 | b3 >> 6 : 64;
      var d4 = i + 2 < ii ? b3 & 0x3F : 64;
      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
    }
    return buffer;
  };
}();
function MessageHandler(sourceName, targetName, comObj) {
  this.sourceName = sourceName;
  this.targetName = targetName;
  this.comObj = comObj;
  this.callbackIndex = 1;
  this.postMessageTransfers = true;
  var callbacksCapabilities = this.callbacksCapabilities = Object.create(null);
  var ah = this.actionHandler = Object.create(null);
  this._onComObjOnMessage = function messageHandlerComObjOnMessage(event) {
    var data = event.data;
    if (data.targetName !== this.sourceName) {
      return;
    }
    if (data.isReply) {
      var callbackId = data.callbackId;
      if (data.callbackId in callbacksCapabilities) {
        var callback = callbacksCapabilities[callbackId];
        delete callbacksCapabilities[callbackId];
        if ('error' in data) {
          callback.reject(data.error);
        } else {
          callback.resolve(data.data);
        }
      } else {
        error('Cannot resolve callback ' + callbackId);
      }
    } else if (data.action in ah) {
      var action = ah[data.action];
      if (data.callbackId) {
        var sourceName = this.sourceName;
        var targetName = data.sourceName;
        Promise.resolve().then(function () {
          return action[0].call(action[1], data.data);
        }).then(function (result) {
          comObj.postMessage({
            sourceName: sourceName,
            targetName: targetName,
            isReply: true,
            callbackId: data.callbackId,
            data: result
          });
        }, function (reason) {
          if (reason instanceof Error) {
            reason = reason + '';
          }
          comObj.postMessage({
            sourceName: sourceName,
            targetName: targetName,
            isReply: true,
            callbackId: data.callbackId,
            error: reason
          });
        });
      } else {
        action[0].call(action[1], data.data);
      }
    } else {
      error('Unknown action from worker: ' + data.action);
    }
  }.bind(this);
  comObj.addEventListener('message', this._onComObjOnMessage);
}
MessageHandler.prototype = {
  on: function messageHandlerOn(actionName, handler, scope) {
    var ah = this.actionHandler;
    if (ah[actionName]) {
      error('There is already an actionName called "' + actionName + '"');
    }
    ah[actionName] = [handler, scope];
  },
  send: function messageHandlerSend(actionName, data, transfers) {
    var message = {
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data: data
    };
    this.postMessage(message, transfers);
  },
  sendWithPromise: function messageHandlerSendWithPromise(actionName, data, transfers) {
    var callbackId = this.callbackIndex++;
    var message = {
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data: data,
      callbackId: callbackId
    };
    var capability = createPromiseCapability();
    this.callbacksCapabilities[callbackId] = capability;
    try {
      this.postMessage(message, transfers);
    } catch (e) {
      capability.reject(e);
    }
    return capability.promise;
  },
  postMessage: function postMessage(message, transfers) {
    if (transfers && this.postMessageTransfers) {
      this.comObj.postMessage(message, transfers);
    } else {
      this.comObj.postMessage(message);
    }
  },
  destroy: function destroy() {
    this.comObj.removeEventListener('message', this._onComObjOnMessage);
  }
};
function loadJpegStream(id, imageUrl, objs) {
  var img = new Image();
  img.onload = function loadJpegStream_onloadClosure() {
    objs.resolve(id, img);
  };
  img.onerror = function loadJpegStream_onerrorClosure() {
    objs.resolve(id, null);
    warn('Error during JPEG image loading');
  };
  img.src = imageUrl;
}
exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
exports.OPS = OPS;
exports.VERBOSITY_LEVELS = VERBOSITY_LEVELS;
exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
exports.AnnotationFieldFlag = AnnotationFieldFlag;
exports.AnnotationFlag = AnnotationFlag;
exports.AnnotationType = AnnotationType;
exports.FontType = FontType;
exports.ImageKind = ImageKind;
exports.CMapCompressionType = CMapCompressionType;
exports.InvalidPDFException = InvalidPDFException;
exports.MessageHandler = MessageHandler;
exports.MissingDataException = MissingDataException;
exports.MissingPDFException = MissingPDFException;
exports.NotImplementedException = NotImplementedException;
exports.PageViewport = PageViewport;
exports.PasswordException = PasswordException;
exports.PasswordResponses = PasswordResponses;
exports.StatTimer = StatTimer;
exports.StreamType = StreamType;
exports.TextRenderingMode = TextRenderingMode;
exports.UnexpectedResponseException = UnexpectedResponseException;
exports.UnknownErrorException = UnknownErrorException;
exports.Util = Util;
exports.XRefParseException = XRefParseException;
exports.arrayByteLength = arrayByteLength;
exports.arraysToBytes = arraysToBytes;
exports.assert = assert;
exports.bytesToString = bytesToString;
exports.createBlob = createBlob;
exports.createPromiseCapability = createPromiseCapability;
exports.createObjectURL = createObjectURL;
exports.deprecated = deprecated;
exports.error = error;
exports.getLookupTableFactory = getLookupTableFactory;
exports.getVerbosityLevel = getVerbosityLevel;
exports.globalScope = globalScope;
exports.info = info;
exports.isArray = isArray;
exports.isArrayBuffer = isArrayBuffer;
exports.isBool = isBool;
exports.isEmptyObj = isEmptyObj;
exports.isInt = isInt;
exports.isNum = isNum;
exports.isString = isString;
exports.isSpace = isSpace;
exports.isNodeJS = isNodeJS;
exports.isSameOrigin = isSameOrigin;
exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
exports.isLittleEndian = isLittleEndian;
exports.isEvalSupported = isEvalSupported;
exports.loadJpegStream = loadJpegStream;
exports.log2 = log2;
exports.readInt8 = readInt8;
exports.readUint16 = readUint16;
exports.readUint32 = readUint32;
exports.removeNullCharacters = removeNullCharacters;
exports.setVerbosityLevel = setVerbosityLevel;
exports.shadow = shadow;
exports.string32 = string32;
exports.stringToBytes = stringToBytes;
exports.stringToPDFString = stringToPDFString;
exports.stringToUTF8String = stringToUTF8String;
exports.utf8StringToString = utf8StringToString;
exports.warn = warn;
/* WEBPACK VAR INJECTION */}.call(exports, __w_pdfjs_require__(9)))

/***/ }),
/* 1 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var sharedUtil = __w_pdfjs_require__(0);
var isArray = sharedUtil.isArray;
var EOF = {};
var Name = function NameClosure() {
  function Name(name) {
    this.name = name;
  }
  Name.prototype = {};
  var nameCache = Object.create(null);
  Name.get = function Name_get(name) {
    var nameValue = nameCache[name];
    return nameValue ? nameValue : nameCache[name] = new Name(name);
  };
  return Name;
}();
var Cmd = function CmdClosure() {
  function Cmd(cmd) {
    this.cmd = cmd;
  }
  Cmd.prototype = {};
  var cmdCache = Object.create(null);
  Cmd.get = function Cmd_get(cmd) {
    var cmdValue = cmdCache[cmd];
    return cmdValue ? cmdValue : cmdCache[cmd] = new Cmd(cmd);
  };
  return Cmd;
}();
var Dict = function DictClosure() {
  var nonSerializable = function nonSerializableClosure() {
    return nonSerializable;
  };
  function Dict(xref) {
    this.map = Object.create(null);
    this.xref = xref;
    this.objId = null;
    this.suppressEncryption = false;
    this.__nonSerializable__ = nonSerializable;
  }
  Dict.prototype = {
    assignXref: function Dict_assignXref(newXref) {
      this.xref = newXref;
    },
    get: function Dict_get(key1, key2, key3) {
      var value;
      var xref = this.xref,
          suppressEncryption = this.suppressEncryption;
      if (typeof (value = this.map[key1]) !== 'undefined' || key1 in this.map || typeof key2 === 'undefined') {
        return xref ? xref.fetchIfRef(value, suppressEncryption) : value;
      }
      if (typeof (value = this.map[key2]) !== 'undefined' || key2 in this.map || typeof key3 === 'undefined') {
        return xref ? xref.fetchIfRef(value, suppressEncryption) : value;
      }
      value = this.map[key3] || null;
      return xref ? xref.fetchIfRef(value, suppressEncryption) : value;
    },
    getAsync: function Dict_getAsync(key1, key2, key3) {
      var value;
      var xref = this.xref,
          suppressEncryption = this.suppressEncryption;
      if (typeof (value = this.map[key1]) !== 'undefined' || key1 in this.map || typeof key2 === 'undefined') {
        if (xref) {
          return xref.fetchIfRefAsync(value, suppressEncryption);
        }
        return Promise.resolve(value);
      }
      if (typeof (value = this.map[key2]) !== 'undefined' || key2 in this.map || typeof key3 === 'undefined') {
        if (xref) {
          return xref.fetchIfRefAsync(value, suppressEncryption);
        }
        return Promise.resolve(value);
      }
      value = this.map[key3] || null;
      if (xref) {
        return xref.fetchIfRefAsync(value, suppressEncryption);
      }
      return Promise.resolve(value);
    },
    getArray: function Dict_getArray(key1, key2, key3) {
      var value = this.get(key1, key2, key3);
      var xref = this.xref,
          suppressEncryption = this.suppressEncryption;
      if (!isArray(value) || !xref) {
        return value;
      }
      value = value.slice();
      for (var i = 0, ii = value.length; i < ii; i++) {
        if (!isRef(value[i])) {
          continue;
        }
        value[i] = xref.fetch(value[i], suppressEncryption);
      }
      return value;
    },
    getRaw: function Dict_getRaw(key) {
      return this.map[key];
    },
    getKeys: function Dict_getKeys() {
      return Object.keys(this.map);
    },
    set: function Dict_set(key, value) {
      this.map[key] = value;
    },
    has: function Dict_has(key) {
      return key in this.map;
    },
    forEach: function Dict_forEach(callback) {
      for (var key in this.map) {
        callback(key, this.get(key));
      }
    }
  };
  Dict.empty = new Dict(null);
  Dict.merge = function Dict_merge(xref, dictArray) {
    var mergedDict = new Dict(xref);
    for (var i = 0, ii = dictArray.length; i < ii; i++) {
      var dict = dictArray[i];
      if (!isDict(dict)) {
        continue;
      }
      for (var keyName in dict.map) {
        if (mergedDict.map[keyName]) {
          continue;
        }
        mergedDict.map[keyName] = dict.map[keyName];
      }
    }
    return mergedDict;
  };
  return Dict;
}();
var Ref = function RefClosure() {
  function Ref(num, gen) {
    this.num = num;
    this.gen = gen;
  }
  Ref.prototype = {
    toString: function Ref_toString() {
      var str = this.num + 'R';
      if (this.gen !== 0) {
        str += this.gen;
      }
      return str;
    }
  };
  return Ref;
}();
var RefSet = function RefSetClosure() {
  function RefSet() {
    this.dict = Object.create(null);
  }
  RefSet.prototype = {
    has: function RefSet_has(ref) {
      return ref.toString() in this.dict;
    },
    put: function RefSet_put(ref) {
      this.dict[ref.toString()] = true;
    },
    remove: function RefSet_remove(ref) {
      delete this.dict[ref.toString()];
    }
  };
  return RefSet;
}();
var RefSetCache = function RefSetCacheClosure() {
  function RefSetCache() {
    this.dict = Object.create(null);
  }
  RefSetCache.prototype = {
    get: function RefSetCache_get(ref) {
      return this.dict[ref.toString()];
    },
    has: function RefSetCache_has(ref) {
      return ref.toString() in this.dict;
    },
    put: function RefSetCache_put(ref, obj) {
      this.dict[ref.toString()] = obj;
    },
    putAlias: function RefSetCache_putAlias(ref, aliasRef) {
      this.dict[ref.toString()] = this.get(aliasRef);
    },
    forEach: function RefSetCache_forEach(fn, thisArg) {
      for (var i in this.dict) {
        fn.call(thisArg, this.dict[i]);
      }
    },
    clear: function RefSetCache_clear() {
      this.dict = Object.create(null);
    }
  };
  return RefSetCache;
}();
function isEOF(v) {
  return v === EOF;
}
function isName(v, name) {
  return v instanceof Name && (name === undefined || v.name === name);
}
function isCmd(v, cmd) {
  return v instanceof Cmd && (cmd === undefined || v.cmd === cmd);
}
function isDict(v, type) {
  return v instanceof Dict && (type === undefined || isName(v.get('Type'), type));
}
function isRef(v) {
  return v instanceof Ref;
}
function isRefsEqual(v1, v2) {
  return v1.num === v2.num && v1.gen === v2.gen;
}
function isStream(v) {
  return (typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object' && v !== null && v.getBytes !== undefined;
}
exports.EOF = EOF;
exports.Cmd = Cmd;
exports.Dict = Dict;
exports.Name = Name;
exports.Ref = Ref;
exports.RefSet = RefSet;
exports.RefSetCache = RefSetCache;
exports.isEOF = isEOF;
exports.isCmd = isCmd;
exports.isDict = isDict;
exports.isName = isName;
exports.isRef = isRef;
exports.isRefsEqual = isRefsEqual;
exports.isStream = isStream;

/***/ }),
/* 2 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var corePrimitives = __w_pdfjs_require__(1);
var coreJbig2 = __w_pdfjs_require__(28);
var coreJpg = __w_pdfjs_require__(29);
var coreJpx = __w_pdfjs_require__(15);
var Util = sharedUtil.Util;
var error = sharedUtil.error;
var info = sharedUtil.info;
var isInt = sharedUtil.isInt;
var isArray = sharedUtil.isArray;
var createObjectURL = sharedUtil.createObjectURL;
var shadow = sharedUtil.shadow;
var isSpace = sharedUtil.isSpace;
var Dict = corePrimitives.Dict;
var isDict = corePrimitives.isDict;
var isStream = corePrimitives.isStream;
var Jbig2Image = coreJbig2.Jbig2Image;
var JpegImage = coreJpg.JpegImage;
var JpxImage = coreJpx.JpxImage;
var Stream = function StreamClosure() {
  function Stream(arrayBuffer, start, length, dict) {
    this.bytes = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
    this.start = start || 0;
    this.pos = this.start;
    this.end = start + length || this.bytes.length;
    this.dict = dict;
  }
  Stream.prototype = {
    get length() {
      return this.end - this.start;
    },
    get isEmpty() {
      return this.length === 0;
    },
    getByte: function Stream_getByte() {
      if (this.pos >= this.end) {
        return -1;
      }
      return this.bytes[this.pos++];
    },
    getUint16: function Stream_getUint16() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      if (b0 === -1 || b1 === -1) {
        return -1;
      }
      return (b0 << 8) + b1;
    },
    getInt32: function Stream_getInt32() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      var b2 = this.getByte();
      var b3 = this.getByte();
      return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
    },
    getBytes: function Stream_getBytes(length) {
      var bytes = this.bytes;
      var pos = this.pos;
      var strEnd = this.end;
      if (!length) {
        return bytes.subarray(pos, strEnd);
      }
      var end = pos + length;
      if (end > strEnd) {
        end = strEnd;
      }
      this.pos = end;
      return bytes.subarray(pos, end);
    },
    peekByte: function Stream_peekByte() {
      var peekedByte = this.getByte();
      this.pos--;
      return peekedByte;
    },
    peekBytes: function Stream_peekBytes(length) {
      var bytes = this.getBytes(length);
      this.pos -= bytes.length;
      return bytes;
    },
    skip: function Stream_skip(n) {
      if (!n) {
        n = 1;
      }
      this.pos += n;
    },
    reset: function Stream_reset() {
      this.pos = this.start;
    },
    moveStart: function Stream_moveStart() {
      this.start = this.pos;
    },
    makeSubStream: function Stream_makeSubStream(start, length, dict) {
      return new Stream(this.bytes.buffer, start, length, dict);
    }
  };
  return Stream;
}();
var StringStream = function StringStreamClosure() {
  function StringStream(str) {
    var length = str.length;
    var bytes = new Uint8Array(length);
    for (var n = 0; n < length; ++n) {
      bytes[n] = str.charCodeAt(n);
    }
    Stream.call(this, bytes);
  }
  StringStream.prototype = Stream.prototype;
  return StringStream;
}();
var DecodeStream = function DecodeStreamClosure() {
  var emptyBuffer = new Uint8Array(0);
  function DecodeStream(maybeMinBufferLength) {
    this.pos = 0;
    this.bufferLength = 0;
    this.eof = false;
    this.buffer = emptyBuffer;
    this.minBufferLength = 512;
    if (maybeMinBufferLength) {
      while (this.minBufferLength < maybeMinBufferLength) {
        this.minBufferLength *= 2;
      }
    }
  }
  DecodeStream.prototype = {
    get isEmpty() {
      while (!this.eof && this.bufferLength === 0) {
        this.readBlock();
      }
      return this.bufferLength === 0;
    },
    ensureBuffer: function DecodeStream_ensureBuffer(requested) {
      var buffer = this.buffer;
      if (requested <= buffer.byteLength) {
        return buffer;
      }
      var size = this.minBufferLength;
      while (size < requested) {
        size *= 2;
      }
      var buffer2 = new Uint8Array(size);
      buffer2.set(buffer);
      return this.buffer = buffer2;
    },
    getByte: function DecodeStream_getByte() {
      var pos = this.pos;
      while (this.bufferLength <= pos) {
        if (this.eof) {
          return -1;
        }
        this.readBlock();
      }
      return this.buffer[this.pos++];
    },
    getUint16: function DecodeStream_getUint16() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      if (b0 === -1 || b1 === -1) {
        return -1;
      }
      return (b0 << 8) + b1;
    },
    getInt32: function DecodeStream_getInt32() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      var b2 = this.getByte();
      var b3 = this.getByte();
      return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
    },
    getBytes: function DecodeStream_getBytes(length) {
      var end,
          pos = this.pos;
      if (length) {
        this.ensureBuffer(pos + length);
        end = pos + length;
        while (!this.eof && this.bufferLength < end) {
          this.readBlock();
        }
        var bufEnd = this.bufferLength;
        if (end > bufEnd) {
          end = bufEnd;
        }
      } else {
        while (!this.eof) {
          this.readBlock();
        }
        end = this.bufferLength;
      }
      this.pos = end;
      return this.buffer.subarray(pos, end);
    },
    peekByte: function DecodeStream_peekByte() {
      var peekedByte = this.getByte();
      this.pos--;
      return peekedByte;
    },
    peekBytes: function DecodeStream_peekBytes(length) {
      var bytes = this.getBytes(length);
      this.pos -= bytes.length;
      return bytes;
    },
    makeSubStream: function DecodeStream_makeSubStream(start, length, dict) {
      var end = start + length;
      while (this.bufferLength <= end && !this.eof) {
        this.readBlock();
      }
      return new Stream(this.buffer, start, length, dict);
    },
    skip: function DecodeStream_skip(n) {
      if (!n) {
        n = 1;
      }
      this.pos += n;
    },
    reset: function DecodeStream_reset() {
      this.pos = 0;
    },
    getBaseStreams: function DecodeStream_getBaseStreams() {
      if (this.str && this.str.getBaseStreams) {
        return this.str.getBaseStreams();
      }
      return [];
    }
  };
  return DecodeStream;
}();
var StreamsSequenceStream = function StreamsSequenceStreamClosure() {
  function StreamsSequenceStream(streams) {
    this.streams = streams;
    DecodeStream.call(this, null);
  }
  StreamsSequenceStream.prototype = Object.create(DecodeStream.prototype);
  StreamsSequenceStream.prototype.readBlock = function streamSequenceStreamReadBlock() {
    var streams = this.streams;
    if (streams.length === 0) {
      this.eof = true;
      return;
    }
    var stream = streams.shift();
    var chunk = stream.getBytes();
    var bufferLength = this.bufferLength;
    var newLength = bufferLength + chunk.length;
    var buffer = this.ensureBuffer(newLength);
    buffer.set(chunk, bufferLength);
    this.bufferLength = newLength;
  };
  StreamsSequenceStream.prototype.getBaseStreams = function StreamsSequenceStream_getBaseStreams() {
    var baseStreams = [];
    for (var i = 0, ii = this.streams.length; i < ii; i++) {
      var stream = this.streams[i];
      if (stream.getBaseStreams) {
        Util.appendToArray(baseStreams, stream.getBaseStreams());
      }
    }
    return baseStreams;
  };
  return StreamsSequenceStream;
}();
var FlateStream = function FlateStreamClosure() {
  var codeLenCodeMap = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var lengthDecode = new Int32Array([0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a, 0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f, 0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073, 0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102]);
  var distDecode = new Int32Array([0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d, 0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1, 0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01, 0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001]);
  var fixedLitCodeTab = [new Int32Array([0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0, 0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0, 0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0, 0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8, 0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8, 0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8, 0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4, 0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4, 0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4, 0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc, 0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec, 0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc, 0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2, 0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2, 0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2, 0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca, 0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea, 0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da, 0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6, 0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6, 0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6, 0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce, 0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee, 0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de, 0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe, 0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1, 0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1, 0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1, 0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9, 0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9, 0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9, 0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5, 0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5, 0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5, 0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd, 0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed, 0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd, 0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3, 0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3, 0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3, 0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb, 0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb, 0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db, 0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7, 0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7, 0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7, 0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf, 0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef, 0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df, 0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff]), 9];
  var fixedDistCodeTab = [new Int32Array([0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c, 0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000, 0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d, 0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000]), 5];
  function FlateStream(str, maybeLength) {
    this.str = str;
    this.dict = str.dict;
    var cmf = str.getByte();
    var flg = str.getByte();
    if (cmf === -1 || flg === -1) {
      error('Invalid header in flate stream: ' + cmf + ', ' + flg);
    }
    if ((cmf & 0x0f) !== 0x08) {
      error('Unknown compression method in flate stream: ' + cmf + ', ' + flg);
    }
    if (((cmf << 8) + flg) % 31 !== 0) {
      error('Bad FCHECK in flate stream: ' + cmf + ', ' + flg);
    }
    if (flg & 0x20) {
      error('FDICT bit set in flate stream: ' + cmf + ', ' + flg);
    }
    this.codeSize = 0;
    this.codeBuf = 0;
    DecodeStream.call(this, maybeLength);
  }
  FlateStream.prototype = Object.create(DecodeStream.prototype);
  FlateStream.prototype.getBits = function FlateStream_getBits(bits) {
    var str = this.str;
    var codeSize = this.codeSize;
    var codeBuf = this.codeBuf;
    var b;
    while (codeSize < bits) {
      if ((b = str.getByte()) === -1) {
        error('Bad encoding in flate stream');
      }
      codeBuf |= b << codeSize;
      codeSize += 8;
    }
    b = codeBuf & (1 << bits) - 1;
    this.codeBuf = codeBuf >> bits;
    this.codeSize = codeSize -= bits;
    return b;
  };
  FlateStream.prototype.getCode = function FlateStream_getCode(table) {
    var str = this.str;
    var codes = table[0];
    var maxLen = table[1];
    var codeSize = this.codeSize;
    var codeBuf = this.codeBuf;
    var b;
    while (codeSize < maxLen) {
      if ((b = str.getByte()) === -1) {
        break;
      }
      codeBuf |= b << codeSize;
      codeSize += 8;
    }
    var code = codes[codeBuf & (1 << maxLen) - 1];
    var codeLen = code >> 16;
    var codeVal = code & 0xffff;
    if (codeLen < 1 || codeSize < codeLen) {
      error('Bad encoding in flate stream');
    }
    this.codeBuf = codeBuf >> codeLen;
    this.codeSize = codeSize - codeLen;
    return codeVal;
  };
  FlateStream.prototype.generateHuffmanTable = function flateStreamGenerateHuffmanTable(lengths) {
    var n = lengths.length;
    var maxLen = 0;
    var i;
    for (i = 0; i < n; ++i) {
      if (lengths[i] > maxLen) {
        maxLen = lengths[i];
      }
    }
    var size = 1 << maxLen;
    var codes = new Int32Array(size);
    for (var len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
      for (var val = 0; val < n; ++val) {
        if (lengths[val] === len) {
          var code2 = 0;
          var t = code;
          for (i = 0; i < len; ++i) {
            code2 = code2 << 1 | t & 1;
            t >>= 1;
          }
          for (i = code2; i < size; i += skip) {
            codes[i] = len << 16 | val;
          }
          ++code;
        }
      }
    }
    return [codes, maxLen];
  };
  FlateStream.prototype.readBlock = function FlateStream_readBlock() {
    var buffer, len;
    var str = this.str;
    var hdr = this.getBits(3);
    if (hdr & 1) {
      this.eof = true;
    }
    hdr >>= 1;
    if (hdr === 0) {
      var b;
      if ((b = str.getByte()) === -1) {
        error('Bad block header in flate stream');
      }
      var blockLen = b;
      if ((b = str.getByte()) === -1) {
        error('Bad block header in flate stream');
      }
      blockLen |= b << 8;
      if ((b = str.getByte()) === -1) {
        error('Bad block header in flate stream');
      }
      var check = b;
      if ((b = str.getByte()) === -1) {
        error('Bad block header in flate stream');
      }
      check |= b << 8;
      if (check !== (~blockLen & 0xffff) && (blockLen !== 0 || check !== 0)) {
        error('Bad uncompressed block length in flate stream');
      }
      this.codeBuf = 0;
      this.codeSize = 0;
      var bufferLength = this.bufferLength;
      buffer = this.ensureBuffer(bufferLength + blockLen);
      var end = bufferLength + blockLen;
      this.bufferLength = end;
      if (blockLen === 0) {
        if (str.peekByte() === -1) {
          this.eof = true;
        }
      } else {
        for (var n = bufferLength; n < end; ++n) {
          if ((b = str.getByte()) === -1) {
            this.eof = true;
            break;
          }
          buffer[n] = b;
        }
      }
      return;
    }
    var litCodeTable;
    var distCodeTable;
    if (hdr === 1) {
      litCodeTable = fixedLitCodeTab;
      distCodeTable = fixedDistCodeTab;
    } else if (hdr === 2) {
      var numLitCodes = this.getBits(5) + 257;
      var numDistCodes = this.getBits(5) + 1;
      var numCodeLenCodes = this.getBits(4) + 4;
      var codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
      var i;
      for (i = 0; i < numCodeLenCodes; ++i) {
        codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
      }
      var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
      len = 0;
      i = 0;
      var codes = numLitCodes + numDistCodes;
      var codeLengths = new Uint8Array(codes);
      var bitsLength, bitsOffset, what;
      while (i < codes) {
        var code = this.getCode(codeLenCodeTab);
        if (code === 16) {
          bitsLength = 2;
          bitsOffset = 3;
          what = len;
        } else if (code === 17) {
          bitsLength = 3;
          bitsOffset = 3;
          what = len = 0;
        } else if (code === 18) {
          bitsLength = 7;
          bitsOffset = 11;
          what = len = 0;
        } else {
          codeLengths[i++] = len = code;
          continue;
        }
        var repeatLength = this.getBits(bitsLength) + bitsOffset;
        while (repeatLength-- > 0) {
          codeLengths[i++] = what;
        }
      }
      litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
      distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
    } else {
      error('Unknown block type in flate stream');
    }
    buffer = this.buffer;
    var limit = buffer ? buffer.length : 0;
    var pos = this.bufferLength;
    while (true) {
      var code1 = this.getCode(litCodeTable);
      if (code1 < 256) {
        if (pos + 1 >= limit) {
          buffer = this.ensureBuffer(pos + 1);
          limit = buffer.length;
        }
        buffer[pos++] = code1;
        continue;
      }
      if (code1 === 256) {
        this.bufferLength = pos;
        return;
      }
      code1 -= 257;
      code1 = lengthDecode[code1];
      var code2 = code1 >> 16;
      if (code2 > 0) {
        code2 = this.getBits(code2);
      }
      len = (code1 & 0xffff) + code2;
      code1 = this.getCode(distCodeTable);
      code1 = distDecode[code1];
      code2 = code1 >> 16;
      if (code2 > 0) {
        code2 = this.getBits(code2);
      }
      var dist = (code1 & 0xffff) + code2;
      if (pos + len >= limit) {
        buffer = this.ensureBuffer(pos + len);
        limit = buffer.length;
      }
      for (var k = 0; k < len; ++k, ++pos) {
        buffer[pos] = buffer[pos - dist];
      }
    }
  };
  return FlateStream;
}();
var PredictorStream = function PredictorStreamClosure() {
  function PredictorStream(str, maybeLength, params) {
    if (!isDict(params)) {
      return str;
    }
    var predictor = this.predictor = params.get('Predictor') || 1;
    if (predictor <= 1) {
      return str;
    }
    if (predictor !== 2 && (predictor < 10 || predictor > 15)) {
      error('Unsupported predictor: ' + predictor);
    }
    if (predictor === 2) {
      this.readBlock = this.readBlockTiff;
    } else {
      this.readBlock = this.readBlockPng;
    }
    this.str = str;
    this.dict = str.dict;
    var colors = this.colors = params.get('Colors') || 1;
    var bits = this.bits = params.get('BitsPerComponent') || 8;
    var columns = this.columns = params.get('Columns') || 1;
    this.pixBytes = colors * bits + 7 >> 3;
    this.rowBytes = columns * colors * bits + 7 >> 3;
    DecodeStream.call(this, maybeLength);
    return this;
  }
  PredictorStream.prototype = Object.create(DecodeStream.prototype);
  PredictorStream.prototype.readBlockTiff = function predictorStreamReadBlockTiff() {
    var rowBytes = this.rowBytes;
    var bufferLength = this.bufferLength;
    var buffer = this.ensureBuffer(bufferLength + rowBytes);
    var bits = this.bits;
    var colors = this.colors;
    var rawBytes = this.str.getBytes(rowBytes);
    this.eof = !rawBytes.length;
    if (this.eof) {
      return;
    }
    var inbuf = 0,
        outbuf = 0;
    var inbits = 0,
        outbits = 0;
    var pos = bufferLength;
    var i;
    if (bits === 1 && colors === 1) {
      for (i = 0; i < rowBytes; ++i) {
        var c = rawBytes[i] ^ inbuf;
        c ^= c >> 1;
        c ^= c >> 2;
        c ^= c >> 4;
        inbuf = (c & 1) << 7;
        buffer[pos++] = c;
      }
    } else if (bits === 8) {
      for (i = 0; i < colors; ++i) {
        buffer[pos++] = rawBytes[i];
      }
      for (; i < rowBytes; ++i) {
        buffer[pos] = buffer[pos - colors] + rawBytes[i];
        pos++;
      }
    } else {
      var compArray = new Uint8Array(colors + 1);
      var bitMask = (1 << bits) - 1;
      var j = 0,
          k = bufferLength;
      var columns = this.columns;
      for (i = 0; i < columns; ++i) {
        for (var kk = 0; kk < colors; ++kk) {
          if (inbits < bits) {
            inbuf = inbuf << 8 | rawBytes[j++] & 0xFF;
            inbits += 8;
          }
          compArray[kk] = compArray[kk] + (inbuf >> inbits - bits) & bitMask;
          inbits -= bits;
          outbuf = outbuf << bits | compArray[kk];
          outbits += bits;
          if (outbits >= 8) {
            buffer[k++] = outbuf >> outbits - 8 & 0xFF;
            outbits -= 8;
          }
        }
      }
      if (outbits > 0) {
        buffer[k++] = (outbuf << 8 - outbits) + (inbuf & (1 << 8 - outbits) - 1);
      }
    }
    this.bufferLength += rowBytes;
  };
  PredictorStream.prototype.readBlockPng = function predictorStreamReadBlockPng() {
    var rowBytes = this.rowBytes;
    var pixBytes = this.pixBytes;
    var predictor = this.str.getByte();
    var rawBytes = this.str.getBytes(rowBytes);
    this.eof = !rawBytes.length;
    if (this.eof) {
      return;
    }
    var bufferLength = this.bufferLength;
    var buffer = this.ensureBuffer(bufferLength + rowBytes);
    var prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);
    if (prevRow.length === 0) {
      prevRow = new Uint8Array(rowBytes);
    }
    var i,
        j = bufferLength,
        up,
        c;
    switch (predictor) {
      case 0:
        for (i = 0; i < rowBytes; ++i) {
          buffer[j++] = rawBytes[i];
        }
        break;
      case 1:
        for (i = 0; i < pixBytes; ++i) {
          buffer[j++] = rawBytes[i];
        }
        for (; i < rowBytes; ++i) {
          buffer[j] = buffer[j - pixBytes] + rawBytes[i] & 0xFF;
          j++;
        }
        break;
      case 2:
        for (i = 0; i < rowBytes; ++i) {
          buffer[j++] = prevRow[i] + rawBytes[i] & 0xFF;
        }
        break;
      case 3:
        for (i = 0; i < pixBytes; ++i) {
          buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];
        }
        for (; i < rowBytes; ++i) {
          buffer[j] = (prevRow[i] + buffer[j - pixBytes] >> 1) + rawBytes[i] & 0xFF;
          j++;
        }
        break;
      case 4:
        for (i = 0; i < pixBytes; ++i) {
          up = prevRow[i];
          c = rawBytes[i];
          buffer[j++] = up + c;
        }
        for (; i < rowBytes; ++i) {
          up = prevRow[i];
          var upLeft = prevRow[i - pixBytes];
          var left = buffer[j - pixBytes];
          var p = left + up - upLeft;
          var pa = p - left;
          if (pa < 0) {
            pa = -pa;
          }
          var pb = p - up;
          if (pb < 0) {
            pb = -pb;
          }
          var pc = p - upLeft;
          if (pc < 0) {
            pc = -pc;
          }
          c = rawBytes[i];
          if (pa <= pb && pa <= pc) {
            buffer[j++] = left + c;
          } else if (pb <= pc) {
            buffer[j++] = up + c;
          } else {
            buffer[j++] = upLeft + c;
          }
        }
        break;
      default:
        error('Unsupported predictor: ' + predictor);
    }
    this.bufferLength += rowBytes;
  };
  return PredictorStream;
}();
var JpegStream = function JpegStreamClosure() {
  function JpegStream(stream, maybeLength, dict, params) {
    var ch;
    while ((ch = stream.getByte()) !== -1) {
      if (ch === 0xFF) {
        stream.skip(-1);
        break;
      }
    }
    this.stream = stream;
    this.maybeLength = maybeLength;
    this.dict = dict;
    this.params = params;
    DecodeStream.call(this, maybeLength);
  }
  JpegStream.prototype = Object.create(DecodeStream.prototype);
  Object.defineProperty(JpegStream.prototype, 'bytes', {
    get: function JpegStream_bytes() {
      return shadow(this, 'bytes', this.stream.getBytes(this.maybeLength));
    },
    configurable: true
  });
  JpegStream.prototype.ensureBuffer = function JpegStream_ensureBuffer(req) {
    if (this.bufferLength) {
      return;
    }
    var jpegImage = new JpegImage();
    var decodeArr = this.dict.getArray('Decode', 'D');
    if (this.forceRGB && isArray(decodeArr)) {
      var bitsPerComponent = this.dict.get('BitsPerComponent') || 8;
      var decodeArrLength = decodeArr.length;
      var transform = new Int32Array(decodeArrLength);
      var transformNeeded = false;
      var maxValue = (1 << bitsPerComponent) - 1;
      for (var i = 0; i < decodeArrLength; i += 2) {
        transform[i] = (decodeArr[i + 1] - decodeArr[i]) * 256 | 0;
        transform[i + 1] = decodeArr[i] * maxValue | 0;
        if (transform[i] !== 256 || transform[i + 1] !== 0) {
          transformNeeded = true;
        }
      }
      if (transformNeeded) {
        jpegImage.decodeTransform = transform;
      }
    }
    if (isDict(this.params)) {
      var colorTransform = this.params.get('ColorTransform');
      if (isInt(colorTransform)) {
        jpegImage.colorTransform = colorTransform;
      }
    }
    jpegImage.parse(this.bytes);
    var data = jpegImage.getData(this.drawWidth, this.drawHeight, this.forceRGB);
    this.buffer = data;
    this.bufferLength = data.length;
    this.eof = true;
  };
  JpegStream.prototype.getBytes = function JpegStream_getBytes(length) {
    this.ensureBuffer();
    return this.buffer;
  };
  JpegStream.prototype.getIR = function JpegStream_getIR(forceDataSchema) {
    return createObjectURL(this.bytes, 'image/jpeg', forceDataSchema);
  };
  return JpegStream;
}();
var JpxStream = function JpxStreamClosure() {
  function JpxStream(stream, maybeLength, dict, params) {
    this.stream = stream;
    this.maybeLength = maybeLength;
    this.dict = dict;
    this.params = params;
    DecodeStream.call(this, maybeLength);
  }
  JpxStream.prototype = Object.create(DecodeStream.prototype);
  Object.defineProperty(JpxStream.prototype, 'bytes', {
    get: function JpxStream_bytes() {
      return shadow(this, 'bytes', this.stream.getBytes(this.maybeLength));
    },
    configurable: true
  });
  JpxStream.prototype.ensureBuffer = function JpxStream_ensureBuffer(req) {
    if (this.bufferLength) {
      return;
    }
    var jpxImage = new JpxImage();
    jpxImage.parse(this.bytes);
    var width = jpxImage.width;
    var height = jpxImage.height;
    var componentsCount = jpxImage.componentsCount;
    var tileCount = jpxImage.tiles.length;
    if (tileCount === 1) {
      this.buffer = jpxImage.tiles[0].items;
    } else {
      var data = new Uint8Array(width * height * componentsCount);
      for (var k = 0; k < tileCount; k++) {
        var tileComponents = jpxImage.tiles[k];
        var tileWidth = tileComponents.width;
        var tileHeight = tileComponents.height;
        var tileLeft = tileComponents.left;
        var tileTop = tileComponents.top;
        var src = tileComponents.items;
        var srcPosition = 0;
        var dataPosition = (width * tileTop + tileLeft) * componentsCount;
        var imgRowSize = width * componentsCount;
        var tileRowSize = tileWidth * componentsCount;
        for (var j = 0; j < tileHeight; j++) {
          var rowBytes = src.subarray(srcPosition, srcPosition + tileRowSize);
          data.set(rowBytes, dataPosition);
          srcPosition += tileRowSize;
          dataPosition += imgRowSize;
        }
      }
      this.buffer = data;
    }
    this.bufferLength = this.buffer.length;
    this.eof = true;
  };
  return JpxStream;
}();
var Jbig2Stream = function Jbig2StreamClosure() {
  function Jbig2Stream(stream, maybeLength, dict, params) {
    this.stream = stream;
    this.maybeLength = maybeLength;
    this.dict = dict;
    this.params = params;
    DecodeStream.call(this, maybeLength);
  }
  Jbig2Stream.prototype = Object.create(DecodeStream.prototype);
  Object.defineProperty(Jbig2Stream.prototype, 'bytes', {
    get: function Jbig2Stream_bytes() {
      return shadow(this, 'bytes', this.stream.getBytes(this.maybeLength));
    },
    configurable: true
  });
  Jbig2Stream.prototype.ensureBuffer = function Jbig2Stream_ensureBuffer(req) {
    if (this.bufferLength) {
      return;
    }
    var jbig2Image = new Jbig2Image();
    var chunks = [];
    if (isDict(this.params)) {
      var globalsStream = this.params.get('JBIG2Globals');
      if (isStream(globalsStream)) {
        var globals = globalsStream.getBytes();
        chunks.push({
          data: globals,
          start: 0,
          end: globals.length
        });
      }
    }
    chunks.push({
      data: this.bytes,
      start: 0,
      end: this.bytes.length
    });
    var data = jbig2Image.parseChunks(chunks);
    var dataLength = data.length;
    for (var i = 0; i < dataLength; i++) {
      data[i] ^= 0xFF;
    }
    this.buffer = data;
    this.bufferLength = dataLength;
    this.eof = true;
  };
  return Jbig2Stream;
}();
var DecryptStream = function DecryptStreamClosure() {
  function DecryptStream(str, maybeLength, decrypt) {
    this.str = str;
    this.dict = str.dict;
    this.decrypt = decrypt;
    this.nextChunk = null;
    this.initialized = false;
    DecodeStream.call(this, maybeLength);
  }
  var chunkSize = 512;
  DecryptStream.prototype = Object.create(DecodeStream.prototype);
  DecryptStream.prototype.readBlock = function DecryptStream_readBlock() {
    var chunk;
    if (this.initialized) {
      chunk = this.nextChunk;
    } else {
      chunk = this.str.getBytes(chunkSize);
      this.initialized = true;
    }
    if (!chunk || chunk.length === 0) {
      this.eof = true;
      return;
    }
    this.nextChunk = this.str.getBytes(chunkSize);
    var hasMoreData = this.nextChunk && this.nextChunk.length > 0;
    var decrypt = this.decrypt;
    chunk = decrypt(chunk, !hasMoreData);
    var bufferLength = this.bufferLength;
    var i,
        n = chunk.length;
    var buffer = this.ensureBuffer(bufferLength + n);
    for (i = 0; i < n; i++) {
      buffer[bufferLength++] = chunk[i];
    }
    this.bufferLength = bufferLength;
  };
  return DecryptStream;
}();
var Ascii85Stream = function Ascii85StreamClosure() {
  function Ascii85Stream(str, maybeLength) {
    this.str = str;
    this.dict = str.dict;
    this.input = new Uint8Array(5);
    if (maybeLength) {
      maybeLength = 0.8 * maybeLength;
    }
    DecodeStream.call(this, maybeLength);
  }
  Ascii85Stream.prototype = Object.create(DecodeStream.prototype);
  Ascii85Stream.prototype.readBlock = function Ascii85Stream_readBlock() {
    var TILDA_CHAR = 0x7E;
    var Z_LOWER_CHAR = 0x7A;
    var EOF = -1;
    var str = this.str;
    var c = str.getByte();
    while (isSpace(c)) {
      c = str.getByte();
    }
    if (c === EOF || c === TILDA_CHAR) {
      this.eof = true;
      return;
    }
    var bufferLength = this.bufferLength,
        buffer;
    var i;
    if (c === Z_LOWER_CHAR) {
      buffer = this.ensureBuffer(bufferLength + 4);
      for (i = 0; i < 4; ++i) {
        buffer[bufferLength + i] = 0;
      }
      this.bufferLength += 4;
    } else {
      var input = this.input;
      input[0] = c;
      for (i = 1; i < 5; ++i) {
        c = str.getByte();
        while (isSpace(c)) {
          c = str.getByte();
        }
        input[i] = c;
        if (c === EOF || c === TILDA_CHAR) {
          break;
        }
      }
      buffer = this.ensureBuffer(bufferLength + i - 1);
      this.bufferLength += i - 1;
      if (i < 5) {
        for (; i < 5; ++i) {
          input[i] = 0x21 + 84;
        }
        this.eof = true;
      }
      var t = 0;
      for (i = 0; i < 5; ++i) {
        t = t * 85 + (input[i] - 0x21);
      }
      for (i = 3; i >= 0; --i) {
        buffer[bufferLength + i] = t & 0xFF;
        t >>= 8;
      }
    }
  };
  return Ascii85Stream;
}();
var AsciiHexStream = function AsciiHexStreamClosure() {
  function AsciiHexStream(str, maybeLength) {
    this.str = str;
    this.dict = str.dict;
    this.firstDigit = -1;
    if (maybeLength) {
      maybeLength = 0.5 * maybeLength;
    }
    DecodeStream.call(this, maybeLength);
  }
  AsciiHexStream.prototype = Object.create(DecodeStream.prototype);
  AsciiHexStream.prototype.readBlock = function AsciiHexStream_readBlock() {
    var UPSTREAM_BLOCK_SIZE = 8000;
    var bytes = this.str.getBytes(UPSTREAM_BLOCK_SIZE);
    if (!bytes.length) {
      this.eof = true;
      return;
    }
    var maxDecodeLength = bytes.length + 1 >> 1;
    var buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
    var bufferLength = this.bufferLength;
    var firstDigit = this.firstDigit;
    for (var i = 0, ii = bytes.length; i < ii; i++) {
      var ch = bytes[i],
          digit;
      if (ch >= 0x30 && ch <= 0x39) {
        digit = ch & 0x0F;
      } else if (ch >= 0x41 && ch <= 0x46 || ch >= 0x61 && ch <= 0x66) {
        digit = (ch & 0x0F) + 9;
      } else if (ch === 0x3E) {
        this.eof = true;
        break;
      } else {
        continue;
      }
      if (firstDigit < 0) {
        firstDigit = digit;
      } else {
        buffer[bufferLength++] = firstDigit << 4 | digit;
        firstDigit = -1;
      }
    }
    if (firstDigit >= 0 && this.eof) {
      buffer[bufferLength++] = firstDigit << 4;
      firstDigit = -1;
    }
    this.firstDigit = firstDigit;
    this.bufferLength = bufferLength;
  };
  return AsciiHexStream;
}();
var RunLengthStream = function RunLengthStreamClosure() {
  function RunLengthStream(str, maybeLength) {
    this.str = str;
    this.dict = str.dict;
    DecodeStream.call(this, maybeLength);
  }
  RunLengthStream.prototype = Object.create(DecodeStream.prototype);
  RunLengthStream.prototype.readBlock = function RunLengthStream_readBlock() {
    var repeatHeader = this.str.getBytes(2);
    if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
      this.eof = true;
      return;
    }
    var buffer;
    var bufferLength = this.bufferLength;
    var n = repeatHeader[0];
    if (n < 128) {
      buffer = this.ensureBuffer(bufferLength + n + 1);
      buffer[bufferLength++] = repeatHeader[1];
      if (n > 0) {
        var source = this.str.getBytes(n);
        buffer.set(source, bufferLength);
        bufferLength += n;
      }
    } else {
      n = 257 - n;
      var b = repeatHeader[1];
      buffer = this.ensureBuffer(bufferLength + n + 1);
      for (var i = 0; i < n; i++) {
        buffer[bufferLength++] = b;
      }
    }
    this.bufferLength = bufferLength;
  };
  return RunLengthStream;
}();
var CCITTFaxStream = function CCITTFaxStreamClosure() {
  var ccittEOL = -2;
  var ccittEOF = -1;
  var twoDimPass = 0;
  var twoDimHoriz = 1;
  var twoDimVert0 = 2;
  var twoDimVertR1 = 3;
  var twoDimVertL1 = 4;
  var twoDimVertR2 = 5;
  var twoDimVertL2 = 6;
  var twoDimVertR3 = 7;
  var twoDimVertL3 = 8;
  var twoDimTable = [[-1, -1], [-1, -1], [7, twoDimVertL3], [7, twoDimVertR3], [6, twoDimVertL2], [6, twoDimVertL2], [6, twoDimVertR2], [6, twoDimVertR2], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0]];
  var whiteTable1 = [[-1, -1], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]];
  var whiteTable2 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]];
  var blackTable1 = [[-1, -1], [-1, -1], [12, ccittEOL], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]];
  var blackTable2 = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]];
  var blackTable3 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
  function CCITTFaxStream(str, maybeLength, params) {
    this.str = str;
    this.dict = str.dict;
    params = params || Dict.empty;
    this.encoding = params.get('K') || 0;
    this.eoline = params.get('EndOfLine') || false;
    this.byteAlign = params.get('EncodedByteAlign') || false;
    this.columns = params.get('Columns') || 1728;
    this.rows = params.get('Rows') || 0;
    var eoblock = params.get('EndOfBlock');
    if (eoblock === null || eoblock === undefined) {
      eoblock = true;
    }
    this.eoblock = eoblock;
    this.black = params.get('BlackIs1') || false;
    this.codingLine = new Uint32Array(this.columns + 1);
    this.refLine = new Uint32Array(this.columns + 2);
    this.codingLine[0] = this.columns;
    this.codingPos = 0;
    this.row = 0;
    this.nextLine2D = this.encoding < 0;
    this.inputBits = 0;
    this.inputBuf = 0;
    this.outputBits = 0;
    var code1;
    while ((code1 = this.lookBits(12)) === 0) {
      this.eatBits(1);
    }
    if (code1 === 1) {
      this.eatBits(12);
    }
    if (this.encoding > 0) {
      this.nextLine2D = !this.lookBits(1);
      this.eatBits(1);
    }
    DecodeStream.call(this, maybeLength);
  }
  CCITTFaxStream.prototype = Object.create(DecodeStream.prototype);
  CCITTFaxStream.prototype.readBlock = function CCITTFaxStream_readBlock() {
    while (!this.eof) {
      var c = this.lookChar();
      this.ensureBuffer(this.bufferLength + 1);
      this.buffer[this.bufferLength++] = c;
    }
  };
  CCITTFaxStream.prototype.addPixels = function ccittFaxStreamAddPixels(a1, blackPixels) {
    var codingLine = this.codingLine;
    var codingPos = this.codingPos;
    if (a1 > codingLine[codingPos]) {
      if (a1 > this.columns) {
        info('row is wrong length');
        this.err = true;
        a1 = this.columns;
      }
      if (codingPos & 1 ^ blackPixels) {
        ++codingPos;
      }
      codingLine[codingPos] = a1;
    }
    this.codingPos = codingPos;
  };
  CCITTFaxStream.prototype.addPixelsNeg = function ccittFaxStreamAddPixelsNeg(a1, blackPixels) {
    var codingLine = this.codingLine;
    var codingPos = this.codingPos;
    if (a1 > codingLine[codingPos]) {
      if (a1 > this.columns) {
        info('row is wrong length');
        this.err = true;
        a1 = this.columns;
      }
      if (codingPos & 1 ^ blackPixels) {
        ++codingPos;
      }
      codingLine[codingPos] = a1;
    } else if (a1 < codingLine[codingPos]) {
      if (a1 < 0) {
        info('invalid code');
        this.err = true;
        a1 = 0;
      }
      while (codingPos > 0 && a1 < codingLine[codingPos - 1]) {
        --codingPos;
      }
      codingLine[codingPos] = a1;
    }
    this.codingPos = codingPos;
  };
  CCITTFaxStream.prototype.lookChar = function CCITTFaxStream_lookChar() {
    var refLine = this.refLine;
    var codingLine = this.codingLine;
    var columns = this.columns;
    var refPos, blackPixels, bits, i;
    if (this.outputBits === 0) {
      if (this.eof) {
        return null;
      }
      this.err = false;
      var code1, code2, code3;
      if (this.nextLine2D) {
        for (i = 0; codingLine[i] < columns; ++i) {
          refLine[i] = codingLine[i];
        }
        refLine[i++] = columns;
        refLine[i] = columns;
        codingLine[0] = 0;
        this.codingPos = 0;
        refPos = 0;
        blackPixels = 0;
        while (codingLine[this.codingPos] < columns) {
          code1 = this.getTwoDimCode();
          switch (code1) {
            case twoDimPass:
              this.addPixels(refLine[refPos + 1], blackPixels);
              if (refLine[refPos + 1] < columns) {
                refPos += 2;
              }
              break;
            case twoDimHoriz:
              code1 = code2 = 0;
              if (blackPixels) {
                do {
                  code1 += code3 = this.getBlackCode();
                } while (code3 >= 64);
                do {
                  code2 += code3 = this.getWhiteCode();
                } while (code3 >= 64);
              } else {
                do {
                  code1 += code3 = this.getWhiteCode();
                } while (code3 >= 64);
                do {
                  code2 += code3 = this.getBlackCode();
                } while (code3 >= 64);
              }
              this.addPixels(codingLine[this.codingPos] + code1, blackPixels);
              if (codingLine[this.codingPos] < columns) {
                this.addPixels(codingLine[this.codingPos] + code2, blackPixels ^ 1);
              }
              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                refPos += 2;
              }
              break;
            case twoDimVertR3:
              this.addPixels(refLine[refPos] + 3, blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                ++refPos;
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case twoDimVertR2:
              this.addPixels(refLine[refPos] + 2, blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                ++refPos;
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case twoDimVertR1:
              this.addPixels(refLine[refPos] + 1, blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                ++refPos;
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case twoDimVert0:
              this.addPixels(refLine[refPos], blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                ++refPos;
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case twoDimVertL3:
              this.addPixelsNeg(refLine[refPos] - 3, blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                if (refPos > 0) {
                  --refPos;
                } else {
                  ++refPos;
                }
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case twoDimVertL2:
              this.addPixelsNeg(refLine[refPos] - 2, blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                if (refPos > 0) {
                  --refPos;
                } else {
                  ++refPos;
                }
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case twoDimVertL1:
              this.addPixelsNeg(refLine[refPos] - 1, blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                if (refPos > 0) {
                  --refPos;
                } else {
                  ++refPos;
                }
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case ccittEOF:
              this.addPixels(columns, 0);
              this.eof = true;
              break;
            default:
              info('bad 2d code');
              this.addPixels(columns, 0);
              this.err = true;
          }
        }
      } else {
        codingLine[0] = 0;
        this.codingPos = 0;
        blackPixels = 0;
        while (codingLine[this.codingPos] < columns) {
          code1 = 0;
          if (blackPixels) {
            do {
              code1 += code3 = this.getBlackCode();
            } while (code3 >= 64);
          } else {
            do {
              code1 += code3 = this.getWhiteCode();
            } while (code3 >= 64);
          }
          this.addPixels(codingLine[this.codingPos] + code1, blackPixels);
          blackPixels ^= 1;
        }
      }
      var gotEOL = false;
      if (this.byteAlign) {
        this.inputBits &= ~7;
      }
      if (!this.eoblock && this.row === this.rows - 1) {
        this.eof = true;
      } else {
        code1 = this.lookBits(12);
        if (this.eoline) {
          while (code1 !== ccittEOF && code1 !== 1) {
            this.eatBits(1);
            code1 = this.lookBits(12);
          }
        } else {
          while (code1 === 0) {
            this.eatBits(1);
            code1 = this.lookBits(12);
          }
        }
        if (code1 === 1) {
          this.eatBits(12);
          gotEOL = true;
        } else if (code1 === ccittEOF) {
          this.eof = true;
        }
      }
      if (!this.eof && this.encoding > 0) {
        this.nextLine2D = !this.lookBits(1);
        this.eatBits(1);
      }
      if (this.eoblock && gotEOL && this.byteAlign) {
        code1 = this.lookBits(12);
        if (code1 === 1) {
          this.eatBits(12);
          if (this.encoding > 0) {
            this.lookBits(1);
            this.eatBits(1);
          }
          if (this.encoding >= 0) {
            for (i = 0; i < 4; ++i) {
              code1 = this.lookBits(12);
              if (code1 !== 1) {
                info('bad rtc code: ' + code1);
              }
              this.eatBits(12);
              if (this.encoding > 0) {
                this.lookBits(1);
                this.eatBits(1);
              }
            }
          }
          this.eof = true;
        }
      } else if (this.err && this.eoline) {
        while (true) {
          code1 = this.lookBits(13);
          if (code1 === ccittEOF) {
            this.eof = true;
            return null;
          }
          if (code1 >> 1 === 1) {
            break;
          }
          this.eatBits(1);
        }
        this.eatBits(12);
        if (this.encoding > 0) {
          this.eatBits(1);
          this.nextLine2D = !(code1 & 1);
        }
      }
      if (codingLine[0] > 0) {
        this.outputBits = codingLine[this.codingPos = 0];
      } else {
        this.outputBits = codingLine[this.codingPos = 1];
      }
      this.row++;
    }
    var c;
    if (this.outputBits >= 8) {
      c = this.codingPos & 1 ? 0 : 0xFF;
      this.outputBits -= 8;
      if (this.outputBits === 0 && codingLine[this.codingPos] < columns) {
        this.codingPos++;
        this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
      }
    } else {
      bits = 8;
      c = 0;
      do {
        if (this.outputBits > bits) {
          c <<= bits;
          if (!(this.codingPos & 1)) {
            c |= 0xFF >> 8 - bits;
          }
          this.outputBits -= bits;
          bits = 0;
        } else {
          c <<= this.outputBits;
          if (!(this.codingPos & 1)) {
            c |= 0xFF >> 8 - this.outputBits;
          }
          bits -= this.outputBits;
          this.outputBits = 0;
          if (codingLine[this.codingPos] < columns) {
            this.codingPos++;
            this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
          } else if (bits > 0) {
            c <<= bits;
            bits = 0;
          }
        }
      } while (bits);
    }
    if (this.black) {
      c ^= 0xFF;
    }
    return c;
  };
  CCITTFaxStream.prototype.findTableCode = function ccittFaxStreamFindTableCode(start, end, table, limit) {
    var limitValue = limit || 0;
    for (var i = start; i <= end; ++i) {
      var code = this.lookBits(i);
      if (code === ccittEOF) {
        return [true, 1, false];
      }
      if (i < end) {
        code <<= end - i;
      }
      if (!limitValue || code >= limitValue) {
        var p = table[code - limitValue];
        if (p[0] === i) {
          this.eatBits(i);
          return [true, p[1], true];
        }
      }
    }
    return [false, 0, false];
  };
  CCITTFaxStream.prototype.getTwoDimCode = function ccittFaxStreamGetTwoDimCode() {
    var code = 0;
    var p;
    if (this.eoblock) {
      code = this.lookBits(7);
      p = twoDimTable[code];
      if (p && p[0] > 0) {
        this.eatBits(p[0]);
        return p[1];
      }
    } else {
      var result = this.findTableCode(1, 7, twoDimTable);
      if (result[0] && result[2]) {
        return result[1];
      }
    }
    info('Bad two dim code');
    return ccittEOF;
  };
  CCITTFaxStream.prototype.getWhiteCode = function ccittFaxStreamGetWhiteCode() {
    var code = 0;
    var p;
    if (this.eoblock) {
      code = this.lookBits(12);
      if (code === ccittEOF) {
        return 1;
      }
      if (code >> 5 === 0) {
        p = whiteTable1[code];
      } else {
        p = whiteTable2[code >> 3];
      }
      if (p[0] > 0) {
        this.eatBits(p[0]);
        return p[1];
      }
    } else {
      var result = this.findTableCode(1, 9, whiteTable2);
      if (result[0]) {
        return result[1];
      }
      result = this.findTableCode(11, 12, whiteTable1);
      if (result[0]) {
        return result[1];
      }
    }
    info('bad white code');
    this.eatBits(1);
    return 1;
  };
  CCITTFaxStream.prototype.getBlackCode = function ccittFaxStreamGetBlackCode() {
    var code, p;
    if (this.eoblock) {
      code = this.lookBits(13);
      if (code === ccittEOF) {
        return 1;
      }
      if (code >> 7 === 0) {
        p = blackTable1[code];
      } else if (code >> 9 === 0 && code >> 7 !== 0) {
        p = blackTable2[(code >> 1) - 64];
      } else {
        p = blackTable3[code >> 7];
      }
      if (p[0] > 0) {
        this.eatBits(p[0]);
        return p[1];
      }
    } else {
      var result = this.findTableCode(2, 6, blackTable3);
      if (result[0]) {
        return result[1];
      }
      result = this.findTableCode(7, 12, blackTable2, 64);
      if (result[0]) {
        return result[1];
      }
      result = this.findTableCode(10, 13, blackTable1);
      if (result[0]) {
        return result[1];
      }
    }
    info('bad black code');
    this.eatBits(1);
    return 1;
  };
  CCITTFaxStream.prototype.lookBits = function CCITTFaxStream_lookBits(n) {
    var c;
    while (this.inputBits < n) {
      if ((c = this.str.getByte()) === -1) {
        if (this.inputBits === 0) {
          return ccittEOF;
        }
        return this.inputBuf << n - this.inputBits & 0xFFFF >> 16 - n;
      }
      this.inputBuf = this.inputBuf << 8 | c;
      this.inputBits += 8;
    }
    return this.inputBuf >> this.inputBits - n & 0xFFFF >> 16 - n;
  };
  CCITTFaxStream.prototype.eatBits = function CCITTFaxStream_eatBits(n) {
    if ((this.inputBits -= n) < 0) {
      this.inputBits = 0;
    }
  };
  return CCITTFaxStream;
}();
var LZWStream = function LZWStreamClosure() {
  function LZWStream(str, maybeLength, earlyChange) {
    this.str = str;
    this.dict = str.dict;
    this.cachedData = 0;
    this.bitsCached = 0;
    var maxLzwDictionarySize = 4096;
    var lzwState = {
      earlyChange: earlyChange,
      codeLength: 9,
      nextCode: 258,
      dictionaryValues: new Uint8Array(maxLzwDictionarySize),
      dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
      dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
      currentSequence: new Uint8Array(maxLzwDictionarySize),
      currentSequenceLength: 0
    };
    for (var i = 0; i < 256; ++i) {
      lzwState.dictionaryValues[i] = i;
      lzwState.dictionaryLengths[i] = 1;
    }
    this.lzwState = lzwState;
    DecodeStream.call(this, maybeLength);
  }
  LZWStream.prototype = Object.create(DecodeStream.prototype);
  LZWStream.prototype.readBits = function LZWStream_readBits(n) {
    var bitsCached = this.bitsCached;
    var cachedData = this.cachedData;
    while (bitsCached < n) {
      var c = this.str.getByte();
      if (c === -1) {
        this.eof = true;
        return null;
      }
      cachedData = cachedData << 8 | c;
      bitsCached += 8;
    }
    this.bitsCached = bitsCached -= n;
    this.cachedData = cachedData;
    this.lastCode = null;
    return cachedData >>> bitsCached & (1 << n) - 1;
  };
  LZWStream.prototype.readBlock = function LZWStream_readBlock() {
    var blockSize = 512;
    var estimatedDecodedSize = blockSize * 2,
        decodedSizeDelta = blockSize;
    var i, j, q;
    var lzwState = this.lzwState;
    if (!lzwState) {
      return;
    }
    var earlyChange = lzwState.earlyChange;
    var nextCode = lzwState.nextCode;
    var dictionaryValues = lzwState.dictionaryValues;
    var dictionaryLengths = lzwState.dictionaryLengths;
    var dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
    var codeLength = lzwState.codeLength;
    var prevCode = lzwState.prevCode;
    var currentSequence = lzwState.currentSequence;
    var currentSequenceLength = lzwState.currentSequenceLength;
    var decodedLength = 0;
    var currentBufferLength = this.bufferLength;
    var buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
    for (i = 0; i < blockSize; i++) {
      var code = this.readBits(codeLength);
      var hasPrev = currentSequenceLength > 0;
      if (code < 256) {
        currentSequence[0] = code;
        currentSequenceLength = 1;
      } else if (code >= 258) {
        if (code < nextCode) {
          currentSequenceLength = dictionaryLengths[code];
          for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {
            currentSequence[j] = dictionaryValues[q];
            q = dictionaryPrevCodes[q];
          }
        } else {
          currentSequence[currentSequenceLength++] = currentSequence[0];
        }
      } else if (code === 256) {
        codeLength = 9;
        nextCode = 258;
        currentSequenceLength = 0;
        continue;
      } else {
        this.eof = true;
        delete this.lzwState;
        break;
      }
      if (hasPrev) {
        dictionaryPrevCodes[nextCode] = prevCode;
        dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
        dictionaryValues[nextCode] = currentSequence[0];
        nextCode++;
        codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
      }
      prevCode = code;
      decodedLength += currentSequenceLength;
      if (estimatedDecodedSize < decodedLength) {
        do {
          estimatedDecodedSize += decodedSizeDelta;
        } while (estimatedDecodedSize < decodedLength);
        buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
      }
      for (j = 0; j < currentSequenceLength; j++) {
        buffer[currentBufferLength++] = currentSequence[j];
      }
    }
    lzwState.nextCode = nextCode;
    lzwState.codeLength = codeLength;
    lzwState.prevCode = prevCode;
    lzwState.currentSequenceLength = currentSequenceLength;
    this.bufferLength = currentBufferLength;
  };
  return LZWStream;
}();
var NullStream = function NullStreamClosure() {
  function NullStream() {
    Stream.call(this, new Uint8Array(0));
  }
  NullStream.prototype = Stream.prototype;
  return NullStream;
}();
exports.Ascii85Stream = Ascii85Stream;
exports.AsciiHexStream = AsciiHexStream;
exports.CCITTFaxStream = CCITTFaxStream;
exports.DecryptStream = DecryptStream;
exports.DecodeStream = DecodeStream;
exports.FlateStream = FlateStream;
exports.Jbig2Stream = Jbig2Stream;
exports.JpegStream = JpegStream;
exports.JpxStream = JpxStream;
exports.NullStream = NullStream;
exports.PredictorStream = PredictorStream;
exports.RunLengthStream = RunLengthStream;
exports.Stream = Stream;
exports.StreamsSequenceStream = StreamsSequenceStream;
exports.StringStream = StringStream;
exports.LZWStream = LZWStream;

/***/ }),
/* 3 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var corePrimitives = __w_pdfjs_require__(1);
var coreFunction = __w_pdfjs_require__(6);
var error = sharedUtil.error;
var info = sharedUtil.info;
var isArray = sharedUtil.isArray;
var isString = sharedUtil.isString;
var shadow = sharedUtil.shadow;
var warn = sharedUtil.warn;
var isDict = corePrimitives.isDict;
var isName = corePrimitives.isName;
var isStream = corePrimitives.isStream;
var PDFFunction = coreFunction.PDFFunction;
var ColorSpace = function ColorSpaceClosure() {
  function resizeRgbImage(src, bpc, w1, h1, w2, h2, alpha01, dest) {
    var COMPONENTS = 3;
    alpha01 = alpha01 !== 1 ? 0 : alpha01;
    var xRatio = w1 / w2;
    var yRatio = h1 / h2;
    var i,
        j,
        py,
        newIndex = 0,
        oldIndex;
    var xScaled = new Uint16Array(w2);
    var w1Scanline = w1 * COMPONENTS;
    for (i = 0; i < w2; i++) {
      xScaled[i] = Math.floor(i * xRatio) * COMPONENTS;
    }
    for (i = 0; i < h2; i++) {
      py = Math.floor(i * yRatio) * w1Scanline;
      for (j = 0; j < w2; j++) {
        oldIndex = py + xScaled[j];
        dest[newIndex++] = src[oldIndex++];
        dest[newIndex++] = src[oldIndex++];
        dest[newIndex++] = src[oldIndex++];
        newIndex += alpha01;
      }
    }
  }
  function ColorSpace() {
    error('should not call ColorSpace constructor');
  }
  ColorSpace.prototype = {
    getRgb: function ColorSpace_getRgb(src, srcOffset) {
      var rgb = new Uint8Array(3);
      this.getRgbItem(src, srcOffset, rgb, 0);
      return rgb;
    },
    getRgbItem: function ColorSpace_getRgbItem(src, srcOffset, dest, destOffset) {
      error('Should not call ColorSpace.getRgbItem');
    },
    getRgbBuffer: function ColorSpace_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      error('Should not call ColorSpace.getRgbBuffer');
    },
    getOutputLength: function ColorSpace_getOutputLength(inputLength, alpha01) {
      error('Should not call ColorSpace.getOutputLength');
    },
    isPassthrough: function ColorSpace_isPassthrough(bits) {
      return false;
    },
    fillRgb: function ColorSpace_fillRgb(dest, originalWidth, originalHeight, width, height, actualHeight, bpc, comps, alpha01) {
      var count = originalWidth * originalHeight;
      var rgbBuf = null;
      var numComponentColors = 1 << bpc;
      var needsResizing = originalHeight !== height || originalWidth !== width;
      var i, ii;
      if (this.isPassthrough(bpc)) {
        rgbBuf = comps;
      } else if (this.numComps === 1 && count > numComponentColors && this.name !== 'DeviceGray' && this.name !== 'DeviceRGB') {
        var allColors = bpc <= 8 ? new Uint8Array(numComponentColors) : new Uint16Array(numComponentColors);
        var key;
        for (i = 0; i < numComponentColors; i++) {
          allColors[i] = i;
        }
        var colorMap = new Uint8Array(numComponentColors * 3);
        this.getRgbBuffer(allColors, 0, numComponentColors, colorMap, 0, bpc, 0);
        var destPos, rgbPos;
        if (!needsResizing) {
          destPos = 0;
          for (i = 0; i < count; ++i) {
            key = comps[i] * 3;
            dest[destPos++] = colorMap[key];
            dest[destPos++] = colorMap[key + 1];
            dest[destPos++] = colorMap[key + 2];
            destPos += alpha01;
          }
        } else {
          rgbBuf = new Uint8Array(count * 3);
          rgbPos = 0;
          for (i = 0; i < count; ++i) {
            key = comps[i] * 3;
            rgbBuf[rgbPos++] = colorMap[key];
            rgbBuf[rgbPos++] = colorMap[key + 1];
            rgbBuf[rgbPos++] = colorMap[key + 2];
          }
        }
      } else {
        if (!needsResizing) {
          this.getRgbBuffer(comps, 0, width * actualHeight, dest, 0, bpc, alpha01);
        } else {
          rgbBuf = new Uint8Array(count * 3);
          this.getRgbBuffer(comps, 0, count, rgbBuf, 0, bpc, 0);
        }
      }
      if (rgbBuf) {
        if (needsResizing) {
          resizeRgbImage(rgbBuf, bpc, originalWidth, originalHeight, width, height, alpha01, dest);
        } else {
          rgbPos = 0;
          destPos = 0;
          for (i = 0, ii = width * actualHeight; i < ii; i++) {
            dest[destPos++] = rgbBuf[rgbPos++];
            dest[destPos++] = rgbBuf[rgbPos++];
            dest[destPos++] = rgbBuf[rgbPos++];
            destPos += alpha01;
          }
        }
      }
    },
    usesZeroToOneRange: true
  };
  ColorSpace.parse = function ColorSpace_parse(cs, xref, res) {
    var IR = ColorSpace.parseToIR(cs, xref, res);
    if (IR instanceof AlternateCS) {
      return IR;
    }
    return ColorSpace.fromIR(IR);
  };
  ColorSpace.fromIR = function ColorSpace_fromIR(IR) {
    var name = isArray(IR) ? IR[0] : IR;
    var whitePoint, blackPoint, gamma;
    switch (name) {
      case 'DeviceGrayCS':
        return this.singletons.gray;
      case 'DeviceRgbCS':
        return this.singletons.rgb;
      case 'DeviceCmykCS':
        return this.singletons.cmyk;
      case 'CalGrayCS':
        whitePoint = IR[1];
        blackPoint = IR[2];
        gamma = IR[3];
        return new CalGrayCS(whitePoint, blackPoint, gamma);
      case 'CalRGBCS':
        whitePoint = IR[1];
        blackPoint = IR[2];
        gamma = IR[3];
        var matrix = IR[4];
        return new CalRGBCS(whitePoint, blackPoint, gamma, matrix);
      case 'PatternCS':
        var basePatternCS = IR[1];
        if (basePatternCS) {
          basePatternCS = ColorSpace.fromIR(basePatternCS);
        }
        return new PatternCS(basePatternCS);
      case 'IndexedCS':
        var baseIndexedCS = IR[1];
        var hiVal = IR[2];
        var lookup = IR[3];
        return new IndexedCS(ColorSpace.fromIR(baseIndexedCS), hiVal, lookup);
      case 'AlternateCS':
        var numComps = IR[1];
        var alt = IR[2];
        var tintFnIR = IR[3];
        return new AlternateCS(numComps, ColorSpace.fromIR(alt), PDFFunction.fromIR(tintFnIR));
      case 'LabCS':
        whitePoint = IR[1];
        blackPoint = IR[2];
        var range = IR[3];
        return new LabCS(whitePoint, blackPoint, range);
      default:
        error('Unknown name ' + name);
    }
    return null;
  };
  ColorSpace.parseToIR = function ColorSpace_parseToIR(cs, xref, res) {
    if (isName(cs)) {
      var colorSpaces = res.get('ColorSpace');
      if (isDict(colorSpaces)) {
        var refcs = colorSpaces.get(cs.name);
        if (refcs) {
          cs = refcs;
        }
      }
    }
    cs = xref.fetchIfRef(cs);
    if (isName(cs)) {
      switch (cs.name) {
        case 'DeviceGray':
        case 'G':
          return 'DeviceGrayCS';
        case 'DeviceRGB':
        case 'RGB':
          return 'DeviceRgbCS';
        case 'DeviceCMYK':
        case 'CMYK':
          return 'DeviceCmykCS';
        case 'Pattern':
          return ['PatternCS', null];
        default:
          error('unrecognized colorspace ' + cs.name);
      }
    } else if (isArray(cs)) {
      var mode = xref.fetchIfRef(cs[0]).name;
      var numComps, params, alt, whitePoint, blackPoint, gamma;
      switch (mode) {
        case 'DeviceGray':
        case 'G':
          return 'DeviceGrayCS';
        case 'DeviceRGB':
        case 'RGB':
          return 'DeviceRgbCS';
        case 'DeviceCMYK':
        case 'CMYK':
          return 'DeviceCmykCS';
        case 'CalGray':
          params = xref.fetchIfRef(cs[1]);
          whitePoint = params.getArray('WhitePoint');
          blackPoint = params.getArray('BlackPoint');
          gamma = params.get('Gamma');
          return ['CalGrayCS', whitePoint, blackPoint, gamma];
        case 'CalRGB':
          params = xref.fetchIfRef(cs[1]);
          whitePoint = params.getArray('WhitePoint');
          blackPoint = params.getArray('BlackPoint');
          gamma = params.getArray('Gamma');
          var matrix = params.getArray('Matrix');
          return ['CalRGBCS', whitePoint, blackPoint, gamma, matrix];
        case 'ICCBased':
          var stream = xref.fetchIfRef(cs[1]);
          var dict = stream.dict;
          numComps = dict.get('N');
          alt = dict.get('Alternate');
          if (alt) {
            var altIR = ColorSpace.parseToIR(alt, xref, res);
            var altCS = ColorSpace.fromIR(altIR);
            if (altCS.numComps === numComps) {
              return altIR;
            }
            warn('ICCBased color space: Ignoring incorrect /Alternate entry.');
          }
          if (numComps === 1) {
            return 'DeviceGrayCS';
          } else if (numComps === 3) {
            return 'DeviceRgbCS';
          } else if (numComps === 4) {
            return 'DeviceCmykCS';
          }
          break;
        case 'Pattern':
          var basePatternCS = cs[1] || null;
          if (basePatternCS) {
            basePatternCS = ColorSpace.parseToIR(basePatternCS, xref, res);
          }
          return ['PatternCS', basePatternCS];
        case 'Indexed':
        case 'I':
          var baseIndexedCS = ColorSpace.parseToIR(cs[1], xref, res);
          var hiVal = xref.fetchIfRef(cs[2]) + 1;
          var lookup = xref.fetchIfRef(cs[3]);
          if (isStream(lookup)) {
            lookup = lookup.getBytes();
          }
          return ['IndexedCS', baseIndexedCS, hiVal, lookup];
        case 'Separation':
        case 'DeviceN':
          var name = xref.fetchIfRef(cs[1]);
          numComps = isArray(name) ? name.length : 1;
          alt = ColorSpace.parseToIR(cs[2], xref, res);
          var tintFnIR = PDFFunction.getIR(xref, xref.fetchIfRef(cs[3]));
          return ['AlternateCS', numComps, alt, tintFnIR];
        case 'Lab':
          params = xref.fetchIfRef(cs[1]);
          whitePoint = params.getArray('WhitePoint');
          blackPoint = params.getArray('BlackPoint');
          var range = params.getArray('Range');
          return ['LabCS', whitePoint, blackPoint, range];
        default:
          error('unimplemented color space object "' + mode + '"');
      }
    } else {
      error('unrecognized color space object: "' + cs + '"');
    }
    return null;
  };
  ColorSpace.isDefaultDecode = function ColorSpace_isDefaultDecode(decode, n) {
    if (!isArray(decode)) {
      return true;
    }
    if (n * 2 !== decode.length) {
      warn('The decode map is not the correct length');
      return true;
    }
    for (var i = 0, ii = decode.length; i < ii; i += 2) {
      if (decode[i] !== 0 || decode[i + 1] !== 1) {
        return false;
      }
    }
    return true;
  };
  ColorSpace.singletons = {
    get gray() {
      return shadow(this, 'gray', new DeviceGrayCS());
    },
    get rgb() {
      return shadow(this, 'rgb', new DeviceRgbCS());
    },
    get cmyk() {
      return shadow(this, 'cmyk', new DeviceCmykCS());
    }
  };
  return ColorSpace;
}();
var AlternateCS = function AlternateCSClosure() {
  function AlternateCS(numComps, base, tintFn) {
    this.name = 'Alternate';
    this.numComps = numComps;
    this.defaultColor = new Float32Array(numComps);
    for (var i = 0; i < numComps; ++i) {
      this.defaultColor[i] = 1;
    }
    this.base = base;
    this.tintFn = tintFn;
    this.tmpBuf = new Float32Array(base.numComps);
  }
  AlternateCS.prototype = {
    getRgb: ColorSpace.prototype.getRgb,
    getRgbItem: function AlternateCS_getRgbItem(src, srcOffset, dest, destOffset) {
      var tmpBuf = this.tmpBuf;
      this.tintFn(src, srcOffset, tmpBuf, 0);
      this.base.getRgbItem(tmpBuf, 0, dest, destOffset);
    },
    getRgbBuffer: function AlternateCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      var tintFn = this.tintFn;
      var base = this.base;
      var scale = 1 / ((1 << bits) - 1);
      var baseNumComps = base.numComps;
      var usesZeroToOneRange = base.usesZeroToOneRange;
      var isPassthrough = (base.isPassthrough(8) || !usesZeroToOneRange) && alpha01 === 0;
      var pos = isPassthrough ? destOffset : 0;
      var baseBuf = isPassthrough ? dest : new Uint8Array(baseNumComps * count);
      var numComps = this.numComps;
      var scaled = new Float32Array(numComps);
      var tinted = new Float32Array(baseNumComps);
      var i, j;
      for (i = 0; i < count; i++) {
        for (j = 0; j < numComps; j++) {
          scaled[j] = src[srcOffset++] * scale;
        }
        tintFn(scaled, 0, tinted, 0);
        if (usesZeroToOneRange) {
          for (j = 0; j < baseNumComps; j++) {
            baseBuf[pos++] = tinted[j] * 255;
          }
        } else {
          base.getRgbItem(tinted, 0, baseBuf, pos);
          pos += baseNumComps;
        }
      }
      if (!isPassthrough) {
        base.getRgbBuffer(baseBuf, 0, count, dest, destOffset, 8, alpha01);
      }
    },
    getOutputLength: function AlternateCS_getOutputLength(inputLength, alpha01) {
      return this.base.getOutputLength(inputLength * this.base.numComps / this.numComps, alpha01);
    },
    isPassthrough: ColorSpace.prototype.isPassthrough,
    fillRgb: ColorSpace.prototype.fillRgb,
    isDefaultDecode: function AlternateCS_isDefaultDecode(decodeMap) {
      return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
    },
    usesZeroToOneRange: true
  };
  return AlternateCS;
}();
var PatternCS = function PatternCSClosure() {
  function PatternCS(baseCS) {
    this.name = 'Pattern';
    this.base = baseCS;
  }
  PatternCS.prototype = {};
  return PatternCS;
}();
var IndexedCS = function IndexedCSClosure() {
  function IndexedCS(base, highVal, lookup) {
    this.name = 'Indexed';
    this.numComps = 1;
    this.defaultColor = new Uint8Array(this.numComps);
    this.base = base;
    this.highVal = highVal;
    var baseNumComps = base.numComps;
    var length = baseNumComps * highVal;
    if (isStream(lookup)) {
      this.lookup = new Uint8Array(length);
      var bytes = lookup.getBytes(length);
      this.lookup.set(bytes);
    } else if (isString(lookup)) {
      this.lookup = new Uint8Array(length);
      for (var i = 0; i < length; ++i) {
        this.lookup[i] = lookup.charCodeAt(i);
      }
    } else if (lookup instanceof Uint8Array || lookup instanceof Array) {
      this.lookup = lookup;
    } else {
      error('Unrecognized lookup table: ' + lookup);
    }
  }
  IndexedCS.prototype = {
    getRgb: ColorSpace.prototype.getRgb,
    getRgbItem: function IndexedCS_getRgbItem(src, srcOffset, dest, destOffset) {
      var numComps = this.base.numComps;
      var start = src[srcOffset] * numComps;
      this.base.getRgbItem(this.lookup, start, dest, destOffset);
    },
    getRgbBuffer: function IndexedCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      var base = this.base;
      var numComps = base.numComps;
      var outputDelta = base.getOutputLength(numComps, alpha01);
      var lookup = this.lookup;
      for (var i = 0; i < count; ++i) {
        var lookupPos = src[srcOffset++] * numComps;
        base.getRgbBuffer(lookup, lookupPos, 1, dest, destOffset, 8, alpha01);
        destOffset += outputDelta;
      }
    },
    getOutputLength: function IndexedCS_getOutputLength(inputLength, alpha01) {
      return this.base.getOutputLength(inputLength * this.base.numComps, alpha01);
    },
    isPassthrough: ColorSpace.prototype.isPassthrough,
    fillRgb: ColorSpace.prototype.fillRgb,
    isDefaultDecode: function IndexedCS_isDefaultDecode(decodeMap) {
      return true;
    },
    usesZeroToOneRange: true
  };
  return IndexedCS;
}();
var DeviceGrayCS = function DeviceGrayCSClosure() {
  function DeviceGrayCS() {
    this.name = 'DeviceGray';
    this.numComps = 1;
    this.defaultColor = new Float32Array(this.numComps);
  }
  DeviceGrayCS.prototype = {
    getRgb: ColorSpace.prototype.getRgb,
    getRgbItem: function DeviceGrayCS_getRgbItem(src, srcOffset, dest, destOffset) {
      var c = src[srcOffset] * 255 | 0;
      c = c < 0 ? 0 : c > 255 ? 255 : c;
      dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = c;
    },
    getRgbBuffer: function DeviceGrayCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      var scale = 255 / ((1 << bits) - 1);
      var j = srcOffset,
          q = destOffset;
      for (var i = 0; i < count; ++i) {
        var c = scale * src[j++] | 0;
        dest[q++] = c;
        dest[q++] = c;
        dest[q++] = c;
        q += alpha01;
      }
    },
    getOutputLength: function DeviceGrayCS_getOutputLength(inputLength, alpha01) {
      return inputLength * (3 + alpha01);
    },
    isPassthrough: ColorSpace.prototype.isPassthrough,
    fillRgb: ColorSpace.prototype.fillRgb,
    isDefaultDecode: function DeviceGrayCS_isDefaultDecode(decodeMap) {
      return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
    },
    usesZeroToOneRange: true
  };
  return DeviceGrayCS;
}();
var DeviceRgbCS = function DeviceRgbCSClosure() {
  function DeviceRgbCS() {
    this.name = 'DeviceRGB';
    this.numComps = 3;
    this.defaultColor = new Float32Array(this.numComps);
  }
  DeviceRgbCS.prototype = {
    getRgb: ColorSpace.prototype.getRgb,
    getRgbItem: function DeviceRgbCS_getRgbItem(src, srcOffset, dest, destOffset) {
      var r = src[srcOffset] * 255 | 0;
      var g = src[srcOffset + 1] * 255 | 0;
      var b = src[srcOffset + 2] * 255 | 0;
      dest[destOffset] = r < 0 ? 0 : r > 255 ? 255 : r;
      dest[destOffset + 1] = g < 0 ? 0 : g > 255 ? 255 : g;
      dest[destOffset + 2] = b < 0 ? 0 : b > 255 ? 255 : b;
    },
    getRgbBuffer: function DeviceRgbCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      if (bits === 8 && alpha01 === 0) {
        dest.set(src.subarray(srcOffset, srcOffset + count * 3), destOffset);
        return;
      }
      var scale = 255 / ((1 << bits) - 1);
      var j = srcOffset,
          q = destOffset;
      for (var i = 0; i < count; ++i) {
        dest[q++] = scale * src[j++] | 0;
        dest[q++] = scale * src[j++] | 0;
        dest[q++] = scale * src[j++] | 0;
        q += alpha01;
      }
    },
    getOutputLength: function DeviceRgbCS_getOutputLength(inputLength, alpha01) {
      return inputLength * (3 + alpha01) / 3 | 0;
    },
    isPassthrough: function DeviceRgbCS_isPassthrough(bits) {
      return bits === 8;
    },
    fillRgb: ColorSpace.prototype.fillRgb,
    isDefaultDecode: function DeviceRgbCS_isDefaultDecode(decodeMap) {
      return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
    },
    usesZeroToOneRange: true
  };
  return DeviceRgbCS;
}();
var DeviceCmykCS = function DeviceCmykCSClosure() {
  function convertToRgb(src, srcOffset, srcScale, dest, destOffset) {
    var c = src[srcOffset + 0] * srcScale;
    var m = src[srcOffset + 1] * srcScale;
    var y = src[srcOffset + 2] * srcScale;
    var k = src[srcOffset + 3] * srcScale;
    var r = c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k + -285.2331026137004) + m * (1.7149763477362134 * m - 5.6096736904047315 * y + -17.873870861415444 * k - 5.497006427196366) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 17.5119270841813) + k * (-21.86122147463605 * k - 189.48180835922747) + 255 | 0;
    var g = c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k + -79.2970844816548) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 190.9453302588951) + y * (4.444339102852739 * y + 9.8632861493405 * k - 24.86741582555878) + k * (-20.737325471181034 * k - 187.80453709719578) + 255 | 0;
    var b = c * (0.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - 0.23883238689178934 * k + -14.183576799673286) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 112.23884253719248) + y * (0.03296041114873217 * y + 115.60384449646641 * k + -193.58209356861505) + k * (-22.33816807309886 * k - 180.12613974708367) + 255 | 0;
    dest[destOffset] = r > 255 ? 255 : r < 0 ? 0 : r;
    dest[destOffset + 1] = g > 255 ? 255 : g < 0 ? 0 : g;
    dest[destOffset + 2] = b > 255 ? 255 : b < 0 ? 0 : b;
  }
  function DeviceCmykCS() {
    this.name = 'DeviceCMYK';
    this.numComps = 4;
    this.defaultColor = new Float32Array(this.numComps);
    this.defaultColor[3] = 1;
  }
  DeviceCmykCS.prototype = {
    getRgb: ColorSpace.prototype.getRgb,
    getRgbItem: function DeviceCmykCS_getRgbItem(src, srcOffset, dest, destOffset) {
      convertToRgb(src, srcOffset, 1, dest, destOffset);
    },
    getRgbBuffer: function DeviceCmykCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      var scale = 1 / ((1 << bits) - 1);
      for (var i = 0; i < count; i++) {
        convertToRgb(src, srcOffset, scale, dest, destOffset);
        srcOffset += 4;
        destOffset += 3 + alpha01;
      }
    },
    getOutputLength: function DeviceCmykCS_getOutputLength(inputLength, alpha01) {
      return inputLength / 4 * (3 + alpha01) | 0;
    },
    isPassthrough: ColorSpace.prototype.isPassthrough,
    fillRgb: ColorSpace.prototype.fillRgb,
    isDefaultDecode: function DeviceCmykCS_isDefaultDecode(decodeMap) {
      return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
    },
    usesZeroToOneRange: true
  };
  return DeviceCmykCS;
}();
var CalGrayCS = function CalGrayCSClosure() {
  function CalGrayCS(whitePoint, blackPoint, gamma) {
    this.name = 'CalGray';
    this.numComps = 1;
    this.defaultColor = new Float32Array(this.numComps);
    if (!whitePoint) {
      error('WhitePoint missing - required for color space CalGray');
    }
    blackPoint = blackPoint || [0, 0, 0];
    gamma = gamma || 1;
    this.XW = whitePoint[0];
    this.YW = whitePoint[1];
    this.ZW = whitePoint[2];
    this.XB = blackPoint[0];
    this.YB = blackPoint[1];
    this.ZB = blackPoint[2];
    this.G = gamma;
    if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
      error('Invalid WhitePoint components for ' + this.name + ', no fallback available');
    }
    if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
      info('Invalid BlackPoint for ' + this.name + ', falling back to default');
      this.XB = this.YB = this.ZB = 0;
    }
    if (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) {
      warn(this.name + ', BlackPoint: XB: ' + this.XB + ', YB: ' + this.YB + ', ZB: ' + this.ZB + ', only default values are supported.');
    }
    if (this.G < 1) {
      info('Invalid Gamma: ' + this.G + ' for ' + this.name + ', falling back to default');
      this.G = 1;
    }
  }
  function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
    var A = src[srcOffset] * scale;
    var AG = Math.pow(A, cs.G);
    var L = cs.YW * AG;
    var val = Math.max(295.8 * Math.pow(L, 0.333333333333333333) - 40.8, 0) | 0;
    dest[destOffset] = val;
    dest[destOffset + 1] = val;
    dest[destOffset + 2] = val;
  }
  CalGrayCS.prototype = {
    getRgb: ColorSpace.prototype.getRgb,
    getRgbItem: function CalGrayCS_getRgbItem(src, srcOffset, dest, destOffset) {
      convertToRgb(this, src, srcOffset, dest, destOffset, 1);
    },
    getRgbBuffer: function CalGrayCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      var scale = 1 / ((1 << bits) - 1);
      for (var i = 0; i < count; ++i) {
        convertToRgb(this, src, srcOffset, dest, destOffset, scale);
        srcOffset += 1;
        destOffset += 3 + alpha01;
      }
    },
    getOutputLength: function CalGrayCS_getOutputLength(inputLength, alpha01) {
      return inputLength * (3 + alpha01);
    },
    isPassthrough: ColorSpace.prototype.isPassthrough,
    fillRgb: ColorSpace.prototype.fillRgb,
    isDefaultDecode: function CalGrayCS_isDefaultDecode(decodeMap) {
      return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
    },
    usesZeroToOneRange: true
  };
  return CalGrayCS;
}();
var CalRGBCS = function CalRGBCSClosure() {
  var BRADFORD_SCALE_MATRIX = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]);
  var BRADFORD_SCALE_INVERSE_MATRIX = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -0.0085287, 0.0400428, 0.9684867]);
  var SRGB_D65_XYZ_TO_RGB_MATRIX = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.9692660, 1.8760108, 0.0415560, 0.0556434, -0.2040259, 1.0572252]);
  var FLAT_WHITEPOINT_MATRIX = new Float32Array([1, 1, 1]);
  var tempNormalizeMatrix = new Float32Array(3);
  var tempConvertMatrix1 = new Float32Array(3);
  var tempConvertMatrix2 = new Float32Array(3);
  var DECODE_L_CONSTANT = Math.pow((8 + 16) / 116, 3) / 8.0;
  function CalRGBCS(whitePoint, blackPoint, gamma, matrix) {
    this.name = 'CalRGB';
    this.numComps = 3;
    this.defaultColor = new Float32Array(this.numComps);
    if (!whitePoint) {
      error('WhitePoint missing - required for color space CalRGB');
    }
    blackPoint = blackPoint || new Float32Array(3);
    gamma = gamma || new Float32Array([1, 1, 1]);
    matrix = matrix || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    var XW = whitePoint[0];
    var YW = whitePoint[1];
    var ZW = whitePoint[2];
    this.whitePoint = whitePoint;
    var XB = blackPoint[0];
    var YB = blackPoint[1];
    var ZB = blackPoint[2];
    this.blackPoint = blackPoint;
    this.GR = gamma[0];
    this.GG = gamma[1];
    this.GB = gamma[2];
    this.MXA = matrix[0];
    this.MYA = matrix[1];
    this.MZA = matrix[2];
    this.MXB = matrix[3];
    this.MYB = matrix[4];
    this.MZB = matrix[5];
    this.MXC = matrix[6];
    this.MYC = matrix[7];
    this.MZC = matrix[8];
    if (XW < 0 || ZW < 0 || YW !== 1) {
      error('Invalid WhitePoint components for ' + this.name + ', no fallback available');
    }
    if (XB < 0 || YB < 0 || ZB < 0) {
      info('Invalid BlackPoint for ' + this.name + ' [' + XB + ', ' + YB + ', ' + ZB + '], falling back to default');
      this.blackPoint = new Float32Array(3);
    }
    if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
      info('Invalid Gamma [' + this.GR + ', ' + this.GG + ', ' + this.GB + '] for ' + this.name + ', falling back to default');
      this.GR = this.GG = this.GB = 1;
    }
    if (this.MXA < 0 || this.MYA < 0 || this.MZA < 0 || this.MXB < 0 || this.MYB < 0 || this.MZB < 0 || this.MXC < 0 || this.MYC < 0 || this.MZC < 0) {
      info('Invalid Matrix for ' + this.name + ' [' + this.MXA + ', ' + this.MYA + ', ' + this.MZA + this.MXB + ', ' + this.MYB + ', ' + this.MZB + this.MXC + ', ' + this.MYC + ', ' + this.MZC + '], falling back to default');
      this.MXA = this.MYB = this.MZC = 1;
      this.MXB = this.MYA = this.MZA = this.MXC = this.MYC = this.MZB = 0;
    }
  }
  function matrixProduct(a, b, result) {
    result[0] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    result[1] = a[3] * b[0] + a[4] * b[1] + a[5] * b[2];
    result[2] = a[6] * b[0] + a[7] * b[1] + a[8] * b[2];
  }
  function convertToFlat(sourceWhitePoint, LMS, result) {
    result[0] = LMS[0] * 1 / sourceWhitePoint[0];
    result[1] = LMS[1] * 1 / sourceWhitePoint[1];
    result[2] = LMS[2] * 1 / sourceWhitePoint[2];
  }
  function convertToD65(sourceWhitePoint, LMS, result) {
    var D65X = 0.95047;
    var D65Y = 1;
    var D65Z = 1.08883;
    result[0] = LMS[0] * D65X / sourceWhitePoint[0];
    result[1] = LMS[1] * D65Y / sourceWhitePoint[1];
    result[2] = LMS[2] * D65Z / sourceWhitePoint[2];
  }
  function sRGBTransferFunction(color) {
    if (color <= 0.0031308) {
      return adjustToRange(0, 1, 12.92 * color);
    }
    return adjustToRange(0, 1, (1 + 0.055) * Math.pow(color, 1 / 2.4) - 0.055);
  }
  function adjustToRange(min, max, value) {
    return Math.max(min, Math.min(max, value));
  }
  function decodeL(L) {
    if (L < 0) {
      return -decodeL(-L);
    }
    if (L > 8.0) {
      return Math.pow((L + 16) / 116, 3);
    }
    return L * DECODE_L_CONSTANT;
  }
  function compensateBlackPoint(sourceBlackPoint, XYZ_Flat, result) {
    if (sourceBlackPoint[0] === 0 && sourceBlackPoint[1] === 0 && sourceBlackPoint[2] === 0) {
      result[0] = XYZ_Flat[0];
      result[1] = XYZ_Flat[1];
      result[2] = XYZ_Flat[2];
      return;
    }
    var zeroDecodeL = decodeL(0);
    var X_DST = zeroDecodeL;
    var X_SRC = decodeL(sourceBlackPoint[0]);
    var Y_DST = zeroDecodeL;
    var Y_SRC = decodeL(sourceBlackPoint[1]);
    var Z_DST = zeroDecodeL;
    var Z_SRC = decodeL(sourceBlackPoint[2]);
    var X_Scale = (1 - X_DST) / (1 - X_SRC);
    var X_Offset = 1 - X_Scale;
    var Y_Scale = (1 - Y_DST) / (1 - Y_SRC);
    var Y_Offset = 1 - Y_Scale;
    var Z_Scale = (1 - Z_DST) / (1 - Z_SRC);
    var Z_Offset = 1 - Z_Scale;
    result[0] = XYZ_Flat[0] * X_Scale + X_Offset;
    result[1] = XYZ_Flat[1] * Y_Scale + Y_Offset;
    result[2] = XYZ_Flat[2] * Z_Scale + Z_Offset;
  }
  function normalizeWhitePointToFlat(sourceWhitePoint, XYZ_In, result) {
    if (sourceWhitePoint[0] === 1 && sourceWhitePoint[2] === 1) {
      result[0] = XYZ_In[0];
      result[1] = XYZ_In[1];
      result[2] = XYZ_In[2];
      return;
    }
    var LMS = result;
    matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
    var LMS_Flat = tempNormalizeMatrix;
    convertToFlat(sourceWhitePoint, LMS, LMS_Flat);
    matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_Flat, result);
  }
  function normalizeWhitePointToD65(sourceWhitePoint, XYZ_In, result) {
    var LMS = result;
    matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
    var LMS_D65 = tempNormalizeMatrix;
    convertToD65(sourceWhitePoint, LMS, LMS_D65);
    matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_D65, result);
  }
  function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
    var A = adjustToRange(0, 1, src[srcOffset] * scale);
    var B = adjustToRange(0, 1, src[srcOffset + 1] * scale);
    var C = adjustToRange(0, 1, src[srcOffset + 2] * scale);
    var AGR = Math.pow(A, cs.GR);
    var BGG = Math.pow(B, cs.GG);
    var CGB = Math.pow(C, cs.GB);
    var X = cs.MXA * AGR + cs.MXB * BGG + cs.MXC * CGB;
    var Y = cs.MYA * AGR + cs.MYB * BGG + cs.MYC * CGB;
    var Z = cs.MZA * AGR + cs.MZB * BGG + cs.MZC * CGB;
    var XYZ = tempConvertMatrix1;
    XYZ[0] = X;
    XYZ[1] = Y;
    XYZ[2] = Z;
    var XYZ_Flat = tempConvertMatrix2;
    normalizeWhitePointToFlat(cs.whitePoint, XYZ, XYZ_Flat);
    var XYZ_Black = tempConvertMatrix1;
    compensateBlackPoint(cs.blackPoint, XYZ_Flat, XYZ_Black);
    var XYZ_D65 = tempConvertMatrix2;
    normalizeWhitePointToD65(FLAT_WHITEPOINT_MATRIX, XYZ_Black, XYZ_D65);
    var SRGB = tempConvertMatrix1;
    matrixProduct(SRGB_D65_XYZ_TO_RGB_MATRIX, XYZ_D65, SRGB);
    var sR = sRGBTransferFunction(SRGB[0]);
    var sG = sRGBTransferFunction(SRGB[1]);
    var sB = sRGBTransferFunction(SRGB[2]);
    dest[destOffset] = Math.round(sR * 255);
    dest[destOffset + 1] = Math.round(sG * 255);
    dest[destOffset + 2] = Math.round(sB * 255);
  }
  CalRGBCS.prototype = {
    getRgb: function CalRGBCS_getRgb(src, srcOffset) {
      var rgb = new Uint8Array(3);
      this.getRgbItem(src, srcOffset, rgb, 0);
      return rgb;
    },
    getRgbItem: function CalRGBCS_getRgbItem(src, srcOffset, dest, destOffset) {
      convertToRgb(this, src, srcOffset, dest, destOffset, 1);
    },
    getRgbBuffer: function CalRGBCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      var scale = 1 / ((1 << bits) - 1);
      for (var i = 0; i < count; ++i) {
        convertToRgb(this, src, srcOffset, dest, destOffset, scale);
        srcOffset += 3;
        destOffset += 3 + alpha01;
      }
    },
    getOutputLength: function CalRGBCS_getOutputLength(inputLength, alpha01) {
      return inputLength * (3 + alpha01) / 3 | 0;
    },
    isPassthrough: ColorSpace.prototype.isPassthrough,
    fillRgb: ColorSpace.prototype.fillRgb,
    isDefaultDecode: function CalRGBCS_isDefaultDecode(decodeMap) {
      return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
    },
    usesZeroToOneRange: true
  };
  return CalRGBCS;
}();
var LabCS = function LabCSClosure() {
  function LabCS(whitePoint, blackPoint, range) {
    this.name = 'Lab';
    this.numComps = 3;
    this.defaultColor = new Float32Array(this.numComps);
    if (!whitePoint) {
      error('WhitePoint missing - required for color space Lab');
    }
    blackPoint = blackPoint || [0, 0, 0];
    range = range || [-100, 100, -100, 100];
    this.XW = whitePoint[0];
    this.YW = whitePoint[1];
    this.ZW = whitePoint[2];
    this.amin = range[0];
    this.amax = range[1];
    this.bmin = range[2];
    this.bmax = range[3];
    this.XB = blackPoint[0];
    this.YB = blackPoint[1];
    this.ZB = blackPoint[2];
    if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
      error('Invalid WhitePoint components, no fallback available');
    }
    if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
      info('Invalid BlackPoint, falling back to default');
      this.XB = this.YB = this.ZB = 0;
    }
    if (this.amin > this.amax || this.bmin > this.bmax) {
      info('Invalid Range, falling back to defaults');
      this.amin = -100;
      this.amax = 100;
      this.bmin = -100;
      this.bmax = 100;
    }
  }
  function fn_g(x) {
    var result;
    if (x >= 6 / 29) {
      result = x * x * x;
    } else {
      result = 108 / 841 * (x - 4 / 29);
    }
    return result;
  }
  function decode(value, high1, low2, high2) {
    return low2 + value * (high2 - low2) / high1;
  }
  function convertToRgb(cs, src, srcOffset, maxVal, dest, destOffset) {
    var Ls = src[srcOffset];
    var as = src[srcOffset + 1];
    var bs = src[srcOffset + 2];
    if (maxVal !== false) {
      Ls = decode(Ls, maxVal, 0, 100);
      as = decode(as, maxVal, cs.amin, cs.amax);
      bs = decode(bs, maxVal, cs.bmin, cs.bmax);
    }
    as = as > cs.amax ? cs.amax : as < cs.amin ? cs.amin : as;
    bs = bs > cs.bmax ? cs.bmax : bs < cs.bmin ? cs.bmin : bs;
    var M = (Ls + 16) / 116;
    var L = M + as / 500;
    var N = M - bs / 200;
    var X = cs.XW * fn_g(L);
    var Y = cs.YW * fn_g(M);
    var Z = cs.ZW * fn_g(N);
    var r, g, b;
    if (cs.ZW < 1) {
      r = X * 3.1339 + Y * -1.6170 + Z * -0.4906;
      g = X * -0.9785 + Y * 1.9160 + Z * 0.0333;
      b = X * 0.0720 + Y * -0.2290 + Z * 1.4057;
    } else {
      r = X * 3.2406 + Y * -1.5372 + Z * -0.4986;
      g = X * -0.9689 + Y * 1.8758 + Z * 0.0415;
      b = X * 0.0557 + Y * -0.2040 + Z * 1.0570;
    }
    dest[destOffset] = r <= 0 ? 0 : r >= 1 ? 255 : Math.sqrt(r) * 255 | 0;
    dest[destOffset + 1] = g <= 0 ? 0 : g >= 1 ? 255 : Math.sqrt(g) * 255 | 0;
    dest[destOffset + 2] = b <= 0 ? 0 : b >= 1 ? 255 : Math.sqrt(b) * 255 | 0;
  }
  LabCS.prototype = {
    getRgb: ColorSpace.prototype.getRgb,
    getRgbItem: function LabCS_getRgbItem(src, srcOffset, dest, destOffset) {
      convertToRgb(this, src, srcOffset, false, dest, destOffset);
    },
    getRgbBuffer: function LabCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      var maxVal = (1 << bits) - 1;
      for (var i = 0; i < count; i++) {
        convertToRgb(this, src, srcOffset, maxVal, dest, destOffset);
        srcOffset += 3;
        destOffset += 3 + alpha01;
      }
    },
    getOutputLength: function LabCS_getOutputLength(inputLength, alpha01) {
      return inputLength * (3 + alpha01) / 3 | 0;
    },
    isPassthrough: ColorSpace.prototype.isPassthrough,
    fillRgb: ColorSpace.prototype.fillRgb,
    isDefaultDecode: function LabCS_isDefaultDecode(decodeMap) {
      return true;
    },
    usesZeroToOneRange: false
  };
  return LabCS;
}();
exports.ColorSpace = ColorSpace;

/***/ }),
/* 4 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var ExpertEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior', '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '', '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];
var MacExpertEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', 'centoldstyle', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', '', 'threequartersemdash', '', 'questionsmall', '', '', '', '', 'Ethsmall', '', '', 'onequarter', 'onehalf', 'threequarters', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '', '', '', '', '', '', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hypheninferior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', 'asuperior', 'centsuperior', '', '', '', '', 'Aacutesmall', 'Agravesmall', 'Acircumflexsmall', 'Adieresissmall', 'Atildesmall', 'Aringsmall', 'Ccedillasmall', 'Eacutesmall', 'Egravesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Iacutesmall', 'Igravesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ntildesmall', 'Oacutesmall', 'Ogravesmall', 'Ocircumflexsmall', 'Odieresissmall', 'Otildesmall', 'Uacutesmall', 'Ugravesmall', 'Ucircumflexsmall', 'Udieresissmall', '', 'eightsuperior', 'fourinferior', 'threeinferior', 'sixinferior', 'eightinferior', 'seveninferior', 'Scaronsmall', '', 'centinferior', 'twoinferior', '', 'Dieresissmall', '', 'Caronsmall', 'osuperior', 'fiveinferior', '', 'commainferior', 'periodinferior', 'Yacutesmall', '', 'dollarinferior', '', 'Thornsmall', '', 'nineinferior', 'zeroinferior', 'Zcaronsmall', 'AEsmall', 'Oslashsmall', 'questiondownsmall', 'oneinferior', 'Lslashsmall', '', '', '', '', '', '', 'Cedillasmall', '', '', '', '', '', 'OEsmall', 'figuredash', 'hyphensuperior', '', '', '', '', 'exclamdownsmall', '', 'Ydieresissmall', '', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'ninesuperior', 'zerosuperior', '', 'esuperior', 'rsuperior', 'tsuperior', '', '', 'isuperior', 'ssuperior', 'dsuperior', '', '', '', '', '', 'lsuperior', 'Ogoneksmall', 'Brevesmall', 'Macronsmall', 'bsuperior', 'nsuperior', 'msuperior', 'commasuperior', 'periodsuperior', 'Dotaccentsmall', 'Ringsmall'];
var MacRomanEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', 'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave', 'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis', 'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis', 'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section', 'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal', 'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation', 'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown', 'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright', 'ellipsis', 'space', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft', 'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction', 'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase', 'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex', 'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron'];
var StandardEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger', 'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron', 'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '', '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '', 'lslash', 'oslash', 'oe', 'germandbls'];
var WinAnsiEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'bullet', 'Euro', 'bullet', 'quotesinglbase', 'florin', 'quotedblbase', 'ellipsis', 'dagger', 'daggerdbl', 'circumflex', 'perthousand', 'Scaron', 'guilsinglleft', 'OE', 'bullet', 'Zcaron', 'bullet', 'bullet', 'quoteleft', 'quoteright', 'quotedblleft', 'quotedblright', 'bullet', 'endash', 'emdash', 'tilde', 'trademark', 'scaron', 'guilsinglright', 'oe', 'bullet', 'zcaron', 'Ydieresis', 'space', 'exclamdown', 'cent', 'sterling', 'currency', 'yen', 'brokenbar', 'section', 'dieresis', 'copyright', 'ordfeminine', 'guillemotleft', 'logicalnot', 'hyphen', 'registered', 'macron', 'degree', 'plusminus', 'twosuperior', 'threesuperior', 'acute', 'mu', 'paragraph', 'periodcentered', 'cedilla', 'onesuperior', 'ordmasculine', 'guillemotright', 'onequarter', 'onehalf', 'threequarters', 'questiondown', 'Agrave', 'Aacute', 'Acircumflex', 'Atilde', 'Adieresis', 'Aring', 'AE', 'Ccedilla', 'Egrave', 'Eacute', 'Ecircumflex', 'Edieresis', 'Igrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Eth', 'Ntilde', 'Ograve', 'Oacute', 'Ocircumflex', 'Otilde', 'Odieresis', 'multiply', 'Oslash', 'Ugrave', 'Uacute', 'Ucircumflex', 'Udieresis', 'Yacute', 'Thorn', 'germandbls', 'agrave', 'aacute', 'acircumflex', 'atilde', 'adieresis', 'aring', 'ae', 'ccedilla', 'egrave', 'eacute', 'ecircumflex', 'edieresis', 'igrave', 'iacute', 'icircumflex', 'idieresis', 'eth', 'ntilde', 'ograve', 'oacute', 'ocircumflex', 'otilde', 'odieresis', 'divide', 'oslash', 'ugrave', 'uacute', 'ucircumflex', 'udieresis', 'yacute', 'thorn', 'ydieresis'];
var SymbolSetEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'universal', 'numbersign', 'existential', 'percent', 'ampersand', 'suchthat', 'parenleft', 'parenright', 'asteriskmath', 'plus', 'comma', 'minus', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'congruent', 'Alpha', 'Beta', 'Chi', 'Delta', 'Epsilon', 'Phi', 'Gamma', 'Eta', 'Iota', 'theta1', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Omicron', 'Pi', 'Theta', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'sigma1', 'Omega', 'Xi', 'Psi', 'Zeta', 'bracketleft', 'therefore', 'bracketright', 'perpendicular', 'underscore', 'radicalex', 'alpha', 'beta', 'chi', 'delta', 'epsilon', 'phi', 'gamma', 'eta', 'iota', 'phi1', 'kappa', 'lambda', 'mu', 'nu', 'omicron', 'pi', 'theta', 'rho', 'sigma', 'tau', 'upsilon', 'omega1', 'omega', 'xi', 'psi', 'zeta', 'braceleft', 'bar', 'braceright', 'similar', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'Euro', 'Upsilon1', 'minute', 'lessequal', 'fraction', 'infinity', 'florin', 'club', 'diamond', 'heart', 'spade', 'arrowboth', 'arrowleft', 'arrowup', 'arrowright', 'arrowdown', 'degree', 'plusminus', 'second', 'greaterequal', 'multiply', 'proportional', 'partialdiff', 'bullet', 'divide', 'notequal', 'equivalence', 'approxequal', 'ellipsis', 'arrowvertex', 'arrowhorizex', 'carriagereturn', 'aleph', 'Ifraktur', 'Rfraktur', 'weierstrass', 'circlemultiply', 'circleplus', 'emptyset', 'intersection', 'union', 'propersuperset', 'reflexsuperset', 'notsubset', 'propersubset', 'reflexsubset', 'element', 'notelement', 'angle', 'gradient', 'registerserif', 'copyrightserif', 'trademarkserif', 'product', 'radical', 'dotmath', 'logicalnot', 'logicaland', 'logicalor', 'arrowdblboth', 'arrowdblleft', 'arrowdblup', 'arrowdblright', 'arrowdbldown', 'lozenge', 'angleleft', 'registersans', 'copyrightsans', 'trademarksans', 'summation', 'parenlefttp', 'parenleftex', 'parenleftbt', 'bracketlefttp', 'bracketleftex', 'bracketleftbt', 'bracelefttp', 'braceleftmid', 'braceleftbt', 'braceex', '', 'angleright', 'integral', 'integraltp', 'integralex', 'integralbt', 'parenrighttp', 'parenrightex', 'parenrightbt', 'bracketrighttp', 'bracketrightex', 'bracketrightbt', 'bracerighttp', 'bracerightmid', 'bracerightbt'];
var ZapfDingbatsEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'a1', 'a2', 'a202', 'a3', 'a4', 'a5', 'a119', 'a118', 'a117', 'a11', 'a12', 'a13', 'a14', 'a15', 'a16', 'a105', 'a17', 'a18', 'a19', 'a20', 'a21', 'a22', 'a23', 'a24', 'a25', 'a26', 'a27', 'a28', 'a6', 'a7', 'a8', 'a9', 'a10', 'a29', 'a30', 'a31', 'a32', 'a33', 'a34', 'a35', 'a36', 'a37', 'a38', 'a39', 'a40', 'a41', 'a42', 'a43', 'a44', 'a45', 'a46', 'a47', 'a48', 'a49', 'a50', 'a51', 'a52', 'a53', 'a54', 'a55', 'a56', 'a57', 'a58', 'a59', 'a60', 'a61', 'a62', 'a63', 'a64', 'a65', 'a66', 'a67', 'a68', 'a69', 'a70', 'a71', 'a72', 'a73', 'a74', 'a203', 'a75', 'a204', 'a76', 'a77', 'a78', 'a79', 'a81', 'a82', 'a83', 'a84', 'a97', 'a98', 'a99', 'a100', '', 'a89', 'a90', 'a93', 'a94', 'a91', 'a92', 'a205', 'a85', 'a206', 'a86', 'a87', 'a88', 'a95', 'a96', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'a101', 'a102', 'a103', 'a104', 'a106', 'a107', 'a108', 'a112', 'a111', 'a110', 'a109', 'a120', 'a121', 'a122', 'a123', 'a124', 'a125', 'a126', 'a127', 'a128', 'a129', 'a130', 'a131', 'a132', 'a133', 'a134', 'a135', 'a136', 'a137', 'a138', 'a139', 'a140', 'a141', 'a142', 'a143', 'a144', 'a145', 'a146', 'a147', 'a148', 'a149', 'a150', 'a151', 'a152', 'a153', 'a154', 'a155', 'a156', 'a157', 'a158', 'a159', 'a160', 'a161', 'a163', 'a164', 'a196', 'a165', 'a192', 'a166', 'a167', 'a168', 'a169', 'a170', 'a171', 'a172', 'a173', 'a162', 'a174', 'a175', 'a176', 'a177', 'a178', 'a179', 'a193', 'a180', 'a199', 'a181', 'a200', 'a182', '', 'a201', 'a183', 'a184', 'a197', 'a185', 'a194', 'a198', 'a186', 'a195', 'a187', 'a188', 'a189', 'a190', 'a191'];
function getEncoding(encodingName) {
  switch (encodingName) {
    case 'WinAnsiEncoding':
      return WinAnsiEncoding;
    case 'StandardEncoding':
      return StandardEncoding;
    case 'MacRomanEncoding':
      return MacRomanEncoding;
    case 'SymbolSetEncoding':
      return SymbolSetEncoding;
    case 'ZapfDingbatsEncoding':
      return ZapfDingbatsEncoding;
    case 'ExpertEncoding':
      return ExpertEncoding;
    case 'MacExpertEncoding':
      return MacExpertEncoding;
    default:
      return null;
  }
}
exports.WinAnsiEncoding = WinAnsiEncoding;
exports.StandardEncoding = StandardEncoding;
exports.MacRomanEncoding = MacRomanEncoding;
exports.SymbolSetEncoding = SymbolSetEncoding;
exports.ZapfDingbatsEncoding = ZapfDingbatsEncoding;
exports.ExpertEncoding = ExpertEncoding;
exports.getEncoding = getEncoding;

/***/ }),
/* 5 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var corePrimitives = __w_pdfjs_require__(1);
var coreStream = __w_pdfjs_require__(2);
var MissingDataException = sharedUtil.MissingDataException;
var StreamType = sharedUtil.StreamType;
var assert = sharedUtil.assert;
var error = sharedUtil.error;
var info = sharedUtil.info;
var isArray = sharedUtil.isArray;
var isInt = sharedUtil.isInt;
var isNum = sharedUtil.isNum;
var isString = sharedUtil.isString;
var warn = sharedUtil.warn;
var EOF = corePrimitives.EOF;
var Cmd = corePrimitives.Cmd;
var Dict = corePrimitives.Dict;
var Name = corePrimitives.Name;
var Ref = corePrimitives.Ref;
var isEOF = corePrimitives.isEOF;
var isCmd = corePrimitives.isCmd;
var isDict = corePrimitives.isDict;
var isName = corePrimitives.isName;
var Ascii85Stream = coreStream.Ascii85Stream;
var AsciiHexStream = coreStream.AsciiHexStream;
var CCITTFaxStream = coreStream.CCITTFaxStream;
var FlateStream = coreStream.FlateStream;
var Jbig2Stream = coreStream.Jbig2Stream;
var JpegStream = coreStream.JpegStream;
var JpxStream = coreStream.JpxStream;
var LZWStream = coreStream.LZWStream;
var NullStream = coreStream.NullStream;
var PredictorStream = coreStream.PredictorStream;
var RunLengthStream = coreStream.RunLengthStream;
var MAX_LENGTH_TO_CACHE = 1000;
var Parser = function ParserClosure() {
  function Parser(lexer, allowStreams, xref, recoveryMode) {
    this.lexer = lexer;
    this.allowStreams = allowStreams;
    this.xref = xref;
    this.recoveryMode = recoveryMode || false;
    this.imageCache = Object.create(null);
    this.refill();
  }
  Parser.prototype = {
    refill: function Parser_refill() {
      this.buf1 = this.lexer.getObj();
      this.buf2 = this.lexer.getObj();
    },
    shift: function Parser_shift() {
      if (isCmd(this.buf2, 'ID')) {
        this.buf1 = this.buf2;
        this.buf2 = null;
      } else {
        this.buf1 = this.buf2;
        this.buf2 = this.lexer.getObj();
      }
    },
    tryShift: function Parser_tryShift() {
      try {
        this.shift();
        return true;
      } catch (e) {
        if (e instanceof MissingDataException) {
          throw e;
        }
        return false;
      }
    },
    getObj: function Parser_getObj(cipherTransform) {
      var buf1 = this.buf1;
      this.shift();
      if (buf1 instanceof Cmd) {
        switch (buf1.cmd) {
          case 'BI':
            return this.makeInlineImage(cipherTransform);
          case '[':
            var array = [];
            while (!isCmd(this.buf1, ']') && !isEOF(this.buf1)) {
              array.push(this.getObj(cipherTransform));
            }
            if (isEOF(this.buf1)) {
              if (!this.recoveryMode) {
                error('End of file inside array');
              }
              return array;
            }
            this.shift();
            return array;
          case '<<':
            var dict = new Dict(this.xref);
            while (!isCmd(this.buf1, '>>') && !isEOF(this.buf1)) {
              if (!isName(this.buf1)) {
                info('Malformed dictionary: key must be a name object');
                this.shift();
                continue;
              }
              var key = this.buf1.name;
              this.shift();
              if (isEOF(this.buf1)) {
                break;
              }
              dict.set(key, this.getObj(cipherTransform));
            }
            if (isEOF(this.buf1)) {
              if (!this.recoveryMode) {
                error('End of file inside dictionary');
              }
              return dict;
            }
            if (isCmd(this.buf2, 'stream')) {
              return this.allowStreams ? this.makeStream(dict, cipherTransform) : dict;
            }
            this.shift();
            return dict;
          default:
            return buf1;
        }
      }
      if (isInt(buf1)) {
        var num = buf1;
        if (isInt(this.buf1) && isCmd(this.buf2, 'R')) {
          var ref = new Ref(num, this.buf1);
          this.shift();
          this.shift();
          return ref;
        }
        return num;
      }
      if (isString(buf1)) {
        var str = buf1;
        if (cipherTransform) {
          str = cipherTransform.decryptString(str);
        }
        return str;
      }
      return buf1;
    },
    findDefaultInlineStreamEnd: function Parser_findDefaultInlineStreamEnd(stream) {
      var E = 0x45,
          I = 0x49,
          SPACE = 0x20,
          LF = 0xA,
          CR = 0xD;
      var startPos = stream.pos,
          state = 0,
          ch,
          i,
          n,
          followingBytes;
      while ((ch = stream.getByte()) !== -1) {
        if (state === 0) {
          state = ch === E ? 1 : 0;
        } else if (state === 1) {
          state = ch === I ? 2 : 0;
        } else {
          assert(state === 2);
          if (ch === SPACE || ch === LF || ch === CR) {
            n = 5;
            followingBytes = stream.peekBytes(n);
            for (i = 0; i < n; i++) {
              ch = followingBytes[i];
              if (ch !== LF && ch !== CR && (ch < SPACE || ch > 0x7F)) {
                state = 0;
                break;
              }
            }
            if (state === 2) {
              break;
            }
          } else {
            state = 0;
          }
        }
      }
      return stream.pos - 4 - startPos;
    },
    findDCTDecodeInlineStreamEnd: function Parser_findDCTDecodeInlineStreamEnd(stream) {
      var startPos = stream.pos,
          foundEOI = false,
          b,
          markerLength,
          length;
      while ((b = stream.getByte()) !== -1) {
        if (b !== 0xFF) {
          continue;
        }
        switch (stream.getByte()) {
          case 0x00:
            break;
          case 0xFF:
            stream.skip(-1);
            break;
          case 0xD9:
            foundEOI = true;
            break;
          case 0xC0:
          case 0xC1:
          case 0xC2:
          case 0xC3:
          case 0xC5:
          case 0xC6:
          case 0xC7:
          case 0xC9:
          case 0xCA:
          case 0xCB:
          case 0xCD:
          case 0xCE:
          case 0xCF:
          case 0xC4:
          case 0xCC:
          case 0xDA:
          case 0xDB:
          case 0xDC:
          case 0xDD:
          case 0xDE:
          case 0xDF:
          case 0xE0:
          case 0xE1:
          case 0xE2:
          case 0xE3:
          case 0xE4:
          case 0xE5:
          case 0xE6:
          case 0xE7:
          case 0xE8:
          case 0xE9:
          case 0xEA:
          case 0xEB:
          case 0xEC:
          case 0xED:
          case 0xEE:
          case 0xEF:
          case 0xFE:
            markerLength = stream.getUint16();
            if (markerLength > 2) {
              stream.skip(markerLength - 2);
            } else {
              stream.skip(-2);
            }
            break;
        }
        if (foundEOI) {
          break;
        }
      }
      length = stream.pos - startPos;
      if (b === -1) {
        warn('Inline DCTDecode image stream: ' + 'EOI marker not found, searching for /EI/ instead.');
        stream.skip(-length);
        return this.findDefaultInlineStreamEnd(stream);
      }
      this.inlineStreamSkipEI(stream);
      return length;
    },
    findASCII85DecodeInlineStreamEnd: function Parser_findASCII85DecodeInlineStreamEnd(stream) {
      var TILDE = 0x7E,
          GT = 0x3E;
      var startPos = stream.pos,
          ch,
          length;
      while ((ch = stream.getByte()) !== -1) {
        if (ch === TILDE && stream.peekByte() === GT) {
          stream.skip();
          break;
        }
      }
      length = stream.pos - startPos;
      if (ch === -1) {
        warn('Inline ASCII85Decode image stream: ' + 'EOD marker not found, searching for /EI/ instead.');
        stream.skip(-length);
        return this.findDefaultInlineStreamEnd(stream);
      }
      this.inlineStreamSkipEI(stream);
      return length;
    },
    findASCIIHexDecodeInlineStreamEnd: function Parser_findASCIIHexDecodeInlineStreamEnd(stream) {
      var GT = 0x3E;
      var startPos = stream.pos,
          ch,
          length;
      while ((ch = stream.getByte()) !== -1) {
        if (ch === GT) {
          break;
        }
      }
      length = stream.pos - startPos;
      if (ch === -1) {
        warn('Inline ASCIIHexDecode image stream: ' + 'EOD marker not found, searching for /EI/ instead.');
        stream.skip(-length);
        return this.findDefaultInlineStreamEnd(stream);
      }
      this.inlineStreamSkipEI(stream);
      return length;
    },
    inlineStreamSkipEI: function Parser_inlineStreamSkipEI(stream) {
      var E = 0x45,
          I = 0x49;
      var state = 0,
          ch;
      while ((ch = stream.getByte()) !== -1) {
        if (state === 0) {
          state = ch === E ? 1 : 0;
        } else if (state === 1) {
          state = ch === I ? 2 : 0;
        } else if (state === 2) {
          break;
        }
      }
    },
    makeInlineImage: function Parser_makeInlineImage(cipherTransform) {
      var lexer = this.lexer;
      var stream = lexer.stream;
      var dict = new Dict(this.xref);
      while (!isCmd(this.buf1, 'ID') && !isEOF(this.buf1)) {
        if (!isName(this.buf1)) {
          error('Dictionary key must be a name object');
        }
        var key = this.buf1.name;
        this.shift();
        if (isEOF(this.buf1)) {
          break;
        }
        dict.set(key, this.getObj(cipherTransform));
      }
      var filter = dict.get('Filter', 'F'),
          filterName;
      if (isName(filter)) {
        filterName = filter.name;
      } else if (isArray(filter)) {
        var filterZero = this.xref.fetchIfRef(filter[0]);
        if (isName(filterZero)) {
          filterName = filterZero.name;
        }
      }
      var startPos = stream.pos,
          length,
          i,
          ii;
      if (filterName === 'DCTDecode' || filterName === 'DCT') {
        length = this.findDCTDecodeInlineStreamEnd(stream);
      } else if (filterName === 'ASCII85Decide' || filterName === 'A85') {
        length = this.findASCII85DecodeInlineStreamEnd(stream);
      } else if (filterName === 'ASCIIHexDecode' || filterName === 'AHx') {
        length = this.findASCIIHexDecodeInlineStreamEnd(stream);
      } else {
        length = this.findDefaultInlineStreamEnd(stream);
      }
      var imageStream = stream.makeSubStream(startPos, length, dict);
      var adler32;
      if (length < MAX_LENGTH_TO_CACHE) {
        var imageBytes = imageStream.getBytes();
        imageStream.reset();
        var a = 1;
        var b = 0;
        for (i = 0, ii = imageBytes.length; i < ii; ++i) {
          a += imageBytes[i] & 0xff;
          b += a;
        }
        adler32 = b % 65521 << 16 | a % 65521;
        if (this.imageCache.adler32 === adler32) {
          this.buf2 = Cmd.get('EI');
          this.shift();
          this.imageCache[adler32].reset();
          return this.imageCache[adler32];
        }
      }
      if (cipherTransform) {
        imageStream = cipherTransform.createStream(imageStream, length);
      }
      imageStream = this.filter(imageStream, dict, length);
      imageStream.dict = dict;
      if (adler32 !== undefined) {
        imageStream.cacheKey = 'inline_' + length + '_' + adler32;
        this.imageCache[adler32] = imageStream;
      }
      this.buf2 = Cmd.get('EI');
      this.shift();
      return imageStream;
    },
    makeStream: function Parser_makeStream(dict, cipherTransform) {
      var lexer = this.lexer;
      var stream = lexer.stream;
      lexer.skipToNextLine();
      var pos = stream.pos - 1;
      var length = dict.get('Length');
      if (!isInt(length)) {
        info('Bad ' + length + ' attribute in stream');
        length = 0;
      }
      stream.pos = pos + length;
      lexer.nextChar();
      if (this.tryShift() && isCmd(this.buf2, 'endstream')) {
        this.shift();
      } else {
        stream.pos = pos;
        var SCAN_BLOCK_SIZE = 2048;
        var ENDSTREAM_SIGNATURE_LENGTH = 9;
        var ENDSTREAM_SIGNATURE = [0x65, 0x6E, 0x64, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D];
        var skipped = 0,
            found = false,
            i,
            j;
        while (stream.pos < stream.end) {
          var scanBytes = stream.peekBytes(SCAN_BLOCK_SIZE);
          var scanLength = scanBytes.length - ENDSTREAM_SIGNATURE_LENGTH;
          if (scanLength <= 0) {
            break;
          }
          found = false;
          i = 0;
          while (i < scanLength) {
            j = 0;
            while (j < ENDSTREAM_SIGNATURE_LENGTH && scanBytes[i + j] === ENDSTREAM_SIGNATURE[j]) {
              j++;
            }
            if (j >= ENDSTREAM_SIGNATURE_LENGTH) {
              found = true;
              break;
            }
            i++;
          }
          if (found) {
            skipped += i;
            stream.pos += i;
            break;
          }
          skipped += scanLength;
          stream.pos += scanLength;
        }
        if (!found) {
          error('Missing endstream');
        }
        length = skipped;
        lexer.nextChar();
        this.shift();
        this.shift();
      }
      this.shift();
      stream = stream.makeSubStream(pos, length, dict);
      if (cipherTransform) {
        stream = cipherTransform.createStream(stream, length);
      }
      stream = this.filter(stream, dict, length);
      stream.dict = dict;
      return stream;
    },
    filter: function Parser_filter(stream, dict, length) {
      var filter = dict.get('Filter', 'F');
      var params = dict.get('DecodeParms', 'DP');
      if (isName(filter)) {
        if (isArray(params)) {
          params = this.xref.fetchIfRef(params[0]);
        }
        return this.makeFilter(stream, filter.name, length, params);
      }
      var maybeLength = length;
      if (isArray(filter)) {
        var filterArray = filter;
        var paramsArray = params;
        for (var i = 0, ii = filterArray.length; i < ii; ++i) {
          filter = this.xref.fetchIfRef(filterArray[i]);
          if (!isName(filter)) {
            error('Bad filter name: ' + filter);
          }
          params = null;
          if (isArray(paramsArray) && i in paramsArray) {
            params = this.xref.fetchIfRef(paramsArray[i]);
          }
          stream = this.makeFilter(stream, filter.name, maybeLength, params);
          maybeLength = null;
        }
      }
      return stream;
    },
    makeFilter: function Parser_makeFilter(stream, name, maybeLength, params) {
      if (maybeLength === 0) {
        warn('Empty "' + name + '" stream.');
        return new NullStream(stream);
      }
      try {
        var xrefStreamStats = this.xref.stats.streamTypes;
        if (name === 'FlateDecode' || name === 'Fl') {
          xrefStreamStats[StreamType.FLATE] = true;
          if (params) {
            return new PredictorStream(new FlateStream(stream, maybeLength), maybeLength, params);
          }
          return new FlateStream(stream, maybeLength);
        }
        if (name === 'LZWDecode' || name === 'LZW') {
          xrefStreamStats[StreamType.LZW] = true;
          var earlyChange = 1;
          if (params) {
            if (params.has('EarlyChange')) {
              earlyChange = params.get('EarlyChange');
            }
            return new PredictorStream(new LZWStream(stream, maybeLength, earlyChange), maybeLength, params);
          }
          return new LZWStream(stream, maybeLength, earlyChange);
        }
        if (name === 'DCTDecode' || name === 'DCT') {
          xrefStreamStats[StreamType.DCT] = true;
          return new JpegStream(stream, maybeLength, stream.dict, params);
        }
        if (name === 'JPXDecode' || name === 'JPX') {
          xrefStreamStats[StreamType.JPX] = true;
          return new JpxStream(stream, maybeLength, stream.dict, params);
        }
        if (name === 'ASCII85Decode' || name === 'A85') {
          xrefStreamStats[StreamType.A85] = true;
          return new Ascii85Stream(stream, maybeLength);
        }
        if (name === 'ASCIIHexDecode' || name === 'AHx') {
          xrefStreamStats[StreamType.AHX] = true;
          return new AsciiHexStream(stream, maybeLength);
        }
        if (name === 'CCITTFaxDecode' || name === 'CCF') {
          xrefStreamStats[StreamType.CCF] = true;
          return new CCITTFaxStream(stream, maybeLength, params);
        }
        if (name === 'RunLengthDecode' || name === 'RL') {
          xrefStreamStats[StreamType.RL] = true;
          return new RunLengthStream(stream, maybeLength);
        }
        if (name === 'JBIG2Decode') {
          xrefStreamStats[StreamType.JBIG] = true;
          return new Jbig2Stream(stream, maybeLength, stream.dict, params);
        }
        warn('filter "' + name + '" not supported yet');
        return stream;
      } catch (ex) {
        if (ex instanceof MissingDataException) {
          throw ex;
        }
        warn('Invalid stream: \"' + ex + '\"');
        return new NullStream(stream);
      }
    }
  };
  return Parser;
}();
var Lexer = function LexerClosure() {
  function Lexer(stream, knownCommands) {
    this.stream = stream;
    this.nextChar();
    this.strBuf = [];
    this.knownCommands = knownCommands;
  }
  var specialChars = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  function toHexDigit(ch) {
    if (ch >= 0x30 && ch <= 0x39) {
      return ch & 0x0F;
    }
    if (ch >= 0x41 && ch <= 0x46 || ch >= 0x61 && ch <= 0x66) {
      return (ch & 0x0F) + 9;
    }
    return -1;
  }
  Lexer.prototype = {
    nextChar: function Lexer_nextChar() {
      return this.currentChar = this.stream.getByte();
    },
    peekChar: function Lexer_peekChar() {
      return this.stream.peekByte();
    },
    getNumber: function Lexer_getNumber() {
      var ch = this.currentChar;
      var eNotation = false;
      var divideBy = 0;
      var sign = 1;
      if (ch === 0x2D) {
        sign = -1;
        ch = this.nextChar();
        if (ch === 0x2D) {
          ch = this.nextChar();
        }
      } else if (ch === 0x2B) {
        ch = this.nextChar();
      }
      if (ch === 0x2E) {
        divideBy = 10;
        ch = this.nextChar();
      }
      if (ch < 0x30 || ch > 0x39) {
        error('Invalid number: ' + String.fromCharCode(ch));
        return 0;
      }
      var baseValue = ch - 0x30;
      var powerValue = 0;
      var powerValueSign = 1;
      while ((ch = this.nextChar()) >= 0) {
        if (0x30 <= ch && ch <= 0x39) {
          var currentDigit = ch - 0x30;
          if (eNotation) {
            powerValue = powerValue * 10 + currentDigit;
          } else {
            if (divideBy !== 0) {
              divideBy *= 10;
            }
            baseValue = baseValue * 10 + currentDigit;
          }
        } else if (ch === 0x2E) {
          if (divideBy === 0) {
            divideBy = 1;
          } else {
            break;
          }
        } else if (ch === 0x2D) {
          warn('Badly formatted number');
        } else if (ch === 0x45 || ch === 0x65) {
          ch = this.peekChar();
          if (ch === 0x2B || ch === 0x2D) {
            powerValueSign = ch === 0x2D ? -1 : 1;
            this.nextChar();
          } else if (ch < 0x30 || ch > 0x39) {
            break;
          }
          eNotation = true;
        } else {
          break;
        }
      }
      if (divideBy !== 0) {
        baseValue /= divideBy;
      }
      if (eNotation) {
        baseValue *= Math.pow(10, powerValueSign * powerValue);
      }
      return sign * baseValue;
    },
    getString: function Lexer_getString() {
      var numParen = 1;
      var done = false;
      var strBuf = this.strBuf;
      strBuf.length = 0;
      var ch = this.nextChar();
      while (true) {
        var charBuffered = false;
        switch (ch | 0) {
          case -1:
            warn('Unterminated string');
            done = true;
            break;
          case 0x28:
            ++numParen;
            strBuf.push('(');
            break;
          case 0x29:
            if (--numParen === 0) {
              this.nextChar();
              done = true;
            } else {
              strBuf.push(')');
            }
            break;
          case 0x5C:
            ch = this.nextChar();
            switch (ch) {
              case -1:
                warn('Unterminated string');
                done = true;
                break;
              case 0x6E:
                strBuf.push('\n');
                break;
              case 0x72:
                strBuf.push('\r');
                break;
              case 0x74:
                strBuf.push('\t');
                break;
              case 0x62:
                strBuf.push('\b');
                break;
              case 0x66:
                strBuf.push('\f');
                break;
              case 0x5C:
              case 0x28:
              case 0x29:
                strBuf.push(String.fromCharCode(ch));
                break;
              case 0x30:
              case 0x31:
              case 0x32:
              case 0x33:
              case 0x34:
              case 0x35:
              case 0x36:
              case 0x37:
                var x = ch & 0x0F;
                ch = this.nextChar();
                charBuffered = true;
                if (ch >= 0x30 && ch <= 0x37) {
                  x = (x << 3) + (ch & 0x0F);
                  ch = this.nextChar();
                  if (ch >= 0x30 && ch <= 0x37) {
                    charBuffered = false;
                    x = (x << 3) + (ch & 0x0F);
                  }
                }
                strBuf.push(String.fromCharCode(x));
                break;
              case 0x0D:
                if (this.peekChar() === 0x0A) {
                  this.nextChar();
                }
                break;
              case 0x0A:
                break;
              default:
                strBuf.push(String.fromCharCode(ch));
                break;
            }
            break;
          default:
            strBuf.push(String.fromCharCode(ch));
            break;
        }
        if (done) {
          break;
        }
        if (!charBuffered) {
          ch = this.nextChar();
        }
      }
      return strBuf.join('');
    },
    getName: function Lexer_getName() {
      var ch, previousCh;
      var strBuf = this.strBuf;
      strBuf.length = 0;
      while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
        if (ch === 0x23) {
          ch = this.nextChar();
          if (specialChars[ch]) {
            warn('Lexer_getName: ' + 'NUMBER SIGN (#) should be followed by a hexadecimal number.');
            strBuf.push('#');
            break;
          }
          var x = toHexDigit(ch);
          if (x !== -1) {
            previousCh = ch;
            ch = this.nextChar();
            var x2 = toHexDigit(ch);
            if (x2 === -1) {
              warn('Lexer_getName: Illegal digit (' + String.fromCharCode(ch) + ') in hexadecimal number.');
              strBuf.push('#', String.fromCharCode(previousCh));
              if (specialChars[ch]) {
                break;
              }
              strBuf.push(String.fromCharCode(ch));
              continue;
            }
            strBuf.push(String.fromCharCode(x << 4 | x2));
          } else {
            strBuf.push('#', String.fromCharCode(ch));
          }
        } else {
          strBuf.push(String.fromCharCode(ch));
        }
      }
      if (strBuf.length > 127) {
        warn('name token is longer than allowed by the spec: ' + strBuf.length);
      }
      return Name.get(strBuf.join(''));
    },
    getHexString: function Lexer_getHexString() {
      var strBuf = this.strBuf;
      strBuf.length = 0;
      var ch = this.currentChar;
      var isFirstHex = true;
      var firstDigit;
      var secondDigit;
      while (true) {
        if (ch < 0) {
          warn('Unterminated hex string');
          break;
        } else if (ch === 0x3E) {
          this.nextChar();
          break;
        } else if (specialChars[ch] === 1) {
          ch = this.nextChar();
          continue;
        } else {
          if (isFirstHex) {
            firstDigit = toHexDigit(ch);
            if (firstDigit === -1) {
              warn('Ignoring invalid character "' + ch + '" in hex string');
              ch = this.nextChar();
              continue;
            }
          } else {
            secondDigit = toHexDigit(ch);
            if (secondDigit === -1) {
              warn('Ignoring invalid character "' + ch + '" in hex string');
              ch = this.nextChar();
              continue;
            }
            strBuf.push(String.fromCharCode(firstDigit << 4 | secondDigit));
          }
          isFirstHex = !isFirstHex;
          ch = this.nextChar();
        }
      }
      return strBuf.join('');
    },
    getObj: function Lexer_getObj() {
      var comment = false;
      var ch = this.currentChar;
      while (true) {
        if (ch < 0) {
          return EOF;
        }
        if (comment) {
          if (ch === 0x0A || ch === 0x0D) {
            comment = false;
          }
        } else if (ch === 0x25) {
          comment = true;
        } else if (specialChars[ch] !== 1) {
          break;
        }
        ch = this.nextChar();
      }
      switch (ch | 0) {
        case 0x30:
        case 0x31:
        case 0x32:
        case 0x33:
        case 0x34:
        case 0x35:
        case 0x36:
        case 0x37:
        case 0x38:
        case 0x39:
        case 0x2B:
        case 0x2D:
        case 0x2E:
          return this.getNumber();
        case 0x28:
          return this.getString();
        case 0x2F:
          return this.getName();
        case 0x5B:
          this.nextChar();
          return Cmd.get('[');
        case 0x5D:
          this.nextChar();
          return Cmd.get(']');
        case 0x3C:
          ch = this.nextChar();
          if (ch === 0x3C) {
            this.nextChar();
            return Cmd.get('<<');
          }
          return this.getHexString();
        case 0x3E:
          ch = this.nextChar();
          if (ch === 0x3E) {
            this.nextChar();
            return Cmd.get('>>');
          }
          return Cmd.get('>');
        case 0x7B:
          this.nextChar();
          return Cmd.get('{');
        case 0x7D:
          this.nextChar();
          return Cmd.get('}');
        case 0x29:
          this.nextChar();
          error('Illegal character: ' + ch);
          break;
      }
      var str = String.fromCharCode(ch);
      var knownCommands = this.knownCommands;
      var knownCommandFound = knownCommands && knownCommands[str] !== undefined;
      while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
        var possibleCommand = str + String.fromCharCode(ch);
        if (knownCommandFound && knownCommands[possibleCommand] === undefined) {
          break;
        }
        if (str.length === 128) {
          error('Command token too long: ' + str.length);
        }
        str = possibleCommand;
        knownCommandFound = knownCommands && knownCommands[str] !== undefined;
      }
      if (str === 'true') {
        return true;
      }
      if (str === 'false') {
        return false;
      }
      if (str === 'null') {
        return null;
      }
      return Cmd.get(str);
    },
    skipToNextLine: function Lexer_skipToNextLine() {
      var ch = this.currentChar;
      while (ch >= 0) {
        if (ch === 0x0D) {
          ch = this.nextChar();
          if (ch === 0x0A) {
            this.nextChar();
          }
          break;
        } else if (ch === 0x0A) {
          this.nextChar();
          break;
        }
        ch = this.nextChar();
      }
    }
  };
  return Lexer;
}();
var Linearization = {
  create: function LinearizationCreate(stream) {
    function getInt(name, allowZeroValue) {
      var obj = linDict.get(name);
      if (isInt(obj) && (allowZeroValue ? obj >= 0 : obj > 0)) {
        return obj;
      }
      throw new Error('The "' + name + '" parameter in the linearization ' + 'dictionary is invalid.');
    }
    function getHints() {
      var hints = linDict.get('H'),
          hintsLength,
          item;
      if (isArray(hints) && ((hintsLength = hints.length) === 2 || hintsLength === 4)) {
        for (var index = 0; index < hintsLength; index++) {
          if (!(isInt(item = hints[index]) && item > 0)) {
            throw new Error('Hint (' + index + ') in the linearization dictionary is invalid.');
          }
        }
        return hints;
      }
      throw new Error('Hint array in the linearization dictionary is invalid.');
    }
    var parser = new Parser(new Lexer(stream), false, null);
    var obj1 = parser.getObj();
    var obj2 = parser.getObj();
    var obj3 = parser.getObj();
    var linDict = parser.getObj();
    var obj, length;
    if (!(isInt(obj1) && isInt(obj2) && isCmd(obj3, 'obj') && isDict(linDict) && isNum(obj = linDict.get('Linearized')) && obj > 0)) {
      return null;
    } else if ((length = getInt('L')) !== stream.length) {
      throw new Error('The "L" parameter in the linearization dictionary ' + 'does not equal the stream length.');
    }
    return {
      length: length,
      hints: getHints(),
      objectNumberFirst: getInt('O'),
      endFirst: getInt('E'),
      numPages: getInt('N'),
      mainXRefEntriesOffset: getInt('T'),
      pageFirst: linDict.has('P') ? getInt('P', true) : 0
    };
  }
};
exports.Lexer = Lexer;
exports.Linearization = Linearization;
exports.Parser = Parser;

/***/ }),
/* 6 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var sharedUtil = __w_pdfjs_require__(0);
var corePrimitives = __w_pdfjs_require__(1);
var corePsParser = __w_pdfjs_require__(34);
var error = sharedUtil.error;
var info = sharedUtil.info;
var isArray = sharedUtil.isArray;
var isBool = sharedUtil.isBool;
var isDict = corePrimitives.isDict;
var isStream = corePrimitives.isStream;
var PostScriptLexer = corePsParser.PostScriptLexer;
var PostScriptParser = corePsParser.PostScriptParser;
var PDFFunction = function PDFFunctionClosure() {
  var CONSTRUCT_SAMPLED = 0;
  var CONSTRUCT_INTERPOLATED = 2;
  var CONSTRUCT_STICHED = 3;
  var CONSTRUCT_POSTSCRIPT = 4;
  return {
    getSampleArray: function PDFFunction_getSampleArray(size, outputSize, bps, str) {
      var i, ii;
      var length = 1;
      for (i = 0, ii = size.length; i < ii; i++) {
        length *= size[i];
      }
      length *= outputSize;
      var array = new Array(length);
      var codeSize = 0;
      var codeBuf = 0;
      var sampleMul = 1.0 / (Math.pow(2.0, bps) - 1);
      var strBytes = str.getBytes((length * bps + 7) / 8);
      var strIdx = 0;
      for (i = 0; i < length; i++) {
        while (codeSize < bps) {
          codeBuf <<= 8;
          codeBuf |= strBytes[strIdx++];
          codeSize += 8;
        }
        codeSize -= bps;
        array[i] = (codeBuf >> codeSize) * sampleMul;
        codeBuf &= (1 << codeSize) - 1;
      }
      return array;
    },
    getIR: function PDFFunction_getIR(xref, fn) {
      var dict = fn.dict;
      if (!dict) {
        dict = fn;
      }
      var types = [this.constructSampled, null, this.constructInterpolated, this.constructStiched, this.constructPostScript];
      var typeNum = dict.get('FunctionType');
      var typeFn = types[typeNum];
      if (!typeFn) {
        error('Unknown type of function');
      }
      return typeFn.call(this, fn, dict, xref);
    },
    fromIR: function PDFFunction_fromIR(IR) {
      var type = IR[0];
      switch (type) {
        case CONSTRUCT_SAMPLED:
          return this.constructSampledFromIR(IR);
        case CONSTRUCT_INTERPOLATED:
          return this.constructInterpolatedFromIR(IR);
        case CONSTRUCT_STICHED:
          return this.constructStichedFromIR(IR);
        default:
          return this.constructPostScriptFromIR(IR);
      }
    },
    parse: function PDFFunction_parse(xref, fn) {
      var IR = this.getIR(xref, fn);
      return this.fromIR(IR);
    },
    parseArray: function PDFFunction_parseArray(xref, fnObj) {
      if (!isArray(fnObj)) {
        return this.parse(xref, fnObj);
      }
      var fnArray = [];
      for (var j = 0, jj = fnObj.length; j < jj; j++) {
        var obj = xref.fetchIfRef(fnObj[j]);
        fnArray.push(PDFFunction.parse(xref, obj));
      }
      return function (src, srcOffset, dest, destOffset) {
        for (var i = 0, ii = fnArray.length; i < ii; i++) {
          fnArray[i](src, srcOffset, dest, destOffset + i);
        }
      };
    },
    constructSampled: function PDFFunction_constructSampled(str, dict) {
      function toMultiArray(arr) {
        var inputLength = arr.length;
        var out = [];
        var index = 0;
        for (var i = 0; i < inputLength; i += 2) {
          out[index] = [arr[i], arr[i + 1]];
          ++index;
        }
        return out;
      }
      var domain = dict.getArray('Domain');
      var range = dict.getArray('Range');
      if (!domain || !range) {
        error('No domain or range');
      }
      var inputSize = domain.length / 2;
      var outputSize = range.length / 2;
      domain = toMultiArray(domain);
      range = toMultiArray(range);
      var size = dict.get('Size');
      var bps = dict.get('BitsPerSample');
      var order = dict.get('Order') || 1;
      if (order !== 1) {
        info('No support for cubic spline interpolation: ' + order);
      }
      var encode = dict.getArray('Encode');
      if (!encode) {
        encode = [];
        for (var i = 0; i < inputSize; ++i) {
          encode.push(0);
          encode.push(size[i] - 1);
        }
      }
      encode = toMultiArray(encode);
      var decode = dict.getArray('Decode');
      if (!decode) {
        decode = range;
      } else {
        decode = toMultiArray(decode);
      }
      var samples = this.getSampleArray(size, outputSize, bps, str);
      return [CONSTRUCT_SAMPLED, inputSize, domain, encode, decode, samples, size, outputSize, Math.pow(2, bps) - 1, range];
    },
    constructSampledFromIR: function PDFFunction_constructSampledFromIR(IR) {
      function interpolate(x, xmin, xmax, ymin, ymax) {
        return ymin + (x - xmin) * ((ymax - ymin) / (xmax - xmin));
      }
      return function constructSampledFromIRResult(src, srcOffset, dest, destOffset) {
        var m = IR[1];
        var domain = IR[2];
        var encode = IR[3];
        var decode = IR[4];
        var samples = IR[5];
        var size = IR[6];
        var n = IR[7];
        var range = IR[9];
        var cubeVertices = 1 << m;
        var cubeN = new Float64Array(cubeVertices);
        var cubeVertex = new Uint32Array(cubeVertices);
        var i, j;
        for (j = 0; j < cubeVertices; j++) {
          cubeN[j] = 1;
        }
        var k = n,
            pos = 1;
        for (i = 0; i < m; ++i) {
          var domain_2i = domain[i][0];
          var domain_2i_1 = domain[i][1];
          var xi = Math.min(Math.max(src[srcOffset + i], domain_2i), domain_2i_1);
          var e = interpolate(xi, domain_2i, domain_2i_1, encode[i][0], encode[i][1]);
          var size_i = size[i];
          e = Math.min(Math.max(e, 0), size_i - 1);
          var e0 = e < size_i - 1 ? Math.floor(e) : e - 1;
          var n0 = e0 + 1 - e;
          var n1 = e - e0;
          var offset0 = e0 * k;
          var offset1 = offset0 + k;
          for (j = 0; j < cubeVertices; j++) {
            if (j & pos) {
              cubeN[j] *= n1;
              cubeVertex[j] += offset1;
            } else {
              cubeN[j] *= n0;
              cubeVertex[j] += offset0;
            }
          }
          k *= size_i;
          pos <<= 1;
        }
        for (j = 0; j < n; ++j) {
          var rj = 0;
          for (i = 0; i < cubeVertices; i++) {
            rj += samples[cubeVertex[i] + j] * cubeN[i];
          }
          rj = interpolate(rj, 0, 1, decode[j][0], decode[j][1]);
          dest[destOffset + j] = Math.min(Math.max(rj, range[j][0]), range[j][1]);
        }
      };
    },
    constructInterpolated: function PDFFunction_constructInterpolated(str, dict) {
      var c0 = dict.getArray('C0') || [0];
      var c1 = dict.getArray('C1') || [1];
      var n = dict.get('N');
      if (!isArray(c0) || !isArray(c1)) {
        error('Illegal dictionary for interpolated function');
      }
      var length = c0.length;
      var diff = [];
      for (var i = 0; i < length; ++i) {
        diff.push(c1[i] - c0[i]);
      }
      return [CONSTRUCT_INTERPOLATED, c0, diff, n];
    },
    constructInterpolatedFromIR: function PDFFunction_constructInterpolatedFromIR(IR) {
      var c0 = IR[1];
      var diff = IR[2];
      var n = IR[3];
      var length = diff.length;
      return function constructInterpolatedFromIRResult(src, srcOffset, dest, destOffset) {
        var x = n === 1 ? src[srcOffset] : Math.pow(src[srcOffset], n);
        for (var j = 0; j < length; ++j) {
          dest[destOffset + j] = c0[j] + x * diff[j];
        }
      };
    },
    constructStiched: function PDFFunction_constructStiched(fn, dict, xref) {
      var domain = dict.getArray('Domain');
      if (!domain) {
        error('No domain');
      }
      var inputSize = domain.length / 2;
      if (inputSize !== 1) {
        error('Bad domain for stiched function');
      }
      var fnRefs = dict.get('Functions');
      var fns = [];
      for (var i = 0, ii = fnRefs.length; i < ii; ++i) {
        fns.push(PDFFunction.getIR(xref, xref.fetchIfRef(fnRefs[i])));
      }
      var bounds = dict.getArray('Bounds');
      var encode = dict.getArray('Encode');
      return [CONSTRUCT_STICHED, domain, bounds, encode, fns];
    },
    constructStichedFromIR: function PDFFunction_constructStichedFromIR(IR) {
      var domain = IR[1];
      var bounds = IR[2];
      var encode = IR[3];
      var fnsIR = IR[4];
      var fns = [];
      var tmpBuf = new Float32Array(1);
      for (var i = 0, ii = fnsIR.length; i < ii; i++) {
        fns.push(PDFFunction.fromIR(fnsIR[i]));
      }
      return function constructStichedFromIRResult(src, srcOffset, dest, destOffset) {
        var clip = function constructStichedFromIRClip(v, min, max) {
          if (v > max) {
            v = max;
          } else if (v < min) {
            v = min;
          }
          return v;
        };
        var v = clip(src[srcOffset], domain[0], domain[1]);
        for (var i = 0, ii = bounds.length; i < ii; ++i) {
          if (v < bounds[i]) {
            break;
          }
        }
        var dmin = domain[0];
        if (i > 0) {
          dmin = bounds[i - 1];
        }
        var dmax = domain[1];
        if (i < bounds.length) {
          dmax = bounds[i];
        }
        var rmin = encode[2 * i];
        var rmax = encode[2 * i + 1];
        tmpBuf[0] = dmin === dmax ? rmin : rmin + (v - dmin) * (rmax - rmin) / (dmax - dmin);
        fns[i](tmpBuf, 0, dest, destOffset);
      };
    },
    constructPostScript: function PDFFunction_constructPostScript(fn, dict, xref) {
      var domain = dict.getArray('Domain');
      var range = dict.getArray('Range');
      if (!domain) {
        error('No domain.');
      }
      if (!range) {
        error('No range.');
      }
      var lexer = new PostScriptLexer(fn);
      var parser = new PostScriptParser(lexer);
      var code = parser.parse();
      return [CONSTRUCT_POSTSCRIPT, domain, range, code];
    },
    constructPostScriptFromIR: function PDFFunction_constructPostScriptFromIR(IR) {
      var domain = IR[1];
      var range = IR[2];
      var code = IR[3];
      var compiled = new PostScriptCompiler().compile(code, domain, range);
      if (compiled) {
        return new Function('src', 'srcOffset', 'dest', 'destOffset', compiled);
      }
      info('Unable to compile PS function');
      var numOutputs = range.length >> 1;
      var numInputs = domain.length >> 1;
      var evaluator = new PostScriptEvaluator(code);
      var cache = Object.create(null);
      var MAX_CACHE_SIZE = 2048 * 4;
      var cache_available = MAX_CACHE_SIZE;
      var tmpBuf = new Float32Array(numInputs);
      return function constructPostScriptFromIRResult(src, srcOffset, dest, destOffset) {
        var i, value;
        var key = '';
        var input = tmpBuf;
        for (i = 0; i < numInputs; i++) {
          value = src[srcOffset + i];
          input[i] = value;
          key += value + '_';
        }
        var cachedValue = cache[key];
        if (cachedValue !== undefined) {
          dest.set(cachedValue, destOffset);
          return;
        }
        var output = new Float32Array(numOutputs);
        var stack = evaluator.execute(input);
        var stackIndex = stack.length - numOutputs;
        for (i = 0; i < numOutputs; i++) {
          value = stack[stackIndex + i];
          var bound = range[i * 2];
          if (value < bound) {
            value = bound;
          } else {
            bound = range[i * 2 + 1];
            if (value > bound) {
              value = bound;
            }
          }
          output[i] = value;
        }
        if (cache_available > 0) {
          cache_available--;
          cache[key] = output;
        }
        dest.set(output, destOffset);
      };
    }
  };
}();
function isPDFFunction(v) {
  var fnDict;
  if ((typeof v === 'undefined' ? 'undefined' : _typeof(v)) !== 'object') {
    return false;
  } else if (isDict(v)) {
    fnDict = v;
  } else if (isStream(v)) {
    fnDict = v.dict;
  } else {
    return false;
  }
  return fnDict.has('FunctionType');
}
var PostScriptStack = function PostScriptStackClosure() {
  var MAX_STACK_SIZE = 100;
  function PostScriptStack(initialStack) {
    this.stack = !initialStack ? [] : Array.prototype.slice.call(initialStack, 0);
  }
  PostScriptStack.prototype = {
    push: function PostScriptStack_push(value) {
      if (this.stack.length >= MAX_STACK_SIZE) {
        error('PostScript function stack overflow.');
      }
      this.stack.push(value);
    },
    pop: function PostScriptStack_pop() {
      if (this.stack.length <= 0) {
        error('PostScript function stack underflow.');
      }
      return this.stack.pop();
    },
    copy: function PostScriptStack_copy(n) {
      if (this.stack.length + n >= MAX_STACK_SIZE) {
        error('PostScript function stack overflow.');
      }
      var stack = this.stack;
      for (var i = stack.length - n, j = n - 1; j >= 0; j--, i++) {
        stack.push(stack[i]);
      }
    },
    index: function PostScriptStack_index(n) {
      this.push(this.stack[this.stack.length - n - 1]);
    },
    roll: function PostScriptStack_roll(n, p) {
      var stack = this.stack;
      var l = stack.length - n;
      var r = stack.length - 1,
          c = l + (p - Math.floor(p / n) * n),
          i,
          j,
          t;
      for (i = l, j = r; i < j; i++, j--) {
        t = stack[i];
        stack[i] = stack[j];
        stack[j] = t;
      }
      for (i = l, j = c - 1; i < j; i++, j--) {
        t = stack[i];
        stack[i] = stack[j];
        stack[j] = t;
      }
      for (i = c, j = r; i < j; i++, j--) {
        t = stack[i];
        stack[i] = stack[j];
        stack[j] = t;
      }
    }
  };
  return PostScriptStack;
}();
var PostScriptEvaluator = function PostScriptEvaluatorClosure() {
  function PostScriptEvaluator(operators) {
    this.operators = operators;
  }
  PostScriptEvaluator.prototype = {
    execute: function PostScriptEvaluator_execute(initialStack) {
      var stack = new PostScriptStack(initialStack);
      var counter = 0;
      var operators = this.operators;
      var length = operators.length;
      var operator, a, b;
      while (counter < length) {
        operator = operators[counter++];
        if (typeof operator === 'number') {
          stack.push(operator);
          continue;
        }
        switch (operator) {
          case 'jz':
            b = stack.pop();
            a = stack.pop();
            if (!a) {
              counter = b;
            }
            break;
          case 'j':
            a = stack.pop();
            counter = a;
            break;
          case 'abs':
            a = stack.pop();
            stack.push(Math.abs(a));
            break;
          case 'add':
            b = stack.pop();
            a = stack.pop();
            stack.push(a + b);
            break;
          case 'and':
            b = stack.pop();
            a = stack.pop();
            if (isBool(a) && isBool(b)) {
              stack.push(a && b);
            } else {
              stack.push(a & b);
            }
            break;
          case 'atan':
            a = stack.pop();
            stack.push(Math.atan(a));
            break;
          case 'bitshift':
            b = stack.pop();
            a = stack.pop();
            if (a > 0) {
              stack.push(a << b);
            } else {
              stack.push(a >> b);
            }
            break;
          case 'ceiling':
            a = stack.pop();
            stack.push(Math.ceil(a));
            break;
          case 'copy':
            a = stack.pop();
            stack.copy(a);
            break;
          case 'cos':
            a = stack.pop();
            stack.push(Math.cos(a));
            break;
          case 'cvi':
            a = stack.pop() | 0;
            stack.push(a);
            break;
          case 'cvr':
            break;
          case 'div':
            b = stack.pop();
            a = stack.pop();
            stack.push(a / b);
            break;
          case 'dup':
            stack.copy(1);
            break;
          case 'eq':
            b = stack.pop();
            a = stack.pop();
            stack.push(a === b);
            break;
          case 'exch':
            stack.roll(2, 1);
            break;
          case 'exp':
            b = stack.pop();
            a = stack.pop();
            stack.push(Math.pow(a, b));
            break;
          case 'false':
            stack.push(false);
            break;
          case 'floor':
            a = stack.pop();
            stack.push(Math.floor(a));
            break;
          case 'ge':
            b = stack.pop();
            a = stack.pop();
            stack.push(a >= b);
            break;
          case 'gt':
            b = stack.pop();
            a = stack.pop();
            stack.push(a > b);
            break;
          case 'idiv':
            b = stack.pop();
            a = stack.pop();
            stack.push(a / b | 0);
            break;
          case 'index':
            a = stack.pop();
            stack.index(a);
            break;
          case 'le':
            b = stack.pop();
            a = stack.pop();
            stack.push(a <= b);
            break;
          case 'ln':
            a = stack.pop();
            stack.push(Math.log(a));
            break;
          case 'log':
            a = stack.pop();
            stack.push(Math.log(a) / Math.LN10);
            break;
          case 'lt':
            b = stack.pop();
            a = stack.pop();
            stack.push(a < b);
            break;
          case 'mod':
            b = stack.pop();
            a = stack.pop();
            stack.push(a % b);
            break;
          case 'mul':
            b = stack.pop();
            a = stack.pop();
            stack.push(a * b);
            break;
          case 'ne':
            b = stack.pop();
            a = stack.pop();
            stack.push(a !== b);
            break;
          case 'neg':
            a = stack.pop();
            stack.push(-a);
            break;
          case 'not':
            a = stack.pop();
            if (isBool(a)) {
              stack.push(!a);
            } else {
              stack.push(~a);
            }
            break;
          case 'or':
            b = stack.pop();
            a = stack.pop();
            if (isBool(a) && isBool(b)) {
              stack.push(a || b);
            } else {
              stack.push(a | b);
            }
            break;
          case 'pop':
            stack.pop();
            break;
          case 'roll':
            b = stack.pop();
            a = stack.pop();
            stack.roll(a, b);
            break;
          case 'round':
            a = stack.pop();
            stack.push(Math.round(a));
            break;
          case 'sin':
            a = stack.pop();
            stack.push(Math.sin(a));
            break;
          case 'sqrt':
            a = stack.pop();
            stack.push(Math.sqrt(a));
            break;
          case 'sub':
            b = stack.pop();
            a = stack.pop();
            stack.push(a - b);
            break;
          case 'true':
            stack.push(true);
            break;
          case 'truncate':
            a = stack.pop();
            a = a < 0 ? Math.ceil(a) : Math.floor(a);
            stack.push(a);
            break;
          case 'xor':
            b = stack.pop();
            a = stack.pop();
            if (isBool(a) && isBool(b)) {
              stack.push(a !== b);
            } else {
              stack.push(a ^ b);
            }
            break;
          default:
            error('Unknown operator ' + operator);
            break;
        }
      }
      return stack.stack;
    }
  };
  return PostScriptEvaluator;
}();
var PostScriptCompiler = function PostScriptCompilerClosure() {
  function AstNode(type) {
    this.type = type;
  }
  AstNode.prototype.visit = function (visitor) {
    throw new Error('abstract method');
  };
  function AstArgument(index, min, max) {
    AstNode.call(this, 'args');
    this.index = index;
    this.min = min;
    this.max = max;
  }
  AstArgument.prototype = Object.create(AstNode.prototype);
  AstArgument.prototype.visit = function (visitor) {
    visitor.visitArgument(this);
  };
  function AstLiteral(number) {
    AstNode.call(this, 'literal');
    this.number = number;
    this.min = number;
    this.max = number;
  }
  AstLiteral.prototype = Object.create(AstNode.prototype);
  AstLiteral.prototype.visit = function (visitor) {
    visitor.visitLiteral(this);
  };
  function AstBinaryOperation(op, arg1, arg2, min, max) {
    AstNode.call(this, 'binary');
    this.op = op;
    this.arg1 = arg1;
    this.arg2 = arg2;
    this.min = min;
    this.max = max;
  }
  AstBinaryOperation.prototype = Object.create(AstNode.prototype);
  AstBinaryOperation.prototype.visit = function (visitor) {
    visitor.visitBinaryOperation(this);
  };
  function AstMin(arg, max) {
    AstNode.call(this, 'max');
    this.arg = arg;
    this.min = arg.min;
    this.max = max;
  }
  AstMin.prototype = Object.create(AstNode.prototype);
  AstMin.prototype.visit = function (visitor) {
    visitor.visitMin(this);
  };
  function AstVariable(index, min, max) {
    AstNode.call(this, 'var');
    this.index = index;
    this.min = min;
    this.max = max;
  }
  AstVariable.prototype = Object.create(AstNode.prototype);
  AstVariable.prototype.visit = function (visitor) {
    visitor.visitVariable(this);
  };
  function AstVariableDefinition(variable, arg) {
    AstNode.call(this, 'definition');
    this.variable = variable;
    this.arg = arg;
  }
  AstVariableDefinition.prototype = Object.create(AstNode.prototype);
  AstVariableDefinition.prototype.visit = function (visitor) {
    visitor.visitVariableDefinition(this);
  };
  function ExpressionBuilderVisitor() {
    this.parts = [];
  }
  ExpressionBuilderVisitor.prototype = {
    visitArgument: function visitArgument(arg) {
      this.parts.push('Math.max(', arg.min, ', Math.min(', arg.max, ', src[srcOffset + ', arg.index, ']))');
    },
    visitVariable: function visitVariable(variable) {
      this.parts.push('v', variable.index);
    },
    visitLiteral: function visitLiteral(literal) {
      this.parts.push(literal.number);
    },
    visitBinaryOperation: function visitBinaryOperation(operation) {
      this.parts.push('(');
      operation.arg1.visit(this);
      this.parts.push(' ', operation.op, ' ');
      operation.arg2.visit(this);
      this.parts.push(')');
    },
    visitVariableDefinition: function visitVariableDefinition(definition) {
      this.parts.push('var ');
      definition.variable.visit(this);
      this.parts.push(' = ');
      definition.arg.visit(this);
      this.parts.push(';');
    },
    visitMin: function visitMin(max) {
      this.parts.push('Math.min(');
      max.arg.visit(this);
      this.parts.push(', ', max.max, ')');
    },
    toString: function toString() {
      return this.parts.join('');
    }
  };
  function buildAddOperation(num1, num2) {
    if (num2.type === 'literal' && num2.number === 0) {
      return num1;
    }
    if (num1.type === 'literal' && num1.number === 0) {
      return num2;
    }
    if (num2.type === 'literal' && num1.type === 'literal') {
      return new AstLiteral(num1.number + num2.number);
    }
    return new AstBinaryOperation('+', num1, num2, num1.min + num2.min, num1.max + num2.max);
  }
  function buildMulOperation(num1, num2) {
    if (num2.type === 'literal') {
      if (num2.number === 0) {
        return new AstLiteral(0);
      } else if (num2.number === 1) {
        return num1;
      } else if (num1.type === 'literal') {
        return new AstLiteral(num1.number * num2.number);
      }
    }
    if (num1.type === 'literal') {
      if (num1.number === 0) {
        return new AstLiteral(0);
      } else if (num1.number === 1) {
        return num2;
      }
    }
    var min = Math.min(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
    var max = Math.max(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
    return new AstBinaryOperation('*', num1, num2, min, max);
  }
  function buildSubOperation(num1, num2) {
    if (num2.type === 'literal') {
      if (num2.number === 0) {
        return num1;
      } else if (num1.type === 'literal') {
        return new AstLiteral(num1.number - num2.number);
      }
    }
    if (num2.type === 'binary' && num2.op === '-' && num1.type === 'literal' && num1.number === 1 && num2.arg1.type === 'literal' && num2.arg1.number === 1) {
      return num2.arg2;
    }
    return new AstBinaryOperation('-', num1, num2, num1.min - num2.max, num1.max - num2.min);
  }
  function buildMinOperation(num1, max) {
    if (num1.min >= max) {
      return new AstLiteral(max);
    } else if (num1.max <= max) {
      return num1;
    }
    return new AstMin(num1, max);
  }
  function PostScriptCompiler() {}
  PostScriptCompiler.prototype = {
    compile: function PostScriptCompiler_compile(code, domain, range) {
      var stack = [];
      var i, ii;
      var instructions = [];
      var inputSize = domain.length >> 1,
          outputSize = range.length >> 1;
      var lastRegister = 0;
      var n, j;
      var num1, num2, ast1, ast2, tmpVar, item;
      for (i = 0; i < inputSize; i++) {
        stack.push(new AstArgument(i, domain[i * 2], domain[i * 2 + 1]));
      }
      for (i = 0, ii = code.length; i < ii; i++) {
        item = code[i];
        if (typeof item === 'number') {
          stack.push(new AstLiteral(item));
          continue;
        }
        switch (item) {
          case 'add':
            if (stack.length < 2) {
              return null;
            }
            num2 = stack.pop();
            num1 = stack.pop();
            stack.push(buildAddOperation(num1, num2));
            break;
          case 'cvr':
            if (stack.length < 1) {
              return null;
            }
            break;
          case 'mul':
            if (stack.length < 2) {
              return null;
            }
            num2 = stack.pop();
            num1 = stack.pop();
            stack.push(buildMulOperation(num1, num2));
            break;
          case 'sub':
            if (stack.length < 2) {
              return null;
            }
            num2 = stack.pop();
            num1 = stack.pop();
            stack.push(buildSubOperation(num1, num2));
            break;
          case 'exch':
            if (stack.length < 2) {
              return null;
            }
            ast1 = stack.pop();
            ast2 = stack.pop();
            stack.push(ast1, ast2);
            break;
          case 'pop':
            if (stack.length < 1) {
              return null;
            }
            stack.pop();
            break;
          case 'index':
            if (stack.length < 1) {
              return null;
            }
            num1 = stack.pop();
            if (num1.type !== 'literal') {
              return null;
            }
            n = num1.number;
            if (n < 0 || (n | 0) !== n || stack.length < n) {
              return null;
            }
            ast1 = stack[stack.length - n - 1];
            if (ast1.type === 'literal' || ast1.type === 'var') {
              stack.push(ast1);
              break;
            }
            tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
            stack[stack.length - n - 1] = tmpVar;
            stack.push(tmpVar);
            instructions.push(new AstVariableDefinition(tmpVar, ast1));
            break;
          case 'dup':
            if (stack.length < 1) {
              return null;
            }
            if (typeof code[i + 1] === 'number' && code[i + 2] === 'gt' && code[i + 3] === i + 7 && code[i + 4] === 'jz' && code[i + 5] === 'pop' && code[i + 6] === code[i + 1]) {
              num1 = stack.pop();
              stack.push(buildMinOperation(num1, code[i + 1]));
              i += 6;
              break;
            }
            ast1 = stack[stack.length - 1];
            if (ast1.type === 'literal' || ast1.type === 'var') {
              stack.push(ast1);
              break;
            }
            tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
            stack[stack.length - 1] = tmpVar;
            stack.push(tmpVar);
            instructions.push(new AstVariableDefinition(tmpVar, ast1));
            break;
          case 'roll':
            if (stack.length < 2) {
              return null;
            }
            num2 = stack.pop();
            num1 = stack.pop();
            if (num2.type !== 'literal' || num1.type !== 'literal') {
              return null;
            }
            j = num2.number;
            n = num1.number;
            if (n <= 0 || (n | 0) !== n || (j | 0) !== j || stack.length < n) {
              return null;
            }
            j = (j % n + n) % n;
            if (j === 0) {
              break;
            }
            Array.prototype.push.apply(stack, stack.splice(stack.length - n, n - j));
            break;
          default:
            return null;
        }
      }
      if (stack.length !== outputSize) {
        return null;
      }
      var result = [];
      instructions.forEach(function (instruction) {
        var statementBuilder = new ExpressionBuilderVisitor();
        instruction.visit(statementBuilder);
        result.push(statementBuilder.toString());
      });
      stack.forEach(function (expr, i) {
        var statementBuilder = new ExpressionBuilderVisitor();
        expr.visit(statementBuilder);
        var min = range[i * 2],
            max = range[i * 2 + 1];
        var out = [statementBuilder.toString()];
        if (min > expr.min) {
          out.unshift('Math.max(', min, ', ');
          out.push(')');
        }
        if (max < expr.max) {
          out.unshift('Math.min(', max, ', ');
          out.push(')');
        }
        out.unshift('dest[destOffset + ', i, '] = ');
        out.push(';');
        result.push(out.join(''));
      });
      return result.join('\n');
    }
  };
  return PostScriptCompiler;
}();
exports.isPDFFunction = isPDFFunction;
exports.PDFFunction = PDFFunction;
exports.PostScriptEvaluator = PostScriptEvaluator;
exports.PostScriptCompiler = PostScriptCompiler;

/***/ }),
/* 7 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var getLookupTableFactory = sharedUtil.getLookupTableFactory;
var getGlyphsUnicode = getLookupTableFactory(function (t) {
  t['A'] = 0x0041;
  t['AE'] = 0x00C6;
  t['AEacute'] = 0x01FC;
  t['AEmacron'] = 0x01E2;
  t['AEsmall'] = 0xF7E6;
  t['Aacute'] = 0x00C1;
  t['Aacutesmall'] = 0xF7E1;
  t['Abreve'] = 0x0102;
  t['Abreveacute'] = 0x1EAE;
  t['Abrevecyrillic'] = 0x04D0;
  t['Abrevedotbelow'] = 0x1EB6;
  t['Abrevegrave'] = 0x1EB0;
  t['Abrevehookabove'] = 0x1EB2;
  t['Abrevetilde'] = 0x1EB4;
  t['Acaron'] = 0x01CD;
  t['Acircle'] = 0x24B6;
  t['Acircumflex'] = 0x00C2;
  t['Acircumflexacute'] = 0x1EA4;
  t['Acircumflexdotbelow'] = 0x1EAC;
  t['Acircumflexgrave'] = 0x1EA6;
  t['Acircumflexhookabove'] = 0x1EA8;
  t['Acircumflexsmall'] = 0xF7E2;
  t['Acircumflextilde'] = 0x1EAA;
  t['Acute'] = 0xF6C9;
  t['Acutesmall'] = 0xF7B4;
  t['Acyrillic'] = 0x0410;
  t['Adblgrave'] = 0x0200;
  t['Adieresis'] = 0x00C4;
  t['Adieresiscyrillic'] = 0x04D2;
  t['Adieresismacron'] = 0x01DE;
  t['Adieresissmall'] = 0xF7E4;
  t['Adotbelow'] = 0x1EA0;
  t['Adotmacron'] = 0x01E0;
  t['Agrave'] = 0x00C0;
  t['Agravesmall'] = 0xF7E0;
  t['Ahookabove'] = 0x1EA2;
  t['Aiecyrillic'] = 0x04D4;
  t['Ainvertedbreve'] = 0x0202;
  t['Alpha'] = 0x0391;
  t['Alphatonos'] = 0x0386;
  t['Amacron'] = 0x0100;
  t['Amonospace'] = 0xFF21;
  t['Aogonek'] = 0x0104;
  t['Aring'] = 0x00C5;
  t['Aringacute'] = 0x01FA;
  t['Aringbelow'] = 0x1E00;
  t['Aringsmall'] = 0xF7E5;
  t['Asmall'] = 0xF761;
  t['Atilde'] = 0x00C3;
  t['Atildesmall'] = 0xF7E3;
  t['Aybarmenian'] = 0x0531;
  t['B'] = 0x0042;
  t['Bcircle'] = 0x24B7;
  t['Bdotaccent'] = 0x1E02;
  t['Bdotbelow'] = 0x1E04;
  t['Becyrillic'] = 0x0411;
  t['Benarmenian'] = 0x0532;
  t['Beta'] = 0x0392;
  t['Bhook'] = 0x0181;
  t['Blinebelow'] = 0x1E06;
  t['Bmonospace'] = 0xFF22;
  t['Brevesmall'] = 0xF6F4;
  t['Bsmall'] = 0xF762;
  t['Btopbar'] = 0x0182;
  t['C'] = 0x0043;
  t['Caarmenian'] = 0x053E;
  t['Cacute'] = 0x0106;
  t['Caron'] = 0xF6CA;
  t['Caronsmall'] = 0xF6F5;
  t['Ccaron'] = 0x010C;
  t['Ccedilla'] = 0x00C7;
  t['Ccedillaacute'] = 0x1E08;
  t['Ccedillasmall'] = 0xF7E7;
  t['Ccircle'] = 0x24B8;
  t['Ccircumflex'] = 0x0108;
  t['Cdot'] = 0x010A;
  t['Cdotaccent'] = 0x010A;
  t['Cedillasmall'] = 0xF7B8;
  t['Chaarmenian'] = 0x0549;
  t['Cheabkhasiancyrillic'] = 0x04BC;
  t['Checyrillic'] = 0x0427;
  t['Chedescenderabkhasiancyrillic'] = 0x04BE;
  t['Chedescendercyrillic'] = 0x04B6;
  t['Chedieresiscyrillic'] = 0x04F4;
  t['Cheharmenian'] = 0x0543;
  t['Chekhakassiancyrillic'] = 0x04CB;
  t['Cheverticalstrokecyrillic'] = 0x04B8;
  t['Chi'] = 0x03A7;
  t['Chook'] = 0x0187;
  t['Circumflexsmall'] = 0xF6F6;
  t['Cmonospace'] = 0xFF23;
  t['Coarmenian'] = 0x0551;
  t['Csmall'] = 0xF763;
  t['D'] = 0x0044;
  t['DZ'] = 0x01F1;
  t['DZcaron'] = 0x01C4;
  t['Daarmenian'] = 0x0534;
  t['Dafrican'] = 0x0189;
  t['Dcaron'] = 0x010E;
  t['Dcedilla'] = 0x1E10;
  t['Dcircle'] = 0x24B9;
  t['Dcircumflexbelow'] = 0x1E12;
  t['Dcroat'] = 0x0110;
  t['Ddotaccent'] = 0x1E0A;
  t['Ddotbelow'] = 0x1E0C;
  t['Decyrillic'] = 0x0414;
  t['Deicoptic'] = 0x03EE;
  t['Delta'] = 0x2206;
  t['Deltagreek'] = 0x0394;
  t['Dhook'] = 0x018A;
  t['Dieresis'] = 0xF6CB;
  t['DieresisAcute'] = 0xF6CC;
  t['DieresisGrave'] = 0xF6CD;
  t['Dieresissmall'] = 0xF7A8;
  t['Digammagreek'] = 0x03DC;
  t['Djecyrillic'] = 0x0402;
  t['Dlinebelow'] = 0x1E0E;
  t['Dmonospace'] = 0xFF24;
  t['Dotaccentsmall'] = 0xF6F7;
  t['Dslash'] = 0x0110;
  t['Dsmall'] = 0xF764;
  t['Dtopbar'] = 0x018B;
  t['Dz'] = 0x01F2;
  t['Dzcaron'] = 0x01C5;
  t['Dzeabkhasiancyrillic'] = 0x04E0;
  t['Dzecyrillic'] = 0x0405;
  t['Dzhecyrillic'] = 0x040F;
  t['E'] = 0x0045;
  t['Eacute'] = 0x00C9;
  t['Eacutesmall'] = 0xF7E9;
  t['Ebreve'] = 0x0114;
  t['Ecaron'] = 0x011A;
  t['Ecedillabreve'] = 0x1E1C;
  t['Echarmenian'] = 0x0535;
  t['Ecircle'] = 0x24BA;
  t['Ecircumflex'] = 0x00CA;
  t['Ecircumflexacute'] = 0x1EBE;
  t['Ecircumflexbelow'] = 0x1E18;
  t['Ecircumflexdotbelow'] = 0x1EC6;
  t['Ecircumflexgrave'] = 0x1EC0;
  t['Ecircumflexhookabove'] = 0x1EC2;
  t['Ecircumflexsmall'] = 0xF7EA;
  t['Ecircumflextilde'] = 0x1EC4;
  t['Ecyrillic'] = 0x0404;
  t['Edblgrave'] = 0x0204;
  t['Edieresis'] = 0x00CB;
  t['Edieresissmall'] = 0xF7EB;
  t['Edot'] = 0x0116;
  t['Edotaccent'] = 0x0116;
  t['Edotbelow'] = 0x1EB8;
  t['Efcyrillic'] = 0x0424;
  t['Egrave'] = 0x00C8;
  t['Egravesmall'] = 0xF7E8;
  t['Eharmenian'] = 0x0537;
  t['Ehookabove'] = 0x1EBA;
  t['Eightroman'] = 0x2167;
  t['Einvertedbreve'] = 0x0206;
  t['Eiotifiedcyrillic'] = 0x0464;
  t['Elcyrillic'] = 0x041B;
  t['Elevenroman'] = 0x216A;
  t['Emacron'] = 0x0112;
  t['Emacronacute'] = 0x1E16;
  t['Emacrongrave'] = 0x1E14;
  t['Emcyrillic'] = 0x041C;
  t['Emonospace'] = 0xFF25;
  t['Encyrillic'] = 0x041D;
  t['Endescendercyrillic'] = 0x04A2;
  t['Eng'] = 0x014A;
  t['Enghecyrillic'] = 0x04A4;
  t['Enhookcyrillic'] = 0x04C7;
  t['Eogonek'] = 0x0118;
  t['Eopen'] = 0x0190;
  t['Epsilon'] = 0x0395;
  t['Epsilontonos'] = 0x0388;
  t['Ercyrillic'] = 0x0420;
  t['Ereversed'] = 0x018E;
  t['Ereversedcyrillic'] = 0x042D;
  t['Escyrillic'] = 0x0421;
  t['Esdescendercyrillic'] = 0x04AA;
  t['Esh'] = 0x01A9;
  t['Esmall'] = 0xF765;
  t['Eta'] = 0x0397;
  t['Etarmenian'] = 0x0538;
  t['Etatonos'] = 0x0389;
  t['Eth'] = 0x00D0;
  t['Ethsmall'] = 0xF7F0;
  t['Etilde'] = 0x1EBC;
  t['Etildebelow'] = 0x1E1A;
  t['Euro'] = 0x20AC;
  t['Ezh'] = 0x01B7;
  t['Ezhcaron'] = 0x01EE;
  t['Ezhreversed'] = 0x01B8;
  t['F'] = 0x0046;
  t['Fcircle'] = 0x24BB;
  t['Fdotaccent'] = 0x1E1E;
  t['Feharmenian'] = 0x0556;
  t['Feicoptic'] = 0x03E4;
  t['Fhook'] = 0x0191;
  t['Fitacyrillic'] = 0x0472;
  t['Fiveroman'] = 0x2164;
  t['Fmonospace'] = 0xFF26;
  t['Fourroman'] = 0x2163;
  t['Fsmall'] = 0xF766;
  t['G'] = 0x0047;
  t['GBsquare'] = 0x3387;
  t['Gacute'] = 0x01F4;
  t['Gamma'] = 0x0393;
  t['Gammaafrican'] = 0x0194;
  t['Gangiacoptic'] = 0x03EA;
  t['Gbreve'] = 0x011E;
  t['Gcaron'] = 0x01E6;
  t['Gcedilla'] = 0x0122;
  t['Gcircle'] = 0x24BC;
  t['Gcircumflex'] = 0x011C;
  t['Gcommaaccent'] = 0x0122;
  t['Gdot'] = 0x0120;
  t['Gdotaccent'] = 0x0120;
  t['Gecyrillic'] = 0x0413;
  t['Ghadarmenian'] = 0x0542;
  t['Ghemiddlehookcyrillic'] = 0x0494;
  t['Ghestrokecyrillic'] = 0x0492;
  t['Gheupturncyrillic'] = 0x0490;
  t['Ghook'] = 0x0193;
  t['Gimarmenian'] = 0x0533;
  t['Gjecyrillic'] = 0x0403;
  t['Gmacron'] = 0x1E20;
  t['Gmonospace'] = 0xFF27;
  t['Grave'] = 0xF6CE;
  t['Gravesmall'] = 0xF760;
  t['Gsmall'] = 0xF767;
  t['Gsmallhook'] = 0x029B;
  t['Gstroke'] = 0x01E4;
  t['H'] = 0x0048;
  t['H18533'] = 0x25CF;
  t['H18543'] = 0x25AA;
  t['H18551'] = 0x25AB;
  t['H22073'] = 0x25A1;
  t['HPsquare'] = 0x33CB;
  t['Haabkhasiancyrillic'] = 0x04A8;
  t['Hadescendercyrillic'] = 0x04B2;
  t['Hardsigncyrillic'] = 0x042A;
  t['Hbar'] = 0x0126;
  t['Hbrevebelow'] = 0x1E2A;
  t['Hcedilla'] = 0x1E28;
  t['Hcircle'] = 0x24BD;
  t['Hcircumflex'] = 0x0124;
  t['Hdieresis'] = 0x1E26;
  t['Hdotaccent'] = 0x1E22;
  t['Hdotbelow'] = 0x1E24;
  t['Hmonospace'] = 0xFF28;
  t['Hoarmenian'] = 0x0540;
  t['Horicoptic'] = 0x03E8;
  t['Hsmall'] = 0xF768;
  t['Hungarumlaut'] = 0xF6CF;
  t['Hungarumlautsmall'] = 0xF6F8;
  t['Hzsquare'] = 0x3390;
  t['I'] = 0x0049;
  t['IAcyrillic'] = 0x042F;
  t['IJ'] = 0x0132;
  t['IUcyrillic'] = 0x042E;
  t['Iacute'] = 0x00CD;
  t['Iacutesmall'] = 0xF7ED;
  t['Ibreve'] = 0x012C;
  t['Icaron'] = 0x01CF;
  t['Icircle'] = 0x24BE;
  t['Icircumflex'] = 0x00CE;
  t['Icircumflexsmall'] = 0xF7EE;
  t['Icyrillic'] = 0x0406;
  t['Idblgrave'] = 0x0208;
  t['Idieresis'] = 0x00CF;
  t['Idieresisacute'] = 0x1E2E;
  t['Idieresiscyrillic'] = 0x04E4;
  t['Idieresissmall'] = 0xF7EF;
  t['Idot'] = 0x0130;
  t['Idotaccent'] = 0x0130;
  t['Idotbelow'] = 0x1ECA;
  t['Iebrevecyrillic'] = 0x04D6;
  t['Iecyrillic'] = 0x0415;
  t['Ifraktur'] = 0x2111;
  t['Igrave'] = 0x00CC;
  t['Igravesmall'] = 0xF7EC;
  t['Ihookabove'] = 0x1EC8;
  t['Iicyrillic'] = 0x0418;
  t['Iinvertedbreve'] = 0x020A;
  t['Iishortcyrillic'] = 0x0419;
  t['Imacron'] = 0x012A;
  t['Imacroncyrillic'] = 0x04E2;
  t['Imonospace'] = 0xFF29;
  t['Iniarmenian'] = 0x053B;
  t['Iocyrillic'] = 0x0401;
  t['Iogonek'] = 0x012E;
  t['Iota'] = 0x0399;
  t['Iotaafrican'] = 0x0196;
  t['Iotadieresis'] = 0x03AA;
  t['Iotatonos'] = 0x038A;
  t['Ismall'] = 0xF769;
  t['Istroke'] = 0x0197;
  t['Itilde'] = 0x0128;
  t['Itildebelow'] = 0x1E2C;
  t['Izhitsacyrillic'] = 0x0474;
  t['Izhitsadblgravecyrillic'] = 0x0476;
  t['J'] = 0x004A;
  t['Jaarmenian'] = 0x0541;
  t['Jcircle'] = 0x24BF;
  t['Jcircumflex'] = 0x0134;
  t['Jecyrillic'] = 0x0408;
  t['Jheharmenian'] = 0x054B;
  t['Jmonospace'] = 0xFF2A;
  t['Jsmall'] = 0xF76A;
  t['K'] = 0x004B;
  t['KBsquare'] = 0x3385;
  t['KKsquare'] = 0x33CD;
  t['Kabashkircyrillic'] = 0x04A0;
  t['Kacute'] = 0x1E30;
  t['Kacyrillic'] = 0x041A;
  t['Kadescendercyrillic'] = 0x049A;
  t['Kahookcyrillic'] = 0x04C3;
  t['Kappa'] = 0x039A;
  t['Kastrokecyrillic'] = 0x049E;
  t['Kaverticalstrokecyrillic'] = 0x049C;
  t['Kcaron'] = 0x01E8;
  t['Kcedilla'] = 0x0136;
  t['Kcircle'] = 0x24C0;
  t['Kcommaaccent'] = 0x0136;
  t['Kdotbelow'] = 0x1E32;
  t['Keharmenian'] = 0x0554;
  t['Kenarmenian'] = 0x053F;
  t['Khacyrillic'] = 0x0425;
  t['Kheicoptic'] = 0x03E6;
  t['Khook'] = 0x0198;
  t['Kjecyrillic'] = 0x040C;
  t['Klinebelow'] = 0x1E34;
  t['Kmonospace'] = 0xFF2B;
  t['Koppacyrillic'] = 0x0480;
  t['Koppagreek'] = 0x03DE;
  t['Ksicyrillic'] = 0x046E;
  t['Ksmall'] = 0xF76B;
  t['L'] = 0x004C;
  t['LJ'] = 0x01C7;
  t['LL'] = 0xF6BF;
  t['Lacute'] = 0x0139;
  t['Lambda'] = 0x039B;
  t['Lcaron'] = 0x013D;
  t['Lcedilla'] = 0x013B;
  t['Lcircle'] = 0x24C1;
  t['Lcircumflexbelow'] = 0x1E3C;
  t['Lcommaaccent'] = 0x013B;
  t['Ldot'] = 0x013F;
  t['Ldotaccent'] = 0x013F;
  t['Ldotbelow'] = 0x1E36;
  t['Ldotbelowmacron'] = 0x1E38;
  t['Liwnarmenian'] = 0x053C;
  t['Lj'] = 0x01C8;
  t['Ljecyrillic'] = 0x0409;
  t['Llinebelow'] = 0x1E3A;
  t['Lmonospace'] = 0xFF2C;
  t['Lslash'] = 0x0141;
  t['Lslashsmall'] = 0xF6F9;
  t['Lsmall'] = 0xF76C;
  t['M'] = 0x004D;
  t['MBsquare'] = 0x3386;
  t['Macron'] = 0xF6D0;
  t['Macronsmall'] = 0xF7AF;
  t['Macute'] = 0x1E3E;
  t['Mcircle'] = 0x24C2;
  t['Mdotaccent'] = 0x1E40;
  t['Mdotbelow'] = 0x1E42;
  t['Menarmenian'] = 0x0544;
  t['Mmonospace'] = 0xFF2D;
  t['Msmall'] = 0xF76D;
  t['Mturned'] = 0x019C;
  t['Mu'] = 0x039C;
  t['N'] = 0x004E;
  t['NJ'] = 0x01CA;
  t['Nacute'] = 0x0143;
  t['Ncaron'] = 0x0147;
  t['Ncedilla'] = 0x0145;
  t['Ncircle'] = 0x24C3;
  t['Ncircumflexbelow'] = 0x1E4A;
  t['Ncommaaccent'] = 0x0145;
  t['Ndotaccent'] = 0x1E44;
  t['Ndotbelow'] = 0x1E46;
  t['Nhookleft'] = 0x019D;
  t['Nineroman'] = 0x2168;
  t['Nj'] = 0x01CB;
  t['Njecyrillic'] = 0x040A;
  t['Nlinebelow'] = 0x1E48;
  t['Nmonospace'] = 0xFF2E;
  t['Nowarmenian'] = 0x0546;
  t['Nsmall'] = 0xF76E;
  t['Ntilde'] = 0x00D1;
  t['Ntildesmall'] = 0xF7F1;
  t['Nu'] = 0x039D;
  t['O'] = 0x004F;
  t['OE'] = 0x0152;
  t['OEsmall'] = 0xF6FA;
  t['Oacute'] = 0x00D3;
  t['Oacutesmall'] = 0xF7F3;
  t['Obarredcyrillic'] = 0x04E8;
  t['Obarreddieresiscyrillic'] = 0x04EA;
  t['Obreve'] = 0x014E;
  t['Ocaron'] = 0x01D1;
  t['Ocenteredtilde'] = 0x019F;
  t['Ocircle'] = 0x24C4;
  t['Ocircumflex'] = 0x00D4;
  t['Ocircumflexacute'] = 0x1ED0;
  t['Ocircumflexdotbelow'] = 0x1ED8;
  t['Ocircumflexgrave'] = 0x1ED2;
  t['Ocircumflexhookabove'] = 0x1ED4;
  t['Ocircumflexsmall'] = 0xF7F4;
  t['Ocircumflextilde'] = 0x1ED6;
  t['Ocyrillic'] = 0x041E;
  t['Odblacute'] = 0x0150;
  t['Odblgrave'] = 0x020C;
  t['Odieresis'] = 0x00D6;
  t['Odieresiscyrillic'] = 0x04E6;
  t['Odieresissmall'] = 0xF7F6;
  t['Odotbelow'] = 0x1ECC;
  t['Ogoneksmall'] = 0xF6FB;
  t['Ograve'] = 0x00D2;
  t['Ogravesmall'] = 0xF7F2;
  t['Oharmenian'] = 0x0555;
  t['Ohm'] = 0x2126;
  t['Ohookabove'] = 0x1ECE;
  t['Ohorn'] = 0x01A0;
  t['Ohornacute'] = 0x1EDA;
  t['Ohorndotbelow'] = 0x1EE2;
  t['Ohorngrave'] = 0x1EDC;
  t['Ohornhookabove'] = 0x1EDE;
  t['Ohorntilde'] = 0x1EE0;
  t['Ohungarumlaut'] = 0x0150;
  t['Oi'] = 0x01A2;
  t['Oinvertedbreve'] = 0x020E;
  t['Omacron'] = 0x014C;
  t['Omacronacute'] = 0x1E52;
  t['Omacrongrave'] = 0x1E50;
  t['Omega'] = 0x2126;
  t['Omegacyrillic'] = 0x0460;
  t['Omegagreek'] = 0x03A9;
  t['Omegaroundcyrillic'] = 0x047A;
  t['Omegatitlocyrillic'] = 0x047C;
  t['Omegatonos'] = 0x038F;
  t['Omicron'] = 0x039F;
  t['Omicrontonos'] = 0x038C;
  t['Omonospace'] = 0xFF2F;
  t['Oneroman'] = 0x2160;
  t['Oogonek'] = 0x01EA;
  t['Oogonekmacron'] = 0x01EC;
  t['Oopen'] = 0x0186;
  t['Oslash'] = 0x00D8;
  t['Oslashacute'] = 0x01FE;
  t['Oslashsmall'] = 0xF7F8;
  t['Osmall'] = 0xF76F;
  t['Ostrokeacute'] = 0x01FE;
  t['Otcyrillic'] = 0x047E;
  t['Otilde'] = 0x00D5;
  t['Otildeacute'] = 0x1E4C;
  t['Otildedieresis'] = 0x1E4E;
  t['Otildesmall'] = 0xF7F5;
  t['P'] = 0x0050;
  t['Pacute'] = 0x1E54;
  t['Pcircle'] = 0x24C5;
  t['Pdotaccent'] = 0x1E56;
  t['Pecyrillic'] = 0x041F;
  t['Peharmenian'] = 0x054A;
  t['Pemiddlehookcyrillic'] = 0x04A6;
  t['Phi'] = 0x03A6;
  t['Phook'] = 0x01A4;
  t['Pi'] = 0x03A0;
  t['Piwrarmenian'] = 0x0553;
  t['Pmonospace'] = 0xFF30;
  t['Psi'] = 0x03A8;
  t['Psicyrillic'] = 0x0470;
  t['Psmall'] = 0xF770;
  t['Q'] = 0x0051;
  t['Qcircle'] = 0x24C6;
  t['Qmonospace'] = 0xFF31;
  t['Qsmall'] = 0xF771;
  t['R'] = 0x0052;
  t['Raarmenian'] = 0x054C;
  t['Racute'] = 0x0154;
  t['Rcaron'] = 0x0158;
  t['Rcedilla'] = 0x0156;
  t['Rcircle'] = 0x24C7;
  t['Rcommaaccent'] = 0x0156;
  t['Rdblgrave'] = 0x0210;
  t['Rdotaccent'] = 0x1E58;
  t['Rdotbelow'] = 0x1E5A;
  t['Rdotbelowmacron'] = 0x1E5C;
  t['Reharmenian'] = 0x0550;
  t['Rfraktur'] = 0x211C;
  t['Rho'] = 0x03A1;
  t['Ringsmall'] = 0xF6FC;
  t['Rinvertedbreve'] = 0x0212;
  t['Rlinebelow'] = 0x1E5E;
  t['Rmonospace'] = 0xFF32;
  t['Rsmall'] = 0xF772;
  t['Rsmallinverted'] = 0x0281;
  t['Rsmallinvertedsuperior'] = 0x02B6;
  t['S'] = 0x0053;
  t['SF010000'] = 0x250C;
  t['SF020000'] = 0x2514;
  t['SF030000'] = 0x2510;
  t['SF040000'] = 0x2518;
  t['SF050000'] = 0x253C;
  t['SF060000'] = 0x252C;
  t['SF070000'] = 0x2534;
  t['SF080000'] = 0x251C;
  t['SF090000'] = 0x2524;
  t['SF100000'] = 0x2500;
  t['SF110000'] = 0x2502;
  t['SF190000'] = 0x2561;
  t['SF200000'] = 0x2562;
  t['SF210000'] = 0x2556;
  t['SF220000'] = 0x2555;
  t['SF230000'] = 0x2563;
  t['SF240000'] = 0x2551;
  t['SF250000'] = 0x2557;
  t['SF260000'] = 0x255D;
  t['SF270000'] = 0x255C;
  t['SF280000'] = 0x255B;
  t['SF360000'] = 0x255E;
  t['SF370000'] = 0x255F;
  t['SF380000'] = 0x255A;
  t['SF390000'] = 0x2554;
  t['SF400000'] = 0x2569;
  t['SF410000'] = 0x2566;
  t['SF420000'] = 0x2560;
  t['SF430000'] = 0x2550;
  t['SF440000'] = 0x256C;
  t['SF450000'] = 0x2567;
  t['SF460000'] = 0x2568;
  t['SF470000'] = 0x2564;
  t['SF480000'] = 0x2565;
  t['SF490000'] = 0x2559;
  t['SF500000'] = 0x2558;
  t['SF510000'] = 0x2552;
  t['SF520000'] = 0x2553;
  t['SF530000'] = 0x256B;
  t['SF540000'] = 0x256A;
  t['Sacute'] = 0x015A;
  t['Sacutedotaccent'] = 0x1E64;
  t['Sampigreek'] = 0x03E0;
  t['Scaron'] = 0x0160;
  t['Scarondotaccent'] = 0x1E66;
  t['Scaronsmall'] = 0xF6FD;
  t['Scedilla'] = 0x015E;
  t['Schwa'] = 0x018F;
  t['Schwacyrillic'] = 0x04D8;
  t['Schwadieresiscyrillic'] = 0x04DA;
  t['Scircle'] = 0x24C8;
  t['Scircumflex'] = 0x015C;
  t['Scommaaccent'] = 0x0218;
  t['Sdotaccent'] = 0x1E60;
  t['Sdotbelow'] = 0x1E62;
  t['Sdotbelowdotaccent'] = 0x1E68;
  t['Seharmenian'] = 0x054D;
  t['Sevenroman'] = 0x2166;
  t['Shaarmenian'] = 0x0547;
  t['Shacyrillic'] = 0x0428;
  t['Shchacyrillic'] = 0x0429;
  t['Sheicoptic'] = 0x03E2;
  t['Shhacyrillic'] = 0x04BA;
  t['Shimacoptic'] = 0x03EC;
  t['Sigma'] = 0x03A3;
  t['Sixroman'] = 0x2165;
  t['Smonospace'] = 0xFF33;
  t['Softsigncyrillic'] = 0x042C;
  t['Ssmall'] = 0xF773;
  t['Stigmagreek'] = 0x03DA;
  t['T'] = 0x0054;
  t['Tau'] = 0x03A4;
  t['Tbar'] = 0x0166;
  t['Tcaron'] = 0x0164;
  t['Tcedilla'] = 0x0162;
  t['Tcircle'] = 0x24C9;
  t['Tcircumflexbelow'] = 0x1E70;
  t['Tcommaaccent'] = 0x0162;
  t['Tdotaccent'] = 0x1E6A;
  t['Tdotbelow'] = 0x1E6C;
  t['Tecyrillic'] = 0x0422;
  t['Tedescendercyrillic'] = 0x04AC;
  t['Tenroman'] = 0x2169;
  t['Tetsecyrillic'] = 0x04B4;
  t['Theta'] = 0x0398;
  t['Thook'] = 0x01AC;
  t['Thorn'] = 0x00DE;
  t['Thornsmall'] = 0xF7FE;
  t['Threeroman'] = 0x2162;
  t['Tildesmall'] = 0xF6FE;
  t['Tiwnarmenian'] = 0x054F;
  t['Tlinebelow'] = 0x1E6E;
  t['Tmonospace'] = 0xFF34;
  t['Toarmenian'] = 0x0539;
  t['Tonefive'] = 0x01BC;
  t['Tonesix'] = 0x0184;
  t['Tonetwo'] = 0x01A7;
  t['Tretroflexhook'] = 0x01AE;
  t['Tsecyrillic'] = 0x0426;
  t['Tshecyrillic'] = 0x040B;
  t['Tsmall'] = 0xF774;
  t['Twelveroman'] = 0x216B;
  t['Tworoman'] = 0x2161;
  t['U'] = 0x0055;
  t['Uacute'] = 0x00DA;
  t['Uacutesmall'] = 0xF7FA;
  t['Ubreve'] = 0x016C;
  t['Ucaron'] = 0x01D3;
  t['Ucircle'] = 0x24CA;
  t['Ucircumflex'] = 0x00DB;
  t['Ucircumflexbelow'] = 0x1E76;
  t['Ucircumflexsmall'] = 0xF7FB;
  t['Ucyrillic'] = 0x0423;
  t['Udblacute'] = 0x0170;
  t['Udblgrave'] = 0x0214;
  t['Udieresis'] = 0x00DC;
  t['Udieresisacute'] = 0x01D7;
  t['Udieresisbelow'] = 0x1E72;
  t['Udieresiscaron'] = 0x01D9;
  t['Udieresiscyrillic'] = 0x04F0;
  t['Udieresisgrave'] = 0x01DB;
  t['Udieresismacron'] = 0x01D5;
  t['Udieresissmall'] = 0xF7FC;
  t['Udotbelow'] = 0x1EE4;
  t['Ugrave'] = 0x00D9;
  t['Ugravesmall'] = 0xF7F9;
  t['Uhookabove'] = 0x1EE6;
  t['Uhorn'] = 0x01AF;
  t['Uhornacute'] = 0x1EE8;
  t['Uhorndotbelow'] = 0x1EF0;
  t['Uhorngrave'] = 0x1EEA;
  t['Uhornhookabove'] = 0x1EEC;
  t['Uhorntilde'] = 0x1EEE;
  t['Uhungarumlaut'] = 0x0170;
  t['Uhungarumlautcyrillic'] = 0x04F2;
  t['Uinvertedbreve'] = 0x0216;
  t['Ukcyrillic'] = 0x0478;
  t['Umacron'] = 0x016A;
  t['Umacroncyrillic'] = 0x04EE;
  t['Umacrondieresis'] = 0x1E7A;
  t['Umonospace'] = 0xFF35;
  t['Uogonek'] = 0x0172;
  t['Upsilon'] = 0x03A5;
  t['Upsilon1'] = 0x03D2;
  t['Upsilonacutehooksymbolgreek'] = 0x03D3;
  t['Upsilonafrican'] = 0x01B1;
  t['Upsilondieresis'] = 0x03AB;
  t['Upsilondieresishooksymbolgreek'] = 0x03D4;
  t['Upsilonhooksymbol'] = 0x03D2;
  t['Upsilontonos'] = 0x038E;
  t['Uring'] = 0x016E;
  t['Ushortcyrillic'] = 0x040E;
  t['Usmall'] = 0xF775;
  t['Ustraightcyrillic'] = 0x04AE;
  t['Ustraightstrokecyrillic'] = 0x04B0;
  t['Utilde'] = 0x0168;
  t['Utildeacute'] = 0x1E78;
  t['Utildebelow'] = 0x1E74;
  t['V'] = 0x0056;
  t['Vcircle'] = 0x24CB;
  t['Vdotbelow'] = 0x1E7E;
  t['Vecyrillic'] = 0x0412;
  t['Vewarmenian'] = 0x054E;
  t['Vhook'] = 0x01B2;
  t['Vmonospace'] = 0xFF36;
  t['Voarmenian'] = 0x0548;
  t['Vsmall'] = 0xF776;
  t['Vtilde'] = 0x1E7C;
  t['W'] = 0x0057;
  t['Wacute'] = 0x1E82;
  t['Wcircle'] = 0x24CC;
  t['Wcircumflex'] = 0x0174;
  t['Wdieresis'] = 0x1E84;
  t['Wdotaccent'] = 0x1E86;
  t['Wdotbelow'] = 0x1E88;
  t['Wgrave'] = 0x1E80;
  t['Wmonospace'] = 0xFF37;
  t['Wsmall'] = 0xF777;
  t['X'] = 0x0058;
  t['Xcircle'] = 0x24CD;
  t['Xdieresis'] = 0x1E8C;
  t['Xdotaccent'] = 0x1E8A;
  t['Xeharmenian'] = 0x053D;
  t['Xi'] = 0x039E;
  t['Xmonospace'] = 0xFF38;
  t['Xsmall'] = 0xF778;
  t['Y'] = 0x0059;
  t['Yacute'] = 0x00DD;
  t['Yacutesmall'] = 0xF7FD;
  t['Yatcyrillic'] = 0x0462;
  t['Ycircle'] = 0x24CE;
  t['Ycircumflex'] = 0x0176;
  t['Ydieresis'] = 0x0178;
  t['Ydieresissmall'] = 0xF7FF;
  t['Ydotaccent'] = 0x1E8E;
  t['Ydotbelow'] = 0x1EF4;
  t['Yericyrillic'] = 0x042B;
  t['Yerudieresiscyrillic'] = 0x04F8;
  t['Ygrave'] = 0x1EF2;
  t['Yhook'] = 0x01B3;
  t['Yhookabove'] = 0x1EF6;
  t['Yiarmenian'] = 0x0545;
  t['Yicyrillic'] = 0x0407;
  t['Yiwnarmenian'] = 0x0552;
  t['Ymonospace'] = 0xFF39;
  t['Ysmall'] = 0xF779;
  t['Ytilde'] = 0x1EF8;
  t['Yusbigcyrillic'] = 0x046A;
  t['Yusbigiotifiedcyrillic'] = 0x046C;
  t['Yuslittlecyrillic'] = 0x0466;
  t['Yuslittleiotifiedcyrillic'] = 0x0468;
  t['Z'] = 0x005A;
  t['Zaarmenian'] = 0x0536;
  t['Zacute'] = 0x0179;
  t['Zcaron'] = 0x017D;
  t['Zcaronsmall'] = 0xF6FF;
  t['Zcircle'] = 0x24CF;
  t['Zcircumflex'] = 0x1E90;
  t['Zdot'] = 0x017B;
  t['Zdotaccent'] = 0x017B;
  t['Zdotbelow'] = 0x1E92;
  t['Zecyrillic'] = 0x0417;
  t['Zedescendercyrillic'] = 0x0498;
  t['Zedieresiscyrillic'] = 0x04DE;
  t['Zeta'] = 0x0396;
  t['Zhearmenian'] = 0x053A;
  t['Zhebrevecyrillic'] = 0x04C1;
  t['Zhecyrillic'] = 0x0416;
  t['Zhedescendercyrillic'] = 0x0496;
  t['Zhedieresiscyrillic'] = 0x04DC;
  t['Zlinebelow'] = 0x1E94;
  t['Zmonospace'] = 0xFF3A;
  t['Zsmall'] = 0xF77A;
  t['Zstroke'] = 0x01B5;
  t['a'] = 0x0061;
  t['aabengali'] = 0x0986;
  t['aacute'] = 0x00E1;
  t['aadeva'] = 0x0906;
  t['aagujarati'] = 0x0A86;
  t['aagurmukhi'] = 0x0A06;
  t['aamatragurmukhi'] = 0x0A3E;
  t['aarusquare'] = 0x3303;
  t['aavowelsignbengali'] = 0x09BE;
  t['aavowelsigndeva'] = 0x093E;
  t['aavowelsigngujarati'] = 0x0ABE;
  t['abbreviationmarkarmenian'] = 0x055F;
  t['abbreviationsigndeva'] = 0x0970;
  t['abengali'] = 0x0985;
  t['abopomofo'] = 0x311A;
  t['abreve'] = 0x0103;
  t['abreveacute'] = 0x1EAF;
  t['abrevecyrillic'] = 0x04D1;
  t['abrevedotbelow'] = 0x1EB7;
  t['abrevegrave'] = 0x1EB1;
  t['abrevehookabove'] = 0x1EB3;
  t['abrevetilde'] = 0x1EB5;
  t['acaron'] = 0x01CE;
  t['acircle'] = 0x24D0;
  t['acircumflex'] = 0x00E2;
  t['acircumflexacute'] = 0x1EA5;
  t['acircumflexdotbelow'] = 0x1EAD;
  t['acircumflexgrave'] = 0x1EA7;
  t['acircumflexhookabove'] = 0x1EA9;
  t['acircumflextilde'] = 0x1EAB;
  t['acute'] = 0x00B4;
  t['acutebelowcmb'] = 0x0317;
  t['acutecmb'] = 0x0301;
  t['acutecomb'] = 0x0301;
  t['acutedeva'] = 0x0954;
  t['acutelowmod'] = 0x02CF;
  t['acutetonecmb'] = 0x0341;
  t['acyrillic'] = 0x0430;
  t['adblgrave'] = 0x0201;
  t['addakgurmukhi'] = 0x0A71;
  t['adeva'] = 0x0905;
  t['adieresis'] = 0x00E4;
  t['adieresiscyrillic'] = 0x04D3;
  t['adieresismacron'] = 0x01DF;
  t['adotbelow'] = 0x1EA1;
  t['adotmacron'] = 0x01E1;
  t['ae'] = 0x00E6;
  t['aeacute'] = 0x01FD;
  t['aekorean'] = 0x3150;
  t['aemacron'] = 0x01E3;
  t['afii00208'] = 0x2015;
  t['afii08941'] = 0x20A4;
  t['afii10017'] = 0x0410;
  t['afii10018'] = 0x0411;
  t['afii10019'] = 0x0412;
  t['afii10020'] = 0x0413;
  t['afii10021'] = 0x0414;
  t['afii10022'] = 0x0415;
  t['afii10023'] = 0x0401;
  t['afii10024'] = 0x0416;
  t['afii10025'] = 0x0417;
  t['afii10026'] = 0x0418;
  t['afii10027'] = 0x0419;
  t['afii10028'] = 0x041A;
  t['afii10029'] = 0x041B;
  t['afii10030'] = 0x041C;
  t['afii10031'] = 0x041D;
  t['afii10032'] = 0x041E;
  t['afii10033'] = 0x041F;
  t['afii10034'] = 0x0420;
  t['afii10035'] = 0x0421;
  t['afii10036'] = 0x0422;
  t['afii10037'] = 0x0423;
  t['afii10038'] = 0x0424;
  t['afii10039'] = 0x0425;
  t['afii10040'] = 0x0426;
  t['afii10041'] = 0x0427;
  t['afii10042'] = 0x0428;
  t['afii10043'] = 0x0429;
  t['afii10044'] = 0x042A;
  t['afii10045'] = 0x042B;
  t['afii10046'] = 0x042C;
  t['afii10047'] = 0x042D;
  t['afii10048'] = 0x042E;
  t['afii10049'] = 0x042F;
  t['afii10050'] = 0x0490;
  t['afii10051'] = 0x0402;
  t['afii10052'] = 0x0403;
  t['afii10053'] = 0x0404;
  t['afii10054'] = 0x0405;
  t['afii10055'] = 0x0406;
  t['afii10056'] = 0x0407;
  t['afii10057'] = 0x0408;
  t['afii10058'] = 0x0409;
  t['afii10059'] = 0x040A;
  t['afii10060'] = 0x040B;
  t['afii10061'] = 0x040C;
  t['afii10062'] = 0x040E;
  t['afii10063'] = 0xF6C4;
  t['afii10064'] = 0xF6C5;
  t['afii10065'] = 0x0430;
  t['afii10066'] = 0x0431;
  t['afii10067'] = 0x0432;
  t['afii10068'] = 0x0433;
  t['afii10069'] = 0x0434;
  t['afii10070'] = 0x0435;
  t['afii10071'] = 0x0451;
  t['afii10072'] = 0x0436;
  t['afii10073'] = 0x0437;
  t['afii10074'] = 0x0438;
  t['afii10075'] = 0x0439;
  t['afii10076'] = 0x043A;
  t['afii10077'] = 0x043B;
  t['afii10078'] = 0x043C;
  t['afii10079'] = 0x043D;
  t['afii10080'] = 0x043E;
  t['afii10081'] = 0x043F;
  t['afii10082'] = 0x0440;
  t['afii10083'] = 0x0441;
  t['afii10084'] = 0x0442;
  t['afii10085'] = 0x0443;
  t['afii10086'] = 0x0444;
  t['afii10087'] = 0x0445;
  t['afii10088'] = 0x0446;
  t['afii10089'] = 0x0447;
  t['afii10090'] = 0x0448;
  t['afii10091'] = 0x0449;
  t['afii10092'] = 0x044A;
  t['afii10093'] = 0x044B;
  t['afii10094'] = 0x044C;
  t['afii10095'] = 0x044D;
  t['afii10096'] = 0x044E;
  t['afii10097'] = 0x044F;
  t['afii10098'] = 0x0491;
  t['afii10099'] = 0x0452;
  t['afii10100'] = 0x0453;
  t['afii10101'] = 0x0454;
  t['afii10102'] = 0x0455;
  t['afii10103'] = 0x0456;
  t['afii10104'] = 0x0457;
  t['afii10105'] = 0x0458;
  t['afii10106'] = 0x0459;
  t['afii10107'] = 0x045A;
  t['afii10108'] = 0x045B;
  t['afii10109'] = 0x045C;
  t['afii10110'] = 0x045E;
  t['afii10145'] = 0x040F;
  t['afii10146'] = 0x0462;
  t['afii10147'] = 0x0472;
  t['afii10148'] = 0x0474;
  t['afii10192'] = 0xF6C6;
  t['afii10193'] = 0x045F;
  t['afii10194'] = 0x0463;
  t['afii10195'] = 0x0473;
  t['afii10196'] = 0x0475;
  t['afii10831'] = 0xF6C7;
  t['afii10832'] = 0xF6C8;
  t['afii10846'] = 0x04D9;
  t['afii299'] = 0x200E;
  t['afii300'] = 0x200F;
  t['afii301'] = 0x200D;
  t['afii57381'] = 0x066A;
  t['afii57388'] = 0x060C;
  t['afii57392'] = 0x0660;
  t['afii57393'] = 0x0661;
  t['afii57394'] = 0x0662;
  t['afii57395'] = 0x0663;
  t['afii57396'] = 0x0664;
  t['afii57397'] = 0x0665;
  t['afii57398'] = 0x0666;
  t['afii57399'] = 0x0667;
  t['afii57400'] = 0x0668;
  t['afii57401'] = 0x0669;
  t['afii57403'] = 0x061B;
  t['afii57407'] = 0x061F;
  t['afii57409'] = 0x0621;
  t['afii57410'] = 0x0622;
  t['afii57411'] = 0x0623;
  t['afii57412'] = 0x0624;
  t['afii57413'] = 0x0625;
  t['afii57414'] = 0x0626;
  t['afii57415'] = 0x0627;
  t['afii57416'] = 0x0628;
  t['afii57417'] = 0x0629;
  t['afii57418'] = 0x062A;
  t['afii57419'] = 0x062B;
  t['afii57420'] = 0x062C;
  t['afii57421'] = 0x062D;
  t['afii57422'] = 0x062E;
  t['afii57423'] = 0x062F;
  t['afii57424'] = 0x0630;
  t['afii57425'] = 0x0631;
  t['afii57426'] = 0x0632;
  t['afii57427'] = 0x0633;
  t['afii57428'] = 0x0634;
  t['afii57429'] = 0x0635;
  t['afii57430'] = 0x0636;
  t['afii57431'] = 0x0637;
  t['afii57432'] = 0x0638;
  t['afii57433'] = 0x0639;
  t['afii57434'] = 0x063A;
  t['afii57440'] = 0x0640;
  t['afii57441'] = 0x0641;
  t['afii57442'] = 0x0642;
  t['afii57443'] = 0x0643;
  t['afii57444'] = 0x0644;
  t['afii57445'] = 0x0645;
  t['afii57446'] = 0x0646;
  t['afii57448'] = 0x0648;
  t['afii57449'] = 0x0649;
  t['afii57450'] = 0x064A;
  t['afii57451'] = 0x064B;
  t['afii57452'] = 0x064C;
  t['afii57453'] = 0x064D;
  t['afii57454'] = 0x064E;
  t['afii57455'] = 0x064F;
  t['afii57456'] = 0x0650;
  t['afii57457'] = 0x0651;
  t['afii57458'] = 0x0652;
  t['afii57470'] = 0x0647;
  t['afii57505'] = 0x06A4;
  t['afii57506'] = 0x067E;
  t['afii57507'] = 0x0686;
  t['afii57508'] = 0x0698;
  t['afii57509'] = 0x06AF;
  t['afii57511'] = 0x0679;
  t['afii57512'] = 0x0688;
  t['afii57513'] = 0x0691;
  t['afii57514'] = 0x06BA;
  t['afii57519'] = 0x06D2;
  t['afii57534'] = 0x06D5;
  t['afii57636'] = 0x20AA;
  t['afii57645'] = 0x05BE;
  t['afii57658'] = 0x05C3;
  t['afii57664'] = 0x05D0;
  t['afii57665'] = 0x05D1;
  t['afii57666'] = 0x05D2;
  t['afii57667'] = 0x05D3;
  t['afii57668'] = 0x05D4;
  t['afii57669'] = 0x05D5;
  t['afii57670'] = 0x05D6;
  t['afii57671'] = 0x05D7;
  t['afii57672'] = 0x05D8;
  t['afii57673'] = 0x05D9;
  t['afii57674'] = 0x05DA;
  t['afii57675'] = 0x05DB;
  t['afii57676'] = 0x05DC;
  t['afii57677'] = 0x05DD;
  t['afii57678'] = 0x05DE;
  t['afii57679'] = 0x05DF;
  t['afii57680'] = 0x05E0;
  t['afii57681'] = 0x05E1;
  t['afii57682'] = 0x05E2;
  t['afii57683'] = 0x05E3;
  t['afii57684'] = 0x05E4;
  t['afii57685'] = 0x05E5;
  t['afii57686'] = 0x05E6;
  t['afii57687'] = 0x05E7;
  t['afii57688'] = 0x05E8;
  t['afii57689'] = 0x05E9;
  t['afii57690'] = 0x05EA;
  t['afii57694'] = 0xFB2A;
  t['afii57695'] = 0xFB2B;
  t['afii57700'] = 0xFB4B;
  t['afii57705'] = 0xFB1F;
  t['afii57716'] = 0x05F0;
  t['afii57717'] = 0x05F1;
  t['afii57718'] = 0x05F2;
  t['afii57723'] = 0xFB35;
  t['afii57793'] = 0x05B4;
  t['afii57794'] = 0x05B5;
  t['afii57795'] = 0x05B6;
  t['afii57796'] = 0x05BB;
  t['afii57797'] = 0x05B8;
  t['afii57798'] = 0x05B7;
  t['afii57799'] = 0x05B0;
  t['afii57800'] = 0x05B2;
  t['afii57801'] = 0x05B1;
  t['afii57802'] = 0x05B3;
  t['afii57803'] = 0x05C2;
  t['afii57804'] = 0x05C1;
  t['afii57806'] = 0x05B9;
  t['afii57807'] = 0x05BC;
  t['afii57839'] = 0x05BD;
  t['afii57841'] = 0x05BF;
  t['afii57842'] = 0x05C0;
  t['afii57929'] = 0x02BC;
  t['afii61248'] = 0x2105;
  t['afii61289'] = 0x2113;
  t['afii61352'] = 0x2116;
  t['afii61573'] = 0x202C;
  t['afii61574'] = 0x202D;
  t['afii61575'] = 0x202E;
  t['afii61664'] = 0x200C;
  t['afii63167'] = 0x066D;
  t['afii64937'] = 0x02BD;
  t['agrave'] = 0x00E0;
  t['agujarati'] = 0x0A85;
  t['agurmukhi'] = 0x0A05;
  t['ahiragana'] = 0x3042;
  t['ahookabove'] = 0x1EA3;
  t['aibengali'] = 0x0990;
  t['aibopomofo'] = 0x311E;
  t['aideva'] = 0x0910;
  t['aiecyrillic'] = 0x04D5;
  t['aigujarati'] = 0x0A90;
  t['aigurmukhi'] = 0x0A10;
  t['aimatragurmukhi'] = 0x0A48;
  t['ainarabic'] = 0x0639;
  t['ainfinalarabic'] = 0xFECA;
  t['aininitialarabic'] = 0xFECB;
  t['ainmedialarabic'] = 0xFECC;
  t['ainvertedbreve'] = 0x0203;
  t['aivowelsignbengali'] = 0x09C8;
  t['aivowelsigndeva'] = 0x0948;
  t['aivowelsigngujarati'] = 0x0AC8;
  t['akatakana'] = 0x30A2;
  t['akatakanahalfwidth'] = 0xFF71;
  t['akorean'] = 0x314F;
  t['alef'] = 0x05D0;
  t['alefarabic'] = 0x0627;
  t['alefdageshhebrew'] = 0xFB30;
  t['aleffinalarabic'] = 0xFE8E;
  t['alefhamzaabovearabic'] = 0x0623;
  t['alefhamzaabovefinalarabic'] = 0xFE84;
  t['alefhamzabelowarabic'] = 0x0625;
  t['alefhamzabelowfinalarabic'] = 0xFE88;
  t['alefhebrew'] = 0x05D0;
  t['aleflamedhebrew'] = 0xFB4F;
  t['alefmaddaabovearabic'] = 0x0622;
  t['alefmaddaabovefinalarabic'] = 0xFE82;
  t['alefmaksuraarabic'] = 0x0649;
  t['alefmaksurafinalarabic'] = 0xFEF0;
  t['alefmaksurainitialarabic'] = 0xFEF3;
  t['alefmaksuramedialarabic'] = 0xFEF4;
  t['alefpatahhebrew'] = 0xFB2E;
  t['alefqamatshebrew'] = 0xFB2F;
  t['aleph'] = 0x2135;
  t['allequal'] = 0x224C;
  t['alpha'] = 0x03B1;
  t['alphatonos'] = 0x03AC;
  t['amacron'] = 0x0101;
  t['amonospace'] = 0xFF41;
  t['ampersand'] = 0x0026;
  t['ampersandmonospace'] = 0xFF06;
  t['ampersandsmall'] = 0xF726;
  t['amsquare'] = 0x33C2;
  t['anbopomofo'] = 0x3122;
  t['angbopomofo'] = 0x3124;
  t['angbracketleft'] = 0x3008;
  t['angbracketright'] = 0x3009;
  t['angkhankhuthai'] = 0x0E5A;
  t['angle'] = 0x2220;
  t['anglebracketleft'] = 0x3008;
  t['anglebracketleftvertical'] = 0xFE3F;
  t['anglebracketright'] = 0x3009;
  t['anglebracketrightvertical'] = 0xFE40;
  t['angleleft'] = 0x2329;
  t['angleright'] = 0x232A;
  t['angstrom'] = 0x212B;
  t['anoteleia'] = 0x0387;
  t['anudattadeva'] = 0x0952;
  t['anusvarabengali'] = 0x0982;
  t['anusvaradeva'] = 0x0902;
  t['anusvaragujarati'] = 0x0A82;
  t['aogonek'] = 0x0105;
  t['apaatosquare'] = 0x3300;
  t['aparen'] = 0x249C;
  t['apostrophearmenian'] = 0x055A;
  t['apostrophemod'] = 0x02BC;
  t['apple'] = 0xF8FF;
  t['approaches'] = 0x2250;
  t['approxequal'] = 0x2248;
  t['approxequalorimage'] = 0x2252;
  t['approximatelyequal'] = 0x2245;
  t['araeaekorean'] = 0x318E;
  t['araeakorean'] = 0x318D;
  t['arc'] = 0x2312;
  t['arighthalfring'] = 0x1E9A;
  t['aring'] = 0x00E5;
  t['aringacute'] = 0x01FB;
  t['aringbelow'] = 0x1E01;
  t['arrowboth'] = 0x2194;
  t['arrowdashdown'] = 0x21E3;
  t['arrowdashleft'] = 0x21E0;
  t['arrowdashright'] = 0x21E2;
  t['arrowdashup'] = 0x21E1;
  t['arrowdblboth'] = 0x21D4;
  t['arrowdbldown'] = 0x21D3;
  t['arrowdblleft'] = 0x21D0;
  t['arrowdblright'] = 0x21D2;
  t['arrowdblup'] = 0x21D1;
  t['arrowdown'] = 0x2193;
  t['arrowdownleft'] = 0x2199;
  t['arrowdownright'] = 0x2198;
  t['arrowdownwhite'] = 0x21E9;
  t['arrowheaddownmod'] = 0x02C5;
  t['arrowheadleftmod'] = 0x02C2;
  t['arrowheadrightmod'] = 0x02C3;
  t['arrowheadupmod'] = 0x02C4;
  t['arrowhorizex'] = 0xF8E7;
  t['arrowleft'] = 0x2190;
  t['arrowleftdbl'] = 0x21D0;
  t['arrowleftdblstroke'] = 0x21CD;
  t['arrowleftoverright'] = 0x21C6;
  t['arrowleftwhite'] = 0x21E6;
  t['arrowright'] = 0x2192;
  t['arrowrightdblstroke'] = 0x21CF;
  t['arrowrightheavy'] = 0x279E;
  t['arrowrightoverleft'] = 0x21C4;
  t['arrowrightwhite'] = 0x21E8;
  t['arrowtableft'] = 0x21E4;
  t['arrowtabright'] = 0x21E5;
  t['arrowup'] = 0x2191;
  t['arrowupdn'] = 0x2195;
  t['arrowupdnbse'] = 0x21A8;
  t['arrowupdownbase'] = 0x21A8;
  t['arrowupleft'] = 0x2196;
  t['arrowupleftofdown'] = 0x21C5;
  t['arrowupright'] = 0x2197;
  t['arrowupwhite'] = 0x21E7;
  t['arrowvertex'] = 0xF8E6;
  t['asciicircum'] = 0x005E;
  t['asciicircummonospace'] = 0xFF3E;
  t['asciitilde'] = 0x007E;
  t['asciitildemonospace'] = 0xFF5E;
  t['ascript'] = 0x0251;
  t['ascriptturned'] = 0x0252;
  t['asmallhiragana'] = 0x3041;
  t['asmallkatakana'] = 0x30A1;
  t['asmallkatakanahalfwidth'] = 0xFF67;
  t['asterisk'] = 0x002A;
  t['asteriskaltonearabic'] = 0x066D;
  t['asteriskarabic'] = 0x066D;
  t['asteriskmath'] = 0x2217;
  t['asteriskmonospace'] = 0xFF0A;
  t['asterisksmall'] = 0xFE61;
  t['asterism'] = 0x2042;
  t['asuperior'] = 0xF6E9;
  t['asymptoticallyequal'] = 0x2243;
  t['at'] = 0x0040;
  t['atilde'] = 0x00E3;
  t['atmonospace'] = 0xFF20;
  t['atsmall'] = 0xFE6B;
  t['aturned'] = 0x0250;
  t['aubengali'] = 0x0994;
  t['aubopomofo'] = 0x3120;
  t['audeva'] = 0x0914;
  t['augujarati'] = 0x0A94;
  t['augurmukhi'] = 0x0A14;
  t['aulengthmarkbengali'] = 0x09D7;
  t['aumatragurmukhi'] = 0x0A4C;
  t['auvowelsignbengali'] = 0x09CC;
  t['auvowelsigndeva'] = 0x094C;
  t['auvowelsigngujarati'] = 0x0ACC;
  t['avagrahadeva'] = 0x093D;
  t['aybarmenian'] = 0x0561;
  t['ayin'] = 0x05E2;
  t['ayinaltonehebrew'] = 0xFB20;
  t['ayinhebrew'] = 0x05E2;
  t['b'] = 0x0062;
  t['babengali'] = 0x09AC;
  t['backslash'] = 0x005C;
  t['backslashmonospace'] = 0xFF3C;
  t['badeva'] = 0x092C;
  t['bagujarati'] = 0x0AAC;
  t['bagurmukhi'] = 0x0A2C;
  t['bahiragana'] = 0x3070;
  t['bahtthai'] = 0x0E3F;
  t['bakatakana'] = 0x30D0;
  t['bar'] = 0x007C;
  t['barmonospace'] = 0xFF5C;
  t['bbopomofo'] = 0x3105;
  t['bcircle'] = 0x24D1;
  t['bdotaccent'] = 0x1E03;
  t['bdotbelow'] = 0x1E05;
  t['beamedsixteenthnotes'] = 0x266C;
  t['because'] = 0x2235;
  t['becyrillic'] = 0x0431;
  t['beharabic'] = 0x0628;
  t['behfinalarabic'] = 0xFE90;
  t['behinitialarabic'] = 0xFE91;
  t['behiragana'] = 0x3079;
  t['behmedialarabic'] = 0xFE92;
  t['behmeeminitialarabic'] = 0xFC9F;
  t['behmeemisolatedarabic'] = 0xFC08;
  t['behnoonfinalarabic'] = 0xFC6D;
  t['bekatakana'] = 0x30D9;
  t['benarmenian'] = 0x0562;
  t['bet'] = 0x05D1;
  t['beta'] = 0x03B2;
  t['betasymbolgreek'] = 0x03D0;
  t['betdagesh'] = 0xFB31;
  t['betdageshhebrew'] = 0xFB31;
  t['bethebrew'] = 0x05D1;
  t['betrafehebrew'] = 0xFB4C;
  t['bhabengali'] = 0x09AD;
  t['bhadeva'] = 0x092D;
  t['bhagujarati'] = 0x0AAD;
  t['bhagurmukhi'] = 0x0A2D;
  t['bhook'] = 0x0253;
  t['bihiragana'] = 0x3073;
  t['bikatakana'] = 0x30D3;
  t['bilabialclick'] = 0x0298;
  t['bindigurmukhi'] = 0x0A02;
  t['birusquare'] = 0x3331;
  t['blackcircle'] = 0x25CF;
  t['blackdiamond'] = 0x25C6;
  t['blackdownpointingtriangle'] = 0x25BC;
  t['blackleftpointingpointer'] = 0x25C4;
  t['blackleftpointingtriangle'] = 0x25C0;
  t['blacklenticularbracketleft'] = 0x3010;
  t['blacklenticularbracketleftvertical'] = 0xFE3B;
  t['blacklenticularbracketright'] = 0x3011;
  t['blacklenticularbracketrightvertical'] = 0xFE3C;
  t['blacklowerlefttriangle'] = 0x25E3;
  t['blacklowerrighttriangle'] = 0x25E2;
  t['blackrectangle'] = 0x25AC;
  t['blackrightpointingpointer'] = 0x25BA;
  t['blackrightpointingtriangle'] = 0x25B6;
  t['blacksmallsquare'] = 0x25AA;
  t['blacksmilingface'] = 0x263B;
  t['blacksquare'] = 0x25A0;
  t['blackstar'] = 0x2605;
  t['blackupperlefttriangle'] = 0x25E4;
  t['blackupperrighttriangle'] = 0x25E5;
  t['blackuppointingsmalltriangle'] = 0x25B4;
  t['blackuppointingtriangle'] = 0x25B2;
  t['blank'] = 0x2423;
  t['blinebelow'] = 0x1E07;
  t['block'] = 0x2588;
  t['bmonospace'] = 0xFF42;
  t['bobaimaithai'] = 0x0E1A;
  t['bohiragana'] = 0x307C;
  t['bokatakana'] = 0x30DC;
  t['bparen'] = 0x249D;
  t['bqsquare'] = 0x33C3;
  t['braceex'] = 0xF8F4;
  t['braceleft'] = 0x007B;
  t['braceleftbt'] = 0xF8F3;
  t['braceleftmid'] = 0xF8F2;
  t['braceleftmonospace'] = 0xFF5B;
  t['braceleftsmall'] = 0xFE5B;
  t['bracelefttp'] = 0xF8F1;
  t['braceleftvertical'] = 0xFE37;
  t['braceright'] = 0x007D;
  t['bracerightbt'] = 0xF8FE;
  t['bracerightmid'] = 0xF8FD;
  t['bracerightmonospace'] = 0xFF5D;
  t['bracerightsmall'] = 0xFE5C;
  t['bracerighttp'] = 0xF8FC;
  t['bracerightvertical'] = 0xFE38;
  t['bracketleft'] = 0x005B;
  t['bracketleftbt'] = 0xF8F0;
  t['bracketleftex'] = 0xF8EF;
  t['bracketleftmonospace'] = 0xFF3B;
  t['bracketlefttp'] = 0xF8EE;
  t['bracketright'] = 0x005D;
  t['bracketrightbt'] = 0xF8FB;
  t['bracketrightex'] = 0xF8FA;
  t['bracketrightmonospace'] = 0xFF3D;
  t['bracketrighttp'] = 0xF8F9;
  t['breve'] = 0x02D8;
  t['brevebelowcmb'] = 0x032E;
  t['brevecmb'] = 0x0306;
  t['breveinvertedbelowcmb'] = 0x032F;
  t['breveinvertedcmb'] = 0x0311;
  t['breveinverteddoublecmb'] = 0x0361;
  t['bridgebelowcmb'] = 0x032A;
  t['bridgeinvertedbelowcmb'] = 0x033A;
  t['brokenbar'] = 0x00A6;
  t['bstroke'] = 0x0180;
  t['bsuperior'] = 0xF6EA;
  t['btopbar'] = 0x0183;
  t['buhiragana'] = 0x3076;
  t['bukatakana'] = 0x30D6;
  t['bullet'] = 0x2022;
  t['bulletinverse'] = 0x25D8;
  t['bulletoperator'] = 0x2219;
  t['bullseye'] = 0x25CE;
  t['c'] = 0x0063;
  t['caarmenian'] = 0x056E;
  t['cabengali'] = 0x099A;
  t['cacute'] = 0x0107;
  t['cadeva'] = 0x091A;
  t['cagujarati'] = 0x0A9A;
  t['cagurmukhi'] = 0x0A1A;
  t['calsquare'] = 0x3388;
  t['candrabindubengali'] = 0x0981;
  t['candrabinducmb'] = 0x0310;
  t['candrabindudeva'] = 0x0901;
  t['candrabindugujarati'] = 0x0A81;
  t['capslock'] = 0x21EA;
  t['careof'] = 0x2105;
  t['caron'] = 0x02C7;
  t['caronbelowcmb'] = 0x032C;
  t['caroncmb'] = 0x030C;
  t['carriagereturn'] = 0x21B5;
  t['cbopomofo'] = 0x3118;
  t['ccaron'] = 0x010D;
  t['ccedilla'] = 0x00E7;
  t['ccedillaacute'] = 0x1E09;
  t['ccircle'] = 0x24D2;
  t['ccircumflex'] = 0x0109;
  t['ccurl'] = 0x0255;
  t['cdot'] = 0x010B;
  t['cdotaccent'] = 0x010B;
  t['cdsquare'] = 0x33C5;
  t['cedilla'] = 0x00B8;
  t['cedillacmb'] = 0x0327;
  t['cent'] = 0x00A2;
  t['centigrade'] = 0x2103;
  t['centinferior'] = 0xF6DF;
  t['centmonospace'] = 0xFFE0;
  t['centoldstyle'] = 0xF7A2;
  t['centsuperior'] = 0xF6E0;
  t['chaarmenian'] = 0x0579;
  t['chabengali'] = 0x099B;
  t['chadeva'] = 0x091B;
  t['chagujarati'] = 0x0A9B;
  t['chagurmukhi'] = 0x0A1B;
  t['chbopomofo'] = 0x3114;
  t['cheabkhasiancyrillic'] = 0x04BD;
  t['checkmark'] = 0x2713;
  t['checyrillic'] = 0x0447;
  t['chedescenderabkhasiancyrillic'] = 0x04BF;
  t['chedescendercyrillic'] = 0x04B7;
  t['chedieresiscyrillic'] = 0x04F5;
  t['cheharmenian'] = 0x0573;
  t['chekhakassiancyrillic'] = 0x04CC;
  t['cheverticalstrokecyrillic'] = 0x04B9;
  t['chi'] = 0x03C7;
  t['chieuchacirclekorean'] = 0x3277;
  t['chieuchaparenkorean'] = 0x3217;
  t['chieuchcirclekorean'] = 0x3269;
  t['chieuchkorean'] = 0x314A;
  t['chieuchparenkorean'] = 0x3209;
  t['chochangthai'] = 0x0E0A;
  t['chochanthai'] = 0x0E08;
  t['chochingthai'] = 0x0E09;
  t['chochoethai'] = 0x0E0C;
  t['chook'] = 0x0188;
  t['cieucacirclekorean'] = 0x3276;
  t['cieucaparenkorean'] = 0x3216;
  t['cieuccirclekorean'] = 0x3268;
  t['cieuckorean'] = 0x3148;
  t['cieucparenkorean'] = 0x3208;
  t['cieucuparenkorean'] = 0x321C;
  t['circle'] = 0x25CB;
  t['circlecopyrt'] = 0x00A9;
  t['circlemultiply'] = 0x2297;
  t['circleot'] = 0x2299;
  t['circleplus'] = 0x2295;
  t['circlepostalmark'] = 0x3036;
  t['circlewithlefthalfblack'] = 0x25D0;
  t['circlewithrighthalfblack'] = 0x25D1;
  t['circumflex'] = 0x02C6;
  t['circumflexbelowcmb'] = 0x032D;
  t['circumflexcmb'] = 0x0302;
  t['clear'] = 0x2327;
  t['clickalveolar'] = 0x01C2;
  t['clickdental'] = 0x01C0;
  t['clicklateral'] = 0x01C1;
  t['clickretroflex'] = 0x01C3;
  t['club'] = 0x2663;
  t['clubsuitblack'] = 0x2663;
  t['clubsuitwhite'] = 0x2667;
  t['cmcubedsquare'] = 0x33A4;
  t['cmonospace'] = 0xFF43;
  t['cmsquaredsquare'] = 0x33A0;
  t['coarmenian'] = 0x0581;
  t['colon'] = 0x003A;
  t['colonmonetary'] = 0x20A1;
  t['colonmonospace'] = 0xFF1A;
  t['colonsign'] = 0x20A1;
  t['colonsmall'] = 0xFE55;
  t['colontriangularhalfmod'] = 0x02D1;
  t['colontriangularmod'] = 0x02D0;
  t['comma'] = 0x002C;
  t['commaabovecmb'] = 0x0313;
  t['commaaboverightcmb'] = 0x0315;
  t['commaaccent'] = 0xF6C3;
  t['commaarabic'] = 0x060C;
  t['commaarmenian'] = 0x055D;
  t['commainferior'] = 0xF6E1;
  t['commamonospace'] = 0xFF0C;
  t['commareversedabovecmb'] = 0x0314;
  t['commareversedmod'] = 0x02BD;
  t['commasmall'] = 0xFE50;
  t['commasuperior'] = 0xF6E2;
  t['commaturnedabovecmb'] = 0x0312;
  t['commaturnedmod'] = 0x02BB;
  t['compass'] = 0x263C;
  t['congruent'] = 0x2245;
  t['contourintegral'] = 0x222E;
  t['control'] = 0x2303;
  t['controlACK'] = 0x0006;
  t['controlBEL'] = 0x0007;
  t['controlBS'] = 0x0008;
  t['controlCAN'] = 0x0018;
  t['controlCR'] = 0x000D;
  t['controlDC1'] = 0x0011;
  t['controlDC2'] = 0x0012;
  t['controlDC3'] = 0x0013;
  t['controlDC4'] = 0x0014;
  t['controlDEL'] = 0x007F;
  t['controlDLE'] = 0x0010;
  t['controlEM'] = 0x0019;
  t['controlENQ'] = 0x0005;
  t['controlEOT'] = 0x0004;
  t['controlESC'] = 0x001B;
  t['controlETB'] = 0x0017;
  t['controlETX'] = 0x0003;
  t['controlFF'] = 0x000C;
  t['controlFS'] = 0x001C;
  t['controlGS'] = 0x001D;
  t['controlHT'] = 0x0009;
  t['controlLF'] = 0x000A;
  t['controlNAK'] = 0x0015;
  t['controlNULL'] = 0x0000;
  t['controlRS'] = 0x001E;
  t['controlSI'] = 0x000F;
  t['controlSO'] = 0x000E;
  t['controlSOT'] = 0x0002;
  t['controlSTX'] = 0x0001;
  t['controlSUB'] = 0x001A;
  t['controlSYN'] = 0x0016;
  t['controlUS'] = 0x001F;
  t['controlVT'] = 0x000B;
  t['copyright'] = 0x00A9;
  t['copyrightsans'] = 0xF8E9;
  t['copyrightserif'] = 0xF6D9;
  t['cornerbracketleft'] = 0x300C;
  t['cornerbracketlefthalfwidth'] = 0xFF62;
  t['cornerbracketleftvertical'] = 0xFE41;
  t['cornerbracketright'] = 0x300D;
  t['cornerbracketrighthalfwidth'] = 0xFF63;
  t['cornerbracketrightvertical'] = 0xFE42;
  t['corporationsquare'] = 0x337F;
  t['cosquare'] = 0x33C7;
  t['coverkgsquare'] = 0x33C6;
  t['cparen'] = 0x249E;
  t['cruzeiro'] = 0x20A2;
  t['cstretched'] = 0x0297;
  t['curlyand'] = 0x22CF;
  t['curlyor'] = 0x22CE;
  t['currency'] = 0x00A4;
  t['cyrBreve'] = 0xF6D1;
  t['cyrFlex'] = 0xF6D2;
  t['cyrbreve'] = 0xF6D4;
  t['cyrflex'] = 0xF6D5;
  t['d'] = 0x0064;
  t['daarmenian'] = 0x0564;
  t['dabengali'] = 0x09A6;
  t['dadarabic'] = 0x0636;
  t['dadeva'] = 0x0926;
  t['dadfinalarabic'] = 0xFEBE;
  t['dadinitialarabic'] = 0xFEBF;
  t['dadmedialarabic'] = 0xFEC0;
  t['dagesh'] = 0x05BC;
  t['dageshhebrew'] = 0x05BC;
  t['dagger'] = 0x2020;
  t['daggerdbl'] = 0x2021;
  t['dagujarati'] = 0x0AA6;
  t['dagurmukhi'] = 0x0A26;
  t['dahiragana'] = 0x3060;
  t['dakatakana'] = 0x30C0;
  t['dalarabic'] = 0x062F;
  t['dalet'] = 0x05D3;
  t['daletdagesh'] = 0xFB33;
  t['daletdageshhebrew'] = 0xFB33;
  t['dalethebrew'] = 0x05D3;
  t['dalfinalarabic'] = 0xFEAA;
  t['dammaarabic'] = 0x064F;
  t['dammalowarabic'] = 0x064F;
  t['dammatanaltonearabic'] = 0x064C;
  t['dammatanarabic'] = 0x064C;
  t['danda'] = 0x0964;
  t['dargahebrew'] = 0x05A7;
  t['dargalefthebrew'] = 0x05A7;
  t['dasiapneumatacyrilliccmb'] = 0x0485;
  t['dblGrave'] = 0xF6D3;
  t['dblanglebracketleft'] = 0x300A;
  t['dblanglebracketleftvertical'] = 0xFE3D;
  t['dblanglebracketright'] = 0x300B;
  t['dblanglebracketrightvertical'] = 0xFE3E;
  t['dblarchinvertedbelowcmb'] = 0x032B;
  t['dblarrowleft'] = 0x21D4;
  t['dblarrowright'] = 0x21D2;
  t['dbldanda'] = 0x0965;
  t['dblgrave'] = 0xF6D6;
  t['dblgravecmb'] = 0x030F;
  t['dblintegral'] = 0x222C;
  t['dbllowline'] = 0x2017;
  t['dbllowlinecmb'] = 0x0333;
  t['dbloverlinecmb'] = 0x033F;
  t['dblprimemod'] = 0x02BA;
  t['dblverticalbar'] = 0x2016;
  t['dblverticallineabovecmb'] = 0x030E;
  t['dbopomofo'] = 0x3109;
  t['dbsquare'] = 0x33C8;
  t['dcaron'] = 0x010F;
  t['dcedilla'] = 0x1E11;
  t['dcircle'] = 0x24D3;
  t['dcircumflexbelow'] = 0x1E13;
  t['dcroat'] = 0x0111;
  t['ddabengali'] = 0x09A1;
  t['ddadeva'] = 0x0921;
  t['ddagujarati'] = 0x0AA1;
  t['ddagurmukhi'] = 0x0A21;
  t['ddalarabic'] = 0x0688;
  t['ddalfinalarabic'] = 0xFB89;
  t['dddhadeva'] = 0x095C;
  t['ddhabengali'] = 0x09A2;
  t['ddhadeva'] = 0x0922;
  t['ddhagujarati'] = 0x0AA2;
  t['ddhagurmukhi'] = 0x0A22;
  t['ddotaccent'] = 0x1E0B;
  t['ddotbelow'] = 0x1E0D;
  t['decimalseparatorarabic'] = 0x066B;
  t['decimalseparatorpersian'] = 0x066B;
  t['decyrillic'] = 0x0434;
  t['degree'] = 0x00B0;
  t['dehihebrew'] = 0x05AD;
  t['dehiragana'] = 0x3067;
  t['deicoptic'] = 0x03EF;
  t['dekatakana'] = 0x30C7;
  t['deleteleft'] = 0x232B;
  t['deleteright'] = 0x2326;
  t['delta'] = 0x03B4;
  t['deltaturned'] = 0x018D;
  t['denominatorminusonenumeratorbengali'] = 0x09F8;
  t['dezh'] = 0x02A4;
  t['dhabengali'] = 0x09A7;
  t['dhadeva'] = 0x0927;
  t['dhagujarati'] = 0x0AA7;
  t['dhagurmukhi'] = 0x0A27;
  t['dhook'] = 0x0257;
  t['dialytikatonos'] = 0x0385;
  t['dialytikatonoscmb'] = 0x0344;
  t['diamond'] = 0x2666;
  t['diamondsuitwhite'] = 0x2662;
  t['dieresis'] = 0x00A8;
  t['dieresisacute'] = 0xF6D7;
  t['dieresisbelowcmb'] = 0x0324;
  t['dieresiscmb'] = 0x0308;
  t['dieresisgrave'] = 0xF6D8;
  t['dieresistonos'] = 0x0385;
  t['dihiragana'] = 0x3062;
  t['dikatakana'] = 0x30C2;
  t['dittomark'] = 0x3003;
  t['divide'] = 0x00F7;
  t['divides'] = 0x2223;
  t['divisionslash'] = 0x2215;
  t['djecyrillic'] = 0x0452;
  t['dkshade'] = 0x2593;
  t['dlinebelow'] = 0x1E0F;
  t['dlsquare'] = 0x3397;
  t['dmacron'] = 0x0111;
  t['dmonospace'] = 0xFF44;
  t['dnblock'] = 0x2584;
  t['dochadathai'] = 0x0E0E;
  t['dodekthai'] = 0x0E14;
  t['dohiragana'] = 0x3069;
  t['dokatakana'] = 0x30C9;
  t['dollar'] = 0x0024;
  t['dollarinferior'] = 0xF6E3;
  t['dollarmonospace'] = 0xFF04;
  t['dollaroldstyle'] = 0xF724;
  t['dollarsmall'] = 0xFE69;
  t['dollarsuperior'] = 0xF6E4;
  t['dong'] = 0x20AB;
  t['dorusquare'] = 0x3326;
  t['dotaccent'] = 0x02D9;
  t['dotaccentcmb'] = 0x0307;
  t['dotbelowcmb'] = 0x0323;
  t['dotbelowcomb'] = 0x0323;
  t['dotkatakana'] = 0x30FB;
  t['dotlessi'] = 0x0131;
  t['dotlessj'] = 0xF6BE;
  t['dotlessjstrokehook'] = 0x0284;
  t['dotmath'] = 0x22C5;
  t['dottedcircle'] = 0x25CC;
  t['doubleyodpatah'] = 0xFB1F;
  t['doubleyodpatahhebrew'] = 0xFB1F;
  t['downtackbelowcmb'] = 0x031E;
  t['downtackmod'] = 0x02D5;
  t['dparen'] = 0x249F;
  t['dsuperior'] = 0xF6EB;
  t['dtail'] = 0x0256;
  t['dtopbar'] = 0x018C;
  t['duhiragana'] = 0x3065;
  t['dukatakana'] = 0x30C5;
  t['dz'] = 0x01F3;
  t['dzaltone'] = 0x02A3;
  t['dzcaron'] = 0x01C6;
  t['dzcurl'] = 0x02A5;
  t['dzeabkhasiancyrillic'] = 0x04E1;
  t['dzecyrillic'] = 0x0455;
  t['dzhecyrillic'] = 0x045F;
  t['e'] = 0x0065;
  t['eacute'] = 0x00E9;
  t['earth'] = 0x2641;
  t['ebengali'] = 0x098F;
  t['ebopomofo'] = 0x311C;
  t['ebreve'] = 0x0115;
  t['ecandradeva'] = 0x090D;
  t['ecandragujarati'] = 0x0A8D;
  t['ecandravowelsigndeva'] = 0x0945;
  t['ecandravowelsigngujarati'] = 0x0AC5;
  t['ecaron'] = 0x011B;
  t['ecedillabreve'] = 0x1E1D;
  t['echarmenian'] = 0x0565;
  t['echyiwnarmenian'] = 0x0587;
  t['ecircle'] = 0x24D4;
  t['ecircumflex'] = 0x00EA;
  t['ecircumflexacute'] = 0x1EBF;
  t['ecircumflexbelow'] = 0x1E19;
  t['ecircumflexdotbelow'] = 0x1EC7;
  t['ecircumflexgrave'] = 0x1EC1;
  t['ecircumflexhookabove'] = 0x1EC3;
  t['ecircumflextilde'] = 0x1EC5;
  t['ecyrillic'] = 0x0454;
  t['edblgrave'] = 0x0205;
  t['edeva'] = 0x090F;
  t['edieresis'] = 0x00EB;
  t['edot'] = 0x0117;
  t['edotaccent'] = 0x0117;
  t['edotbelow'] = 0x1EB9;
  t['eegurmukhi'] = 0x0A0F;
  t['eematragurmukhi'] = 0x0A47;
  t['efcyrillic'] = 0x0444;
  t['egrave'] = 0x00E8;
  t['egujarati'] = 0x0A8F;
  t['eharmenian'] = 0x0567;
  t['ehbopomofo'] = 0x311D;
  t['ehiragana'] = 0x3048;
  t['ehookabove'] = 0x1EBB;
  t['eibopomofo'] = 0x311F;
  t['eight'] = 0x0038;
  t['eightarabic'] = 0x0668;
  t['eightbengali'] = 0x09EE;
  t['eightcircle'] = 0x2467;
  t['eightcircleinversesansserif'] = 0x2791;
  t['eightdeva'] = 0x096E;
  t['eighteencircle'] = 0x2471;
  t['eighteenparen'] = 0x2485;
  t['eighteenperiod'] = 0x2499;
  t['eightgujarati'] = 0x0AEE;
  t['eightgurmukhi'] = 0x0A6E;
  t['eighthackarabic'] = 0x0668;
  t['eighthangzhou'] = 0x3028;
  t['eighthnotebeamed'] = 0x266B;
  t['eightideographicparen'] = 0x3227;
  t['eightinferior'] = 0x2088;
  t['eightmonospace'] = 0xFF18;
  t['eightoldstyle'] = 0xF738;
  t['eightparen'] = 0x247B;
  t['eightperiod'] = 0x248F;
  t['eightpersian'] = 0x06F8;
  t['eightroman'] = 0x2177;
  t['eightsuperior'] = 0x2078;
  t['eightthai'] = 0x0E58;
  t['einvertedbreve'] = 0x0207;
  t['eiotifiedcyrillic'] = 0x0465;
  t['ekatakana'] = 0x30A8;
  t['ekatakanahalfwidth'] = 0xFF74;
  t['ekonkargurmukhi'] = 0x0A74;
  t['ekorean'] = 0x3154;
  t['elcyrillic'] = 0x043B;
  t['element'] = 0x2208;
  t['elevencircle'] = 0x246A;
  t['elevenparen'] = 0x247E;
  t['elevenperiod'] = 0x2492;
  t['elevenroman'] = 0x217A;
  t['ellipsis'] = 0x2026;
  t['ellipsisvertical'] = 0x22EE;
  t['emacron'] = 0x0113;
  t['emacronacute'] = 0x1E17;
  t['emacrongrave'] = 0x1E15;
  t['emcyrillic'] = 0x043C;
  t['emdash'] = 0x2014;
  t['emdashvertical'] = 0xFE31;
  t['emonospace'] = 0xFF45;
  t['emphasismarkarmenian'] = 0x055B;
  t['emptyset'] = 0x2205;
  t['enbopomofo'] = 0x3123;
  t['encyrillic'] = 0x043D;
  t['endash'] = 0x2013;
  t['endashvertical'] = 0xFE32;
  t['endescendercyrillic'] = 0x04A3;
  t['eng'] = 0x014B;
  t['engbopomofo'] = 0x3125;
  t['enghecyrillic'] = 0x04A5;
  t['enhookcyrillic'] = 0x04C8;
  t['enspace'] = 0x2002;
  t['eogonek'] = 0x0119;
  t['eokorean'] = 0x3153;
  t['eopen'] = 0x025B;
  t['eopenclosed'] = 0x029A;
  t['eopenreversed'] = 0x025C;
  t['eopenreversedclosed'] = 0x025E;
  t['eopenreversedhook'] = 0x025D;
  t['eparen'] = 0x24A0;
  t['epsilon'] = 0x03B5;
  t['epsilontonos'] = 0x03AD;
  t['equal'] = 0x003D;
  t['equalmonospace'] = 0xFF1D;
  t['equalsmall'] = 0xFE66;
  t['equalsuperior'] = 0x207C;
  t['equivalence'] = 0x2261;
  t['erbopomofo'] = 0x3126;
  t['ercyrillic'] = 0x0440;
  t['ereversed'] = 0x0258;
  t['ereversedcyrillic'] = 0x044D;
  t['escyrillic'] = 0x0441;
  t['esdescendercyrillic'] = 0x04AB;
  t['esh'] = 0x0283;
  t['eshcurl'] = 0x0286;
  t['eshortdeva'] = 0x090E;
  t['eshortvowelsigndeva'] = 0x0946;
  t['eshreversedloop'] = 0x01AA;
  t['eshsquatreversed'] = 0x0285;
  t['esmallhiragana'] = 0x3047;
  t['esmallkatakana'] = 0x30A7;
  t['esmallkatakanahalfwidth'] = 0xFF6A;
  t['estimated'] = 0x212E;
  t['esuperior'] = 0xF6EC;
  t['eta'] = 0x03B7;
  t['etarmenian'] = 0x0568;
  t['etatonos'] = 0x03AE;
  t['eth'] = 0x00F0;
  t['etilde'] = 0x1EBD;
  t['etildebelow'] = 0x1E1B;
  t['etnahtafoukhhebrew'] = 0x0591;
  t['etnahtafoukhlefthebrew'] = 0x0591;
  t['etnahtahebrew'] = 0x0591;
  t['etnahtalefthebrew'] = 0x0591;
  t['eturned'] = 0x01DD;
  t['eukorean'] = 0x3161;
  t['euro'] = 0x20AC;
  t['evowelsignbengali'] = 0x09C7;
  t['evowelsigndeva'] = 0x0947;
  t['evowelsigngujarati'] = 0x0AC7;
  t['exclam'] = 0x0021;
  t['exclamarmenian'] = 0x055C;
  t['exclamdbl'] = 0x203C;
  t['exclamdown'] = 0x00A1;
  t['exclamdownsmall'] = 0xF7A1;
  t['exclammonospace'] = 0xFF01;
  t['exclamsmall'] = 0xF721;
  t['existential'] = 0x2203;
  t['ezh'] = 0x0292;
  t['ezhcaron'] = 0x01EF;
  t['ezhcurl'] = 0x0293;
  t['ezhreversed'] = 0x01B9;
  t['ezhtail'] = 0x01BA;
  t['f'] = 0x0066;
  t['fadeva'] = 0x095E;
  t['fagurmukhi'] = 0x0A5E;
  t['fahrenheit'] = 0x2109;
  t['fathaarabic'] = 0x064E;
  t['fathalowarabic'] = 0x064E;
  t['fathatanarabic'] = 0x064B;
  t['fbopomofo'] = 0x3108;
  t['fcircle'] = 0x24D5;
  t['fdotaccent'] = 0x1E1F;
  t['feharabic'] = 0x0641;
  t['feharmenian'] = 0x0586;
  t['fehfinalarabic'] = 0xFED2;
  t['fehinitialarabic'] = 0xFED3;
  t['fehmedialarabic'] = 0xFED4;
  t['feicoptic'] = 0x03E5;
  t['female'] = 0x2640;
  t['ff'] = 0xFB00;
  t['ffi'] = 0xFB03;
  t['ffl'] = 0xFB04;
  t['fi'] = 0xFB01;
  t['fifteencircle'] = 0x246E;
  t['fifteenparen'] = 0x2482;
  t['fifteenperiod'] = 0x2496;
  t['figuredash'] = 0x2012;
  t['filledbox'] = 0x25A0;
  t['filledrect'] = 0x25AC;
  t['finalkaf'] = 0x05DA;
  t['finalkafdagesh'] = 0xFB3A;
  t['finalkafdageshhebrew'] = 0xFB3A;
  t['finalkafhebrew'] = 0x05DA;
  t['finalmem'] = 0x05DD;
  t['finalmemhebrew'] = 0x05DD;
  t['finalnun'] = 0x05DF;
  t['finalnunhebrew'] = 0x05DF;
  t['finalpe'] = 0x05E3;
  t['finalpehebrew'] = 0x05E3;
  t['finaltsadi'] = 0x05E5;
  t['finaltsadihebrew'] = 0x05E5;
  t['firsttonechinese'] = 0x02C9;
  t['fisheye'] = 0x25C9;
  t['fitacyrillic'] = 0x0473;
  t['five'] = 0x0035;
  t['fivearabic'] = 0x0665;
  t['fivebengali'] = 0x09EB;
  t['fivecircle'] = 0x2464;
  t['fivecircleinversesansserif'] = 0x278E;
  t['fivedeva'] = 0x096B;
  t['fiveeighths'] = 0x215D;
  t['fivegujarati'] = 0x0AEB;
  t['fivegurmukhi'] = 0x0A6B;
  t['fivehackarabic'] = 0x0665;
  t['fivehangzhou'] = 0x3025;
  t['fiveideographicparen'] = 0x3224;
  t['fiveinferior'] = 0x2085;
  t['fivemonospace'] = 0xFF15;
  t['fiveoldstyle'] = 0xF735;
  t['fiveparen'] = 0x2478;
  t['fiveperiod'] = 0x248C;
  t['fivepersian'] = 0x06F5;
  t['fiveroman'] = 0x2174;
  t['fivesuperior'] = 0x2075;
  t['fivethai'] = 0x0E55;
  t['fl'] = 0xFB02;
  t['florin'] = 0x0192;
  t['fmonospace'] = 0xFF46;
  t['fmsquare'] = 0x3399;
  t['fofanthai'] = 0x0E1F;
  t['fofathai'] = 0x0E1D;
  t['fongmanthai'] = 0x0E4F;
  t['forall'] = 0x2200;
  t['four'] = 0x0034;
  t['fourarabic'] = 0x0664;
  t['fourbengali'] = 0x09EA;
  t['fourcircle'] = 0x2463;
  t['fourcircleinversesansserif'] = 0x278D;
  t['fourdeva'] = 0x096A;
  t['fourgujarati'] = 0x0AEA;
  t['fourgurmukhi'] = 0x0A6A;
  t['fourhackarabic'] = 0x0664;
  t['fourhangzhou'] = 0x3024;
  t['fourideographicparen'] = 0x3223;
  t['fourinferior'] = 0x2084;
  t['fourmonospace'] = 0xFF14;
  t['fournumeratorbengali'] = 0x09F7;
  t['fouroldstyle'] = 0xF734;
  t['fourparen'] = 0x2477;
  t['fourperiod'] = 0x248B;
  t['fourpersian'] = 0x06F4;
  t['fourroman'] = 0x2173;
  t['foursuperior'] = 0x2074;
  t['fourteencircle'] = 0x246D;
  t['fourteenparen'] = 0x2481;
  t['fourteenperiod'] = 0x2495;
  t['fourthai'] = 0x0E54;
  t['fourthtonechinese'] = 0x02CB;
  t['fparen'] = 0x24A1;
  t['fraction'] = 0x2044;
  t['franc'] = 0x20A3;
  t['g'] = 0x0067;
  t['gabengali'] = 0x0997;
  t['gacute'] = 0x01F5;
  t['gadeva'] = 0x0917;
  t['gafarabic'] = 0x06AF;
  t['gaffinalarabic'] = 0xFB93;
  t['gafinitialarabic'] = 0xFB94;
  t['gafmedialarabic'] = 0xFB95;
  t['gagujarati'] = 0x0A97;
  t['gagurmukhi'] = 0x0A17;
  t['gahiragana'] = 0x304C;
  t['gakatakana'] = 0x30AC;
  t['gamma'] = 0x03B3;
  t['gammalatinsmall'] = 0x0263;
  t['gammasuperior'] = 0x02E0;
  t['gangiacoptic'] = 0x03EB;
  t['gbopomofo'] = 0x310D;
  t['gbreve'] = 0x011F;
  t['gcaron'] = 0x01E7;
  t['gcedilla'] = 0x0123;
  t['gcircle'] = 0x24D6;
  t['gcircumflex'] = 0x011D;
  t['gcommaaccent'] = 0x0123;
  t['gdot'] = 0x0121;
  t['gdotaccent'] = 0x0121;
  t['gecyrillic'] = 0x0433;
  t['gehiragana'] = 0x3052;
  t['gekatakana'] = 0x30B2;
  t['geometricallyequal'] = 0x2251;
  t['gereshaccenthebrew'] = 0x059C;
  t['gereshhebrew'] = 0x05F3;
  t['gereshmuqdamhebrew'] = 0x059D;
  t['germandbls'] = 0x00DF;
  t['gershayimaccenthebrew'] = 0x059E;
  t['gershayimhebrew'] = 0x05F4;
  t['getamark'] = 0x3013;
  t['ghabengali'] = 0x0998;
  t['ghadarmenian'] = 0x0572;
  t['ghadeva'] = 0x0918;
  t['ghagujarati'] = 0x0A98;
  t['ghagurmukhi'] = 0x0A18;
  t['ghainarabic'] = 0x063A;
  t['ghainfinalarabic'] = 0xFECE;
  t['ghaininitialarabic'] = 0xFECF;
  t['ghainmedialarabic'] = 0xFED0;
  t['ghemiddlehookcyrillic'] = 0x0495;
  t['ghestrokecyrillic'] = 0x0493;
  t['gheupturncyrillic'] = 0x0491;
  t['ghhadeva'] = 0x095A;
  t['ghhagurmukhi'] = 0x0A5A;
  t['ghook'] = 0x0260;
  t['ghzsquare'] = 0x3393;
  t['gihiragana'] = 0x304E;
  t['gikatakana'] = 0x30AE;
  t['gimarmenian'] = 0x0563;
  t['gimel'] = 0x05D2;
  t['gimeldagesh'] = 0xFB32;
  t['gimeldageshhebrew'] = 0xFB32;
  t['gimelhebrew'] = 0x05D2;
  t['gjecyrillic'] = 0x0453;
  t['glottalinvertedstroke'] = 0x01BE;
  t['glottalstop'] = 0x0294;
  t['glottalstopinverted'] = 0x0296;
  t['glottalstopmod'] = 0x02C0;
  t['glottalstopreversed'] = 0x0295;
  t['glottalstopreversedmod'] = 0x02C1;
  t['glottalstopreversedsuperior'] = 0x02E4;
  t['glottalstopstroke'] = 0x02A1;
  t['glottalstopstrokereversed'] = 0x02A2;
  t['gmacron'] = 0x1E21;
  t['gmonospace'] = 0xFF47;
  t['gohiragana'] = 0x3054;
  t['gokatakana'] = 0x30B4;
  t['gparen'] = 0x24A2;
  t['gpasquare'] = 0x33AC;
  t['gradient'] = 0x2207;
  t['grave'] = 0x0060;
  t['gravebelowcmb'] = 0x0316;
  t['gravecmb'] = 0x0300;
  t['gravecomb'] = 0x0300;
  t['gravedeva'] = 0x0953;
  t['gravelowmod'] = 0x02CE;
  t['gravemonospace'] = 0xFF40;
  t['gravetonecmb'] = 0x0340;
  t['greater'] = 0x003E;
  t['greaterequal'] = 0x2265;
  t['greaterequalorless'] = 0x22DB;
  t['greatermonospace'] = 0xFF1E;
  t['greaterorequivalent'] = 0x2273;
  t['greaterorless'] = 0x2277;
  t['greateroverequal'] = 0x2267;
  t['greatersmall'] = 0xFE65;
  t['gscript'] = 0x0261;
  t['gstroke'] = 0x01E5;
  t['guhiragana'] = 0x3050;
  t['guillemotleft'] = 0x00AB;
  t['guillemotright'] = 0x00BB;
  t['guilsinglleft'] = 0x2039;
  t['guilsinglright'] = 0x203A;
  t['gukatakana'] = 0x30B0;
  t['guramusquare'] = 0x3318;
  t['gysquare'] = 0x33C9;
  t['h'] = 0x0068;
  t['haabkhasiancyrillic'] = 0x04A9;
  t['haaltonearabic'] = 0x06C1;
  t['habengali'] = 0x09B9;
  t['hadescendercyrillic'] = 0x04B3;
  t['hadeva'] = 0x0939;
  t['hagujarati'] = 0x0AB9;
  t['hagurmukhi'] = 0x0A39;
  t['haharabic'] = 0x062D;
  t['hahfinalarabic'] = 0xFEA2;
  t['hahinitialarabic'] = 0xFEA3;
  t['hahiragana'] = 0x306F;
  t['hahmedialarabic'] = 0xFEA4;
  t['haitusquare'] = 0x332A;
  t['hakatakana'] = 0x30CF;
  t['hakatakanahalfwidth'] = 0xFF8A;
  t['halantgurmukhi'] = 0x0A4D;
  t['hamzaarabic'] = 0x0621;
  t['hamzalowarabic'] = 0x0621;
  t['hangulfiller'] = 0x3164;
  t['hardsigncyrillic'] = 0x044A;
  t['harpoonleftbarbup'] = 0x21BC;
  t['harpoonrightbarbup'] = 0x21C0;
  t['hasquare'] = 0x33CA;
  t['hatafpatah'] = 0x05B2;
  t['hatafpatah16'] = 0x05B2;
  t['hatafpatah23'] = 0x05B2;
  t['hatafpatah2f'] = 0x05B2;
  t['hatafpatahhebrew'] = 0x05B2;
  t['hatafpatahnarrowhebrew'] = 0x05B2;
  t['hatafpatahquarterhebrew'] = 0x05B2;
  t['hatafpatahwidehebrew'] = 0x05B2;
  t['hatafqamats'] = 0x05B3;
  t['hatafqamats1b'] = 0x05B3;
  t['hatafqamats28'] = 0x05B3;
  t['hatafqamats34'] = 0x05B3;
  t['hatafqamatshebrew'] = 0x05B3;
  t['hatafqamatsnarrowhebrew'] = 0x05B3;
  t['hatafqamatsquarterhebrew'] = 0x05B3;
  t['hatafqamatswidehebrew'] = 0x05B3;
  t['hatafsegol'] = 0x05B1;
  t['hatafsegol17'] = 0x05B1;
  t['hatafsegol24'] = 0x05B1;
  t['hatafsegol30'] = 0x05B1;
  t['hatafsegolhebrew'] = 0x05B1;
  t['hatafsegolnarrowhebrew'] = 0x05B1;
  t['hatafsegolquarterhebrew'] = 0x05B1;
  t['hatafsegolwidehebrew'] = 0x05B1;
  t['hbar'] = 0x0127;
  t['hbopomofo'] = 0x310F;
  t['hbrevebelow'] = 0x1E2B;
  t['hcedilla'] = 0x1E29;
  t['hcircle'] = 0x24D7;
  t['hcircumflex'] = 0x0125;
  t['hdieresis'] = 0x1E27;
  t['hdotaccent'] = 0x1E23;
  t['hdotbelow'] = 0x1E25;
  t['he'] = 0x05D4;
  t['heart'] = 0x2665;
  t['heartsuitblack'] = 0x2665;
  t['heartsuitwhite'] = 0x2661;
  t['hedagesh'] = 0xFB34;
  t['hedageshhebrew'] = 0xFB34;
  t['hehaltonearabic'] = 0x06C1;
  t['heharabic'] = 0x0647;
  t['hehebrew'] = 0x05D4;
  t['hehfinalaltonearabic'] = 0xFBA7;
  t['hehfinalalttwoarabic'] = 0xFEEA;
  t['hehfinalarabic'] = 0xFEEA;
  t['hehhamzaabovefinalarabic'] = 0xFBA5;
  t['hehhamzaaboveisolatedarabic'] = 0xFBA4;
  t['hehinitialaltonearabic'] = 0xFBA8;
  t['hehinitialarabic'] = 0xFEEB;
  t['hehiragana'] = 0x3078;
  t['hehmedialaltonearabic'] = 0xFBA9;
  t['hehmedialarabic'] = 0xFEEC;
  t['heiseierasquare'] = 0x337B;
  t['hekatakana'] = 0x30D8;
  t['hekatakanahalfwidth'] = 0xFF8D;
  t['hekutaarusquare'] = 0x3336;
  t['henghook'] = 0x0267;
  t['herutusquare'] = 0x3339;
  t['het'] = 0x05D7;
  t['hethebrew'] = 0x05D7;
  t['hhook'] = 0x0266;
  t['hhooksuperior'] = 0x02B1;
  t['hieuhacirclekorean'] = 0x327B;
  t['hieuhaparenkorean'] = 0x321B;
  t['hieuhcirclekorean'] = 0x326D;
  t['hieuhkorean'] = 0x314E;
  t['hieuhparenkorean'] = 0x320D;
  t['hihiragana'] = 0x3072;
  t['hikatakana'] = 0x30D2;
  t['hikatakanahalfwidth'] = 0xFF8B;
  t['hiriq'] = 0x05B4;
  t['hiriq14'] = 0x05B4;
  t['hiriq21'] = 0x05B4;
  t['hiriq2d'] = 0x05B4;
  t['hiriqhebrew'] = 0x05B4;
  t['hiriqnarrowhebrew'] = 0x05B4;
  t['hiriqquarterhebrew'] = 0x05B4;
  t['hiriqwidehebrew'] = 0x05B4;
  t['hlinebelow'] = 0x1E96;
  t['hmonospace'] = 0xFF48;
  t['hoarmenian'] = 0x0570;
  t['hohipthai'] = 0x0E2B;
  t['hohiragana'] = 0x307B;
  t['hokatakana'] = 0x30DB;
  t['hokatakanahalfwidth'] = 0xFF8E;
  t['holam'] = 0x05B9;
  t['holam19'] = 0x05B9;
  t['holam26'] = 0x05B9;
  t['holam32'] = 0x05B9;
  t['holamhebrew'] = 0x05B9;
  t['holamnarrowhebrew'] = 0x05B9;
  t['holamquarterhebrew'] = 0x05B9;
  t['holamwidehebrew'] = 0x05B9;
  t['honokhukthai'] = 0x0E2E;
  t['hookabovecomb'] = 0x0309;
  t['hookcmb'] = 0x0309;
  t['hookpalatalizedbelowcmb'] = 0x0321;
  t['hookretroflexbelowcmb'] = 0x0322;
  t['hoonsquare'] = 0x3342;
  t['horicoptic'] = 0x03E9;
  t['horizontalbar'] = 0x2015;
  t['horncmb'] = 0x031B;
  t['hotsprings'] = 0x2668;
  t['house'] = 0x2302;
  t['hparen'] = 0x24A3;
  t['hsuperior'] = 0x02B0;
  t['hturned'] = 0x0265;
  t['huhiragana'] = 0x3075;
  t['huiitosquare'] = 0x3333;
  t['hukatakana'] = 0x30D5;
  t['hukatakanahalfwidth'] = 0xFF8C;
  t['hungarumlaut'] = 0x02DD;
  t['hungarumlautcmb'] = 0x030B;
  t['hv'] = 0x0195;
  t['hyphen'] = 0x002D;
  t['hypheninferior'] = 0xF6E5;
  t['hyphenmonospace'] = 0xFF0D;
  t['hyphensmall'] = 0xFE63;
  t['hyphensuperior'] = 0xF6E6;
  t['hyphentwo'] = 0x2010;
  t['i'] = 0x0069;
  t['iacute'] = 0x00ED;
  t['iacyrillic'] = 0x044F;
  t['ibengali'] = 0x0987;
  t['ibopomofo'] = 0x3127;
  t['ibreve'] = 0x012D;
  t['icaron'] = 0x01D0;
  t['icircle'] = 0x24D8;
  t['icircumflex'] = 0x00EE;
  t['icyrillic'] = 0x0456;
  t['idblgrave'] = 0x0209;
  t['ideographearthcircle'] = 0x328F;
  t['ideographfirecircle'] = 0x328B;
  t['ideographicallianceparen'] = 0x323F;
  t['ideographiccallparen'] = 0x323A;
  t['ideographiccentrecircle'] = 0x32A5;
  t['ideographicclose'] = 0x3006;
  t['ideographiccomma'] = 0x3001;
  t['ideographiccommaleft'] = 0xFF64;
  t['ideographiccongratulationparen'] = 0x3237;
  t['ideographiccorrectcircle'] = 0x32A3;
  t['ideographicearthparen'] = 0x322F;
  t['ideographicenterpriseparen'] = 0x323D;
  t['ideographicexcellentcircle'] = 0x329D;
  t['ideographicfestivalparen'] = 0x3240;
  t['ideographicfinancialcircle'] = 0x3296;
  t['ideographicfinancialparen'] = 0x3236;
  t['ideographicfireparen'] = 0x322B;
  t['ideographichaveparen'] = 0x3232;
  t['ideographichighcircle'] = 0x32A4;
  t['ideographiciterationmark'] = 0x3005;
  t['ideographiclaborcircle'] = 0x3298;
  t['ideographiclaborparen'] = 0x3238;
  t['ideographicleftcircle'] = 0x32A7;
  t['ideographiclowcircle'] = 0x32A6;
  t['ideographicmedicinecircle'] = 0x32A9;
  t['ideographicmetalparen'] = 0x322E;
  t['ideographicmoonparen'] = 0x322A;
  t['ideographicnameparen'] = 0x3234;
  t['ideographicperiod'] = 0x3002;
  t['ideographicprintcircle'] = 0x329E;
  t['ideographicreachparen'] = 0x3243;
  t['ideographicrepresentparen'] = 0x3239;
  t['ideographicresourceparen'] = 0x323E;
  t['ideographicrightcircle'] = 0x32A8;
  t['ideographicsecretcircle'] = 0x3299;
  t['ideographicselfparen'] = 0x3242;
  t['ideographicsocietyparen'] = 0x3233;
  t['ideographicspace'] = 0x3000;
  t['ideographicspecialparen'] = 0x3235;
  t['ideographicstockparen'] = 0x3231;
  t['ideographicstudyparen'] = 0x323B;
  t['ideographicsunparen'] = 0x3230;
  t['ideographicsuperviseparen'] = 0x323C;
  t['ideographicwaterparen'] = 0x322C;
  t['ideographicwoodparen'] = 0x322D;
  t['ideographiczero'] = 0x3007;
  t['ideographmetalcircle'] = 0x328E;
  t['ideographmooncircle'] = 0x328A;
  t['ideographnamecircle'] = 0x3294;
  t['ideographsuncircle'] = 0x3290;
  t['ideographwatercircle'] = 0x328C;
  t['ideographwoodcircle'] = 0x328D;
  t['ideva'] = 0x0907;
  t['idieresis'] = 0x00EF;
  t['idieresisacute'] = 0x1E2F;
  t['idieresiscyrillic'] = 0x04E5;
  t['idotbelow'] = 0x1ECB;
  t['iebrevecyrillic'] = 0x04D7;
  t['iecyrillic'] = 0x0435;
  t['ieungacirclekorean'] = 0x3275;
  t['ieungaparenkorean'] = 0x3215;
  t['ieungcirclekorean'] = 0x3267;
  t['ieungkorean'] = 0x3147;
  t['ieungparenkorean'] = 0x3207;
  t['igrave'] = 0x00EC;
  t['igujarati'] = 0x0A87;
  t['igurmukhi'] = 0x0A07;
  t['ihiragana'] = 0x3044;
  t['ihookabove'] = 0x1EC9;
  t['iibengali'] = 0x0988;
  t['iicyrillic'] = 0x0438;
  t['iideva'] = 0x0908;
  t['iigujarati'] = 0x0A88;
  t['iigurmukhi'] = 0x0A08;
  t['iimatragurmukhi'] = 0x0A40;
  t['iinvertedbreve'] = 0x020B;
  t['iishortcyrillic'] = 0x0439;
  t['iivowelsignbengali'] = 0x09C0;
  t['iivowelsigndeva'] = 0x0940;
  t['iivowelsigngujarati'] = 0x0AC0;
  t['ij'] = 0x0133;
  t['ikatakana'] = 0x30A4;
  t['ikatakanahalfwidth'] = 0xFF72;
  t['ikorean'] = 0x3163;
  t['ilde'] = 0x02DC;
  t['iluyhebrew'] = 0x05AC;
  t['imacron'] = 0x012B;
  t['imacroncyrillic'] = 0x04E3;
  t['imageorapproximatelyequal'] = 0x2253;
  t['imatragurmukhi'] = 0x0A3F;
  t['imonospace'] = 0xFF49;
  t['increment'] = 0x2206;
  t['infinity'] = 0x221E;
  t['iniarmenian'] = 0x056B;
  t['integral'] = 0x222B;
  t['integralbottom'] = 0x2321;
  t['integralbt'] = 0x2321;
  t['integralex'] = 0xF8F5;
  t['integraltop'] = 0x2320;
  t['integraltp'] = 0x2320;
  t['intersection'] = 0x2229;
  t['intisquare'] = 0x3305;
  t['invbullet'] = 0x25D8;
  t['invcircle'] = 0x25D9;
  t['invsmileface'] = 0x263B;
  t['iocyrillic'] = 0x0451;
  t['iogonek'] = 0x012F;
  t['iota'] = 0x03B9;
  t['iotadieresis'] = 0x03CA;
  t['iotadieresistonos'] = 0x0390;
  t['iotalatin'] = 0x0269;
  t['iotatonos'] = 0x03AF;
  t['iparen'] = 0x24A4;
  t['irigurmukhi'] = 0x0A72;
  t['ismallhiragana'] = 0x3043;
  t['ismallkatakana'] = 0x30A3;
  t['ismallkatakanahalfwidth'] = 0xFF68;
  t['issharbengali'] = 0x09FA;
  t['istroke'] = 0x0268;
  t['isuperior'] = 0xF6ED;
  t['iterationhiragana'] = 0x309D;
  t['iterationkatakana'] = 0x30FD;
  t['itilde'] = 0x0129;
  t['itildebelow'] = 0x1E2D;
  t['iubopomofo'] = 0x3129;
  t['iucyrillic'] = 0x044E;
  t['ivowelsignbengali'] = 0x09BF;
  t['ivowelsigndeva'] = 0x093F;
  t['ivowelsigngujarati'] = 0x0ABF;
  t['izhitsacyrillic'] = 0x0475;
  t['izhitsadblgravecyrillic'] = 0x0477;
  t['j'] = 0x006A;
  t['jaarmenian'] = 0x0571;
  t['jabengali'] = 0x099C;
  t['jadeva'] = 0x091C;
  t['jagujarati'] = 0x0A9C;
  t['jagurmukhi'] = 0x0A1C;
  t['jbopomofo'] = 0x3110;
  t['jcaron'] = 0x01F0;
  t['jcircle'] = 0x24D9;
  t['jcircumflex'] = 0x0135;
  t['jcrossedtail'] = 0x029D;
  t['jdotlessstroke'] = 0x025F;
  t['jecyrillic'] = 0x0458;
  t['jeemarabic'] = 0x062C;
  t['jeemfinalarabic'] = 0xFE9E;
  t['jeeminitialarabic'] = 0xFE9F;
  t['jeemmedialarabic'] = 0xFEA0;
  t['jeharabic'] = 0x0698;
  t['jehfinalarabic'] = 0xFB8B;
  t['jhabengali'] = 0x099D;
  t['jhadeva'] = 0x091D;
  t['jhagujarati'] = 0x0A9D;
  t['jhagurmukhi'] = 0x0A1D;
  t['jheharmenian'] = 0x057B;
  t['jis'] = 0x3004;
  t['jmonospace'] = 0xFF4A;
  t['jparen'] = 0x24A5;
  t['jsuperior'] = 0x02B2;
  t['k'] = 0x006B;
  t['kabashkircyrillic'] = 0x04A1;
  t['kabengali'] = 0x0995;
  t['kacute'] = 0x1E31;
  t['kacyrillic'] = 0x043A;
  t['kadescendercyrillic'] = 0x049B;
  t['kadeva'] = 0x0915;
  t['kaf'] = 0x05DB;
  t['kafarabic'] = 0x0643;
  t['kafdagesh'] = 0xFB3B;
  t['kafdageshhebrew'] = 0xFB3B;
  t['kaffinalarabic'] = 0xFEDA;
  t['kafhebrew'] = 0x05DB;
  t['kafinitialarabic'] = 0xFEDB;
  t['kafmedialarabic'] = 0xFEDC;
  t['kafrafehebrew'] = 0xFB4D;
  t['kagujarati'] = 0x0A95;
  t['kagurmukhi'] = 0x0A15;
  t['kahiragana'] = 0x304B;
  t['kahookcyrillic'] = 0x04C4;
  t['kakatakana'] = 0x30AB;
  t['kakatakanahalfwidth'] = 0xFF76;
  t['kappa'] = 0x03BA;
  t['kappasymbolgreek'] = 0x03F0;
  t['kapyeounmieumkorean'] = 0x3171;
  t['kapyeounphieuphkorean'] = 0x3184;
  t['kapyeounpieupkorean'] = 0x3178;
  t['kapyeounssangpieupkorean'] = 0x3179;
  t['karoriisquare'] = 0x330D;
  t['kashidaautoarabic'] = 0x0640;
  t['kashidaautonosidebearingarabic'] = 0x0640;
  t['kasmallkatakana'] = 0x30F5;
  t['kasquare'] = 0x3384;
  t['kasraarabic'] = 0x0650;
  t['kasratanarabic'] = 0x064D;
  t['kastrokecyrillic'] = 0x049F;
  t['katahiraprolongmarkhalfwidth'] = 0xFF70;
  t['kaverticalstrokecyrillic'] = 0x049D;
  t['kbopomofo'] = 0x310E;
  t['kcalsquare'] = 0x3389;
  t['kcaron'] = 0x01E9;
  t['kcedilla'] = 0x0137;
  t['kcircle'] = 0x24DA;
  t['kcommaaccent'] = 0x0137;
  t['kdotbelow'] = 0x1E33;
  t['keharmenian'] = 0x0584;
  t['kehiragana'] = 0x3051;
  t['kekatakana'] = 0x30B1;
  t['kekatakanahalfwidth'] = 0xFF79;
  t['kenarmenian'] = 0x056F;
  t['kesmallkatakana'] = 0x30F6;
  t['kgreenlandic'] = 0x0138;
  t['khabengali'] = 0x0996;
  t['khacyrillic'] = 0x0445;
  t['khadeva'] = 0x0916;
  t['khagujarati'] = 0x0A96;
  t['khagurmukhi'] = 0x0A16;
  t['khaharabic'] = 0x062E;
  t['khahfinalarabic'] = 0xFEA6;
  t['khahinitialarabic'] = 0xFEA7;
  t['khahmedialarabic'] = 0xFEA8;
  t['kheicoptic'] = 0x03E7;
  t['khhadeva'] = 0x0959;
  t['khhagurmukhi'] = 0x0A59;
  t['khieukhacirclekorean'] = 0x3278;
  t['khieukhaparenkorean'] = 0x3218;
  t['khieukhcirclekorean'] = 0x326A;
  t['khieukhkorean'] = 0x314B;
  t['khieukhparenkorean'] = 0x320A;
  t['khokhaithai'] = 0x0E02;
  t['khokhonthai'] = 0x0E05;
  t['khokhuatthai'] = 0x0E03;
  t['khokhwaithai'] = 0x0E04;
  t['khomutthai'] = 0x0E5B;
  t['khook'] = 0x0199;
  t['khorakhangthai'] = 0x0E06;
  t['khzsquare'] = 0x3391;
  t['kihiragana'] = 0x304D;
  t['kikatakana'] = 0x30AD;
  t['kikatakanahalfwidth'] = 0xFF77;
  t['kiroguramusquare'] = 0x3315;
  t['kiromeetorusquare'] = 0x3316;
  t['kirosquare'] = 0x3314;
  t['kiyeokacirclekorean'] = 0x326E;
  t['kiyeokaparenkorean'] = 0x320E;
  t['kiyeokcirclekorean'] = 0x3260;
  t['kiyeokkorean'] = 0x3131;
  t['kiyeokparenkorean'] = 0x3200;
  t['kiyeoksioskorean'] = 0x3133;
  t['kjecyrillic'] = 0x045C;
  t['klinebelow'] = 0x1E35;
  t['klsquare'] = 0x3398;
  t['kmcubedsquare'] = 0x33A6;
  t['kmonospace'] = 0xFF4B;
  t['kmsquaredsquare'] = 0x33A2;
  t['kohiragana'] = 0x3053;
  t['kohmsquare'] = 0x33C0;
  t['kokaithai'] = 0x0E01;
  t['kokatakana'] = 0x30B3;
  t['kokatakanahalfwidth'] = 0xFF7A;
  t['kooposquare'] = 0x331E;
  t['koppacyrillic'] = 0x0481;
  t['koreanstandardsymbol'] = 0x327F;
  t['koroniscmb'] = 0x0343;
  t['kparen'] = 0x24A6;
  t['kpasquare'] = 0x33AA;
  t['ksicyrillic'] = 0x046F;
  t['ktsquare'] = 0x33CF;
  t['kturned'] = 0x029E;
  t['kuhiragana'] = 0x304F;
  t['kukatakana'] = 0x30AF;
  t['kukatakanahalfwidth'] = 0xFF78;
  t['kvsquare'] = 0x33B8;
  t['kwsquare'] = 0x33BE;
  t['l'] = 0x006C;
  t['labengali'] = 0x09B2;
  t['lacute'] = 0x013A;
  t['ladeva'] = 0x0932;
  t['lagujarati'] = 0x0AB2;
  t['lagurmukhi'] = 0x0A32;
  t['lakkhangyaothai'] = 0x0E45;
  t['lamaleffinalarabic'] = 0xFEFC;
  t['lamalefhamzaabovefinalarabic'] = 0xFEF8;
  t['lamalefhamzaaboveisolatedarabic'] = 0xFEF7;
  t['lamalefhamzabelowfinalarabic'] = 0xFEFA;
  t['lamalefhamzabelowisolatedarabic'] = 0xFEF9;
  t['lamalefisolatedarabic'] = 0xFEFB;
  t['lamalefmaddaabovefinalarabic'] = 0xFEF6;
  t['lamalefmaddaaboveisolatedarabic'] = 0xFEF5;
  t['lamarabic'] = 0x0644;
  t['lambda'] = 0x03BB;
  t['lambdastroke'] = 0x019B;
  t['lamed'] = 0x05DC;
  t['lameddagesh'] = 0xFB3C;
  t['lameddageshhebrew'] = 0xFB3C;
  t['lamedhebrew'] = 0x05DC;
  t['lamfinalarabic'] = 0xFEDE;
  t['lamhahinitialarabic'] = 0xFCCA;
  t['laminitialarabic'] = 0xFEDF;
  t['lamjeeminitialarabic'] = 0xFCC9;
  t['lamkhahinitialarabic'] = 0xFCCB;
  t['lamlamhehisolatedarabic'] = 0xFDF2;
  t['lammedialarabic'] = 0xFEE0;
  t['lammeemhahinitialarabic'] = 0xFD88;
  t['lammeeminitialarabic'] = 0xFCCC;
  t['largecircle'] = 0x25EF;
  t['lbar'] = 0x019A;
  t['lbelt'] = 0x026C;
  t['lbopomofo'] = 0x310C;
  t['lcaron'] = 0x013E;
  t['lcedilla'] = 0x013C;
  t['lcircle'] = 0x24DB;
  t['lcircumflexbelow'] = 0x1E3D;
  t['lcommaaccent'] = 0x013C;
  t['ldot'] = 0x0140;
  t['ldotaccent'] = 0x0140;
  t['ldotbelow'] = 0x1E37;
  t['ldotbelowmacron'] = 0x1E39;
  t['leftangleabovecmb'] = 0x031A;
  t['lefttackbelowcmb'] = 0x0318;
  t['less'] = 0x003C;
  t['lessequal'] = 0x2264;
  t['lessequalorgreater'] = 0x22DA;
  t['lessmonospace'] = 0xFF1C;
  t['lessorequivalent'] = 0x2272;
  t['lessorgreater'] = 0x2276;
  t['lessoverequal'] = 0x2266;
  t['lesssmall'] = 0xFE64;
  t['lezh'] = 0x026E;
  t['lfblock'] = 0x258C;
  t['lhookretroflex'] = 0x026D;
  t['lira'] = 0x20A4;
  t['liwnarmenian'] = 0x056C;
  t['lj'] = 0x01C9;
  t['ljecyrillic'] = 0x0459;
  t['ll'] = 0xF6C0;
  t['lladeva'] = 0x0933;
  t['llagujarati'] = 0x0AB3;
  t['llinebelow'] = 0x1E3B;
  t['llladeva'] = 0x0934;
  t['llvocalicbengali'] = 0x09E1;
  t['llvocalicdeva'] = 0x0961;
  t['llvocalicvowelsignbengali'] = 0x09E3;
  t['llvocalicvowelsigndeva'] = 0x0963;
  t['lmiddletilde'] = 0x026B;
  t['lmonospace'] = 0xFF4C;
  t['lmsquare'] = 0x33D0;
  t['lochulathai'] = 0x0E2C;
  t['logicaland'] = 0x2227;
  t['logicalnot'] = 0x00AC;
  t['logicalnotreversed'] = 0x2310;
  t['logicalor'] = 0x2228;
  t['lolingthai'] = 0x0E25;
  t['longs'] = 0x017F;
  t['lowlinecenterline'] = 0xFE4E;
  t['lowlinecmb'] = 0x0332;
  t['lowlinedashed'] = 0xFE4D;
  t['lozenge'] = 0x25CA;
  t['lparen'] = 0x24A7;
  t['lslash'] = 0x0142;
  t['lsquare'] = 0x2113;
  t['lsuperior'] = 0xF6EE;
  t['ltshade'] = 0x2591;
  t['luthai'] = 0x0E26;
  t['lvocalicbengali'] = 0x098C;
  t['lvocalicdeva'] = 0x090C;
  t['lvocalicvowelsignbengali'] = 0x09E2;
  t['lvocalicvowelsigndeva'] = 0x0962;
  t['lxsquare'] = 0x33D3;
  t['m'] = 0x006D;
  t['mabengali'] = 0x09AE;
  t['macron'] = 0x00AF;
  t['macronbelowcmb'] = 0x0331;
  t['macroncmb'] = 0x0304;
  t['macronlowmod'] = 0x02CD;
  t['macronmonospace'] = 0xFFE3;
  t['macute'] = 0x1E3F;
  t['madeva'] = 0x092E;
  t['magujarati'] = 0x0AAE;
  t['magurmukhi'] = 0x0A2E;
  t['mahapakhhebrew'] = 0x05A4;
  t['mahapakhlefthebrew'] = 0x05A4;
  t['mahiragana'] = 0x307E;
  t['maichattawalowleftthai'] = 0xF895;
  t['maichattawalowrightthai'] = 0xF894;
  t['maichattawathai'] = 0x0E4B;
  t['maichattawaupperleftthai'] = 0xF893;
  t['maieklowleftthai'] = 0xF88C;
  t['maieklowrightthai'] = 0xF88B;
  t['maiekthai'] = 0x0E48;
  t['maiekupperleftthai'] = 0xF88A;
  t['maihanakatleftthai'] = 0xF884;
  t['maihanakatthai'] = 0x0E31;
  t['maitaikhuleftthai'] = 0xF889;
  t['maitaikhuthai'] = 0x0E47;
  t['maitholowleftthai'] = 0xF88F;
  t['maitholowrightthai'] = 0xF88E;
  t['maithothai'] = 0x0E49;
  t['maithoupperleftthai'] = 0xF88D;
  t['maitrilowleftthai'] = 0xF892;
  t['maitrilowrightthai'] = 0xF891;
  t['maitrithai'] = 0x0E4A;
  t['maitriupperleftthai'] = 0xF890;
  t['maiyamokthai'] = 0x0E46;
  t['makatakana'] = 0x30DE;
  t['makatakanahalfwidth'] = 0xFF8F;
  t['male'] = 0x2642;
  t['mansyonsquare'] = 0x3347;
  t['maqafhebrew'] = 0x05BE;
  t['mars'] = 0x2642;
  t['masoracirclehebrew'] = 0x05AF;
  t['masquare'] = 0x3383;
  t['mbopomofo'] = 0x3107;
  t['mbsquare'] = 0x33D4;
  t['mcircle'] = 0x24DC;
  t['mcubedsquare'] = 0x33A5;
  t['mdotaccent'] = 0x1E41;
  t['mdotbelow'] = 0x1E43;
  t['meemarabic'] = 0x0645;
  t['meemfinalarabic'] = 0xFEE2;
  t['meeminitialarabic'] = 0xFEE3;
  t['meemmedialarabic'] = 0xFEE4;
  t['meemmeeminitialarabic'] = 0xFCD1;
  t['meemmeemisolatedarabic'] = 0xFC48;
  t['meetorusquare'] = 0x334D;
  t['mehiragana'] = 0x3081;
  t['meizierasquare'] = 0x337E;
  t['mekatakana'] = 0x30E1;
  t['mekatakanahalfwidth'] = 0xFF92;
  t['mem'] = 0x05DE;
  t['memdagesh'] = 0xFB3E;
  t['memdageshhebrew'] = 0xFB3E;
  t['memhebrew'] = 0x05DE;
  t['menarmenian'] = 0x0574;
  t['merkhahebrew'] = 0x05A5;
  t['merkhakefulahebrew'] = 0x05A6;
  t['merkhakefulalefthebrew'] = 0x05A6;
  t['merkhalefthebrew'] = 0x05A5;
  t['mhook'] = 0x0271;
  t['mhzsquare'] = 0x3392;
  t['middledotkatakanahalfwidth'] = 0xFF65;
  t['middot'] = 0x00B7;
  t['mieumacirclekorean'] = 0x3272;
  t['mieumaparenkorean'] = 0x3212;
  t['mieumcirclekorean'] = 0x3264;
  t['mieumkorean'] = 0x3141;
  t['mieumpansioskorean'] = 0x3170;
  t['mieumparenkorean'] = 0x3204;
  t['mieumpieupkorean'] = 0x316E;
  t['mieumsioskorean'] = 0x316F;
  t['mihiragana'] = 0x307F;
  t['mikatakana'] = 0x30DF;
  t['mikatakanahalfwidth'] = 0xFF90;
  t['minus'] = 0x2212;
  t['minusbelowcmb'] = 0x0320;
  t['minuscircle'] = 0x2296;
  t['minusmod'] = 0x02D7;
  t['minusplus'] = 0x2213;
  t['minute'] = 0x2032;
  t['miribaarusquare'] = 0x334A;
  t['mirisquare'] = 0x3349;
  t['mlonglegturned'] = 0x0270;
  t['mlsquare'] = 0x3396;
  t['mmcubedsquare'] = 0x33A3;
  t['mmonospace'] = 0xFF4D;
  t['mmsquaredsquare'] = 0x339F;
  t['mohiragana'] = 0x3082;
  t['mohmsquare'] = 0x33C1;
  t['mokatakana'] = 0x30E2;
  t['mokatakanahalfwidth'] = 0xFF93;
  t['molsquare'] = 0x33D6;
  t['momathai'] = 0x0E21;
  t['moverssquare'] = 0x33A7;
  t['moverssquaredsquare'] = 0x33A8;
  t['mparen'] = 0x24A8;
  t['mpasquare'] = 0x33AB;
  t['mssquare'] = 0x33B3;
  t['msuperior'] = 0xF6EF;
  t['mturned'] = 0x026F;
  t['mu'] = 0x00B5;
  t['mu1'] = 0x00B5;
  t['muasquare'] = 0x3382;
  t['muchgreater'] = 0x226B;
  t['muchless'] = 0x226A;
  t['mufsquare'] = 0x338C;
  t['mugreek'] = 0x03BC;
  t['mugsquare'] = 0x338D;
  t['muhiragana'] = 0x3080;
  t['mukatakana'] = 0x30E0;
  t['mukatakanahalfwidth'] = 0xFF91;
  t['mulsquare'] = 0x3395;
  t['multiply'] = 0x00D7;
  t['mumsquare'] = 0x339B;
  t['munahhebrew'] = 0x05A3;
  t['munahlefthebrew'] = 0x05A3;
  t['musicalnote'] = 0x266A;
  t['musicalnotedbl'] = 0x266B;
  t['musicflatsign'] = 0x266D;
  t['musicsharpsign'] = 0x266F;
  t['mussquare'] = 0x33B2;
  t['muvsquare'] = 0x33B6;
  t['muwsquare'] = 0x33BC;
  t['mvmegasquare'] = 0x33B9;
  t['mvsquare'] = 0x33B7;
  t['mwmegasquare'] = 0x33BF;
  t['mwsquare'] = 0x33BD;
  t['n'] = 0x006E;
  t['nabengali'] = 0x09A8;
  t['nabla'] = 0x2207;
  t['nacute'] = 0x0144;
  t['nadeva'] = 0x0928;
  t['nagujarati'] = 0x0AA8;
  t['nagurmukhi'] = 0x0A28;
  t['nahiragana'] = 0x306A;
  t['nakatakana'] = 0x30CA;
  t['nakatakanahalfwidth'] = 0xFF85;
  t['napostrophe'] = 0x0149;
  t['nasquare'] = 0x3381;
  t['nbopomofo'] = 0x310B;
  t['nbspace'] = 0x00A0;
  t['ncaron'] = 0x0148;
  t['ncedilla'] = 0x0146;
  t['ncircle'] = 0x24DD;
  t['ncircumflexbelow'] = 0x1E4B;
  t['ncommaaccent'] = 0x0146;
  t['ndotaccent'] = 0x1E45;
  t['ndotbelow'] = 0x1E47;
  t['nehiragana'] = 0x306D;
  t['nekatakana'] = 0x30CD;
  t['nekatakanahalfwidth'] = 0xFF88;
  t['newsheqelsign'] = 0x20AA;
  t['nfsquare'] = 0x338B;
  t['ngabengali'] = 0x0999;
  t['ngadeva'] = 0x0919;
  t['ngagujarati'] = 0x0A99;
  t['ngagurmukhi'] = 0x0A19;
  t['ngonguthai'] = 0x0E07;
  t['nhiragana'] = 0x3093;
  t['nhookleft'] = 0x0272;
  t['nhookretroflex'] = 0x0273;
  t['nieunacirclekorean'] = 0x326F;
  t['nieunaparenkorean'] = 0x320F;
  t['nieuncieuckorean'] = 0x3135;
  t['nieuncirclekorean'] = 0x3261;
  t['nieunhieuhkorean'] = 0x3136;
  t['nieunkorean'] = 0x3134;
  t['nieunpansioskorean'] = 0x3168;
  t['nieunparenkorean'] = 0x3201;
  t['nieunsioskorean'] = 0x3167;
  t['nieuntikeutkorean'] = 0x3166;
  t['nihiragana'] = 0x306B;
  t['nikatakana'] = 0x30CB;
  t['nikatakanahalfwidth'] = 0xFF86;
  t['nikhahitleftthai'] = 0xF899;
  t['nikhahitthai'] = 0x0E4D;
  t['nine'] = 0x0039;
  t['ninearabic'] = 0x0669;
  t['ninebengali'] = 0x09EF;
  t['ninecircle'] = 0x2468;
  t['ninecircleinversesansserif'] = 0x2792;
  t['ninedeva'] = 0x096F;
  t['ninegujarati'] = 0x0AEF;
  t['ninegurmukhi'] = 0x0A6F;
  t['ninehackarabic'] = 0x0669;
  t['ninehangzhou'] = 0x3029;
  t['nineideographicparen'] = 0x3228;
  t['nineinferior'] = 0x2089;
  t['ninemonospace'] = 0xFF19;
  t['nineoldstyle'] = 0xF739;
  t['nineparen'] = 0x247C;
  t['nineperiod'] = 0x2490;
  t['ninepersian'] = 0x06F9;
  t['nineroman'] = 0x2178;
  t['ninesuperior'] = 0x2079;
  t['nineteencircle'] = 0x2472;
  t['nineteenparen'] = 0x2486;
  t['nineteenperiod'] = 0x249A;
  t['ninethai'] = 0x0E59;
  t['nj'] = 0x01CC;
  t['njecyrillic'] = 0x045A;
  t['nkatakana'] = 0x30F3;
  t['nkatakanahalfwidth'] = 0xFF9D;
  t['nlegrightlong'] = 0x019E;
  t['nlinebelow'] = 0x1E49;
  t['nmonospace'] = 0xFF4E;
  t['nmsquare'] = 0x339A;
  t['nnabengali'] = 0x09A3;
  t['nnadeva'] = 0x0923;
  t['nnagujarati'] = 0x0AA3;
  t['nnagurmukhi'] = 0x0A23;
  t['nnnadeva'] = 0x0929;
  t['nohiragana'] = 0x306E;
  t['nokatakana'] = 0x30CE;
  t['nokatakanahalfwidth'] = 0xFF89;
  t['nonbreakingspace'] = 0x00A0;
  t['nonenthai'] = 0x0E13;
  t['nonuthai'] = 0x0E19;
  t['noonarabic'] = 0x0646;
  t['noonfinalarabic'] = 0xFEE6;
  t['noonghunnaarabic'] = 0x06BA;
  t['noonghunnafinalarabic'] = 0xFB9F;
  t['nooninitialarabic'] = 0xFEE7;
  t['noonjeeminitialarabic'] = 0xFCD2;
  t['noonjeemisolatedarabic'] = 0xFC4B;
  t['noonmedialarabic'] = 0xFEE8;
  t['noonmeeminitialarabic'] = 0xFCD5;
  t['noonmeemisolatedarabic'] = 0xFC4E;
  t['noonnoonfinalarabic'] = 0xFC8D;
  t['notcontains'] = 0x220C;
  t['notelement'] = 0x2209;
  t['notelementof'] = 0x2209;
  t['notequal'] = 0x2260;
  t['notgreater'] = 0x226F;
  t['notgreaternorequal'] = 0x2271;
  t['notgreaternorless'] = 0x2279;
  t['notidentical'] = 0x2262;
  t['notless'] = 0x226E;
  t['notlessnorequal'] = 0x2270;
  t['notparallel'] = 0x2226;
  t['notprecedes'] = 0x2280;
  t['notsubset'] = 0x2284;
  t['notsucceeds'] = 0x2281;
  t['notsuperset'] = 0x2285;
  t['nowarmenian'] = 0x0576;
  t['nparen'] = 0x24A9;
  t['nssquare'] = 0x33B1;
  t['nsuperior'] = 0x207F;
  t['ntilde'] = 0x00F1;
  t['nu'] = 0x03BD;
  t['nuhiragana'] = 0x306C;
  t['nukatakana'] = 0x30CC;
  t['nukatakanahalfwidth'] = 0xFF87;
  t['nuktabengali'] = 0x09BC;
  t['nuktadeva'] = 0x093C;
  t['nuktagujarati'] = 0x0ABC;
  t['nuktagurmukhi'] = 0x0A3C;
  t['numbersign'] = 0x0023;
  t['numbersignmonospace'] = 0xFF03;
  t['numbersignsmall'] = 0xFE5F;
  t['numeralsigngreek'] = 0x0374;
  t['numeralsignlowergreek'] = 0x0375;
  t['numero'] = 0x2116;
  t['nun'] = 0x05E0;
  t['nundagesh'] = 0xFB40;
  t['nundageshhebrew'] = 0xFB40;
  t['nunhebrew'] = 0x05E0;
  t['nvsquare'] = 0x33B5;
  t['nwsquare'] = 0x33BB;
  t['nyabengali'] = 0x099E;
  t['nyadeva'] = 0x091E;
  t['nyagujarati'] = 0x0A9E;
  t['nyagurmukhi'] = 0x0A1E;
  t['o'] = 0x006F;
  t['oacute'] = 0x00F3;
  t['oangthai'] = 0x0E2D;
  t['obarred'] = 0x0275;
  t['obarredcyrillic'] = 0x04E9;
  t['obarreddieresiscyrillic'] = 0x04EB;
  t['obengali'] = 0x0993;
  t['obopomofo'] = 0x311B;
  t['obreve'] = 0x014F;
  t['ocandradeva'] = 0x0911;
  t['ocandragujarati'] = 0x0A91;
  t['ocandravowelsigndeva'] = 0x0949;
  t['ocandravowelsigngujarati'] = 0x0AC9;
  t['ocaron'] = 0x01D2;
  t['ocircle'] = 0x24DE;
  t['ocircumflex'] = 0x00F4;
  t['ocircumflexacute'] = 0x1ED1;
  t['ocircumflexdotbelow'] = 0x1ED9;
  t['ocircumflexgrave'] = 0x1ED3;
  t['ocircumflexhookabove'] = 0x1ED5;
  t['ocircumflextilde'] = 0x1ED7;
  t['ocyrillic'] = 0x043E;
  t['odblacute'] = 0x0151;
  t['odblgrave'] = 0x020D;
  t['odeva'] = 0x0913;
  t['odieresis'] = 0x00F6;
  t['odieresiscyrillic'] = 0x04E7;
  t['odotbelow'] = 0x1ECD;
  t['oe'] = 0x0153;
  t['oekorean'] = 0x315A;
  t['ogonek'] = 0x02DB;
  t['ogonekcmb'] = 0x0328;
  t['ograve'] = 0x00F2;
  t['ogujarati'] = 0x0A93;
  t['oharmenian'] = 0x0585;
  t['ohiragana'] = 0x304A;
  t['ohookabove'] = 0x1ECF;
  t['ohorn'] = 0x01A1;
  t['ohornacute'] = 0x1EDB;
  t['ohorndotbelow'] = 0x1EE3;
  t['ohorngrave'] = 0x1EDD;
  t['ohornhookabove'] = 0x1EDF;
  t['ohorntilde'] = 0x1EE1;
  t['ohungarumlaut'] = 0x0151;
  t['oi'] = 0x01A3;
  t['oinvertedbreve'] = 0x020F;
  t['okatakana'] = 0x30AA;
  t['okatakanahalfwidth'] = 0xFF75;
  t['okorean'] = 0x3157;
  t['olehebrew'] = 0x05AB;
  t['omacron'] = 0x014D;
  t['omacronacute'] = 0x1E53;
  t['omacrongrave'] = 0x1E51;
  t['omdeva'] = 0x0950;
  t['omega'] = 0x03C9;
  t['omega1'] = 0x03D6;
  t['omegacyrillic'] = 0x0461;
  t['omegalatinclosed'] = 0x0277;
  t['omegaroundcyrillic'] = 0x047B;
  t['omegatitlocyrillic'] = 0x047D;
  t['omegatonos'] = 0x03CE;
  t['omgujarati'] = 0x0AD0;
  t['omicron'] = 0x03BF;
  t['omicrontonos'] = 0x03CC;
  t['omonospace'] = 0xFF4F;
  t['one'] = 0x0031;
  t['onearabic'] = 0x0661;
  t['onebengali'] = 0x09E7;
  t['onecircle'] = 0x2460;
  t['onecircleinversesansserif'] = 0x278A;
  t['onedeva'] = 0x0967;
  t['onedotenleader'] = 0x2024;
  t['oneeighth'] = 0x215B;
  t['onefitted'] = 0xF6DC;
  t['onegujarati'] = 0x0AE7;
  t['onegurmukhi'] = 0x0A67;
  t['onehackarabic'] = 0x0661;
  t['onehalf'] = 0x00BD;
  t['onehangzhou'] = 0x3021;
  t['oneideographicparen'] = 0x3220;
  t['oneinferior'] = 0x2081;
  t['onemonospace'] = 0xFF11;
  t['onenumeratorbengali'] = 0x09F4;
  t['oneoldstyle'] = 0xF731;
  t['oneparen'] = 0x2474;
  t['oneperiod'] = 0x2488;
  t['onepersian'] = 0x06F1;
  t['onequarter'] = 0x00BC;
  t['oneroman'] = 0x2170;
  t['onesuperior'] = 0x00B9;
  t['onethai'] = 0x0E51;
  t['onethird'] = 0x2153;
  t['oogonek'] = 0x01EB;
  t['oogonekmacron'] = 0x01ED;
  t['oogurmukhi'] = 0x0A13;
  t['oomatragurmukhi'] = 0x0A4B;
  t['oopen'] = 0x0254;
  t['oparen'] = 0x24AA;
  t['openbullet'] = 0x25E6;
  t['option'] = 0x2325;
  t['ordfeminine'] = 0x00AA;
  t['ordmasculine'] = 0x00BA;
  t['orthogonal'] = 0x221F;
  t['oshortdeva'] = 0x0912;
  t['oshortvowelsigndeva'] = 0x094A;
  t['oslash'] = 0x00F8;
  t['oslashacute'] = 0x01FF;
  t['osmallhiragana'] = 0x3049;
  t['osmallkatakana'] = 0x30A9;
  t['osmallkatakanahalfwidth'] = 0xFF6B;
  t['ostrokeacute'] = 0x01FF;
  t['osuperior'] = 0xF6F0;
  t['otcyrillic'] = 0x047F;
  t['otilde'] = 0x00F5;
  t['otildeacute'] = 0x1E4D;
  t['otildedieresis'] = 0x1E4F;
  t['oubopomofo'] = 0x3121;
  t['overline'] = 0x203E;
  t['overlinecenterline'] = 0xFE4A;
  t['overlinecmb'] = 0x0305;
  t['overlinedashed'] = 0xFE49;
  t['overlinedblwavy'] = 0xFE4C;
  t['overlinewavy'] = 0xFE4B;
  t['overscore'] = 0x00AF;
  t['ovowelsignbengali'] = 0x09CB;
  t['ovowelsigndeva'] = 0x094B;
  t['ovowelsigngujarati'] = 0x0ACB;
  t['p'] = 0x0070;
  t['paampssquare'] = 0x3380;
  t['paasentosquare'] = 0x332B;
  t['pabengali'] = 0x09AA;
  t['pacute'] = 0x1E55;
  t['padeva'] = 0x092A;
  t['pagedown'] = 0x21DF;
  t['pageup'] = 0x21DE;
  t['pagujarati'] = 0x0AAA;
  t['pagurmukhi'] = 0x0A2A;
  t['pahiragana'] = 0x3071;
  t['paiyannoithai'] = 0x0E2F;
  t['pakatakana'] = 0x30D1;
  t['palatalizationcyrilliccmb'] = 0x0484;
  t['palochkacyrillic'] = 0x04C0;
  t['pansioskorean'] = 0x317F;
  t['paragraph'] = 0x00B6;
  t['parallel'] = 0x2225;
  t['parenleft'] = 0x0028;
  t['parenleftaltonearabic'] = 0xFD3E;
  t['parenleftbt'] = 0xF8ED;
  t['parenleftex'] = 0xF8EC;
  t['parenleftinferior'] = 0x208D;
  t['parenleftmonospace'] = 0xFF08;
  t['parenleftsmall'] = 0xFE59;
  t['parenleftsuperior'] = 0x207D;
  t['parenlefttp'] = 0xF8EB;
  t['parenleftvertical'] = 0xFE35;
  t['parenright'] = 0x0029;
  t['parenrightaltonearabic'] = 0xFD3F;
  t['parenrightbt'] = 0xF8F8;
  t['parenrightex'] = 0xF8F7;
  t['parenrightinferior'] = 0x208E;
  t['parenrightmonospace'] = 0xFF09;
  t['parenrightsmall'] = 0xFE5A;
  t['parenrightsuperior'] = 0x207E;
  t['parenrighttp'] = 0xF8F6;
  t['parenrightvertical'] = 0xFE36;
  t['partialdiff'] = 0x2202;
  t['paseqhebrew'] = 0x05C0;
  t['pashtahebrew'] = 0x0599;
  t['pasquare'] = 0x33A9;
  t['patah'] = 0x05B7;
  t['patah11'] = 0x05B7;
  t['patah1d'] = 0x05B7;
  t['patah2a'] = 0x05B7;
  t['patahhebrew'] = 0x05B7;
  t['patahnarrowhebrew'] = 0x05B7;
  t['patahquarterhebrew'] = 0x05B7;
  t['patahwidehebrew'] = 0x05B7;
  t['pazerhebrew'] = 0x05A1;
  t['pbopomofo'] = 0x3106;
  t['pcircle'] = 0x24DF;
  t['pdotaccent'] = 0x1E57;
  t['pe'] = 0x05E4;
  t['pecyrillic'] = 0x043F;
  t['pedagesh'] = 0xFB44;
  t['pedageshhebrew'] = 0xFB44;
  t['peezisquare'] = 0x333B;
  t['pefinaldageshhebrew'] = 0xFB43;
  t['peharabic'] = 0x067E;
  t['peharmenian'] = 0x057A;
  t['pehebrew'] = 0x05E4;
  t['pehfinalarabic'] = 0xFB57;
  t['pehinitialarabic'] = 0xFB58;
  t['pehiragana'] = 0x307A;
  t['pehmedialarabic'] = 0xFB59;
  t['pekatakana'] = 0x30DA;
  t['pemiddlehookcyrillic'] = 0x04A7;
  t['perafehebrew'] = 0xFB4E;
  t['percent'] = 0x0025;
  t['percentarabic'] = 0x066A;
  t['percentmonospace'] = 0xFF05;
  t['percentsmall'] = 0xFE6A;
  t['period'] = 0x002E;
  t['periodarmenian'] = 0x0589;
  t['periodcentered'] = 0x00B7;
  t['periodhalfwidth'] = 0xFF61;
  t['periodinferior'] = 0xF6E7;
  t['periodmonospace'] = 0xFF0E;
  t['periodsmall'] = 0xFE52;
  t['periodsuperior'] = 0xF6E8;
  t['perispomenigreekcmb'] = 0x0342;
  t['perpendicular'] = 0x22A5;
  t['perthousand'] = 0x2030;
  t['peseta'] = 0x20A7;
  t['pfsquare'] = 0x338A;
  t['phabengali'] = 0x09AB;
  t['phadeva'] = 0x092B;
  t['phagujarati'] = 0x0AAB;
  t['phagurmukhi'] = 0x0A2B;
  t['phi'] = 0x03C6;
  t['phi1'] = 0x03D5;
  t['phieuphacirclekorean'] = 0x327A;
  t['phieuphaparenkorean'] = 0x321A;
  t['phieuphcirclekorean'] = 0x326C;
  t['phieuphkorean'] = 0x314D;
  t['phieuphparenkorean'] = 0x320C;
  t['philatin'] = 0x0278;
  t['phinthuthai'] = 0x0E3A;
  t['phisymbolgreek'] = 0x03D5;
  t['phook'] = 0x01A5;
  t['phophanthai'] = 0x0E1E;
  t['phophungthai'] = 0x0E1C;
  t['phosamphaothai'] = 0x0E20;
  t['pi'] = 0x03C0;
  t['pieupacirclekorean'] = 0x3273;
  t['pieupaparenkorean'] = 0x3213;
  t['pieupcieuckorean'] = 0x3176;
  t['pieupcirclekorean'] = 0x3265;
  t['pieupkiyeokkorean'] = 0x3172;
  t['pieupkorean'] = 0x3142;
  t['pieupparenkorean'] = 0x3205;
  t['pieupsioskiyeokkorean'] = 0x3174;
  t['pieupsioskorean'] = 0x3144;
  t['pieupsiostikeutkorean'] = 0x3175;
  t['pieupthieuthkorean'] = 0x3177;
  t['pieuptikeutkorean'] = 0x3173;
  t['pihiragana'] = 0x3074;
  t['pikatakana'] = 0x30D4;
  t['pisymbolgreek'] = 0x03D6;
  t['piwrarmenian'] = 0x0583;
  t['plus'] = 0x002B;
  t['plusbelowcmb'] = 0x031F;
  t['pluscircle'] = 0x2295;
  t['plusminus'] = 0x00B1;
  t['plusmod'] = 0x02D6;
  t['plusmonospace'] = 0xFF0B;
  t['plussmall'] = 0xFE62;
  t['plussuperior'] = 0x207A;
  t['pmonospace'] = 0xFF50;
  t['pmsquare'] = 0x33D8;
  t['pohiragana'] = 0x307D;
  t['pointingindexdownwhite'] = 0x261F;
  t['pointingindexleftwhite'] = 0x261C;
  t['pointingindexrightwhite'] = 0x261E;
  t['pointingindexupwhite'] = 0x261D;
  t['pokatakana'] = 0x30DD;
  t['poplathai'] = 0x0E1B;
  t['postalmark'] = 0x3012;
  t['postalmarkface'] = 0x3020;
  t['pparen'] = 0x24AB;
  t['precedes'] = 0x227A;
  t['prescription'] = 0x211E;
  t['primemod'] = 0x02B9;
  t['primereversed'] = 0x2035;
  t['product'] = 0x220F;
  t['projective'] = 0x2305;
  t['prolongedkana'] = 0x30FC;
  t['propellor'] = 0x2318;
  t['propersubset'] = 0x2282;
  t['propersuperset'] = 0x2283;
  t['proportion'] = 0x2237;
  t['proportional'] = 0x221D;
  t['psi'] = 0x03C8;
  t['psicyrillic'] = 0x0471;
  t['psilipneumatacyrilliccmb'] = 0x0486;
  t['pssquare'] = 0x33B0;
  t['puhiragana'] = 0x3077;
  t['pukatakana'] = 0x30D7;
  t['pvsquare'] = 0x33B4;
  t['pwsquare'] = 0x33BA;
  t['q'] = 0x0071;
  t['qadeva'] = 0x0958;
  t['qadmahebrew'] = 0x05A8;
  t['qafarabic'] = 0x0642;
  t['qaffinalarabic'] = 0xFED6;
  t['qafinitialarabic'] = 0xFED7;
  t['qafmedialarabic'] = 0xFED8;
  t['qamats'] = 0x05B8;
  t['qamats10'] = 0x05B8;
  t['qamats1a'] = 0x05B8;
  t['qamats1c'] = 0x05B8;
  t['qamats27'] = 0x05B8;
  t['qamats29'] = 0x05B8;
  t['qamats33'] = 0x05B8;
  t['qamatsde'] = 0x05B8;
  t['qamatshebrew'] = 0x05B8;
  t['qamatsnarrowhebrew'] = 0x05B8;
  t['qamatsqatanhebrew'] = 0x05B8;
  t['qamatsqatannarrowhebrew'] = 0x05B8;
  t['qamatsqatanquarterhebrew'] = 0x05B8;
  t['qamatsqatanwidehebrew'] = 0x05B8;
  t['qamatsquarterhebrew'] = 0x05B8;
  t['qamatswidehebrew'] = 0x05B8;
  t['qarneyparahebrew'] = 0x059F;
  t['qbopomofo'] = 0x3111;
  t['qcircle'] = 0x24E0;
  t['qhook'] = 0x02A0;
  t['qmonospace'] = 0xFF51;
  t['qof'] = 0x05E7;
  t['qofdagesh'] = 0xFB47;
  t['qofdageshhebrew'] = 0xFB47;
  t['qofhebrew'] = 0x05E7;
  t['qparen'] = 0x24AC;
  t['quarternote'] = 0x2669;
  t['qubuts'] = 0x05BB;
  t['qubuts18'] = 0x05BB;
  t['qubuts25'] = 0x05BB;
  t['qubuts31'] = 0x05BB;
  t['qubutshebrew'] = 0x05BB;
  t['qubutsnarrowhebrew'] = 0x05BB;
  t['qubutsquarterhebrew'] = 0x05BB;
  t['qubutswidehebrew'] = 0x05BB;
  t['question'] = 0x003F;
  t['questionarabic'] = 0x061F;
  t['questionarmenian'] = 0x055E;
  t['questiondown'] = 0x00BF;
  t['questiondownsmall'] = 0xF7BF;
  t['questiongreek'] = 0x037E;
  t['questionmonospace'] = 0xFF1F;
  t['questionsmall'] = 0xF73F;
  t['quotedbl'] = 0x0022;
  t['quotedblbase'] = 0x201E;
  t['quotedblleft'] = 0x201C;
  t['quotedblmonospace'] = 0xFF02;
  t['quotedblprime'] = 0x301E;
  t['quotedblprimereversed'] = 0x301D;
  t['quotedblright'] = 0x201D;
  t['quoteleft'] = 0x2018;
  t['quoteleftreversed'] = 0x201B;
  t['quotereversed'] = 0x201B;
  t['quoteright'] = 0x2019;
  t['quoterightn'] = 0x0149;
  t['quotesinglbase'] = 0x201A;
  t['quotesingle'] = 0x0027;
  t['quotesinglemonospace'] = 0xFF07;
  t['r'] = 0x0072;
  t['raarmenian'] = 0x057C;
  t['rabengali'] = 0x09B0;
  t['racute'] = 0x0155;
  t['radeva'] = 0x0930;
  t['radical'] = 0x221A;
  t['radicalex'] = 0xF8E5;
  t['radoverssquare'] = 0x33AE;
  t['radoverssquaredsquare'] = 0x33AF;
  t['radsquare'] = 0x33AD;
  t['rafe'] = 0x05BF;
  t['rafehebrew'] = 0x05BF;
  t['ragujarati'] = 0x0AB0;
  t['ragurmukhi'] = 0x0A30;
  t['rahiragana'] = 0x3089;
  t['rakatakana'] = 0x30E9;
  t['rakatakanahalfwidth'] = 0xFF97;
  t['ralowerdiagonalbengali'] = 0x09F1;
  t['ramiddlediagonalbengali'] = 0x09F0;
  t['ramshorn'] = 0x0264;
  t['ratio'] = 0x2236;
  t['rbopomofo'] = 0x3116;
  t['rcaron'] = 0x0159;
  t['rcedilla'] = 0x0157;
  t['rcircle'] = 0x24E1;
  t['rcommaaccent'] = 0x0157;
  t['rdblgrave'] = 0x0211;
  t['rdotaccent'] = 0x1E59;
  t['rdotbelow'] = 0x1E5B;
  t['rdotbelowmacron'] = 0x1E5D;
  t['referencemark'] = 0x203B;
  t['reflexsubset'] = 0x2286;
  t['reflexsuperset'] = 0x2287;
  t['registered'] = 0x00AE;
  t['registersans'] = 0xF8E8;
  t['registerserif'] = 0xF6DA;
  t['reharabic'] = 0x0631;
  t['reharmenian'] = 0x0580;
  t['rehfinalarabic'] = 0xFEAE;
  t['rehiragana'] = 0x308C;
  t['rekatakana'] = 0x30EC;
  t['rekatakanahalfwidth'] = 0xFF9A;
  t['resh'] = 0x05E8;
  t['reshdageshhebrew'] = 0xFB48;
  t['reshhebrew'] = 0x05E8;
  t['reversedtilde'] = 0x223D;
  t['reviahebrew'] = 0x0597;
  t['reviamugrashhebrew'] = 0x0597;
  t['revlogicalnot'] = 0x2310;
  t['rfishhook'] = 0x027E;
  t['rfishhookreversed'] = 0x027F;
  t['rhabengali'] = 0x09DD;
  t['rhadeva'] = 0x095D;
  t['rho'] = 0x03C1;
  t['rhook'] = 0x027D;
  t['rhookturned'] = 0x027B;
  t['rhookturnedsuperior'] = 0x02B5;
  t['rhosymbolgreek'] = 0x03F1;
  t['rhotichookmod'] = 0x02DE;
  t['rieulacirclekorean'] = 0x3271;
  t['rieulaparenkorean'] = 0x3211;
  t['rieulcirclekorean'] = 0x3263;
  t['rieulhieuhkorean'] = 0x3140;
  t['rieulkiyeokkorean'] = 0x313A;
  t['rieulkiyeoksioskorean'] = 0x3169;
  t['rieulkorean'] = 0x3139;
  t['rieulmieumkorean'] = 0x313B;
  t['rieulpansioskorean'] = 0x316C;
  t['rieulparenkorean'] = 0x3203;
  t['rieulphieuphkorean'] = 0x313F;
  t['rieulpieupkorean'] = 0x313C;
  t['rieulpieupsioskorean'] = 0x316B;
  t['rieulsioskorean'] = 0x313D;
  t['rieulthieuthkorean'] = 0x313E;
  t['rieultikeutkorean'] = 0x316A;
  t['rieulyeorinhieuhkorean'] = 0x316D;
  t['rightangle'] = 0x221F;
  t['righttackbelowcmb'] = 0x0319;
  t['righttriangle'] = 0x22BF;
  t['rihiragana'] = 0x308A;
  t['rikatakana'] = 0x30EA;
  t['rikatakanahalfwidth'] = 0xFF98;
  t['ring'] = 0x02DA;
  t['ringbelowcmb'] = 0x0325;
  t['ringcmb'] = 0x030A;
  t['ringhalfleft'] = 0x02BF;
  t['ringhalfleftarmenian'] = 0x0559;
  t['ringhalfleftbelowcmb'] = 0x031C;
  t['ringhalfleftcentered'] = 0x02D3;
  t['ringhalfright'] = 0x02BE;
  t['ringhalfrightbelowcmb'] = 0x0339;
  t['ringhalfrightcentered'] = 0x02D2;
  t['rinvertedbreve'] = 0x0213;
  t['rittorusquare'] = 0x3351;
  t['rlinebelow'] = 0x1E5F;
  t['rlongleg'] = 0x027C;
  t['rlonglegturned'] = 0x027A;
  t['rmonospace'] = 0xFF52;
  t['rohiragana'] = 0x308D;
  t['rokatakana'] = 0x30ED;
  t['rokatakanahalfwidth'] = 0xFF9B;
  t['roruathai'] = 0x0E23;
  t['rparen'] = 0x24AD;
  t['rrabengali'] = 0x09DC;
  t['rradeva'] = 0x0931;
  t['rragurmukhi'] = 0x0A5C;
  t['rreharabic'] = 0x0691;
  t['rrehfinalarabic'] = 0xFB8D;
  t['rrvocalicbengali'] = 0x09E0;
  t['rrvocalicdeva'] = 0x0960;
  t['rrvocalicgujarati'] = 0x0AE0;
  t['rrvocalicvowelsignbengali'] = 0x09C4;
  t['rrvocalicvowelsigndeva'] = 0x0944;
  t['rrvocalicvowelsigngujarati'] = 0x0AC4;
  t['rsuperior'] = 0xF6F1;
  t['rtblock'] = 0x2590;
  t['rturned'] = 0x0279;
  t['rturnedsuperior'] = 0x02B4;
  t['ruhiragana'] = 0x308B;
  t['rukatakana'] = 0x30EB;
  t['rukatakanahalfwidth'] = 0xFF99;
  t['rupeemarkbengali'] = 0x09F2;
  t['rupeesignbengali'] = 0x09F3;
  t['rupiah'] = 0xF6DD;
  t['ruthai'] = 0x0E24;
  t['rvocalicbengali'] = 0x098B;
  t['rvocalicdeva'] = 0x090B;
  t['rvocalicgujarati'] = 0x0A8B;
  t['rvocalicvowelsignbengali'] = 0x09C3;
  t['rvocalicvowelsigndeva'] = 0x0943;
  t['rvocalicvowelsigngujarati'] = 0x0AC3;
  t['s'] = 0x0073;
  t['sabengali'] = 0x09B8;
  t['sacute'] = 0x015B;
  t['sacutedotaccent'] = 0x1E65;
  t['sadarabic'] = 0x0635;
  t['sadeva'] = 0x0938;
  t['sadfinalarabic'] = 0xFEBA;
  t['sadinitialarabic'] = 0xFEBB;
  t['sadmedialarabic'] = 0xFEBC;
  t['sagujarati'] = 0x0AB8;
  t['sagurmukhi'] = 0x0A38;
  t['sahiragana'] = 0x3055;
  t['sakatakana'] = 0x30B5;
  t['sakatakanahalfwidth'] = 0xFF7B;
  t['sallallahoualayhewasallamarabic'] = 0xFDFA;
  t['samekh'] = 0x05E1;
  t['samekhdagesh'] = 0xFB41;
  t['samekhdageshhebrew'] = 0xFB41;
  t['samekhhebrew'] = 0x05E1;
  t['saraaathai'] = 0x0E32;
  t['saraaethai'] = 0x0E41;
  t['saraaimaimalaithai'] = 0x0E44;
  t['saraaimaimuanthai'] = 0x0E43;
  t['saraamthai'] = 0x0E33;
  t['saraathai'] = 0x0E30;
  t['saraethai'] = 0x0E40;
  t['saraiileftthai'] = 0xF886;
  t['saraiithai'] = 0x0E35;
  t['saraileftthai'] = 0xF885;
  t['saraithai'] = 0x0E34;
  t['saraothai'] = 0x0E42;
  t['saraueeleftthai'] = 0xF888;
  t['saraueethai'] = 0x0E37;
  t['saraueleftthai'] = 0xF887;
  t['sarauethai'] = 0x0E36;
  t['sarauthai'] = 0x0E38;
  t['sarauuthai'] = 0x0E39;
  t['sbopomofo'] = 0x3119;
  t['scaron'] = 0x0161;
  t['scarondotaccent'] = 0x1E67;
  t['scedilla'] = 0x015F;
  t['schwa'] = 0x0259;
  t['schwacyrillic'] = 0x04D9;
  t['schwadieresiscyrillic'] = 0x04DB;
  t['schwahook'] = 0x025A;
  t['scircle'] = 0x24E2;
  t['scircumflex'] = 0x015D;
  t['scommaaccent'] = 0x0219;
  t['sdotaccent'] = 0x1E61;
  t['sdotbelow'] = 0x1E63;
  t['sdotbelowdotaccent'] = 0x1E69;
  t['seagullbelowcmb'] = 0x033C;
  t['second'] = 0x2033;
  t['secondtonechinese'] = 0x02CA;
  t['section'] = 0x00A7;
  t['seenarabic'] = 0x0633;
  t['seenfinalarabic'] = 0xFEB2;
  t['seeninitialarabic'] = 0xFEB3;
  t['seenmedialarabic'] = 0xFEB4;
  t['segol'] = 0x05B6;
  t['segol13'] = 0x05B6;
  t['segol1f'] = 0x05B6;
  t['segol2c'] = 0x05B6;
  t['segolhebrew'] = 0x05B6;
  t['segolnarrowhebrew'] = 0x05B6;
  t['segolquarterhebrew'] = 0x05B6;
  t['segoltahebrew'] = 0x0592;
  t['segolwidehebrew'] = 0x05B6;
  t['seharmenian'] = 0x057D;
  t['sehiragana'] = 0x305B;
  t['sekatakana'] = 0x30BB;
  t['sekatakanahalfwidth'] = 0xFF7E;
  t['semicolon'] = 0x003B;
  t['semicolonarabic'] = 0x061B;
  t['semicolonmonospace'] = 0xFF1B;
  t['semicolonsmall'] = 0xFE54;
  t['semivoicedmarkkana'] = 0x309C;
  t['semivoicedmarkkanahalfwidth'] = 0xFF9F;
  t['sentisquare'] = 0x3322;
  t['sentosquare'] = 0x3323;
  t['seven'] = 0x0037;
  t['sevenarabic'] = 0x0667;
  t['sevenbengali'] = 0x09ED;
  t['sevencircle'] = 0x2466;
  t['sevencircleinversesansserif'] = 0x2790;
  t['sevendeva'] = 0x096D;
  t['seveneighths'] = 0x215E;
  t['sevengujarati'] = 0x0AED;
  t['sevengurmukhi'] = 0x0A6D;
  t['sevenhackarabic'] = 0x0667;
  t['sevenhangzhou'] = 0x3027;
  t['sevenideographicparen'] = 0x3226;
  t['seveninferior'] = 0x2087;
  t['sevenmonospace'] = 0xFF17;
  t['sevenoldstyle'] = 0xF737;
  t['sevenparen'] = 0x247A;
  t['sevenperiod'] = 0x248E;
  t['sevenpersian'] = 0x06F7;
  t['sevenroman'] = 0x2176;
  t['sevensuperior'] = 0x2077;
  t['seventeencircle'] = 0x2470;
  t['seventeenparen'] = 0x2484;
  t['seventeenperiod'] = 0x2498;
  t['seventhai'] = 0x0E57;
  t['sfthyphen'] = 0x00AD;
  t['shaarmenian'] = 0x0577;
  t['shabengali'] = 0x09B6;
  t['shacyrillic'] = 0x0448;
  t['shaddaarabic'] = 0x0651;
  t['shaddadammaarabic'] = 0xFC61;
  t['shaddadammatanarabic'] = 0xFC5E;
  t['shaddafathaarabic'] = 0xFC60;
  t['shaddakasraarabic'] = 0xFC62;
  t['shaddakasratanarabic'] = 0xFC5F;
  t['shade'] = 0x2592;
  t['shadedark'] = 0x2593;
  t['shadelight'] = 0x2591;
  t['shademedium'] = 0x2592;
  t['shadeva'] = 0x0936;
  t['shagujarati'] = 0x0AB6;
  t['shagurmukhi'] = 0x0A36;
  t['shalshelethebrew'] = 0x0593;
  t['shbopomofo'] = 0x3115;
  t['shchacyrillic'] = 0x0449;
  t['sheenarabic'] = 0x0634;
  t['sheenfinalarabic'] = 0xFEB6;
  t['sheeninitialarabic'] = 0xFEB7;
  t['sheenmedialarabic'] = 0xFEB8;
  t['sheicoptic'] = 0x03E3;
  t['sheqel'] = 0x20AA;
  t['sheqelhebrew'] = 0x20AA;
  t['sheva'] = 0x05B0;
  t['sheva115'] = 0x05B0;
  t['sheva15'] = 0x05B0;
  t['sheva22'] = 0x05B0;
  t['sheva2e'] = 0x05B0;
  t['shevahebrew'] = 0x05B0;
  t['shevanarrowhebrew'] = 0x05B0;
  t['shevaquarterhebrew'] = 0x05B0;
  t['shevawidehebrew'] = 0x05B0;
  t['shhacyrillic'] = 0x04BB;
  t['shimacoptic'] = 0x03ED;
  t['shin'] = 0x05E9;
  t['shindagesh'] = 0xFB49;
  t['shindageshhebrew'] = 0xFB49;
  t['shindageshshindot'] = 0xFB2C;
  t['shindageshshindothebrew'] = 0xFB2C;
  t['shindageshsindot'] = 0xFB2D;
  t['shindageshsindothebrew'] = 0xFB2D;
  t['shindothebrew'] = 0x05C1;
  t['shinhebrew'] = 0x05E9;
  t['shinshindot'] = 0xFB2A;
  t['shinshindothebrew'] = 0xFB2A;
  t['shinsindot'] = 0xFB2B;
  t['shinsindothebrew'] = 0xFB2B;
  t['shook'] = 0x0282;
  t['sigma'] = 0x03C3;
  t['sigma1'] = 0x03C2;
  t['sigmafinal'] = 0x03C2;
  t['sigmalunatesymbolgreek'] = 0x03F2;
  t['sihiragana'] = 0x3057;
  t['sikatakana'] = 0x30B7;
  t['sikatakanahalfwidth'] = 0xFF7C;
  t['siluqhebrew'] = 0x05BD;
  t['siluqlefthebrew'] = 0x05BD;
  t['similar'] = 0x223C;
  t['sindothebrew'] = 0x05C2;
  t['siosacirclekorean'] = 0x3274;
  t['siosaparenkorean'] = 0x3214;
  t['sioscieuckorean'] = 0x317E;
  t['sioscirclekorean'] = 0x3266;
  t['sioskiyeokkorean'] = 0x317A;
  t['sioskorean'] = 0x3145;
  t['siosnieunkorean'] = 0x317B;
  t['siosparenkorean'] = 0x3206;
  t['siospieupkorean'] = 0x317D;
  t['siostikeutkorean'] = 0x317C;
  t['six'] = 0x0036;
  t['sixarabic'] = 0x0666;
  t['sixbengali'] = 0x09EC;
  t['sixcircle'] = 0x2465;
  t['sixcircleinversesansserif'] = 0x278F;
  t['sixdeva'] = 0x096C;
  t['sixgujarati'] = 0x0AEC;
  t['sixgurmukhi'] = 0x0A6C;
  t['sixhackarabic'] = 0x0666;
  t['sixhangzhou'] = 0x3026;
  t['sixideographicparen'] = 0x3225;
  t['sixinferior'] = 0x2086;
  t['sixmonospace'] = 0xFF16;
  t['sixoldstyle'] = 0xF736;
  t['sixparen'] = 0x2479;
  t['sixperiod'] = 0x248D;
  t['sixpersian'] = 0x06F6;
  t['sixroman'] = 0x2175;
  t['sixsuperior'] = 0x2076;
  t['sixteencircle'] = 0x246F;
  t['sixteencurrencydenominatorbengali'] = 0x09F9;
  t['sixteenparen'] = 0x2483;
  t['sixteenperiod'] = 0x2497;
  t['sixthai'] = 0x0E56;
  t['slash'] = 0x002F;
  t['slashmonospace'] = 0xFF0F;
  t['slong'] = 0x017F;
  t['slongdotaccent'] = 0x1E9B;
  t['smileface'] = 0x263A;
  t['smonospace'] = 0xFF53;
  t['sofpasuqhebrew'] = 0x05C3;
  t['softhyphen'] = 0x00AD;
  t['softsigncyrillic'] = 0x044C;
  t['sohiragana'] = 0x305D;
  t['sokatakana'] = 0x30BD;
  t['sokatakanahalfwidth'] = 0xFF7F;
  t['soliduslongoverlaycmb'] = 0x0338;
  t['solidusshortoverlaycmb'] = 0x0337;
  t['sorusithai'] = 0x0E29;
  t['sosalathai'] = 0x0E28;
  t['sosothai'] = 0x0E0B;
  t['sosuathai'] = 0x0E2A;
  t['space'] = 0x0020;
  t['spacehackarabic'] = 0x0020;
  t['spade'] = 0x2660;
  t['spadesuitblack'] = 0x2660;
  t['spadesuitwhite'] = 0x2664;
  t['sparen'] = 0x24AE;
  t['squarebelowcmb'] = 0x033B;
  t['squarecc'] = 0x33C4;
  t['squarecm'] = 0x339D;
  t['squarediagonalcrosshatchfill'] = 0x25A9;
  t['squarehorizontalfill'] = 0x25A4;
  t['squarekg'] = 0x338F;
  t['squarekm'] = 0x339E;
  t['squarekmcapital'] = 0x33CE;
  t['squareln'] = 0x33D1;
  t['squarelog'] = 0x33D2;
  t['squaremg'] = 0x338E;
  t['squaremil'] = 0x33D5;
  t['squaremm'] = 0x339C;
  t['squaremsquared'] = 0x33A1;
  t['squareorthogonalcrosshatchfill'] = 0x25A6;
  t['squareupperlefttolowerrightfill'] = 0x25A7;
  t['squareupperrighttolowerleftfill'] = 0x25A8;
  t['squareverticalfill'] = 0x25A5;
  t['squarewhitewithsmallblack'] = 0x25A3;
  t['srsquare'] = 0x33DB;
  t['ssabengali'] = 0x09B7;
  t['ssadeva'] = 0x0937;
  t['ssagujarati'] = 0x0AB7;
  t['ssangcieuckorean'] = 0x3149;
  t['ssanghieuhkorean'] = 0x3185;
  t['ssangieungkorean'] = 0x3180;
  t['ssangkiyeokkorean'] = 0x3132;
  t['ssangnieunkorean'] = 0x3165;
  t['ssangpieupkorean'] = 0x3143;
  t['ssangsioskorean'] = 0x3146;
  t['ssangtikeutkorean'] = 0x3138;
  t['ssuperior'] = 0xF6F2;
  t['sterling'] = 0x00A3;
  t['sterlingmonospace'] = 0xFFE1;
  t['strokelongoverlaycmb'] = 0x0336;
  t['strokeshortoverlaycmb'] = 0x0335;
  t['subset'] = 0x2282;
  t['subsetnotequal'] = 0x228A;
  t['subsetorequal'] = 0x2286;
  t['succeeds'] = 0x227B;
  t['suchthat'] = 0x220B;
  t['suhiragana'] = 0x3059;
  t['sukatakana'] = 0x30B9;
  t['sukatakanahalfwidth'] = 0xFF7D;
  t['sukunarabic'] = 0x0652;
  t['summation'] = 0x2211;
  t['sun'] = 0x263C;
  t['superset'] = 0x2283;
  t['supersetnotequal'] = 0x228B;
  t['supersetorequal'] = 0x2287;
  t['svsquare'] = 0x33DC;
  t['syouwaerasquare'] = 0x337C;
  t['t'] = 0x0074;
  t['tabengali'] = 0x09A4;
  t['tackdown'] = 0x22A4;
  t['tackleft'] = 0x22A3;
  t['tadeva'] = 0x0924;
  t['tagujarati'] = 0x0AA4;
  t['tagurmukhi'] = 0x0A24;
  t['taharabic'] = 0x0637;
  t['tahfinalarabic'] = 0xFEC2;
  t['tahinitialarabic'] = 0xFEC3;
  t['tahiragana'] = 0x305F;
  t['tahmedialarabic'] = 0xFEC4;
  t['taisyouerasquare'] = 0x337D;
  t['takatakana'] = 0x30BF;
  t['takatakanahalfwidth'] = 0xFF80;
  t['tatweelarabic'] = 0x0640;
  t['tau'] = 0x03C4;
  t['tav'] = 0x05EA;
  t['tavdages'] = 0xFB4A;
  t['tavdagesh'] = 0xFB4A;
  t['tavdageshhebrew'] = 0xFB4A;
  t['tavhebrew'] = 0x05EA;
  t['tbar'] = 0x0167;
  t['tbopomofo'] = 0x310A;
  t['tcaron'] = 0x0165;
  t['tccurl'] = 0x02A8;
  t['tcedilla'] = 0x0163;
  t['tcheharabic'] = 0x0686;
  t['tchehfinalarabic'] = 0xFB7B;
  t['tchehinitialarabic'] = 0xFB7C;
  t['tchehmedialarabic'] = 0xFB7D;
  t['tcircle'] = 0x24E3;
  t['tcircumflexbelow'] = 0x1E71;
  t['tcommaaccent'] = 0x0163;
  t['tdieresis'] = 0x1E97;
  t['tdotaccent'] = 0x1E6B;
  t['tdotbelow'] = 0x1E6D;
  t['tecyrillic'] = 0x0442;
  t['tedescendercyrillic'] = 0x04AD;
  t['teharabic'] = 0x062A;
  t['tehfinalarabic'] = 0xFE96;
  t['tehhahinitialarabic'] = 0xFCA2;
  t['tehhahisolatedarabic'] = 0xFC0C;
  t['tehinitialarabic'] = 0xFE97;
  t['tehiragana'] = 0x3066;
  t['tehjeeminitialarabic'] = 0xFCA1;
  t['tehjeemisolatedarabic'] = 0xFC0B;
  t['tehmarbutaarabic'] = 0x0629;
  t['tehmarbutafinalarabic'] = 0xFE94;
  t['tehmedialarabic'] = 0xFE98;
  t['tehmeeminitialarabic'] = 0xFCA4;
  t['tehmeemisolatedarabic'] = 0xFC0E;
  t['tehnoonfinalarabic'] = 0xFC73;
  t['tekatakana'] = 0x30C6;
  t['tekatakanahalfwidth'] = 0xFF83;
  t['telephone'] = 0x2121;
  t['telephoneblack'] = 0x260E;
  t['telishagedolahebrew'] = 0x05A0;
  t['telishaqetanahebrew'] = 0x05A9;
  t['tencircle'] = 0x2469;
  t['tenideographicparen'] = 0x3229;
  t['tenparen'] = 0x247D;
  t['tenperiod'] = 0x2491;
  t['tenroman'] = 0x2179;
  t['tesh'] = 0x02A7;
  t['tet'] = 0x05D8;
  t['tetdagesh'] = 0xFB38;
  t['tetdageshhebrew'] = 0xFB38;
  t['tethebrew'] = 0x05D8;
  t['tetsecyrillic'] = 0x04B5;
  t['tevirhebrew'] = 0x059B;
  t['tevirlefthebrew'] = 0x059B;
  t['thabengali'] = 0x09A5;
  t['thadeva'] = 0x0925;
  t['thagujarati'] = 0x0AA5;
  t['thagurmukhi'] = 0x0A25;
  t['thalarabic'] = 0x0630;
  t['thalfinalarabic'] = 0xFEAC;
  t['thanthakhatlowleftthai'] = 0xF898;
  t['thanthakhatlowrightthai'] = 0xF897;
  t['thanthakhatthai'] = 0x0E4C;
  t['thanthakhatupperleftthai'] = 0xF896;
  t['theharabic'] = 0x062B;
  t['thehfinalarabic'] = 0xFE9A;
  t['thehinitialarabic'] = 0xFE9B;
  t['thehmedialarabic'] = 0xFE9C;
  t['thereexists'] = 0x2203;
  t['therefore'] = 0x2234;
  t['theta'] = 0x03B8;
  t['theta1'] = 0x03D1;
  t['thetasymbolgreek'] = 0x03D1;
  t['thieuthacirclekorean'] = 0x3279;
  t['thieuthaparenkorean'] = 0x3219;
  t['thieuthcirclekorean'] = 0x326B;
  t['thieuthkorean'] = 0x314C;
  t['thieuthparenkorean'] = 0x320B;
  t['thirteencircle'] = 0x246C;
  t['thirteenparen'] = 0x2480;
  t['thirteenperiod'] = 0x2494;
  t['thonangmonthothai'] = 0x0E11;
  t['thook'] = 0x01AD;
  t['thophuthaothai'] = 0x0E12;
  t['thorn'] = 0x00FE;
  t['thothahanthai'] = 0x0E17;
  t['thothanthai'] = 0x0E10;
  t['thothongthai'] = 0x0E18;
  t['thothungthai'] = 0x0E16;
  t['thousandcyrillic'] = 0x0482;
  t['thousandsseparatorarabic'] = 0x066C;
  t['thousandsseparatorpersian'] = 0x066C;
  t['three'] = 0x0033;
  t['threearabic'] = 0x0663;
  t['threebengali'] = 0x09E9;
  t['threecircle'] = 0x2462;
  t['threecircleinversesansserif'] = 0x278C;
  t['threedeva'] = 0x0969;
  t['threeeighths'] = 0x215C;
  t['threegujarati'] = 0x0AE9;
  t['threegurmukhi'] = 0x0A69;
  t['threehackarabic'] = 0x0663;
  t['threehangzhou'] = 0x3023;
  t['threeideographicparen'] = 0x3222;
  t['threeinferior'] = 0x2083;
  t['threemonospace'] = 0xFF13;
  t['threenumeratorbengali'] = 0x09F6;
  t['threeoldstyle'] = 0xF733;
  t['threeparen'] = 0x2476;
  t['threeperiod'] = 0x248A;
  t['threepersian'] = 0x06F3;
  t['threequarters'] = 0x00BE;
  t['threequartersemdash'] = 0xF6DE;
  t['threeroman'] = 0x2172;
  t['threesuperior'] = 0x00B3;
  t['threethai'] = 0x0E53;
  t['thzsquare'] = 0x3394;
  t['tihiragana'] = 0x3061;
  t['tikatakana'] = 0x30C1;
  t['tikatakanahalfwidth'] = 0xFF81;
  t['tikeutacirclekorean'] = 0x3270;
  t['tikeutaparenkorean'] = 0x3210;
  t['tikeutcirclekorean'] = 0x3262;
  t['tikeutkorean'] = 0x3137;
  t['tikeutparenkorean'] = 0x3202;
  t['tilde'] = 0x02DC;
  t['tildebelowcmb'] = 0x0330;
  t['tildecmb'] = 0x0303;
  t['tildecomb'] = 0x0303;
  t['tildedoublecmb'] = 0x0360;
  t['tildeoperator'] = 0x223C;
  t['tildeoverlaycmb'] = 0x0334;
  t['tildeverticalcmb'] = 0x033E;
  t['timescircle'] = 0x2297;
  t['tipehahebrew'] = 0x0596;
  t['tipehalefthebrew'] = 0x0596;
  t['tippigurmukhi'] = 0x0A70;
  t['titlocyrilliccmb'] = 0x0483;
  t['tiwnarmenian'] = 0x057F;
  t['tlinebelow'] = 0x1E6F;
  t['tmonospace'] = 0xFF54;
  t['toarmenian'] = 0x0569;
  t['tohiragana'] = 0x3068;
  t['tokatakana'] = 0x30C8;
  t['tokatakanahalfwidth'] = 0xFF84;
  t['tonebarextrahighmod'] = 0x02E5;
  t['tonebarextralowmod'] = 0x02E9;
  t['tonebarhighmod'] = 0x02E6;
  t['tonebarlowmod'] = 0x02E8;
  t['tonebarmidmod'] = 0x02E7;
  t['tonefive'] = 0x01BD;
  t['tonesix'] = 0x0185;
  t['tonetwo'] = 0x01A8;
  t['tonos'] = 0x0384;
  t['tonsquare'] = 0x3327;
  t['topatakthai'] = 0x0E0F;
  t['tortoiseshellbracketleft'] = 0x3014;
  t['tortoiseshellbracketleftsmall'] = 0xFE5D;
  t['tortoiseshellbracketleftvertical'] = 0xFE39;
  t['tortoiseshellbracketright'] = 0x3015;
  t['tortoiseshellbracketrightsmall'] = 0xFE5E;
  t['tortoiseshellbracketrightvertical'] = 0xFE3A;
  t['totaothai'] = 0x0E15;
  t['tpalatalhook'] = 0x01AB;
  t['tparen'] = 0x24AF;
  t['trademark'] = 0x2122;
  t['trademarksans'] = 0xF8EA;
  t['trademarkserif'] = 0xF6DB;
  t['tretroflexhook'] = 0x0288;
  t['triagdn'] = 0x25BC;
  t['triaglf'] = 0x25C4;
  t['triagrt'] = 0x25BA;
  t['triagup'] = 0x25B2;
  t['ts'] = 0x02A6;
  t['tsadi'] = 0x05E6;
  t['tsadidagesh'] = 0xFB46;
  t['tsadidageshhebrew'] = 0xFB46;
  t['tsadihebrew'] = 0x05E6;
  t['tsecyrillic'] = 0x0446;
  t['tsere'] = 0x05B5;
  t['tsere12'] = 0x05B5;
  t['tsere1e'] = 0x05B5;
  t['tsere2b'] = 0x05B5;
  t['tserehebrew'] = 0x05B5;
  t['tserenarrowhebrew'] = 0x05B5;
  t['tserequarterhebrew'] = 0x05B5;
  t['tserewidehebrew'] = 0x05B5;
  t['tshecyrillic'] = 0x045B;
  t['tsuperior'] = 0xF6F3;
  t['ttabengali'] = 0x099F;
  t['ttadeva'] = 0x091F;
  t['ttagujarati'] = 0x0A9F;
  t['ttagurmukhi'] = 0x0A1F;
  t['tteharabic'] = 0x0679;
  t['ttehfinalarabic'] = 0xFB67;
  t['ttehinitialarabic'] = 0xFB68;
  t['ttehmedialarabic'] = 0xFB69;
  t['tthabengali'] = 0x09A0;
  t['tthadeva'] = 0x0920;
  t['tthagujarati'] = 0x0AA0;
  t['tthagurmukhi'] = 0x0A20;
  t['tturned'] = 0x0287;
  t['tuhiragana'] = 0x3064;
  t['tukatakana'] = 0x30C4;
  t['tukatakanahalfwidth'] = 0xFF82;
  t['tusmallhiragana'] = 0x3063;
  t['tusmallkatakana'] = 0x30C3;
  t['tusmallkatakanahalfwidth'] = 0xFF6F;
  t['twelvecircle'] = 0x246B;
  t['twelveparen'] = 0x247F;
  t['twelveperiod'] = 0x2493;
  t['twelveroman'] = 0x217B;
  t['twentycircle'] = 0x2473;
  t['twentyhangzhou'] = 0x5344;
  t['twentyparen'] = 0x2487;
  t['twentyperiod'] = 0x249B;
  t['two'] = 0x0032;
  t['twoarabic'] = 0x0662;
  t['twobengali'] = 0x09E8;
  t['twocircle'] = 0x2461;
  t['twocircleinversesansserif'] = 0x278B;
  t['twodeva'] = 0x0968;
  t['twodotenleader'] = 0x2025;
  t['twodotleader'] = 0x2025;
  t['twodotleadervertical'] = 0xFE30;
  t['twogujarati'] = 0x0AE8;
  t['twogurmukhi'] = 0x0A68;
  t['twohackarabic'] = 0x0662;
  t['twohangzhou'] = 0x3022;
  t['twoideographicparen'] = 0x3221;
  t['twoinferior'] = 0x2082;
  t['twomonospace'] = 0xFF12;
  t['twonumeratorbengali'] = 0x09F5;
  t['twooldstyle'] = 0xF732;
  t['twoparen'] = 0x2475;
  t['twoperiod'] = 0x2489;
  t['twopersian'] = 0x06F2;
  t['tworoman'] = 0x2171;
  t['twostroke'] = 0x01BB;
  t['twosuperior'] = 0x00B2;
  t['twothai'] = 0x0E52;
  t['twothirds'] = 0x2154;
  t['u'] = 0x0075;
  t['uacute'] = 0x00FA;
  t['ubar'] = 0x0289;
  t['ubengali'] = 0x0989;
  t['ubopomofo'] = 0x3128;
  t['ubreve'] = 0x016D;
  t['ucaron'] = 0x01D4;
  t['ucircle'] = 0x24E4;
  t['ucircumflex'] = 0x00FB;
  t['ucircumflexbelow'] = 0x1E77;
  t['ucyrillic'] = 0x0443;
  t['udattadeva'] = 0x0951;
  t['udblacute'] = 0x0171;
  t['udblgrave'] = 0x0215;
  t['udeva'] = 0x0909;
  t['udieresis'] = 0x00FC;
  t['udieresisacute'] = 0x01D8;
  t['udieresisbelow'] = 0x1E73;
  t['udieresiscaron'] = 0x01DA;
  t['udieresiscyrillic'] = 0x04F1;
  t['udieresisgrave'] = 0x01DC;
  t['udieresismacron'] = 0x01D6;
  t['udotbelow'] = 0x1EE5;
  t['ugrave'] = 0x00F9;
  t['ugujarati'] = 0x0A89;
  t['ugurmukhi'] = 0x0A09;
  t['uhiragana'] = 0x3046;
  t['uhookabove'] = 0x1EE7;
  t['uhorn'] = 0x01B0;
  t['uhornacute'] = 0x1EE9;
  t['uhorndotbelow'] = 0x1EF1;
  t['uhorngrave'] = 0x1EEB;
  t['uhornhookabove'] = 0x1EED;
  t['uhorntilde'] = 0x1EEF;
  t['uhungarumlaut'] = 0x0171;
  t['uhungarumlautcyrillic'] = 0x04F3;
  t['uinvertedbreve'] = 0x0217;
  t['ukatakana'] = 0x30A6;
  t['ukatakanahalfwidth'] = 0xFF73;
  t['ukcyrillic'] = 0x0479;
  t['ukorean'] = 0x315C;
  t['umacron'] = 0x016B;
  t['umacroncyrillic'] = 0x04EF;
  t['umacrondieresis'] = 0x1E7B;
  t['umatragurmukhi'] = 0x0A41;
  t['umonospace'] = 0xFF55;
  t['underscore'] = 0x005F;
  t['underscoredbl'] = 0x2017;
  t['underscoremonospace'] = 0xFF3F;
  t['underscorevertical'] = 0xFE33;
  t['underscorewavy'] = 0xFE4F;
  t['union'] = 0x222A;
  t['universal'] = 0x2200;
  t['uogonek'] = 0x0173;
  t['uparen'] = 0x24B0;
  t['upblock'] = 0x2580;
  t['upperdothebrew'] = 0x05C4;
  t['upsilon'] = 0x03C5;
  t['upsilondieresis'] = 0x03CB;
  t['upsilondieresistonos'] = 0x03B0;
  t['upsilonlatin'] = 0x028A;
  t['upsilontonos'] = 0x03CD;
  t['uptackbelowcmb'] = 0x031D;
  t['uptackmod'] = 0x02D4;
  t['uragurmukhi'] = 0x0A73;
  t['uring'] = 0x016F;
  t['ushortcyrillic'] = 0x045E;
  t['usmallhiragana'] = 0x3045;
  t['usmallkatakana'] = 0x30A5;
  t['usmallkatakanahalfwidth'] = 0xFF69;
  t['ustraightcyrillic'] = 0x04AF;
  t['ustraightstrokecyrillic'] = 0x04B1;
  t['utilde'] = 0x0169;
  t['utildeacute'] = 0x1E79;
  t['utildebelow'] = 0x1E75;
  t['uubengali'] = 0x098A;
  t['uudeva'] = 0x090A;
  t['uugujarati'] = 0x0A8A;
  t['uugurmukhi'] = 0x0A0A;
  t['uumatragurmukhi'] = 0x0A42;
  t['uuvowelsignbengali'] = 0x09C2;
  t['uuvowelsigndeva'] = 0x0942;
  t['uuvowelsigngujarati'] = 0x0AC2;
  t['uvowelsignbengali'] = 0x09C1;
  t['uvowelsigndeva'] = 0x0941;
  t['uvowelsigngujarati'] = 0x0AC1;
  t['v'] = 0x0076;
  t['vadeva'] = 0x0935;
  t['vagujarati'] = 0x0AB5;
  t['vagurmukhi'] = 0x0A35;
  t['vakatakana'] = 0x30F7;
  t['vav'] = 0x05D5;
  t['vavdagesh'] = 0xFB35;
  t['vavdagesh65'] = 0xFB35;
  t['vavdageshhebrew'] = 0xFB35;
  t['vavhebrew'] = 0x05D5;
  t['vavholam'] = 0xFB4B;
  t['vavholamhebrew'] = 0xFB4B;
  t['vavvavhebrew'] = 0x05F0;
  t['vavyodhebrew'] = 0x05F1;
  t['vcircle'] = 0x24E5;
  t['vdotbelow'] = 0x1E7F;
  t['vecyrillic'] = 0x0432;
  t['veharabic'] = 0x06A4;
  t['vehfinalarabic'] = 0xFB6B;
  t['vehinitialarabic'] = 0xFB6C;
  t['vehmedialarabic'] = 0xFB6D;
  t['vekatakana'] = 0x30F9;
  t['venus'] = 0x2640;
  t['verticalbar'] = 0x007C;
  t['verticallineabovecmb'] = 0x030D;
  t['verticallinebelowcmb'] = 0x0329;
  t['verticallinelowmod'] = 0x02CC;
  t['verticallinemod'] = 0x02C8;
  t['vewarmenian'] = 0x057E;
  t['vhook'] = 0x028B;
  t['vikatakana'] = 0x30F8;
  t['viramabengali'] = 0x09CD;
  t['viramadeva'] = 0x094D;
  t['viramagujarati'] = 0x0ACD;
  t['visargabengali'] = 0x0983;
  t['visargadeva'] = 0x0903;
  t['visargagujarati'] = 0x0A83;
  t['vmonospace'] = 0xFF56;
  t['voarmenian'] = 0x0578;
  t['voicediterationhiragana'] = 0x309E;
  t['voicediterationkatakana'] = 0x30FE;
  t['voicedmarkkana'] = 0x309B;
  t['voicedmarkkanahalfwidth'] = 0xFF9E;
  t['vokatakana'] = 0x30FA;
  t['vparen'] = 0x24B1;
  t['vtilde'] = 0x1E7D;
  t['vturned'] = 0x028C;
  t['vuhiragana'] = 0x3094;
  t['vukatakana'] = 0x30F4;
  t['w'] = 0x0077;
  t['wacute'] = 0x1E83;
  t['waekorean'] = 0x3159;
  t['wahiragana'] = 0x308F;
  t['wakatakana'] = 0x30EF;
  t['wakatakanahalfwidth'] = 0xFF9C;
  t['wakorean'] = 0x3158;
  t['wasmallhiragana'] = 0x308E;
  t['wasmallkatakana'] = 0x30EE;
  t['wattosquare'] = 0x3357;
  t['wavedash'] = 0x301C;
  t['wavyunderscorevertical'] = 0xFE34;
  t['wawarabic'] = 0x0648;
  t['wawfinalarabic'] = 0xFEEE;
  t['wawhamzaabovearabic'] = 0x0624;
  t['wawhamzaabovefinalarabic'] = 0xFE86;
  t['wbsquare'] = 0x33DD;
  t['wcircle'] = 0x24E6;
  t['wcircumflex'] = 0x0175;
  t['wdieresis'] = 0x1E85;
  t['wdotaccent'] = 0x1E87;
  t['wdotbelow'] = 0x1E89;
  t['wehiragana'] = 0x3091;
  t['weierstrass'] = 0x2118;
  t['wekatakana'] = 0x30F1;
  t['wekorean'] = 0x315E;
  t['weokorean'] = 0x315D;
  t['wgrave'] = 0x1E81;
  t['whitebullet'] = 0x25E6;
  t['whitecircle'] = 0x25CB;
  t['whitecircleinverse'] = 0x25D9;
  t['whitecornerbracketleft'] = 0x300E;
  t['whitecornerbracketleftvertical'] = 0xFE43;
  t['whitecornerbracketright'] = 0x300F;
  t['whitecornerbracketrightvertical'] = 0xFE44;
  t['whitediamond'] = 0x25C7;
  t['whitediamondcontainingblacksmalldiamond'] = 0x25C8;
  t['whitedownpointingsmalltriangle'] = 0x25BF;
  t['whitedownpointingtriangle'] = 0x25BD;
  t['whiteleftpointingsmalltriangle'] = 0x25C3;
  t['whiteleftpointingtriangle'] = 0x25C1;
  t['whitelenticularbracketleft'] = 0x3016;
  t['whitelenticularbracketright'] = 0x3017;
  t['whiterightpointingsmalltriangle'] = 0x25B9;
  t['whiterightpointingtriangle'] = 0x25B7;
  t['whitesmallsquare'] = 0x25AB;
  t['whitesmilingface'] = 0x263A;
  t['whitesquare'] = 0x25A1;
  t['whitestar'] = 0x2606;
  t['whitetelephone'] = 0x260F;
  t['whitetortoiseshellbracketleft'] = 0x3018;
  t['whitetortoiseshellbracketright'] = 0x3019;
  t['whiteuppointingsmalltriangle'] = 0x25B5;
  t['whiteuppointingtriangle'] = 0x25B3;
  t['wihiragana'] = 0x3090;
  t['wikatakana'] = 0x30F0;
  t['wikorean'] = 0x315F;
  t['wmonospace'] = 0xFF57;
  t['wohiragana'] = 0x3092;
  t['wokatakana'] = 0x30F2;
  t['wokatakanahalfwidth'] = 0xFF66;
  t['won'] = 0x20A9;
  t['wonmonospace'] = 0xFFE6;
  t['wowaenthai'] = 0x0E27;
  t['wparen'] = 0x24B2;
  t['wring'] = 0x1E98;
  t['wsuperior'] = 0x02B7;
  t['wturned'] = 0x028D;
  t['wynn'] = 0x01BF;
  t['x'] = 0x0078;
  t['xabovecmb'] = 0x033D;
  t['xbopomofo'] = 0x3112;
  t['xcircle'] = 0x24E7;
  t['xdieresis'] = 0x1E8D;
  t['xdotaccent'] = 0x1E8B;
  t['xeharmenian'] = 0x056D;
  t['xi'] = 0x03BE;
  t['xmonospace'] = 0xFF58;
  t['xparen'] = 0x24B3;
  t['xsuperior'] = 0x02E3;
  t['y'] = 0x0079;
  t['yaadosquare'] = 0x334E;
  t['yabengali'] = 0x09AF;
  t['yacute'] = 0x00FD;
  t['yadeva'] = 0x092F;
  t['yaekorean'] = 0x3152;
  t['yagujarati'] = 0x0AAF;
  t['yagurmukhi'] = 0x0A2F;
  t['yahiragana'] = 0x3084;
  t['yakatakana'] = 0x30E4;
  t['yakatakanahalfwidth'] = 0xFF94;
  t['yakorean'] = 0x3151;
  t['yamakkanthai'] = 0x0E4E;
  t['yasmallhiragana'] = 0x3083;
  t['yasmallkatakana'] = 0x30E3;
  t['yasmallkatakanahalfwidth'] = 0xFF6C;
  t['yatcyrillic'] = 0x0463;
  t['ycircle'] = 0x24E8;
  t['ycircumflex'] = 0x0177;
  t['ydieresis'] = 0x00FF;
  t['ydotaccent'] = 0x1E8F;
  t['ydotbelow'] = 0x1EF5;
  t['yeharabic'] = 0x064A;
  t['yehbarreearabic'] = 0x06D2;
  t['yehbarreefinalarabic'] = 0xFBAF;
  t['yehfinalarabic'] = 0xFEF2;
  t['yehhamzaabovearabic'] = 0x0626;
  t['yehhamzaabovefinalarabic'] = 0xFE8A;
  t['yehhamzaaboveinitialarabic'] = 0xFE8B;
  t['yehhamzaabovemedialarabic'] = 0xFE8C;
  t['yehinitialarabic'] = 0xFEF3;
  t['yehmedialarabic'] = 0xFEF4;
  t['yehmeeminitialarabic'] = 0xFCDD;
  t['yehmeemisolatedarabic'] = 0xFC58;
  t['yehnoonfinalarabic'] = 0xFC94;
  t['yehthreedotsbelowarabic'] = 0x06D1;
  t['yekorean'] = 0x3156;
  t['yen'] = 0x00A5;
  t['yenmonospace'] = 0xFFE5;
  t['yeokorean'] = 0x3155;
  t['yeorinhieuhkorean'] = 0x3186;
  t['yerahbenyomohebrew'] = 0x05AA;
  t['yerahbenyomolefthebrew'] = 0x05AA;
  t['yericyrillic'] = 0x044B;
  t['yerudieresiscyrillic'] = 0x04F9;
  t['yesieungkorean'] = 0x3181;
  t['yesieungpansioskorean'] = 0x3183;
  t['yesieungsioskorean'] = 0x3182;
  t['yetivhebrew'] = 0x059A;
  t['ygrave'] = 0x1EF3;
  t['yhook'] = 0x01B4;
  t['yhookabove'] = 0x1EF7;
  t['yiarmenian'] = 0x0575;
  t['yicyrillic'] = 0x0457;
  t['yikorean'] = 0x3162;
  t['yinyang'] = 0x262F;
  t['yiwnarmenian'] = 0x0582;
  t['ymonospace'] = 0xFF59;
  t['yod'] = 0x05D9;
  t['yoddagesh'] = 0xFB39;
  t['yoddageshhebrew'] = 0xFB39;
  t['yodhebrew'] = 0x05D9;
  t['yodyodhebrew'] = 0x05F2;
  t['yodyodpatahhebrew'] = 0xFB1F;
  t['yohiragana'] = 0x3088;
  t['yoikorean'] = 0x3189;
  t['yokatakana'] = 0x30E8;
  t['yokatakanahalfwidth'] = 0xFF96;
  t['yokorean'] = 0x315B;
  t['yosmallhiragana'] = 0x3087;
  t['yosmallkatakana'] = 0x30E7;
  t['yosmallkatakanahalfwidth'] = 0xFF6E;
  t['yotgreek'] = 0x03F3;
  t['yoyaekorean'] = 0x3188;
  t['yoyakorean'] = 0x3187;
  t['yoyakthai'] = 0x0E22;
  t['yoyingthai'] = 0x0E0D;
  t['yparen'] = 0x24B4;
  t['ypogegrammeni'] = 0x037A;
  t['ypogegrammenigreekcmb'] = 0x0345;
  t['yr'] = 0x01A6;
  t['yring'] = 0x1E99;
  t['ysuperior'] = 0x02B8;
  t['ytilde'] = 0x1EF9;
  t['yturned'] = 0x028E;
  t['yuhiragana'] = 0x3086;
  t['yuikorean'] = 0x318C;
  t['yukatakana'] = 0x30E6;
  t['yukatakanahalfwidth'] = 0xFF95;
  t['yukorean'] = 0x3160;
  t['yusbigcyrillic'] = 0x046B;
  t['yusbigiotifiedcyrillic'] = 0x046D;
  t['yuslittlecyrillic'] = 0x0467;
  t['yuslittleiotifiedcyrillic'] = 0x0469;
  t['yusmallhiragana'] = 0x3085;
  t['yusmallkatakana'] = 0x30E5;
  t['yusmallkatakanahalfwidth'] = 0xFF6D;
  t['yuyekorean'] = 0x318B;
  t['yuyeokorean'] = 0x318A;
  t['yyabengali'] = 0x09DF;
  t['yyadeva'] = 0x095F;
  t['z'] = 0x007A;
  t['zaarmenian'] = 0x0566;
  t['zacute'] = 0x017A;
  t['zadeva'] = 0x095B;
  t['zagurmukhi'] = 0x0A5B;
  t['zaharabic'] = 0x0638;
  t['zahfinalarabic'] = 0xFEC6;
  t['zahinitialarabic'] = 0xFEC7;
  t['zahiragana'] = 0x3056;
  t['zahmedialarabic'] = 0xFEC8;
  t['zainarabic'] = 0x0632;
  t['zainfinalarabic'] = 0xFEB0;
  t['zakatakana'] = 0x30B6;
  t['zaqefgadolhebrew'] = 0x0595;
  t['zaqefqatanhebrew'] = 0x0594;
  t['zarqahebrew'] = 0x0598;
  t['zayin'] = 0x05D6;
  t['zayindagesh'] = 0xFB36;
  t['zayindageshhebrew'] = 0xFB36;
  t['zayinhebrew'] = 0x05D6;
  t['zbopomofo'] = 0x3117;
  t['zcaron'] = 0x017E;
  t['zcircle'] = 0x24E9;
  t['zcircumflex'] = 0x1E91;
  t['zcurl'] = 0x0291;
  t['zdot'] = 0x017C;
  t['zdotaccent'] = 0x017C;
  t['zdotbelow'] = 0x1E93;
  t['zecyrillic'] = 0x0437;
  t['zedescendercyrillic'] = 0x0499;
  t['zedieresiscyrillic'] = 0x04DF;
  t['zehiragana'] = 0x305C;
  t['zekatakana'] = 0x30BC;
  t['zero'] = 0x0030;
  t['zeroarabic'] = 0x0660;
  t['zerobengali'] = 0x09E6;
  t['zerodeva'] = 0x0966;
  t['zerogujarati'] = 0x0AE6;
  t['zerogurmukhi'] = 0x0A66;
  t['zerohackarabic'] = 0x0660;
  t['zeroinferior'] = 0x2080;
  t['zeromonospace'] = 0xFF10;
  t['zerooldstyle'] = 0xF730;
  t['zeropersian'] = 0x06F0;
  t['zerosuperior'] = 0x2070;
  t['zerothai'] = 0x0E50;
  t['zerowidthjoiner'] = 0xFEFF;
  t['zerowidthnonjoiner'] = 0x200C;
  t['zerowidthspace'] = 0x200B;
  t['zeta'] = 0x03B6;
  t['zhbopomofo'] = 0x3113;
  t['zhearmenian'] = 0x056A;
  t['zhebrevecyrillic'] = 0x04C2;
  t['zhecyrillic'] = 0x0436;
  t['zhedescendercyrillic'] = 0x0497;
  t['zhedieresiscyrillic'] = 0x04DD;
  t['zihiragana'] = 0x3058;
  t['zikatakana'] = 0x30B8;
  t['zinorhebrew'] = 0x05AE;
  t['zlinebelow'] = 0x1E95;
  t['zmonospace'] = 0xFF5A;
  t['zohiragana'] = 0x305E;
  t['zokatakana'] = 0x30BE;
  t['zparen'] = 0x24B5;
  t['zretroflexhook'] = 0x0290;
  t['zstroke'] = 0x01B6;
  t['zuhiragana'] = 0x305A;
  t['zukatakana'] = 0x30BA;
  t['.notdef'] = 0x0000;
  t['angbracketleftbig'] = 0x2329;
  t['angbracketleftBig'] = 0x2329;
  t['angbracketleftbigg'] = 0x2329;
  t['angbracketleftBigg'] = 0x2329;
  t['angbracketrightBig'] = 0x232A;
  t['angbracketrightbig'] = 0x232A;
  t['angbracketrightBigg'] = 0x232A;
  t['angbracketrightbigg'] = 0x232A;
  t['arrowhookleft'] = 0x21AA;
  t['arrowhookright'] = 0x21A9;
  t['arrowlefttophalf'] = 0x21BC;
  t['arrowleftbothalf'] = 0x21BD;
  t['arrownortheast'] = 0x2197;
  t['arrownorthwest'] = 0x2196;
  t['arrowrighttophalf'] = 0x21C0;
  t['arrowrightbothalf'] = 0x21C1;
  t['arrowsoutheast'] = 0x2198;
  t['arrowsouthwest'] = 0x2199;
  t['backslashbig'] = 0x2216;
  t['backslashBig'] = 0x2216;
  t['backslashBigg'] = 0x2216;
  t['backslashbigg'] = 0x2216;
  t['bardbl'] = 0x2016;
  t['bracehtipdownleft'] = 0xFE37;
  t['bracehtipdownright'] = 0xFE37;
  t['bracehtipupleft'] = 0xFE38;
  t['bracehtipupright'] = 0xFE38;
  t['braceleftBig'] = 0x007B;
  t['braceleftbig'] = 0x007B;
  t['braceleftbigg'] = 0x007B;
  t['braceleftBigg'] = 0x007B;
  t['bracerightBig'] = 0x007D;
  t['bracerightbig'] = 0x007D;
  t['bracerightbigg'] = 0x007D;
  t['bracerightBigg'] = 0x007D;
  t['bracketleftbig'] = 0x005B;
  t['bracketleftBig'] = 0x005B;
  t['bracketleftbigg'] = 0x005B;
  t['bracketleftBigg'] = 0x005B;
  t['bracketrightBig'] = 0x005D;
  t['bracketrightbig'] = 0x005D;
  t['bracketrightbigg'] = 0x005D;
  t['bracketrightBigg'] = 0x005D;
  t['ceilingleftbig'] = 0x2308;
  t['ceilingleftBig'] = 0x2308;
  t['ceilingleftBigg'] = 0x2308;
  t['ceilingleftbigg'] = 0x2308;
  t['ceilingrightbig'] = 0x2309;
  t['ceilingrightBig'] = 0x2309;
  t['ceilingrightbigg'] = 0x2309;
  t['ceilingrightBigg'] = 0x2309;
  t['circledotdisplay'] = 0x2299;
  t['circledottext'] = 0x2299;
  t['circlemultiplydisplay'] = 0x2297;
  t['circlemultiplytext'] = 0x2297;
  t['circleplusdisplay'] = 0x2295;
  t['circleplustext'] = 0x2295;
  t['contintegraldisplay'] = 0x222E;
  t['contintegraltext'] = 0x222E;
  t['coproductdisplay'] = 0x2210;
  t['coproducttext'] = 0x2210;
  t['floorleftBig'] = 0x230A;
  t['floorleftbig'] = 0x230A;
  t['floorleftbigg'] = 0x230A;
  t['floorleftBigg'] = 0x230A;
  t['floorrightbig'] = 0x230B;
  t['floorrightBig'] = 0x230B;
  t['floorrightBigg'] = 0x230B;
  t['floorrightbigg'] = 0x230B;
  t['hatwide'] = 0x0302;
  t['hatwider'] = 0x0302;
  t['hatwidest'] = 0x0302;
  t['intercal'] = 0x1D40;
  t['integraldisplay'] = 0x222B;
  t['integraltext'] = 0x222B;
  t['intersectiondisplay'] = 0x22C2;
  t['intersectiontext'] = 0x22C2;
  t['logicalanddisplay'] = 0x2227;
  t['logicalandtext'] = 0x2227;
  t['logicalordisplay'] = 0x2228;
  t['logicalortext'] = 0x2228;
  t['parenleftBig'] = 0x0028;
  t['parenleftbig'] = 0x0028;
  t['parenleftBigg'] = 0x0028;
  t['parenleftbigg'] = 0x0028;
  t['parenrightBig'] = 0x0029;
  t['parenrightbig'] = 0x0029;
  t['parenrightBigg'] = 0x0029;
  t['parenrightbigg'] = 0x0029;
  t['prime'] = 0x2032;
  t['productdisplay'] = 0x220F;
  t['producttext'] = 0x220F;
  t['radicalbig'] = 0x221A;
  t['radicalBig'] = 0x221A;
  t['radicalBigg'] = 0x221A;
  t['radicalbigg'] = 0x221A;
  t['radicalbt'] = 0x221A;
  t['radicaltp'] = 0x221A;
  t['radicalvertex'] = 0x221A;
  t['slashbig'] = 0x002F;
  t['slashBig'] = 0x002F;
  t['slashBigg'] = 0x002F;
  t['slashbigg'] = 0x002F;
  t['summationdisplay'] = 0x2211;
  t['summationtext'] = 0x2211;
  t['tildewide'] = 0x02DC;
  t['tildewider'] = 0x02DC;
  t['tildewidest'] = 0x02DC;
  t['uniondisplay'] = 0x22C3;
  t['unionmultidisplay'] = 0x228E;
  t['unionmultitext'] = 0x228E;
  t['unionsqdisplay'] = 0x2294;
  t['unionsqtext'] = 0x2294;
  t['uniontext'] = 0x22C3;
  t['vextenddouble'] = 0x2225;
  t['vextendsingle'] = 0x2223;
});
var getDingbatsGlyphsUnicode = getLookupTableFactory(function (t) {
  t['space'] = 0x0020;
  t['a1'] = 0x2701;
  t['a2'] = 0x2702;
  t['a202'] = 0x2703;
  t['a3'] = 0x2704;
  t['a4'] = 0x260E;
  t['a5'] = 0x2706;
  t['a119'] = 0x2707;
  t['a118'] = 0x2708;
  t['a117'] = 0x2709;
  t['a11'] = 0x261B;
  t['a12'] = 0x261E;
  t['a13'] = 0x270C;
  t['a14'] = 0x270D;
  t['a15'] = 0x270E;
  t['a16'] = 0x270F;
  t['a105'] = 0x2710;
  t['a17'] = 0x2711;
  t['a18'] = 0x2712;
  t['a19'] = 0x2713;
  t['a20'] = 0x2714;
  t['a21'] = 0x2715;
  t['a22'] = 0x2716;
  t['a23'] = 0x2717;
  t['a24'] = 0x2718;
  t['a25'] = 0x2719;
  t['a26'] = 0x271A;
  t['a27'] = 0x271B;
  t['a28'] = 0x271C;
  t['a6'] = 0x271D;
  t['a7'] = 0x271E;
  t['a8'] = 0x271F;
  t['a9'] = 0x2720;
  t['a10'] = 0x2721;
  t['a29'] = 0x2722;
  t['a30'] = 0x2723;
  t['a31'] = 0x2724;
  t['a32'] = 0x2725;
  t['a33'] = 0x2726;
  t['a34'] = 0x2727;
  t['a35'] = 0x2605;
  t['a36'] = 0x2729;
  t['a37'] = 0x272A;
  t['a38'] = 0x272B;
  t['a39'] = 0x272C;
  t['a40'] = 0x272D;
  t['a41'] = 0x272E;
  t['a42'] = 0x272F;
  t['a43'] = 0x2730;
  t['a44'] = 0x2731;
  t['a45'] = 0x2732;
  t['a46'] = 0x2733;
  t['a47'] = 0x2734;
  t['a48'] = 0x2735;
  t['a49'] = 0x2736;
  t['a50'] = 0x2737;
  t['a51'] = 0x2738;
  t['a52'] = 0x2739;
  t['a53'] = 0x273A;
  t['a54'] = 0x273B;
  t['a55'] = 0x273C;
  t['a56'] = 0x273D;
  t['a57'] = 0x273E;
  t['a58'] = 0x273F;
  t['a59'] = 0x2740;
  t['a60'] = 0x2741;
  t['a61'] = 0x2742;
  t['a62'] = 0x2743;
  t['a63'] = 0x2744;
  t['a64'] = 0x2745;
  t['a65'] = 0x2746;
  t['a66'] = 0x2747;
  t['a67'] = 0x2748;
  t['a68'] = 0x2749;
  t['a69'] = 0x274A;
  t['a70'] = 0x274B;
  t['a71'] = 0x25CF;
  t['a72'] = 0x274D;
  t['a73'] = 0x25A0;
  t['a74'] = 0x274F;
  t['a203'] = 0x2750;
  t['a75'] = 0x2751;
  t['a204'] = 0x2752;
  t['a76'] = 0x25B2;
  t['a77'] = 0x25BC;
  t['a78'] = 0x25C6;
  t['a79'] = 0x2756;
  t['a81'] = 0x25D7;
  t['a82'] = 0x2758;
  t['a83'] = 0x2759;
  t['a84'] = 0x275A;
  t['a97'] = 0x275B;
  t['a98'] = 0x275C;
  t['a99'] = 0x275D;
  t['a100'] = 0x275E;
  t['a101'] = 0x2761;
  t['a102'] = 0x2762;
  t['a103'] = 0x2763;
  t['a104'] = 0x2764;
  t['a106'] = 0x2765;
  t['a107'] = 0x2766;
  t['a108'] = 0x2767;
  t['a112'] = 0x2663;
  t['a111'] = 0x2666;
  t['a110'] = 0x2665;
  t['a109'] = 0x2660;
  t['a120'] = 0x2460;
  t['a121'] = 0x2461;
  t['a122'] = 0x2462;
  t['a123'] = 0x2463;
  t['a124'] = 0x2464;
  t['a125'] = 0x2465;
  t['a126'] = 0x2466;
  t['a127'] = 0x2467;
  t['a128'] = 0x2468;
  t['a129'] = 0x2469;
  t['a130'] = 0x2776;
  t['a131'] = 0x2777;
  t['a132'] = 0x2778;
  t['a133'] = 0x2779;
  t['a134'] = 0x277A;
  t['a135'] = 0x277B;
  t['a136'] = 0x277C;
  t['a137'] = 0x277D;
  t['a138'] = 0x277E;
  t['a139'] = 0x277F;
  t['a140'] = 0x2780;
  t['a141'] = 0x2781;
  t['a142'] = 0x2782;
  t['a143'] = 0x2783;
  t['a144'] = 0x2784;
  t['a145'] = 0x2785;
  t['a146'] = 0x2786;
  t['a147'] = 0x2787;
  t['a148'] = 0x2788;
  t['a149'] = 0x2789;
  t['a150'] = 0x278A;
  t['a151'] = 0x278B;
  t['a152'] = 0x278C;
  t['a153'] = 0x278D;
  t['a154'] = 0x278E;
  t['a155'] = 0x278F;
  t['a156'] = 0x2790;
  t['a157'] = 0x2791;
  t['a158'] = 0x2792;
  t['a159'] = 0x2793;
  t['a160'] = 0x2794;
  t['a161'] = 0x2192;
  t['a163'] = 0x2194;
  t['a164'] = 0x2195;
  t['a196'] = 0x2798;
  t['a165'] = 0x2799;
  t['a192'] = 0x279A;
  t['a166'] = 0x279B;
  t['a167'] = 0x279C;
  t['a168'] = 0x279D;
  t['a169'] = 0x279E;
  t['a170'] = 0x279F;
  t['a171'] = 0x27A0;
  t['a172'] = 0x27A1;
  t['a173'] = 0x27A2;
  t['a162'] = 0x27A3;
  t['a174'] = 0x27A4;
  t['a175'] = 0x27A5;
  t['a176'] = 0x27A6;
  t['a177'] = 0x27A7;
  t['a178'] = 0x27A8;
  t['a179'] = 0x27A9;
  t['a193'] = 0x27AA;
  t['a180'] = 0x27AB;
  t['a199'] = 0x27AC;
  t['a181'] = 0x27AD;
  t['a200'] = 0x27AE;
  t['a182'] = 0x27AF;
  t['a201'] = 0x27B1;
  t['a183'] = 0x27B2;
  t['a184'] = 0x27B3;
  t['a197'] = 0x27B4;
  t['a185'] = 0x27B5;
  t['a194'] = 0x27B6;
  t['a198'] = 0x27B7;
  t['a186'] = 0x27B8;
  t['a195'] = 0x27B9;
  t['a187'] = 0x27BA;
  t['a188'] = 0x27BB;
  t['a189'] = 0x27BC;
  t['a190'] = 0x27BD;
  t['a191'] = 0x27BE;
  t['a89'] = 0x2768;
  t['a90'] = 0x2769;
  t['a93'] = 0x276A;
  t['a94'] = 0x276B;
  t['a91'] = 0x276C;
  t['a92'] = 0x276D;
  t['a205'] = 0x276E;
  t['a85'] = 0x276F;
  t['a206'] = 0x2770;
  t['a86'] = 0x2771;
  t['a87'] = 0x2772;
  t['a88'] = 0x2773;
  t['a95'] = 0x2774;
  t['a96'] = 0x2775;
  t['.notdef'] = 0x0000;
});
exports.getGlyphsUnicode = getGlyphsUnicode;
exports.getDingbatsGlyphsUnicode = getDingbatsGlyphsUnicode;

/***/ }),
/* 8 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var sharedUtil = __w_pdfjs_require__(0);
var corePrimitives = __w_pdfjs_require__(1);
var corePdfManager = __w_pdfjs_require__(33);
var UNSUPPORTED_FEATURES = sharedUtil.UNSUPPORTED_FEATURES;
var InvalidPDFException = sharedUtil.InvalidPDFException;
var MessageHandler = sharedUtil.MessageHandler;
var MissingPDFException = sharedUtil.MissingPDFException;
var UnexpectedResponseException = sharedUtil.UnexpectedResponseException;
var PasswordException = sharedUtil.PasswordException;
var UnknownErrorException = sharedUtil.UnknownErrorException;
var XRefParseException = sharedUtil.XRefParseException;
var arrayByteLength = sharedUtil.arrayByteLength;
var arraysToBytes = sharedUtil.arraysToBytes;
var assert = sharedUtil.assert;
var createPromiseCapability = sharedUtil.createPromiseCapability;
var info = sharedUtil.info;
var warn = sharedUtil.warn;
var setVerbosityLevel = sharedUtil.setVerbosityLevel;
var isNodeJS = sharedUtil.isNodeJS;
var Ref = corePrimitives.Ref;
var LocalPdfManager = corePdfManager.LocalPdfManager;
var NetworkPdfManager = corePdfManager.NetworkPdfManager;
var WorkerTask = function WorkerTaskClosure() {
  function WorkerTask(name) {
    this.name = name;
    this.terminated = false;
    this._capability = createPromiseCapability();
  }
  WorkerTask.prototype = {
    get finished() {
      return this._capability.promise;
    },
    finish: function finish() {
      this._capability.resolve();
    },
    terminate: function terminate() {
      this.terminated = true;
    },
    ensureNotTerminated: function ensureNotTerminated() {
      if (this.terminated) {
        throw new Error('Worker task was terminated');
      }
    }
  };
  return WorkerTask;
}();
var PDFWorkerStream = function PDFWorkerStreamClosure() {
  function PDFWorkerStream(params, msgHandler) {
    this._queuedChunks = [];
    var initialData = params.initialData;
    if (initialData && initialData.length > 0) {
      this._queuedChunks.push(initialData);
    }
    this._msgHandler = msgHandler;
    this._isRangeSupported = !params.disableRange;
    this._isStreamingSupported = !params.disableStream;
    this._contentLength = params.length;
    this._fullRequestReader = null;
    this._rangeReaders = [];
    msgHandler.on('OnDataRange', this._onReceiveData.bind(this));
    msgHandler.on('OnDataProgress', this._onProgress.bind(this));
  }
  PDFWorkerStream.prototype = {
    _onReceiveData: function PDFWorkerStream_onReceiveData(args) {
      if (args.begin === undefined) {
        if (this._fullRequestReader) {
          this._fullRequestReader._enqueue(args.chunk);
        } else {
          this._queuedChunks.push(args.chunk);
        }
      } else {
        var found = this._rangeReaders.some(function (rangeReader) {
          if (rangeReader._begin !== args.begin) {
            return false;
          }
          rangeReader._enqueue(args.chunk);
          return true;
        });
        assert(found);
      }
    },
    _onProgress: function PDFWorkerStream_onProgress(evt) {
      if (this._rangeReaders.length > 0) {
        var firstReader = this._rangeReaders[0];
        if (firstReader.onProgress) {
          firstReader.onProgress({ loaded: evt.loaded });
        }
      }
    },
    _removeRangeReader: function PDFWorkerStream_removeRangeReader(reader) {
      var i = this._rangeReaders.indexOf(reader);
      if (i >= 0) {
        this._rangeReaders.splice(i, 1);
      }
    },
    getFullReader: function PDFWorkerStream_getFullReader() {
      assert(!this._fullRequestReader);
      var queuedChunks = this._queuedChunks;
      this._queuedChunks = null;
      return new PDFWorkerStreamReader(this, queuedChunks);
    },
    getRangeReader: function PDFWorkerStream_getRangeReader(begin, end) {
      var reader = new PDFWorkerStreamRangeReader(this, begin, end);
      this._msgHandler.send('RequestDataRange', {
        begin: begin,
        end: end
      });
      this._rangeReaders.push(reader);
      return reader;
    },
    cancelAllRequests: function PDFWorkerStream_cancelAllRequests(reason) {
      if (this._fullRequestReader) {
        this._fullRequestReader.cancel(reason);
      }
      var readers = this._rangeReaders.slice(0);
      readers.forEach(function (rangeReader) {
        rangeReader.cancel(reason);
      });
    }
  };
  function PDFWorkerStreamReader(stream, queuedChunks) {
    this._stream = stream;
    this._done = false;
    this._queuedChunks = queuedChunks || [];
    this._requests = [];
    this._headersReady = Promise.resolve();
    stream._fullRequestReader = this;
    this.onProgress = null;
  }
  PDFWorkerStreamReader.prototype = {
    _enqueue: function PDFWorkerStreamReader_enqueue(chunk) {
      if (this._done) {
        return;
      }
      if (this._requests.length > 0) {
        var requestCapability = this._requests.shift();
        requestCapability.resolve({
          value: chunk,
          done: false
        });
        return;
      }
      this._queuedChunks.push(chunk);
    },
    get headersReady() {
      return this._headersReady;
    },
    get isRangeSupported() {
      return this._stream._isRangeSupported;
    },
    get isStreamingSupported() {
      return this._stream._isStreamingSupported;
    },
    get contentLength() {
      return this._stream._contentLength;
    },
    read: function PDFWorkerStreamReader_read() {
      if (this._queuedChunks.length > 0) {
        var chunk = this._queuedChunks.shift();
        return Promise.resolve({
          value: chunk,
          done: false
        });
      }
      if (this._done) {
        return Promise.resolve({
          value: undefined,
          done: true
        });
      }
      var requestCapability = createPromiseCapability();
      this._requests.push(requestCapability);
      return requestCapability.promise;
    },
    cancel: function PDFWorkerStreamReader_cancel(reason) {
      this._done = true;
      this._requests.forEach(function (requestCapability) {
        requestCapability.resolve({
          value: undefined,
          done: true
        });
      });
      this._requests = [];
    }
  };
  function PDFWorkerStreamRangeReader(stream, begin, end) {
    this._stream = stream;
    this._begin = begin;
    this._end = end;
    this._queuedChunk = null;
    this._requests = [];
    this._done = false;
    this.onProgress = null;
  }
  PDFWorkerStreamRangeReader.prototype = {
    _enqueue: function PDFWorkerStreamRangeReader_enqueue(chunk) {
      if (this._done) {
        return;
      }
      if (this._requests.length === 0) {
        this._queuedChunk = chunk;
      } else {
        var requestsCapability = this._requests.shift();
        requestsCapability.resolve({
          value: chunk,
          done: false
        });
        this._requests.forEach(function (requestCapability) {
          requestCapability.resolve({
            value: undefined,
            done: true
          });
        });
        this._requests = [];
      }
      this._done = true;
      this._stream._removeRangeReader(this);
    },
    get isStreamingSupported() {
      return false;
    },
    read: function PDFWorkerStreamRangeReader_read() {
      if (this._queuedChunk) {
        return Promise.resolve({
          value: this._queuedChunk,
          done: false
        });
      }
      if (this._done) {
        return Promise.resolve({
          value: undefined,
          done: true
        });
      }
      var requestCapability = createPromiseCapability();
      this._requests.push(requestCapability);
      return requestCapability.promise;
    },
    cancel: function PDFWorkerStreamRangeReader_cancel(reason) {
      this._done = true;
      this._requests.forEach(function (requestCapability) {
        requestCapability.resolve({
          value: undefined,
          done: true
        });
      });
      this._requests = [];
      this._stream._removeRangeReader(this);
    }
  };
  return PDFWorkerStream;
}();
var PDFNetworkStream;
function setPDFNetworkStreamClass(cls) {
  PDFNetworkStream = cls;
}
var WorkerMessageHandler = {
  setup: function wphSetup(handler, port) {
    var testMessageProcessed = false;
    handler.on('test', function wphSetupTest(data) {
      if (testMessageProcessed) {
        return;
      }
      testMessageProcessed = true;
      if (!(data instanceof Uint8Array)) {
        handler.send('test', 'main', false);
        return;
      }
      var supportTransfers = data[0] === 255;
      handler.postMessageTransfers = supportTransfers;
      var xhr = new XMLHttpRequest();
      var responseExists = 'response' in xhr;
      try {
        xhr.responseType;
      } catch (e) {
        responseExists = false;
      }
      if (!responseExists) {
        handler.send('test', false);
        return;
      }
      handler.send('test', {
        supportTypedArray: true,
        supportTransfers: supportTransfers
      });
    });
    handler.on('configure', function wphConfigure(data) {
      setVerbosityLevel(data.verbosity);
    });
    handler.on('GetDocRequest', function wphSetupDoc(data) {
      return WorkerMessageHandler.createDocumentHandler(data, port);
    });
  },
  createDocumentHandler: function wphCreateDocumentHandler(docParams, port) {
    var pdfManager;
    var terminated = false;
    var cancelXHRs = null;
    var WorkerTasks = [];
    var docId = docParams.docId;
    var docBaseUrl = docParams.docBaseUrl;
    var workerHandlerName = docParams.docId + '_worker';
    var handler = new MessageHandler(workerHandlerName, docId, port);
    handler.postMessageTransfers = docParams.postMessageTransfers;
    function ensureNotTerminated() {
      if (terminated) {
        throw new Error('Worker was terminated');
      }
    }
    function startWorkerTask(task) {
      WorkerTasks.push(task);
    }
    function finishWorkerTask(task) {
      task.finish();
      var i = WorkerTasks.indexOf(task);
      WorkerTasks.splice(i, 1);
    }
    function loadDocument(recoveryMode) {
      var loadDocumentCapability = createPromiseCapability();
      var parseSuccess = function parseSuccess() {
        var numPagesPromise = pdfManager.ensureDoc('numPages');
        var fingerprintPromise = pdfManager.ensureDoc('fingerprint');
        var encryptedPromise = pdfManager.ensureXRef('encrypt');
        Promise.all([numPagesPromise, fingerprintPromise, encryptedPromise]).then(function onDocReady(results) {
          var doc = {
            numPages: results[0],
            fingerprint: results[1],
            encrypted: !!results[2]
          };
          loadDocumentCapability.resolve(doc);
        }, parseFailure);
      };
      var parseFailure = function parseFailure(e) {
        loadDocumentCapability.reject(e);
      };
      pdfManager.ensureDoc('checkHeader', []).then(function () {
        pdfManager.ensureDoc('parseStartXRef', []).then(function () {
          pdfManager.ensureDoc('parse', [recoveryMode]).then(parseSuccess, parseFailure);
        }, parseFailure);
      }, parseFailure);
      return loadDocumentCapability.promise;
    }
    function getPdfManager(data, evaluatorOptions) {
      var pdfManagerCapability = createPromiseCapability();
      var pdfManager;
      var source = data.source;
      if (source.data) {
        try {
          pdfManager = new LocalPdfManager(docId, source.data, source.password, evaluatorOptions, docBaseUrl);
          pdfManagerCapability.resolve(pdfManager);
        } catch (ex) {
          pdfManagerCapability.reject(ex);
        }
        return pdfManagerCapability.promise;
      }
      var pdfStream;
      try {
        if (source.chunkedViewerLoading) {
          pdfStream = new PDFWorkerStream(source, handler);
        } else {
          assert(PDFNetworkStream, 'pdfjs/core/network module is not loaded');
          pdfStream = new PDFNetworkStream(data);
        }
      } catch (ex) {
        pdfManagerCapability.reject(ex);
        return pdfManagerCapability.promise;
      }
      var fullRequest = pdfStream.getFullReader();
      fullRequest.headersReady.then(function () {
        if (!fullRequest.isStreamingSupported || !fullRequest.isRangeSupported) {
          fullRequest.onProgress = function (evt) {
            handler.send('DocProgress', {
              loaded: evt.loaded,
              total: evt.total
            });
          };
        }
        if (!fullRequest.isRangeSupported) {
          return;
        }
        var disableAutoFetch = source.disableAutoFetch || fullRequest.isStreamingSupported;
        pdfManager = new NetworkPdfManager(docId, pdfStream, {
          msgHandler: handler,
          url: source.url,
          password: source.password,
          length: fullRequest.contentLength,
          disableAutoFetch: disableAutoFetch,
          rangeChunkSize: source.rangeChunkSize
        }, evaluatorOptions, docBaseUrl);
        pdfManagerCapability.resolve(pdfManager);
        cancelXHRs = null;
      }).catch(function (reason) {
        pdfManagerCapability.reject(reason);
        cancelXHRs = null;
      });
      var cachedChunks = [],
          loaded = 0;
      var flushChunks = function flushChunks() {
        var pdfFile = arraysToBytes(cachedChunks);
        if (source.length && pdfFile.length !== source.length) {
          warn('reported HTTP length is different from actual');
        }
        try {
          pdfManager = new LocalPdfManager(docId, pdfFile, source.password, evaluatorOptions, docBaseUrl);
          pdfManagerCapability.resolve(pdfManager);
        } catch (ex) {
          pdfManagerCapability.reject(ex);
        }
        cachedChunks = [];
      };
      var readPromise = new Promise(function (resolve, reject) {
        var readChunk = function readChunk(chunk) {
          try {
            ensureNotTerminated();
            if (chunk.done) {
              if (!pdfManager) {
                flushChunks();
              }
              cancelXHRs = null;
              return;
            }
            var data = chunk.value;
            loaded += arrayByteLength(data);
            if (!fullRequest.isStreamingSupported) {
              handler.send('DocProgress', {
                loaded: loaded,
                total: Math.max(loaded, fullRequest.contentLength || 0)
              });
            }
            if (pdfManager) {
              pdfManager.sendProgressiveData(data);
            } else {
              cachedChunks.push(data);
            }
            fullRequest.read().then(readChunk, reject);
          } catch (e) {
            reject(e);
          }
        };
        fullRequest.read().then(readChunk, reject);
      });
      readPromise.catch(function (e) {
        pdfManagerCapability.reject(e);
        cancelXHRs = null;
      });
      cancelXHRs = function cancelXHRs() {
        pdfStream.cancelAllRequests('abort');
      };
      return pdfManagerCapability.promise;
    }
    function setupDoc(data) {
      function onSuccess(doc) {
        ensureNotTerminated();
        handler.send('GetDoc', { pdfInfo: doc });
      }
      function onFailure(e) {
        if (e instanceof PasswordException) {
          var task = new WorkerTask('PasswordException: response ' + e.code);
          startWorkerTask(task);
          handler.sendWithPromise('PasswordRequest', e).then(function (data) {
            finishWorkerTask(task);
            pdfManager.updatePassword(data.password);
            pdfManagerReady();
          }).catch(function (ex) {
            finishWorkerTask(task);
            handler.send('PasswordException', ex);
          }.bind(null, e));
        } else if (e instanceof InvalidPDFException) {
          handler.send('InvalidPDF', e);
        } else if (e instanceof MissingPDFException) {
          handler.send('MissingPDF', e);
        } else if (e instanceof UnexpectedResponseException) {
          handler.send('UnexpectedResponse', e);
        } else {
          handler.send('UnknownError', new UnknownErrorException(e.message, e.toString()));
        }
      }
      function pdfManagerReady() {
        ensureNotTerminated();
        loadDocument(false).then(onSuccess, function loadFailure(ex) {
          ensureNotTerminated();
          if (!(ex instanceof XRefParseException)) {
            onFailure(ex);
            return;
          }
          pdfManager.requestLoadedStream();
          pdfManager.onLoadedStream().then(function () {
            ensureNotTerminated();
            loadDocument(true).then(onSuccess, onFailure);
          });
        }, onFailure);
      }
      ensureNotTerminated();
      var evaluatorOptions = {
        forceDataSchema: data.disableCreateObjectURL,
        maxImageSize: data.maxImageSize === undefined ? -1 : data.maxImageSize,
        disableFontFace: data.disableFontFace,
        disableNativeImageDecoder: data.disableNativeImageDecoder,
        ignoreErrors: data.ignoreErrors
      };
      getPdfManager(data, evaluatorOptions).then(function (newPdfManager) {
        if (terminated) {
          newPdfManager.terminate();
          throw new Error('Worker was terminated');
        }
        pdfManager = newPdfManager;
        handler.send('PDFManagerReady', null);
        pdfManager.onLoadedStream().then(function (stream) {
          handler.send('DataLoaded', { length: stream.bytes.byteLength });
        });
      }).then(pdfManagerReady, onFailure);
    }
    handler.on('GetPage', function wphSetupGetPage(data) {
      return pdfManager.getPage(data.pageIndex).then(function (page) {
        var rotatePromise = pdfManager.ensure(page, 'rotate');
        var refPromise = pdfManager.ensure(page, 'ref');
        var userUnitPromise = pdfManager.ensure(page, 'userUnit');
        var viewPromise = pdfManager.ensure(page, 'view');
        return Promise.all([rotatePromise, refPromise, userUnitPromise, viewPromise]).then(function (results) {
          return {
            rotate: results[0],
            ref: results[1],
            userUnit: results[2],
            view: results[3]
          };
        });
      });
    });
    handler.on('GetPageIndex', function wphSetupGetPageIndex(data) {
      var ref = new Ref(data.ref.num, data.ref.gen);
      var catalog = pdfManager.pdfDocument.catalog;
      return catalog.getPageIndex(ref);
    });
    handler.on('GetDestinations', function wphSetupGetDestinations(data) {
      return pdfManager.ensureCatalog('destinations');
    });
    handler.on('GetDestination', function wphSetupGetDestination(data) {
      return pdfManager.ensureCatalog('getDestination', [data.id]);
    });
    handler.on('GetPageLabels', function wphSetupGetPageLabels(data) {
      return pdfManager.ensureCatalog('pageLabels');
    });
    handler.on('GetAttachments', function wphSetupGetAttachments(data) {
      return pdfManager.ensureCatalog('attachments');
    });
    handler.on('GetJavaScript', function wphSetupGetJavaScript(data) {
      return pdfManager.ensureCatalog('javaScript');
    });
    handler.on('GetOutline', function wphSetupGetOutline(data) {
      return pdfManager.ensureCatalog('documentOutline');
    });
    handler.on('GetMetadata', function wphSetupGetMetadata(data) {
      return Promise.all([pdfManager.ensureDoc('documentInfo'), pdfManager.ensureCatalog('metadata')]);
    });
    handler.on('GetData', function wphSetupGetData(data) {
      pdfManager.requestLoadedStream();
      return pdfManager.onLoadedStream().then(function (stream) {
        return stream.bytes;
      });
    });
    handler.on('GetStats', function wphSetupGetStats(data) {
      return pdfManager.pdfDocument.xref.stats;
    });
    handler.on('GetAnnotations', function wphSetupGetAnnotations(data) {
      return pdfManager.getPage(data.pageIndex).then(function (page) {
        return pdfManager.ensure(page, 'getAnnotationsData', [data.intent]);
      });
    });
    handler.on('RenderPageRequest', function wphSetupRenderPage(data) {
      var pageIndex = data.pageIndex;
      pdfManager.getPage(pageIndex).then(function (page) {
        var task = new WorkerTask('RenderPageRequest: page ' + pageIndex);
        startWorkerTask(task);
        var pageNum = pageIndex + 1;
        var start = Date.now();
        page.getOperatorList(handler, task, data.intent, data.renderInteractiveForms).then(function (operatorList) {
          finishWorkerTask(task);
          info('page=' + pageNum + ' - getOperatorList: time=' + (Date.now() - start) + 'ms, len=' + operatorList.totalLength);
        }, function (e) {
          finishWorkerTask(task);
          if (task.terminated) {
            return;
          }
          handler.send('UnsupportedFeature', { featureId: UNSUPPORTED_FEATURES.unknown });
          var minimumStackMessage = 'worker.js: while trying to getPage() and getOperatorList()';
          var wrappedException;
          if (typeof e === 'string') {
            wrappedException = {
              message: e,
              stack: minimumStackMessage
            };
          } else if ((typeof e === 'undefined' ? 'undefined' : _typeof(e)) === 'object') {
            wrappedException = {
              message: e.message || e.toString(),
              stack: e.stack || minimumStackMessage
            };
          } else {
            wrappedException = {
              message: 'Unknown exception type: ' + (typeof e === 'undefined' ? 'undefined' : _typeof(e)),
              stack: minimumStackMessage
            };
          }
          handler.send('PageError', {
            pageNum: pageNum,
            error: wrappedException,
            intent: data.intent
          });
        });
      });
    }, this);
    handler.on('GetTextContent', function wphExtractText(data) {
      var pageIndex = data.pageIndex;
      return pdfManager.getPage(pageIndex).then(function (page) {
        var task = new WorkerTask('GetTextContent: page ' + pageIndex);
        startWorkerTask(task);
        var pageNum = pageIndex + 1;
        var start = Date.now();
        return page.extractTextContent(handler, task, data.normalizeWhitespace, data.combineTextItems).then(function (textContent) {
          finishWorkerTask(task);
          info('text indexing: page=' + pageNum + ' - time=' + (Date.now() - start) + 'ms');
          return textContent;
        }, function (reason) {
          finishWorkerTask(task);
          if (task.terminated) {
            return;
          }
          throw reason;
        });
      });
    });
    handler.on('Cleanup', function wphCleanup(data) {
      return pdfManager.cleanup();
    });
    handler.on('Terminate', function wphTerminate(data) {
      terminated = true;
      if (pdfManager) {
        pdfManager.terminate();
        pdfManager = null;
      }
      if (cancelXHRs) {
        cancelXHRs();
      }
      var waitOn = [];
      WorkerTasks.forEach(function (task) {
        waitOn.push(task.finished);
        task.terminate();
      });
      return Promise.all(waitOn).then(function () {
        handler.destroy();
        handler = null;
      });
    });
    handler.on('Ready', function wphReady(data) {
      setupDoc(docParams);
      docParams = null;
    });
    return workerHandlerName;
  }
};
function initializeWorker() {
  var handler = new MessageHandler('worker', 'main', self);
  WorkerMessageHandler.setup(handler, self);
  handler.send('ready', null);
}
if (typeof window === 'undefined' && !isNodeJS()) {
  initializeWorker();
}
exports.setPDFNetworkStreamClass = setPDFNetworkStreamClass;
exports.WorkerTask = WorkerTask;
exports.WorkerMessageHandler = WorkerMessageHandler;

/***/ }),
/* 9 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;
g = function () {
  return this;
}();
try {
  g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}
module.exports = g;

/***/ }),
/* 10 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var ArithmeticDecoder = function ArithmeticDecoderClosure() {
  var QeTable = [{
    qe: 0x5601,
    nmps: 1,
    nlps: 1,
    switchFlag: 1
  }, {
    qe: 0x3401,
    nmps: 2,
    nlps: 6,
    switchFlag: 0
  }, {
    qe: 0x1801,
    nmps: 3,
    nlps: 9,
    switchFlag: 0
  }, {
    qe: 0x0AC1,
    nmps: 4,
    nlps: 12,
    switchFlag: 0
  }, {
    qe: 0x0521,
    nmps: 5,
    nlps: 29,
    switchFlag: 0
  }, {
    qe: 0x0221,
    nmps: 38,
    nlps: 33,
    switchFlag: 0
  }, {
    qe: 0x5601,
    nmps: 7,
    nlps: 6,
    switchFlag: 1
  }, {
    qe: 0x5401,
    nmps: 8,
    nlps: 14,
    switchFlag: 0
  }, {
    qe: 0x4801,
    nmps: 9,
    nlps: 14,
    switchFlag: 0
  }, {
    qe: 0x3801,
    nmps: 10,
    nlps: 14,
    switchFlag: 0
  }, {
    qe: 0x3001,
    nmps: 11,
    nlps: 17,
    switchFlag: 0
  }, {
    qe: 0x2401,
    nmps: 12,
    nlps: 18,
    switchFlag: 0
  }, {
    qe: 0x1C01,
    nmps: 13,
    nlps: 20,
    switchFlag: 0
  }, {
    qe: 0x1601,
    nmps: 29,
    nlps: 21,
    switchFlag: 0
  }, {
    qe: 0x5601,
    nmps: 15,
    nlps: 14,
    switchFlag: 1
  }, {
    qe: 0x5401,
    nmps: 16,
    nlps: 14,
    switchFlag: 0
  }, {
    qe: 0x5101,
    nmps: 17,
    nlps: 15,
    switchFlag: 0
  }, {
    qe: 0x4801,
    nmps: 18,
    nlps: 16,
    switchFlag: 0
  }, {
    qe: 0x3801,
    nmps: 19,
    nlps: 17,
    switchFlag: 0
  }, {
    qe: 0x3401,
    nmps: 20,
    nlps: 18,
    switchFlag: 0
  }, {
    qe: 0x3001,
    nmps: 21,
    nlps: 19,
    switchFlag: 0
  }, {
    qe: 0x2801,
    nmps: 22,
    nlps: 19,
    switchFlag: 0
  }, {
    qe: 0x2401,
    nmps: 23,
    nlps: 20,
    switchFlag: 0
  }, {
    qe: 0x2201,
    nmps: 24,
    nlps: 21,
    switchFlag: 0
  }, {
    qe: 0x1C01,
    nmps: 25,
    nlps: 22,
    switchFlag: 0
  }, {
    qe: 0x1801,
    nmps: 26,
    nlps: 23,
    switchFlag: 0
  }, {
    qe: 0x1601,
    nmps: 27,
    nlps: 24,
    switchFlag: 0
  }, {
    qe: 0x1401,
    nmps: 28,
    nlps: 25,
    switchFlag: 0
  }, {
    qe: 0x1201,
    nmps: 29,
    nlps: 26,
    switchFlag: 0
  }, {
    qe: 0x1101,
    nmps: 30,
    nlps: 27,
    switchFlag: 0
  }, {
    qe: 0x0AC1,
    nmps: 31,
    nlps: 28,
    switchFlag: 0
  }, {
    qe: 0x09C1,
    nmps: 32,
    nlps: 29,
    switchFlag: 0
  }, {
    qe: 0x08A1,
    nmps: 33,
    nlps: 30,
    switchFlag: 0
  }, {
    qe: 0x0521,
    nmps: 34,
    nlps: 31,
    switchFlag: 0
  }, {
    qe: 0x0441,
    nmps: 35,
    nlps: 32,
    switchFlag: 0
  }, {
    qe: 0x02A1,
    nmps: 36,
    nlps: 33,
    switchFlag: 0
  }, {
    qe: 0x0221,
    nmps: 37,
    nlps: 34,
    switchFlag: 0
  }, {
    qe: 0x0141,
    nmps: 38,
    nlps: 35,
    switchFlag: 0
  }, {
    qe: 0x0111,
    nmps: 39,
    nlps: 36,
    switchFlag: 0
  }, {
    qe: 0x0085,
    nmps: 40,
    nlps: 37,
    switchFlag: 0
  }, {
    qe: 0x0049,
    nmps: 41,
    nlps: 38,
    switchFlag: 0
  }, {
    qe: 0x0025,
    nmps: 42,
    nlps: 39,
    switchFlag: 0
  }, {
    qe: 0x0015,
    nmps: 43,
    nlps: 40,
    switchFlag: 0
  }, {
    qe: 0x0009,
    nmps: 44,
    nlps: 41,
    switchFlag: 0
  }, {
    qe: 0x0005,
    nmps: 45,
    nlps: 42,
    switchFlag: 0
  }, {
    qe: 0x0001,
    nmps: 45,
    nlps: 43,
    switchFlag: 0
  }, {
    qe: 0x5601,
    nmps: 46,
    nlps: 46,
    switchFlag: 0
  }];
  function ArithmeticDecoder(data, start, end) {
    this.data = data;
    this.bp = start;
    this.dataEnd = end;
    this.chigh = data[start];
    this.clow = 0;
    this.byteIn();
    this.chigh = this.chigh << 7 & 0xFFFF | this.clow >> 9 & 0x7F;
    this.clow = this.clow << 7 & 0xFFFF;
    this.ct -= 7;
    this.a = 0x8000;
  }
  ArithmeticDecoder.prototype = {
    byteIn: function ArithmeticDecoder_byteIn() {
      var data = this.data;
      var bp = this.bp;
      if (data[bp] === 0xFF) {
        var b1 = data[bp + 1];
        if (b1 > 0x8F) {
          this.clow += 0xFF00;
          this.ct = 8;
        } else {
          bp++;
          this.clow += data[bp] << 9;
          this.ct = 7;
          this.bp = bp;
        }
      } else {
        bp++;
        this.clow += bp < this.dataEnd ? data[bp] << 8 : 0xFF00;
        this.ct = 8;
        this.bp = bp;
      }
      if (this.clow > 0xFFFF) {
        this.chigh += this.clow >> 16;
        this.clow &= 0xFFFF;
      }
    },
    readBit: function ArithmeticDecoder_readBit(contexts, pos) {
      var cx_index = contexts[pos] >> 1,
          cx_mps = contexts[pos] & 1;
      var qeTableIcx = QeTable[cx_index];
      var qeIcx = qeTableIcx.qe;
      var d;
      var a = this.a - qeIcx;
      if (this.chigh < qeIcx) {
        if (a < qeIcx) {
          a = qeIcx;
          d = cx_mps;
          cx_index = qeTableIcx.nmps;
        } else {
          a = qeIcx;
          d = 1 ^ cx_mps;
          if (qeTableIcx.switchFlag === 1) {
            cx_mps = d;
          }
          cx_index = qeTableIcx.nlps;
        }
      } else {
        this.chigh -= qeIcx;
        if ((a & 0x8000) !== 0) {
          this.a = a;
          return cx_mps;
        }
        if (a < qeIcx) {
          d = 1 ^ cx_mps;
          if (qeTableIcx.switchFlag === 1) {
            cx_mps = d;
          }
          cx_index = qeTableIcx.nlps;
        } else {
          d = cx_mps;
          cx_index = qeTableIcx.nmps;
        }
      }
      do {
        if (this.ct === 0) {
          this.byteIn();
        }
        a <<= 1;
        this.chigh = this.chigh << 1 & 0xFFFF | this.clow >> 15 & 1;
        this.clow = this.clow << 1 & 0xFFFF;
        this.ct--;
      } while ((a & 0x8000) === 0);
      this.a = a;
      contexts[pos] = cx_index << 1 | cx_mps;
      return d;
    }
  };
  return ArithmeticDecoder;
}();
exports.ArithmeticDecoder = ArithmeticDecoder;

/***/ }),
/* 11 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var coreCharsets = __w_pdfjs_require__(22);
var coreEncodings = __w_pdfjs_require__(4);
var error = sharedUtil.error;
var info = sharedUtil.info;
var bytesToString = sharedUtil.bytesToString;
var warn = sharedUtil.warn;
var isArray = sharedUtil.isArray;
var Util = sharedUtil.Util;
var stringToBytes = sharedUtil.stringToBytes;
var assert = sharedUtil.assert;
var ISOAdobeCharset = coreCharsets.ISOAdobeCharset;
var ExpertCharset = coreCharsets.ExpertCharset;
var ExpertSubsetCharset = coreCharsets.ExpertSubsetCharset;
var StandardEncoding = coreEncodings.StandardEncoding;
var ExpertEncoding = coreEncodings.ExpertEncoding;
var MAX_SUBR_NESTING = 10;
var CFFStandardStrings = ['.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', 'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE', 'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu', 'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn', 'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright', 'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex', 'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute', 'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute', 'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute', 'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave', 'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl', 'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', 'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000', '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];
var CFFParser = function CFFParserClosure() {
  var CharstringValidationData = [null, {
    id: 'hstem',
    min: 2,
    stackClearing: true,
    stem: true
  }, null, {
    id: 'vstem',
    min: 2,
    stackClearing: true,
    stem: true
  }, {
    id: 'vmoveto',
    min: 1,
    stackClearing: true
  }, {
    id: 'rlineto',
    min: 2,
    resetStack: true
  }, {
    id: 'hlineto',
    min: 1,
    resetStack: true
  }, {
    id: 'vlineto',
    min: 1,
    resetStack: true
  }, {
    id: 'rrcurveto',
    min: 6,
    resetStack: true
  }, null, {
    id: 'callsubr',
    min: 1,
    undefStack: true
  }, {
    id: 'return',
    min: 0,
    undefStack: true
  }, null, null, {
    id: 'endchar',
    min: 0,
    stackClearing: true
  }, null, null, null, {
    id: 'hstemhm',
    min: 2,
    stackClearing: true,
    stem: true
  }, {
    id: 'hintmask',
    min: 0,
    stackClearing: true
  }, {
    id: 'cntrmask',
    min: 0,
    stackClearing: true
  }, {
    id: 'rmoveto',
    min: 2,
    stackClearing: true
  }, {
    id: 'hmoveto',
    min: 1,
    stackClearing: true
  }, {
    id: 'vstemhm',
    min: 2,
    stackClearing: true,
    stem: true
  }, {
    id: 'rcurveline',
    min: 8,
    resetStack: true
  }, {
    id: 'rlinecurve',
    min: 8,
    resetStack: true
  }, {
    id: 'vvcurveto',
    min: 4,
    resetStack: true
  }, {
    id: 'hhcurveto',
    min: 4,
    resetStack: true
  }, null, {
    id: 'callgsubr',
    min: 1,
    undefStack: true
  }, {
    id: 'vhcurveto',
    min: 4,
    resetStack: true
  }, {
    id: 'hvcurveto',
    min: 4,
    resetStack: true
  }];
  var CharstringValidationData12 = [null, null, null, {
    id: 'and',
    min: 2,
    stackDelta: -1
  }, {
    id: 'or',
    min: 2,
    stackDelta: -1
  }, {
    id: 'not',
    min: 1,
    stackDelta: 0
  }, null, null, null, {
    id: 'abs',
    min: 1,
    stackDelta: 0
  }, {
    id: 'add',
    min: 2,
    stackDelta: -1,
    stackFn: function stack_div(stack, index) {
      stack[index - 2] = stack[index - 2] + stack[index - 1];
    }
  }, {
    id: 'sub',
    min: 2,
    stackDelta: -1,
    stackFn: function stack_div(stack, index) {
      stack[index - 2] = stack[index - 2] - stack[index - 1];
    }
  }, {
    id: 'div',
    min: 2,
    stackDelta: -1,
    stackFn: function stack_div(stack, index) {
      stack[index - 2] = stack[index - 2] / stack[index - 1];
    }
  }, null, {
    id: 'neg',
    min: 1,
    stackDelta: 0,
    stackFn: function stack_div(stack, index) {
      stack[index - 1] = -stack[index - 1];
    }
  }, {
    id: 'eq',
    min: 2,
    stackDelta: -1
  }, null, null, {
    id: 'drop',
    min: 1,
    stackDelta: -1
  }, null, {
    id: 'put',
    min: 2,
    stackDelta: -2
  }, {
    id: 'get',
    min: 1,
    stackDelta: 0
  }, {
    id: 'ifelse',
    min: 4,
    stackDelta: -3
  }, {
    id: 'random',
    min: 0,
    stackDelta: 1
  }, {
    id: 'mul',
    min: 2,
    stackDelta: -1,
    stackFn: function stack_div(stack, index) {
      stack[index - 2] = stack[index - 2] * stack[index - 1];
    }
  }, null, {
    id: 'sqrt',
    min: 1,
    stackDelta: 0
  }, {
    id: 'dup',
    min: 1,
    stackDelta: 1
  }, {
    id: 'exch',
    min: 2,
    stackDelta: 0
  }, {
    id: 'index',
    min: 2,
    stackDelta: 0
  }, {
    id: 'roll',
    min: 3,
    stackDelta: -2
  }, null, null, null, {
    id: 'hflex',
    min: 7,
    resetStack: true
  }, {
    id: 'flex',
    min: 13,
    resetStack: true
  }, {
    id: 'hflex1',
    min: 9,
    resetStack: true
  }, {
    id: 'flex1',
    min: 11,
    resetStack: true
  }];
  function CFFParser(file, properties, seacAnalysisEnabled) {
    this.bytes = file.getBytes();
    this.properties = properties;
    this.seacAnalysisEnabled = !!seacAnalysisEnabled;
  }
  CFFParser.prototype = {
    parse: function CFFParser_parse() {
      var properties = this.properties;
      var cff = new CFF();
      this.cff = cff;
      var header = this.parseHeader();
      var nameIndex = this.parseIndex(header.endPos);
      var topDictIndex = this.parseIndex(nameIndex.endPos);
      var stringIndex = this.parseIndex(topDictIndex.endPos);
      var globalSubrIndex = this.parseIndex(stringIndex.endPos);
      var topDictParsed = this.parseDict(topDictIndex.obj.get(0));
      var topDict = this.createDict(CFFTopDict, topDictParsed, cff.strings);
      cff.header = header.obj;
      cff.names = this.parseNameIndex(nameIndex.obj);
      cff.strings = this.parseStringIndex(stringIndex.obj);
      cff.topDict = topDict;
      cff.globalSubrIndex = globalSubrIndex.obj;
      this.parsePrivateDict(cff.topDict);
      cff.isCIDFont = topDict.hasName('ROS');
      var charStringOffset = topDict.getByName('CharStrings');
      var charStringIndex = this.parseIndex(charStringOffset).obj;
      var fontMatrix = topDict.getByName('FontMatrix');
      if (fontMatrix) {
        properties.fontMatrix = fontMatrix;
      }
      var fontBBox = topDict.getByName('FontBBox');
      if (fontBBox) {
        properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
        properties.descent = Math.min(fontBBox[1], fontBBox[3]);
        properties.ascentScaled = true;
      }
      var charset, encoding;
      if (cff.isCIDFont) {
        var fdArrayIndex = this.parseIndex(topDict.getByName('FDArray')).obj;
        for (var i = 0, ii = fdArrayIndex.count; i < ii; ++i) {
          var dictRaw = fdArrayIndex.get(i);
          var fontDict = this.createDict(CFFTopDict, this.parseDict(dictRaw), cff.strings);
          this.parsePrivateDict(fontDict);
          cff.fdArray.push(fontDict);
        }
        encoding = null;
        charset = this.parseCharsets(topDict.getByName('charset'), charStringIndex.count, cff.strings, true);
        cff.fdSelect = this.parseFDSelect(topDict.getByName('FDSelect'), charStringIndex.count);
      } else {
        charset = this.parseCharsets(topDict.getByName('charset'), charStringIndex.count, cff.strings, false);
        encoding = this.parseEncoding(topDict.getByName('Encoding'), properties, cff.strings, charset.charset);
      }
      cff.charset = charset;
      cff.encoding = encoding;
      var charStringsAndSeacs = this.parseCharStrings(charStringIndex, topDict.privateDict.subrsIndex, globalSubrIndex.obj, cff.fdSelect, cff.fdArray);
      cff.charStrings = charStringsAndSeacs.charStrings;
      cff.seacs = charStringsAndSeacs.seacs;
      cff.widths = charStringsAndSeacs.widths;
      return cff;
    },
    parseHeader: function CFFParser_parseHeader() {
      var bytes = this.bytes;
      var bytesLength = bytes.length;
      var offset = 0;
      while (offset < bytesLength && bytes[offset] !== 1) {
        ++offset;
      }
      if (offset >= bytesLength) {
        error('Invalid CFF header');
      } else if (offset !== 0) {
        info('cff data is shifted');
        bytes = bytes.subarray(offset);
        this.bytes = bytes;
      }
      var major = bytes[0];
      var minor = bytes[1];
      var hdrSize = bytes[2];
      var offSize = bytes[3];
      var header = new CFFHeader(major, minor, hdrSize, offSize);
      return {
        obj: header,
        endPos: hdrSize
      };
    },
    parseDict: function CFFParser_parseDict(dict) {
      var pos = 0;
      function parseOperand() {
        var value = dict[pos++];
        if (value === 30) {
          return parseFloatOperand();
        } else if (value === 28) {
          value = dict[pos++];
          value = (value << 24 | dict[pos++] << 16) >> 16;
          return value;
        } else if (value === 29) {
          value = dict[pos++];
          value = value << 8 | dict[pos++];
          value = value << 8 | dict[pos++];
          value = value << 8 | dict[pos++];
          return value;
        } else if (value >= 32 && value <= 246) {
          return value - 139;
        } else if (value >= 247 && value <= 250) {
          return (value - 247) * 256 + dict[pos++] + 108;
        } else if (value >= 251 && value <= 254) {
          return -((value - 251) * 256) - dict[pos++] - 108;
        }
        warn('CFFParser_parseDict: "' + value + '" is a reserved command.');
        return NaN;
      }
      function parseFloatOperand() {
        var str = '';
        var eof = 15;
        var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
        var length = dict.length;
        while (pos < length) {
          var b = dict[pos++];
          var b1 = b >> 4;
          var b2 = b & 15;
          if (b1 === eof) {
            break;
          }
          str += lookup[b1];
          if (b2 === eof) {
            break;
          }
          str += lookup[b2];
        }
        return parseFloat(str);
      }
      var operands = [];
      var entries = [];
      pos = 0;
      var end = dict.length;
      while (pos < end) {
        var b = dict[pos];
        if (b <= 21) {
          if (b === 12) {
            b = b << 8 | dict[++pos];
          }
          entries.push([b, operands]);
          operands = [];
          ++pos;
        } else {
          operands.push(parseOperand());
        }
      }
      return entries;
    },
    parseIndex: function CFFParser_parseIndex(pos) {
      var cffIndex = new CFFIndex();
      var bytes = this.bytes;
      var count = bytes[pos++] << 8 | bytes[pos++];
      var offsets = [];
      var end = pos;
      var i, ii;
      if (count !== 0) {
        var offsetSize = bytes[pos++];
        var startPos = pos + (count + 1) * offsetSize - 1;
        for (i = 0, ii = count + 1; i < ii; ++i) {
          var offset = 0;
          for (var j = 0; j < offsetSize; ++j) {
            offset <<= 8;
            offset += bytes[pos++];
          }
          offsets.push(startPos + offset);
        }
        end = offsets[count];
      }
      for (i = 0, ii = offsets.length - 1; i < ii; ++i) {
        var offsetStart = offsets[i];
        var offsetEnd = offsets[i + 1];
        cffIndex.add(bytes.subarray(offsetStart, offsetEnd));
      }
      return {
        obj: cffIndex,
        endPos: end
      };
    },
    parseNameIndex: function CFFParser_parseNameIndex(index) {
      var names = [];
      for (var i = 0, ii = index.count; i < ii; ++i) {
        var name = index.get(i);
        var length = Math.min(name.length, 127);
        var data = [];
        for (var j = 0; j < length; ++j) {
          var c = name[j];
          if (j === 0 && c === 0) {
            data[j] = c;
            continue;
          }
          if (c < 33 || c > 126 || c === 91 || c === 93 || c === 40 || c === 41 || c === 123 || c === 125 || c === 60 || c === 62 || c === 47 || c === 37 || c === 35) {
            data[j] = 95;
            continue;
          }
          data[j] = c;
        }
        names.push(bytesToString(data));
      }
      return names;
    },
    parseStringIndex: function CFFParser_parseStringIndex(index) {
      var strings = new CFFStrings();
      for (var i = 0, ii = index.count; i < ii; ++i) {
        var data = index.get(i);
        strings.add(bytesToString(data));
      }
      return strings;
    },
    createDict: function CFFParser_createDict(Type, dict, strings) {
      var cffDict = new Type(strings);
      for (var i = 0, ii = dict.length; i < ii; ++i) {
        var pair = dict[i];
        var key = pair[0];
        var value = pair[1];
        cffDict.setByKey(key, value);
      }
      return cffDict;
    },
    parseCharString: function CFFParser_parseCharString(state, data, localSubrIndex, globalSubrIndex) {
      if (!data || state.callDepth > MAX_SUBR_NESTING) {
        return false;
      }
      var stackSize = state.stackSize;
      var stack = state.stack;
      var length = data.length;
      for (var j = 0; j < length;) {
        var value = data[j++];
        var validationCommand = null;
        if (value === 12) {
          var q = data[j++];
          if (q === 0) {
            data[j - 2] = 139;
            data[j - 1] = 22;
            stackSize = 0;
          } else {
            validationCommand = CharstringValidationData12[q];
          }
        } else if (value === 28) {
          stack[stackSize] = (data[j] << 24 | data[j + 1] << 16) >> 16;
          j += 2;
          stackSize++;
        } else if (value === 14) {
          if (stackSize >= 4) {
            stackSize -= 4;
            if (this.seacAnalysisEnabled) {
              state.seac = stack.slice(stackSize, stackSize + 4);
              return false;
            }
          }
          validationCommand = CharstringValidationData[value];
        } else if (value >= 32 && value <= 246) {
          stack[stackSize] = value - 139;
          stackSize++;
        } else if (value >= 247 && value <= 254) {
          stack[stackSize] = value < 251 ? (value - 247 << 8) + data[j] + 108 : -(value - 251 << 8) - data[j] - 108;
          j++;
          stackSize++;
        } else if (value === 255) {
          stack[stackSize] = (data[j] << 24 | data[j + 1] << 16 | data[j + 2] << 8 | data[j + 3]) / 65536;
          j += 4;
          stackSize++;
        } else if (value === 19 || value === 20) {
          state.hints += stackSize >> 1;
          j += state.hints + 7 >> 3;
          stackSize %= 2;
          validationCommand = CharstringValidationData[value];
        } else if (value === 10 || value === 29) {
          var subrsIndex;
          if (value === 10) {
            subrsIndex = localSubrIndex;
          } else {
            subrsIndex = globalSubrIndex;
          }
          if (!subrsIndex) {
            validationCommand = CharstringValidationData[value];
            warn('Missing subrsIndex for ' + validationCommand.id);
            return false;
          }
          var bias = 32768;
          if (subrsIndex.count < 1240) {
            bias = 107;
          } else if (subrsIndex.count < 33900) {
            bias = 1131;
          }
          var subrNumber = stack[--stackSize] + bias;
          if (subrNumber < 0 || subrNumber >= subrsIndex.count || isNaN(subrNumber)) {
            validationCommand = CharstringValidationData[value];
            warn('Out of bounds subrIndex for ' + validationCommand.id);
            return false;
          }
          state.stackSize = stackSize;
          state.callDepth++;
          var valid = this.parseCharString(state, subrsIndex.get(subrNumber), localSubrIndex, globalSubrIndex);
          if (!valid) {
            return false;
          }
          state.callDepth--;
          stackSize = state.stackSize;
          continue;
        } else if (value === 11) {
          state.stackSize = stackSize;
          return true;
        } else {
          validationCommand = CharstringValidationData[value];
        }
        if (validationCommand) {
          if (validationCommand.stem) {
            state.hints += stackSize >> 1;
          }
          if ('min' in validationCommand) {
            if (!state.undefStack && stackSize < validationCommand.min) {
              warn('Not enough parameters for ' + validationCommand.id + '; actual: ' + stackSize + ', expected: ' + validationCommand.min);
              return false;
            }
          }
          if (state.firstStackClearing && validationCommand.stackClearing) {
            state.firstStackClearing = false;
            stackSize -= validationCommand.min;
            if (stackSize >= 2 && validationCommand.stem) {
              stackSize %= 2;
            } else if (stackSize > 1) {
              warn('Found too many parameters for stack-clearing command');
            }
            if (stackSize > 0 && stack[stackSize - 1] >= 0) {
              state.width = stack[stackSize - 1];
            }
          }
          if ('stackDelta' in validationCommand) {
            if ('stackFn' in validationCommand) {
              validationCommand.stackFn(stack, stackSize);
            }
            stackSize += validationCommand.stackDelta;
          } else if (validationCommand.stackClearing) {
            stackSize = 0;
          } else if (validationCommand.resetStack) {
            stackSize = 0;
            state.undefStack = false;
          } else if (validationCommand.undefStack) {
            stackSize = 0;
            state.undefStack = true;
            state.firstStackClearing = false;
          }
        }
      }
      state.stackSize = stackSize;
      return true;
    },
    parseCharStrings: function CFFParser_parseCharStrings(charStrings, localSubrIndex, globalSubrIndex, fdSelect, fdArray) {
      var seacs = [];
      var widths = [];
      var count = charStrings.count;
      for (var i = 0; i < count; i++) {
        var charstring = charStrings.get(i);
        var state = {
          callDepth: 0,
          stackSize: 0,
          stack: [],
          undefStack: true,
          hints: 0,
          firstStackClearing: true,
          seac: null,
          width: null
        };
        var valid = true;
        var localSubrToUse = null;
        if (fdSelect && fdArray.length) {
          var fdIndex = fdSelect.getFDIndex(i);
          if (fdIndex === -1) {
            warn('Glyph index is not in fd select.');
            valid = false;
          }
          if (fdIndex >= fdArray.length) {
            warn('Invalid fd index for glyph index.');
            valid = false;
          }
          if (valid) {
            localSubrToUse = fdArray[fdIndex].privateDict.subrsIndex;
          }
        } else if (localSubrIndex) {
          localSubrToUse = localSubrIndex;
        }
        if (valid) {
          valid = this.parseCharString(state, charstring, localSubrToUse, globalSubrIndex);
        }
        if (state.width !== null) {
          widths[i] = state.width;
        }
        if (state.seac !== null) {
          seacs[i] = state.seac;
        }
        if (!valid) {
          charStrings.set(i, new Uint8Array([14]));
        }
      }
      return {
        charStrings: charStrings,
        seacs: seacs,
        widths: widths
      };
    },
    emptyPrivateDictionary: function CFFParser_emptyPrivateDictionary(parentDict) {
      var privateDict = this.createDict(CFFPrivateDict, [], parentDict.strings);
      parentDict.setByKey(18, [0, 0]);
      parentDict.privateDict = privateDict;
    },
    parsePrivateDict: function CFFParser_parsePrivateDict(parentDict) {
      if (!parentDict.hasName('Private')) {
        this.emptyPrivateDictionary(parentDict);
        return;
      }
      var privateOffset = parentDict.getByName('Private');
      if (!isArray(privateOffset) || privateOffset.length !== 2) {
        parentDict.removeByName('Private');
        return;
      }
      var size = privateOffset[0];
      var offset = privateOffset[1];
      if (size === 0 || offset >= this.bytes.length) {
        this.emptyPrivateDictionary(parentDict);
        return;
      }
      var privateDictEnd = offset + size;
      var dictData = this.bytes.subarray(offset, privateDictEnd);
      var dict = this.parseDict(dictData);
      var privateDict = this.createDict(CFFPrivateDict, dict, parentDict.strings);
      parentDict.privateDict = privateDict;
      if (!privateDict.getByName('Subrs')) {
        return;
      }
      var subrsOffset = privateDict.getByName('Subrs');
      var relativeOffset = offset + subrsOffset;
      if (subrsOffset === 0 || relativeOffset >= this.bytes.length) {
        this.emptyPrivateDictionary(parentDict);
        return;
      }
      var subrsIndex = this.parseIndex(relativeOffset);
      privateDict.subrsIndex = subrsIndex.obj;
    },
    parseCharsets: function CFFParser_parseCharsets(pos, length, strings, cid) {
      if (pos === 0) {
        return new CFFCharset(true, CFFCharsetPredefinedTypes.ISO_ADOBE, ISOAdobeCharset);
      } else if (pos === 1) {
        return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT, ExpertCharset);
      } else if (pos === 2) {
        return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT_SUBSET, ExpertSubsetCharset);
      }
      var bytes = this.bytes;
      var start = pos;
      var format = bytes[pos++];
      var charset = ['.notdef'];
      var id, count, i;
      length -= 1;
      switch (format) {
        case 0:
          for (i = 0; i < length; i++) {
            id = bytes[pos++] << 8 | bytes[pos++];
            charset.push(cid ? id : strings.get(id));
          }
          break;
        case 1:
          while (charset.length <= length) {
            id = bytes[pos++] << 8 | bytes[pos++];
            count = bytes[pos++];
            for (i = 0; i <= count; i++) {
              charset.push(cid ? id++ : strings.get(id++));
            }
          }
          break;
        case 2:
          while (charset.length <= length) {
            id = bytes[pos++] << 8 | bytes[pos++];
            count = bytes[pos++] << 8 | bytes[pos++];
            for (i = 0; i <= count; i++) {
              charset.push(cid ? id++ : strings.get(id++));
            }
          }
          break;
        default:
          error('Unknown charset format');
      }
      var end = pos;
      var raw = bytes.subarray(start, end);
      return new CFFCharset(false, format, charset, raw);
    },
    parseEncoding: function CFFParser_parseEncoding(pos, properties, strings, charset) {
      var encoding = Object.create(null);
      var bytes = this.bytes;
      var predefined = false;
      var format, i, ii;
      var raw = null;
      function readSupplement() {
        var supplementsCount = bytes[pos++];
        for (i = 0; i < supplementsCount; i++) {
          var code = bytes[pos++];
          var sid = (bytes[pos++] << 8) + (bytes[pos++] & 0xff);
          encoding[code] = charset.indexOf(strings.get(sid));
        }
      }
      if (pos === 0 || pos === 1) {
        predefined = true;
        format = pos;
        var baseEncoding = pos ? ExpertEncoding : StandardEncoding;
        for (i = 0, ii = charset.length; i < ii; i++) {
          var index = baseEncoding.indexOf(charset[i]);
          if (index !== -1) {
            encoding[index] = i;
          }
        }
      } else {
        var dataStart = pos;
        format = bytes[pos++];
        switch (format & 0x7f) {
          case 0:
            var glyphsCount = bytes[pos++];
            for (i = 1; i <= glyphsCount; i++) {
              encoding[bytes[pos++]] = i;
            }
            break;
          case 1:
            var rangesCount = bytes[pos++];
            var gid = 1;
            for (i = 0; i < rangesCount; i++) {
              var start = bytes[pos++];
              var left = bytes[pos++];
              for (var j = start; j <= start + left; j++) {
                encoding[j] = gid++;
              }
            }
            break;
          default:
            error('Unknown encoding format: ' + format + ' in CFF');
            break;
        }
        var dataEnd = pos;
        if (format & 0x80) {
          bytes[dataStart] &= 0x7f;
          readSupplement();
        }
        raw = bytes.subarray(dataStart, dataEnd);
      }
      format = format & 0x7f;
      return new CFFEncoding(predefined, format, encoding, raw);
    },
    parseFDSelect: function CFFParser_parseFDSelect(pos, length) {
      var start = pos;
      var bytes = this.bytes;
      var format = bytes[pos++];
      var fdSelect = [],
          rawBytes;
      var i,
          invalidFirstGID = false;
      switch (format) {
        case 0:
          for (i = 0; i < length; ++i) {
            var id = bytes[pos++];
            fdSelect.push(id);
          }
          rawBytes = bytes.subarray(start, pos);
          break;
        case 3:
          var rangesCount = bytes[pos++] << 8 | bytes[pos++];
          for (i = 0; i < rangesCount; ++i) {
            var first = bytes[pos++] << 8 | bytes[pos++];
            if (i === 0 && first !== 0) {
              warn('parseFDSelect: The first range must have a first GID of 0' + ' -- trying to recover.');
              invalidFirstGID = true;
              first = 0;
            }
            var fdIndex = bytes[pos++];
            var next = bytes[pos] << 8 | bytes[pos + 1];
            for (var j = first; j < next; ++j) {
              fdSelect.push(fdIndex);
            }
          }
          pos += 2;
          rawBytes = bytes.subarray(start, pos);
          if (invalidFirstGID) {
            rawBytes[3] = rawBytes[4] = 0;
          }
          break;
        default:
          error('parseFDSelect: Unknown format "' + format + '".');
          break;
      }
      assert(fdSelect.length === length, 'parseFDSelect: Invalid font data.');
      return new CFFFDSelect(fdSelect, rawBytes);
    }
  };
  return CFFParser;
}();
var CFF = function CFFClosure() {
  function CFF() {
    this.header = null;
    this.names = [];
    this.topDict = null;
    this.strings = new CFFStrings();
    this.globalSubrIndex = null;
    this.encoding = null;
    this.charset = null;
    this.charStrings = null;
    this.fdArray = [];
    this.fdSelect = null;
    this.isCIDFont = false;
  }
  return CFF;
}();
var CFFHeader = function CFFHeaderClosure() {
  function CFFHeader(major, minor, hdrSize, offSize) {
    this.major = major;
    this.minor = minor;
    this.hdrSize = hdrSize;
    this.offSize = offSize;
  }
  return CFFHeader;
}();
var CFFStrings = function CFFStringsClosure() {
  function CFFStrings() {
    this.strings = [];
  }
  CFFStrings.prototype = {
    get: function CFFStrings_get(index) {
      if (index >= 0 && index <= 390) {
        return CFFStandardStrings[index];
      }
      if (index - 391 <= this.strings.length) {
        return this.strings[index - 391];
      }
      return CFFStandardStrings[0];
    },
    add: function CFFStrings_add(value) {
      this.strings.push(value);
    },
    get count() {
      return this.strings.length;
    }
  };
  return CFFStrings;
}();
var CFFIndex = function CFFIndexClosure() {
  function CFFIndex() {
    this.objects = [];
    this.length = 0;
  }
  CFFIndex.prototype = {
    add: function CFFIndex_add(data) {
      this.length += data.length;
      this.objects.push(data);
    },
    set: function CFFIndex_set(index, data) {
      this.length += data.length - this.objects[index].length;
      this.objects[index] = data;
    },
    get: function CFFIndex_get(index) {
      return this.objects[index];
    },
    get count() {
      return this.objects.length;
    }
  };
  return CFFIndex;
}();
var CFFDict = function CFFDictClosure() {
  function CFFDict(tables, strings) {
    this.keyToNameMap = tables.keyToNameMap;
    this.nameToKeyMap = tables.nameToKeyMap;
    this.defaults = tables.defaults;
    this.types = tables.types;
    this.opcodes = tables.opcodes;
    this.order = tables.order;
    this.strings = strings;
    this.values = Object.create(null);
  }
  CFFDict.prototype = {
    setByKey: function CFFDict_setByKey(key, value) {
      if (!(key in this.keyToNameMap)) {
        return false;
      }
      var valueLength = value.length;
      if (valueLength === 0) {
        return true;
      }
      for (var i = 0; i < valueLength; i++) {
        if (isNaN(value[i])) {
          warn('Invalid CFFDict value: "' + value + '" for key "' + key + '".');
          return true;
        }
      }
      var type = this.types[key];
      if (type === 'num' || type === 'sid' || type === 'offset') {
        value = value[0];
      }
      this.values[key] = value;
      return true;
    },
    setByName: function CFFDict_setByName(name, value) {
      if (!(name in this.nameToKeyMap)) {
        error('Invalid dictionary name "' + name + '"');
      }
      this.values[this.nameToKeyMap[name]] = value;
    },
    hasName: function CFFDict_hasName(name) {
      return this.nameToKeyMap[name] in this.values;
    },
    getByName: function CFFDict_getByName(name) {
      if (!(name in this.nameToKeyMap)) {
        error('Invalid dictionary name "' + name + '"');
      }
      var key = this.nameToKeyMap[name];
      if (!(key in this.values)) {
        return this.defaults[key];
      }
      return this.values[key];
    },
    removeByName: function CFFDict_removeByName(name) {
      delete this.values[this.nameToKeyMap[name]];
    }
  };
  CFFDict.createTables = function CFFDict_createTables(layout) {
    var tables = {
      keyToNameMap: {},
      nameToKeyMap: {},
      defaults: {},
      types: {},
      opcodes: {},
      order: []
    };
    for (var i = 0, ii = layout.length; i < ii; ++i) {
      var entry = layout[i];
      var key = isArray(entry[0]) ? (entry[0][0] << 8) + entry[0][1] : entry[0];
      tables.keyToNameMap[key] = entry[1];
      tables.nameToKeyMap[entry[1]] = key;
      tables.types[key] = entry[2];
      tables.defaults[key] = entry[3];
      tables.opcodes[key] = isArray(entry[0]) ? entry[0] : [entry[0]];
      tables.order.push(key);
    }
    return tables;
  };
  return CFFDict;
}();
var CFFTopDict = function CFFTopDictClosure() {
  var layout = [[[12, 30], 'ROS', ['sid', 'sid', 'num'], null], [[12, 20], 'SyntheticBase', 'num', null], [0, 'version', 'sid', null], [1, 'Notice', 'sid', null], [[12, 0], 'Copyright', 'sid', null], [2, 'FullName', 'sid', null], [3, 'FamilyName', 'sid', null], [4, 'Weight', 'sid', null], [[12, 1], 'isFixedPitch', 'num', 0], [[12, 2], 'ItalicAngle', 'num', 0], [[12, 3], 'UnderlinePosition', 'num', -100], [[12, 4], 'UnderlineThickness', 'num', 50], [[12, 5], 'PaintType', 'num', 0], [[12, 6], 'CharstringType', 'num', 2], [[12, 7], 'FontMatrix', ['num', 'num', 'num', 'num', 'num', 'num'], [0.001, 0, 0, 0.001, 0, 0]], [13, 'UniqueID', 'num', null], [5, 'FontBBox', ['num', 'num', 'num', 'num'], [0, 0, 0, 0]], [[12, 8], 'StrokeWidth', 'num', 0], [14, 'XUID', 'array', null], [15, 'charset', 'offset', 0], [16, 'Encoding', 'offset', 0], [17, 'CharStrings', 'offset', 0], [18, 'Private', ['offset', 'offset'], null], [[12, 21], 'PostScript', 'sid', null], [[12, 22], 'BaseFontName', 'sid', null], [[12, 23], 'BaseFontBlend', 'delta', null], [[12, 31], 'CIDFontVersion', 'num', 0], [[12, 32], 'CIDFontRevision', 'num', 0], [[12, 33], 'CIDFontType', 'num', 0], [[12, 34], 'CIDCount', 'num', 8720], [[12, 35], 'UIDBase', 'num', null], [[12, 37], 'FDSelect', 'offset', null], [[12, 36], 'FDArray', 'offset', null], [[12, 38], 'FontName', 'sid', null]];
  var tables = null;
  function CFFTopDict(strings) {
    if (tables === null) {
      tables = CFFDict.createTables(layout);
    }
    CFFDict.call(this, tables, strings);
    this.privateDict = null;
  }
  CFFTopDict.prototype = Object.create(CFFDict.prototype);
  return CFFTopDict;
}();
var CFFPrivateDict = function CFFPrivateDictClosure() {
  var layout = [[6, 'BlueValues', 'delta', null], [7, 'OtherBlues', 'delta', null], [8, 'FamilyBlues', 'delta', null], [9, 'FamilyOtherBlues', 'delta', null], [[12, 9], 'BlueScale', 'num', 0.039625], [[12, 10], 'BlueShift', 'num', 7], [[12, 11], 'BlueFuzz', 'num', 1], [10, 'StdHW', 'num', null], [11, 'StdVW', 'num', null], [[12, 12], 'StemSnapH', 'delta', null], [[12, 13], 'StemSnapV', 'delta', null], [[12, 14], 'ForceBold', 'num', 0], [[12, 17], 'LanguageGroup', 'num', 0], [[12, 18], 'ExpansionFactor', 'num', 0.06], [[12, 19], 'initialRandomSeed', 'num', 0], [20, 'defaultWidthX', 'num', 0], [21, 'nominalWidthX', 'num', 0], [19, 'Subrs', 'offset', null]];
  var tables = null;
  function CFFPrivateDict(strings) {
    if (tables === null) {
      tables = CFFDict.createTables(layout);
    }
    CFFDict.call(this, tables, strings);
    this.subrsIndex = null;
  }
  CFFPrivateDict.prototype = Object.create(CFFDict.prototype);
  return CFFPrivateDict;
}();
var CFFCharsetPredefinedTypes = {
  ISO_ADOBE: 0,
  EXPERT: 1,
  EXPERT_SUBSET: 2
};
var CFFCharset = function CFFCharsetClosure() {
  function CFFCharset(predefined, format, charset, raw) {
    this.predefined = predefined;
    this.format = format;
    this.charset = charset;
    this.raw = raw;
  }
  return CFFCharset;
}();
var CFFEncoding = function CFFEncodingClosure() {
  function CFFEncoding(predefined, format, encoding, raw) {
    this.predefined = predefined;
    this.format = format;
    this.encoding = encoding;
    this.raw = raw;
  }
  return CFFEncoding;
}();
var CFFFDSelect = function CFFFDSelectClosure() {
  function CFFFDSelect(fdSelect, raw) {
    this.fdSelect = fdSelect;
    this.raw = raw;
  }
  CFFFDSelect.prototype = {
    getFDIndex: function CFFFDSelect_get(glyphIndex) {
      if (glyphIndex < 0 || glyphIndex >= this.fdSelect.length) {
        return -1;
      }
      return this.fdSelect[glyphIndex];
    }
  };
  return CFFFDSelect;
}();
var CFFOffsetTracker = function CFFOffsetTrackerClosure() {
  function CFFOffsetTracker() {
    this.offsets = Object.create(null);
  }
  CFFOffsetTracker.prototype = {
    isTracking: function CFFOffsetTracker_isTracking(key) {
      return key in this.offsets;
    },
    track: function CFFOffsetTracker_track(key, location) {
      if (key in this.offsets) {
        error('Already tracking location of ' + key);
      }
      this.offsets[key] = location;
    },
    offset: function CFFOffsetTracker_offset(value) {
      for (var key in this.offsets) {
        this.offsets[key] += value;
      }
    },
    setEntryLocation: function CFFOffsetTracker_setEntryLocation(key, values, output) {
      if (!(key in this.offsets)) {
        error('Not tracking location of ' + key);
      }
      var data = output.data;
      var dataOffset = this.offsets[key];
      var size = 5;
      for (var i = 0, ii = values.length; i < ii; ++i) {
        var offset0 = i * size + dataOffset;
        var offset1 = offset0 + 1;
        var offset2 = offset0 + 2;
        var offset3 = offset0 + 3;
        var offset4 = offset0 + 4;
        if (data[offset0] !== 0x1d || data[offset1] !== 0 || data[offset2] !== 0 || data[offset3] !== 0 || data[offset4] !== 0) {
          error('writing to an offset that is not empty');
        }
        var value = values[i];
        data[offset0] = 0x1d;
        data[offset1] = value >> 24 & 0xFF;
        data[offset2] = value >> 16 & 0xFF;
        data[offset3] = value >> 8 & 0xFF;
        data[offset4] = value & 0xFF;
      }
    }
  };
  return CFFOffsetTracker;
}();
var CFFCompiler = function CFFCompilerClosure() {
  function CFFCompiler(cff) {
    this.cff = cff;
  }
  CFFCompiler.prototype = {
    compile: function CFFCompiler_compile() {
      var cff = this.cff;
      var output = {
        data: [],
        length: 0,
        add: function CFFCompiler_add(data) {
          this.data = this.data.concat(data);
          this.length = this.data.length;
        }
      };
      var header = this.compileHeader(cff.header);
      output.add(header);
      var nameIndex = this.compileNameIndex(cff.names);
      output.add(nameIndex);
      if (cff.isCIDFont) {
        if (cff.topDict.hasName('FontMatrix')) {
          var base = cff.topDict.getByName('FontMatrix');
          cff.topDict.removeByName('FontMatrix');
          for (var i = 0, ii = cff.fdArray.length; i < ii; i++) {
            var subDict = cff.fdArray[i];
            var matrix = base.slice(0);
            if (subDict.hasName('FontMatrix')) {
              matrix = Util.transform(matrix, subDict.getByName('FontMatrix'));
            }
            subDict.setByName('FontMatrix', matrix);
          }
        }
      }
      var compiled = this.compileTopDicts([cff.topDict], output.length, cff.isCIDFont);
      output.add(compiled.output);
      var topDictTracker = compiled.trackers[0];
      var stringIndex = this.compileStringIndex(cff.strings.strings);
      output.add(stringIndex);
      var globalSubrIndex = this.compileIndex(cff.globalSubrIndex);
      output.add(globalSubrIndex);
      if (cff.encoding && cff.topDict.hasName('Encoding')) {
        if (cff.encoding.predefined) {
          topDictTracker.setEntryLocation('Encoding', [cff.encoding.format], output);
        } else {
          var encoding = this.compileEncoding(cff.encoding);
          topDictTracker.setEntryLocation('Encoding', [output.length], output);
          output.add(encoding);
        }
      }
      if (cff.charset && cff.topDict.hasName('charset')) {
        if (cff.charset.predefined) {
          topDictTracker.setEntryLocation('charset', [cff.charset.format], output);
        } else {
          var charset = this.compileCharset(cff.charset);
          topDictTracker.setEntryLocation('charset', [output.length], output);
          output.add(charset);
        }
      }
      var charStrings = this.compileCharStrings(cff.charStrings);
      topDictTracker.setEntryLocation('CharStrings', [output.length], output);
      output.add(charStrings);
      if (cff.isCIDFont) {
        topDictTracker.setEntryLocation('FDSelect', [output.length], output);
        var fdSelect = this.compileFDSelect(cff.fdSelect.raw);
        output.add(fdSelect);
        compiled = this.compileTopDicts(cff.fdArray, output.length, true);
        topDictTracker.setEntryLocation('FDArray', [output.length], output);
        output.add(compiled.output);
        var fontDictTrackers = compiled.trackers;
        this.compilePrivateDicts(cff.fdArray, fontDictTrackers, output);
      }
      this.compilePrivateDicts([cff.topDict], [topDictTracker], output);
      output.add([0]);
      return output.data;
    },
    encodeNumber: function CFFCompiler_encodeNumber(value) {
      if (parseFloat(value) === parseInt(value, 10) && !isNaN(value)) {
        return this.encodeInteger(value);
      }
      return this.encodeFloat(value);
    },
    encodeFloat: function CFFCompiler_encodeFloat(num) {
      var value = num.toString();
      var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
      if (m) {
        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));
        value = (Math.round(num * epsilon) / epsilon).toString();
      }
      var nibbles = '';
      var i, ii;
      for (i = 0, ii = value.length; i < ii; ++i) {
        var a = value[i];
        if (a === 'e') {
          nibbles += value[++i] === '-' ? 'c' : 'b';
        } else if (a === '.') {
          nibbles += 'a';
        } else if (a === '-') {
          nibbles += 'e';
        } else {
          nibbles += a;
        }
      }
      nibbles += nibbles.length & 1 ? 'f' : 'ff';
      var out = [30];
      for (i = 0, ii = nibbles.length; i < ii; i += 2) {
        out.push(parseInt(nibbles.substr(i, 2), 16));
      }
      return out;
    },
    encodeInteger: function CFFCompiler_encodeInteger(value) {
      var code;
      if (value >= -107 && value <= 107) {
        code = [value + 139];
      } else if (value >= 108 && value <= 1131) {
        value = value - 108;
        code = [(value >> 8) + 247, value & 0xFF];
      } else if (value >= -1131 && value <= -108) {
        value = -value - 108;
        code = [(value >> 8) + 251, value & 0xFF];
      } else if (value >= -32768 && value <= 32767) {
        code = [0x1c, value >> 8 & 0xFF, value & 0xFF];
      } else {
        code = [0x1d, value >> 24 & 0xFF, value >> 16 & 0xFF, value >> 8 & 0xFF, value & 0xFF];
      }
      return code;
    },
    compileHeader: function CFFCompiler_compileHeader(header) {
      return [header.major, header.minor, header.hdrSize, header.offSize];
    },
    compileNameIndex: function CFFCompiler_compileNameIndex(names) {
      var nameIndex = new CFFIndex();
      for (var i = 0, ii = names.length; i < ii; ++i) {
        nameIndex.add(stringToBytes(names[i]));
      }
      return this.compileIndex(nameIndex);
    },
    compileTopDicts: function CFFCompiler_compileTopDicts(dicts, length, removeCidKeys) {
      var fontDictTrackers = [];
      var fdArrayIndex = new CFFIndex();
      for (var i = 0, ii = dicts.length; i < ii; ++i) {
        var fontDict = dicts[i];
        if (removeCidKeys) {
          fontDict.removeByName('CIDFontVersion');
          fontDict.removeByName('CIDFontRevision');
          fontDict.removeByName('CIDFontType');
          fontDict.removeByName('CIDCount');
          fontDict.removeByName('UIDBase');
        }
        var fontDictTracker = new CFFOffsetTracker();
        var fontDictData = this.compileDict(fontDict, fontDictTracker);
        fontDictTrackers.push(fontDictTracker);
        fdArrayIndex.add(fontDictData);
        fontDictTracker.offset(length);
      }
      fdArrayIndex = this.compileIndex(fdArrayIndex, fontDictTrackers);
      return {
        trackers: fontDictTrackers,
        output: fdArrayIndex
      };
    },
    compilePrivateDicts: function CFFCompiler_compilePrivateDicts(dicts, trackers, output) {
      for (var i = 0, ii = dicts.length; i < ii; ++i) {
        var fontDict = dicts[i];
        assert(fontDict.privateDict && fontDict.hasName('Private'), 'There must be an private dictionary.');
        var privateDict = fontDict.privateDict;
        var privateDictTracker = new CFFOffsetTracker();
        var privateDictData = this.compileDict(privateDict, privateDictTracker);
        var outputLength = output.length;
        privateDictTracker.offset(outputLength);
        if (!privateDictData.length) {
          outputLength = 0;
        }
        trackers[i].setEntryLocation('Private', [privateDictData.length, outputLength], output);
        output.add(privateDictData);
        if (privateDict.subrsIndex && privateDict.hasName('Subrs')) {
          var subrs = this.compileIndex(privateDict.subrsIndex);
          privateDictTracker.setEntryLocation('Subrs', [privateDictData.length], output);
          output.add(subrs);
        }
      }
    },
    compileDict: function CFFCompiler_compileDict(dict, offsetTracker) {
      var out = [];
      var order = dict.order;
      for (var i = 0; i < order.length; ++i) {
        var key = order[i];
        if (!(key in dict.values)) {
          continue;
        }
        var values = dict.values[key];
        var types = dict.types[key];
        if (!isArray(types)) {
          types = [types];
        }
        if (!isArray(values)) {
          values = [values];
        }
        if (values.length === 0) {
          continue;
        }
        for (var j = 0, jj = types.length; j < jj; ++j) {
          var type = types[j];
          var value = values[j];
          switch (type) {
            case 'num':
            case 'sid':
              out = out.concat(this.encodeNumber(value));
              break;
            case 'offset':
              var name = dict.keyToNameMap[key];
              if (!offsetTracker.isTracking(name)) {
                offsetTracker.track(name, out.length);
              }
              out = out.concat([0x1d, 0, 0, 0, 0]);
              break;
            case 'array':
            case 'delta':
              out = out.concat(this.encodeNumber(value));
              for (var k = 1, kk = values.length; k < kk; ++k) {
                out = out.concat(this.encodeNumber(values[k]));
              }
              break;
            default:
              error('Unknown data type of ' + type);
              break;
          }
        }
        out = out.concat(dict.opcodes[key]);
      }
      return out;
    },
    compileStringIndex: function CFFCompiler_compileStringIndex(strings) {
      var stringIndex = new CFFIndex();
      for (var i = 0, ii = strings.length; i < ii; ++i) {
        stringIndex.add(stringToBytes(strings[i]));
      }
      return this.compileIndex(stringIndex);
    },
    compileGlobalSubrIndex: function CFFCompiler_compileGlobalSubrIndex() {
      var globalSubrIndex = this.cff.globalSubrIndex;
      this.out.writeByteArray(this.compileIndex(globalSubrIndex));
    },
    compileCharStrings: function CFFCompiler_compileCharStrings(charStrings) {
      return this.compileIndex(charStrings);
    },
    compileCharset: function CFFCompiler_compileCharset(charset) {
      return this.compileTypedArray(charset.raw);
    },
    compileEncoding: function CFFCompiler_compileEncoding(encoding) {
      return this.compileTypedArray(encoding.raw);
    },
    compileFDSelect: function CFFCompiler_compileFDSelect(fdSelect) {
      return this.compileTypedArray(fdSelect);
    },
    compileTypedArray: function CFFCompiler_compileTypedArray(data) {
      var out = [];
      for (var i = 0, ii = data.length; i < ii; ++i) {
        out[i] = data[i];
      }
      return out;
    },
    compileIndex: function CFFCompiler_compileIndex(index, trackers) {
      trackers = trackers || [];
      var objects = index.objects;
      var count = objects.length;
      if (count === 0) {
        return [0, 0, 0];
      }
      var data = [count >> 8 & 0xFF, count & 0xff];
      var lastOffset = 1,
          i;
      for (i = 0; i < count; ++i) {
        lastOffset += objects[i].length;
      }
      var offsetSize;
      if (lastOffset < 0x100) {
        offsetSize = 1;
      } else if (lastOffset < 0x10000) {
        offsetSize = 2;
      } else if (lastOffset < 0x1000000) {
        offsetSize = 3;
      } else {
        offsetSize = 4;
      }
      data.push(offsetSize);
      var relativeOffset = 1;
      for (i = 0; i < count + 1; i++) {
        if (offsetSize === 1) {
          data.push(relativeOffset & 0xFF);
        } else if (offsetSize === 2) {
          data.push(relativeOffset >> 8 & 0xFF, relativeOffset & 0xFF);
        } else if (offsetSize === 3) {
          data.push(relativeOffset >> 16 & 0xFF, relativeOffset >> 8 & 0xFF, relativeOffset & 0xFF);
        } else {
          data.push(relativeOffset >>> 24 & 0xFF, relativeOffset >> 16 & 0xFF, relativeOffset >> 8 & 0xFF, relativeOffset & 0xFF);
        }
        if (objects[i]) {
          relativeOffset += objects[i].length;
        }
      }
      for (i = 0; i < count; i++) {
        if (trackers[i]) {
          trackers[i].offset(data.length);
        }
        for (var j = 0, jj = objects[i].length; j < jj; j++) {
          data.push(objects[i][j]);
        }
      }
      return data;
    }
  };
  return CFFCompiler;
}();
exports.CFFStandardStrings = CFFStandardStrings;
exports.CFFParser = CFFParser;
exports.CFF = CFF;
exports.CFFHeader = CFFHeader;
exports.CFFStrings = CFFStrings;
exports.CFFIndex = CFFIndex;
exports.CFFCharset = CFFCharset;
exports.CFFTopDict = CFFTopDict;
exports.CFFPrivateDict = CFFPrivateDict;
exports.CFFCompiler = CFFCompiler;

/***/ }),
/* 12 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var MissingDataException = sharedUtil.MissingDataException;
var arrayByteLength = sharedUtil.arrayByteLength;
var arraysToBytes = sharedUtil.arraysToBytes;
var assert = sharedUtil.assert;
var createPromiseCapability = sharedUtil.createPromiseCapability;
var isInt = sharedUtil.isInt;
var isEmptyObj = sharedUtil.isEmptyObj;
var ChunkedStream = function ChunkedStreamClosure() {
  function ChunkedStream(length, chunkSize, manager) {
    this.bytes = new Uint8Array(length);
    this.start = 0;
    this.pos = 0;
    this.end = length;
    this.chunkSize = chunkSize;
    this.loadedChunks = [];
    this.numChunksLoaded = 0;
    this.numChunks = Math.ceil(length / chunkSize);
    this.manager = manager;
    this.progressiveDataLength = 0;
    this.lastSuccessfulEnsureByteChunk = -1;
  }
  ChunkedStream.prototype = {
    getMissingChunks: function ChunkedStream_getMissingChunks() {
      var chunks = [];
      for (var chunk = 0, n = this.numChunks; chunk < n; ++chunk) {
        if (!this.loadedChunks[chunk]) {
          chunks.push(chunk);
        }
      }
      return chunks;
    },
    getBaseStreams: function ChunkedStream_getBaseStreams() {
      return [this];
    },
    allChunksLoaded: function ChunkedStream_allChunksLoaded() {
      return this.numChunksLoaded === this.numChunks;
    },
    onReceiveData: function ChunkedStream_onReceiveData(begin, chunk) {
      var end = begin + chunk.byteLength;
      assert(begin % this.chunkSize === 0, 'Bad begin offset: ' + begin);
      var length = this.bytes.length;
      assert(end % this.chunkSize === 0 || end === length, 'Bad end offset: ' + end);
      this.bytes.set(new Uint8Array(chunk), begin);
      var chunkSize = this.chunkSize;
      var beginChunk = Math.floor(begin / chunkSize);
      var endChunk = Math.floor((end - 1) / chunkSize) + 1;
      var curChunk;
      for (curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
        if (!this.loadedChunks[curChunk]) {
          this.loadedChunks[curChunk] = true;
          ++this.numChunksLoaded;
        }
      }
    },
    onReceiveProgressiveData: function ChunkedStream_onReceiveProgressiveData(data) {
      var position = this.progressiveDataLength;
      var beginChunk = Math.floor(position / this.chunkSize);
      this.bytes.set(new Uint8Array(data), position);
      position += data.byteLength;
      this.progressiveDataLength = position;
      var endChunk = position >= this.end ? this.numChunks : Math.floor(position / this.chunkSize);
      var curChunk;
      for (curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
        if (!this.loadedChunks[curChunk]) {
          this.loadedChunks[curChunk] = true;
          ++this.numChunksLoaded;
        }
      }
    },
    ensureByte: function ChunkedStream_ensureByte(pos) {
      var chunk = Math.floor(pos / this.chunkSize);
      if (chunk === this.lastSuccessfulEnsureByteChunk) {
        return;
      }
      if (!this.loadedChunks[chunk]) {
        throw new MissingDataException(pos, pos + 1);
      }
      this.lastSuccessfulEnsureByteChunk = chunk;
    },
    ensureRange: function ChunkedStream_ensureRange(begin, end) {
      if (begin >= end) {
        return;
      }
      if (end <= this.progressiveDataLength) {
        return;
      }
      var chunkSize = this.chunkSize;
      var beginChunk = Math.floor(begin / chunkSize);
      var endChunk = Math.floor((end - 1) / chunkSize) + 1;
      for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
        if (!this.loadedChunks[chunk]) {
          throw new MissingDataException(begin, end);
        }
      }
    },
    nextEmptyChunk: function ChunkedStream_nextEmptyChunk(beginChunk) {
      var chunk,
          numChunks = this.numChunks;
      for (var i = 0; i < numChunks; ++i) {
        chunk = (beginChunk + i) % numChunks;
        if (!this.loadedChunks[chunk]) {
          return chunk;
        }
      }
      return null;
    },
    hasChunk: function ChunkedStream_hasChunk(chunk) {
      return !!this.loadedChunks[chunk];
    },
    get length() {
      return this.end - this.start;
    },
    get isEmpty() {
      return this.length === 0;
    },
    getByte: function ChunkedStream_getByte() {
      var pos = this.pos;
      if (pos >= this.end) {
        return -1;
      }
      this.ensureByte(pos);
      return this.bytes[this.pos++];
    },
    getUint16: function ChunkedStream_getUint16() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      if (b0 === -1 || b1 === -1) {
        return -1;
      }
      return (b0 << 8) + b1;
    },
    getInt32: function ChunkedStream_getInt32() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      var b2 = this.getByte();
      var b3 = this.getByte();
      return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
    },
    getBytes: function ChunkedStream_getBytes(length) {
      var bytes = this.bytes;
      var pos = this.pos;
      var strEnd = this.end;
      if (!length) {
        this.ensureRange(pos, strEnd);
        return bytes.subarray(pos, strEnd);
      }
      var end = pos + length;
      if (end > strEnd) {
        end = strEnd;
      }
      this.ensureRange(pos, end);
      this.pos = end;
      return bytes.subarray(pos, end);
    },
    peekByte: function ChunkedStream_peekByte() {
      var peekedByte = this.getByte();
      this.pos--;
      return peekedByte;
    },
    peekBytes: function ChunkedStream_peekBytes(length) {
      var bytes = this.getBytes(length);
      this.pos -= bytes.length;
      return bytes;
    },
    getByteRange: function ChunkedStream_getBytes(begin, end) {
      this.ensureRange(begin, end);
      return this.bytes.subarray(begin, end);
    },
    skip: function ChunkedStream_skip(n) {
      if (!n) {
        n = 1;
      }
      this.pos += n;
    },
    reset: function ChunkedStream_reset() {
      this.pos = this.start;
    },
    moveStart: function ChunkedStream_moveStart() {
      this.start = this.pos;
    },
    makeSubStream: function ChunkedStream_makeSubStream(start, length, dict) {
      this.ensureRange(start, start + length);
      function ChunkedStreamSubstream() {}
      ChunkedStreamSubstream.prototype = Object.create(this);
      ChunkedStreamSubstream.prototype.getMissingChunks = function () {
        var chunkSize = this.chunkSize;
        var beginChunk = Math.floor(this.start / chunkSize);
        var endChunk = Math.floor((this.end - 1) / chunkSize) + 1;
        var missingChunks = [];
        for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
          if (!this.loadedChunks[chunk]) {
            missingChunks.push(chunk);
          }
        }
        return missingChunks;
      };
      var subStream = new ChunkedStreamSubstream();
      subStream.pos = subStream.start = start;
      subStream.end = start + length || this.end;
      subStream.dict = dict;
      return subStream;
    }
  };
  return ChunkedStream;
}();
var ChunkedStreamManager = function ChunkedStreamManagerClosure() {
  function ChunkedStreamManager(pdfNetworkStream, args) {
    var chunkSize = args.rangeChunkSize;
    var length = args.length;
    this.stream = new ChunkedStream(length, chunkSize, this);
    this.length = length;
    this.chunkSize = chunkSize;
    this.pdfNetworkStream = pdfNetworkStream;
    this.url = args.url;
    this.disableAutoFetch = args.disableAutoFetch;
    this.msgHandler = args.msgHandler;
    this.currRequestId = 0;
    this.chunksNeededByRequest = Object.create(null);
    this.requestsByChunk = Object.create(null);
    this.promisesByRequest = Object.create(null);
    this.progressiveDataLength = 0;
    this.aborted = false;
    this._loadedStreamCapability = createPromiseCapability();
  }
  ChunkedStreamManager.prototype = {
    onLoadedStream: function ChunkedStreamManager_getLoadedStream() {
      return this._loadedStreamCapability.promise;
    },
    sendRequest: function ChunkedStreamManager_sendRequest(begin, end) {
      var rangeReader = this.pdfNetworkStream.getRangeReader(begin, end);
      if (!rangeReader.isStreamingSupported) {
        rangeReader.onProgress = this.onProgress.bind(this);
      }
      var chunks = [],
          loaded = 0;
      var manager = this;
      var promise = new Promise(function (resolve, reject) {
        var readChunk = function readChunk(chunk) {
          try {
            if (!chunk.done) {
              var data = chunk.value;
              chunks.push(data);
              loaded += arrayByteLength(data);
              if (rangeReader.isStreamingSupported) {
                manager.onProgress({ loaded: loaded });
              }
              rangeReader.read().then(readChunk, reject);
              return;
            }
            var chunkData = arraysToBytes(chunks);
            chunks = null;
            resolve(chunkData);
          } catch (e) {
            reject(e);
          }
        };
        rangeReader.read().then(readChunk, reject);
      });
      promise.then(function (data) {
        if (this.aborted) {
          return;
        }
        this.onReceiveData({
          chunk: data,
          begin: begin
        });
      }.bind(this));
    },
    requestAllChunks: function ChunkedStreamManager_requestAllChunks() {
      var missingChunks = this.stream.getMissingChunks();
      this._requestChunks(missingChunks);
      return this._loadedStreamCapability.promise;
    },
    _requestChunks: function ChunkedStreamManager_requestChunks(chunks) {
      var requestId = this.currRequestId++;
      var i, ii;
      var chunksNeeded = Object.create(null);
      this.chunksNeededByRequest[requestId] = chunksNeeded;
      for (i = 0, ii = chunks.length; i < ii; i++) {
        if (!this.stream.hasChunk(chunks[i])) {
          chunksNeeded[chunks[i]] = true;
        }
      }
      if (isEmptyObj(chunksNeeded)) {
        return Promise.resolve();
      }
      var capability = createPromiseCapability();
      this.promisesByRequest[requestId] = capability;
      var chunksToRequest = [];
      for (var chunk in chunksNeeded) {
        chunk = chunk | 0;
        if (!(chunk in this.requestsByChunk)) {
          this.requestsByChunk[chunk] = [];
          chunksToRequest.push(chunk);
        }
        this.requestsByChunk[chunk].push(requestId);
      }
      if (!chunksToRequest.length) {
        return capability.promise;
      }
      var groupedChunksToRequest = this.groupChunks(chunksToRequest);
      for (i = 0; i < groupedChunksToRequest.length; ++i) {
        var groupedChunk = groupedChunksToRequest[i];
        var begin = groupedChunk.beginChunk * this.chunkSize;
        var end = Math.min(groupedChunk.endChunk * this.chunkSize, this.length);
        this.sendRequest(begin, end);
      }
      return capability.promise;
    },
    getStream: function ChunkedStreamManager_getStream() {
      return this.stream;
    },
    requestRange: function ChunkedStreamManager_requestRange(begin, end) {
      end = Math.min(end, this.length);
      var beginChunk = this.getBeginChunk(begin);
      var endChunk = this.getEndChunk(end);
      var chunks = [];
      for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
        chunks.push(chunk);
      }
      return this._requestChunks(chunks);
    },
    requestRanges: function ChunkedStreamManager_requestRanges(ranges) {
      ranges = ranges || [];
      var chunksToRequest = [];
      for (var i = 0; i < ranges.length; i++) {
        var beginChunk = this.getBeginChunk(ranges[i].begin);
        var endChunk = this.getEndChunk(ranges[i].end);
        for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
          if (chunksToRequest.indexOf(chunk) < 0) {
            chunksToRequest.push(chunk);
          }
        }
      }
      chunksToRequest.sort(function (a, b) {
        return a - b;
      });
      return this._requestChunks(chunksToRequest);
    },
    groupChunks: function ChunkedStreamManager_groupChunks(chunks) {
      var groupedChunks = [];
      var beginChunk = -1;
      var prevChunk = -1;
      for (var i = 0; i < chunks.length; ++i) {
        var chunk = chunks[i];
        if (beginChunk < 0) {
          beginChunk = chunk;
        }
        if (prevChunk >= 0 && prevChunk + 1 !== chunk) {
          groupedChunks.push({
            beginChunk: beginChunk,
            endChunk: prevChunk + 1
          });
          beginChunk = chunk;
        }
        if (i + 1 === chunks.length) {
          groupedChunks.push({
            beginChunk: beginChunk,
            endChunk: chunk + 1
          });
        }
        prevChunk = chunk;
      }
      return groupedChunks;
    },
    onProgress: function ChunkedStreamManager_onProgress(args) {
      var bytesLoaded = this.stream.numChunksLoaded * this.chunkSize + args.loaded;
      this.msgHandler.send('DocProgress', {
        loaded: bytesLoaded,
        total: this.length
      });
    },
    onReceiveData: function ChunkedStreamManager_onReceiveData(args) {
      var chunk = args.chunk;
      var isProgressive = args.begin === undefined;
      var begin = isProgressive ? this.progressiveDataLength : args.begin;
      var end = begin + chunk.byteLength;
      var beginChunk = Math.floor(begin / this.chunkSize);
      var endChunk = end < this.length ? Math.floor(end / this.chunkSize) : Math.ceil(end / this.chunkSize);
      if (isProgressive) {
        this.stream.onReceiveProgressiveData(chunk);
        this.progressiveDataLength = end;
      } else {
        this.stream.onReceiveData(begin, chunk);
      }
      if (this.stream.allChunksLoaded()) {
        this._loadedStreamCapability.resolve(this.stream);
      }
      var loadedRequests = [];
      var i, requestId;
      for (chunk = beginChunk; chunk < endChunk; ++chunk) {
        var requestIds = this.requestsByChunk[chunk] || [];
        delete this.requestsByChunk[chunk];
        for (i = 0; i < requestIds.length; ++i) {
          requestId = requestIds[i];
          var chunksNeeded = this.chunksNeededByRequest[requestId];
          if (chunk in chunksNeeded) {
            delete chunksNeeded[chunk];
          }
          if (!isEmptyObj(chunksNeeded)) {
            continue;
          }
          loadedRequests.push(requestId);
        }
      }
      if (!this.disableAutoFetch && isEmptyObj(this.requestsByChunk)) {
        var nextEmptyChunk;
        if (this.stream.numChunksLoaded === 1) {
          var lastChunk = this.stream.numChunks - 1;
          if (!this.stream.hasChunk(lastChunk)) {
            nextEmptyChunk = lastChunk;
          }
        } else {
          nextEmptyChunk = this.stream.nextEmptyChunk(endChunk);
        }
        if (isInt(nextEmptyChunk)) {
          this._requestChunks([nextEmptyChunk]);
        }
      }
      for (i = 0; i < loadedRequests.length; ++i) {
        requestId = loadedRequests[i];
        var capability = this.promisesByRequest[requestId];
        delete this.promisesByRequest[requestId];
        capability.resolve();
      }
      this.msgHandler.send('DocProgress', {
        loaded: this.stream.numChunksLoaded * this.chunkSize,
        total: this.length
      });
    },
    onError: function ChunkedStreamManager_onError(err) {
      this._loadedStreamCapability.reject(err);
    },
    getBeginChunk: function ChunkedStreamManager_getBeginChunk(begin) {
      var chunk = Math.floor(begin / this.chunkSize);
      return chunk;
    },
    getEndChunk: function ChunkedStreamManager_getEndChunk(end) {
      var chunk = Math.floor((end - 1) / this.chunkSize) + 1;
      return chunk;
    },
    abort: function ChunkedStreamManager_abort() {
      this.aborted = true;
      if (this.pdfNetworkStream) {
        this.pdfNetworkStream.cancelAllRequests('abort');
      }
      for (var requestId in this.promisesByRequest) {
        var capability = this.promisesByRequest[requestId];
        capability.reject(new Error('Request was aborted'));
      }
    }
  };
  return ChunkedStreamManager;
}();
exports.ChunkedStream = ChunkedStream;
exports.ChunkedStreamManager = ChunkedStreamManager;

/***/ }),
/* 13 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var corePrimitives = __w_pdfjs_require__(1);
var coreStream = __w_pdfjs_require__(2);
var PasswordException = sharedUtil.PasswordException;
var PasswordResponses = sharedUtil.PasswordResponses;
var bytesToString = sharedUtil.bytesToString;
var warn = sharedUtil.warn;
var error = sharedUtil.error;
var assert = sharedUtil.assert;
var isInt = sharedUtil.isInt;
var stringToBytes = sharedUtil.stringToBytes;
var utf8StringToString = sharedUtil.utf8StringToString;
var Name = corePrimitives.Name;
var isName = corePrimitives.isName;
var isDict = corePrimitives.isDict;
var DecryptStream = coreStream.DecryptStream;
var ARCFourCipher = function ARCFourCipherClosure() {
  function ARCFourCipher(key) {
    this.a = 0;
    this.b = 0;
    var s = new Uint8Array(256);
    var i,
        j = 0,
        tmp,
        keyLength = key.length;
    for (i = 0; i < 256; ++i) {
      s[i] = i;
    }
    for (i = 0; i < 256; ++i) {
      tmp = s[i];
      j = j + tmp + key[i % keyLength] & 0xFF;
      s[i] = s[j];
      s[j] = tmp;
    }
    this.s = s;
  }
  ARCFourCipher.prototype = {
    encryptBlock: function ARCFourCipher_encryptBlock(data) {
      var i,
          n = data.length,
          tmp,
          tmp2;
      var a = this.a,
          b = this.b,
          s = this.s;
      var output = new Uint8Array(n);
      for (i = 0; i < n; ++i) {
        a = a + 1 & 0xFF;
        tmp = s[a];
        b = b + tmp & 0xFF;
        tmp2 = s[b];
        s[a] = tmp2;
        s[b] = tmp;
        output[i] = data[i] ^ s[tmp + tmp2 & 0xFF];
      }
      this.a = a;
      this.b = b;
      return output;
    }
  };
  ARCFourCipher.prototype.decryptBlock = ARCFourCipher.prototype.encryptBlock;
  return ARCFourCipher;
}();
var calculateMD5 = function calculateMD5Closure() {
  var r = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);
  var k = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
  function hash(data, offset, length) {
    var h0 = 1732584193,
        h1 = -271733879,
        h2 = -1732584194,
        h3 = 271733878;
    var paddedLength = length + 72 & ~63;
    var padded = new Uint8Array(paddedLength);
    var i, j, n;
    for (i = 0; i < length; ++i) {
      padded[i] = data[offset++];
    }
    padded[i++] = 0x80;
    n = paddedLength - 8;
    while (i < n) {
      padded[i++] = 0;
    }
    padded[i++] = length << 3 & 0xFF;
    padded[i++] = length >> 5 & 0xFF;
    padded[i++] = length >> 13 & 0xFF;
    padded[i++] = length >> 21 & 0xFF;
    padded[i++] = length >>> 29 & 0xFF;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    var w = new Int32Array(16);
    for (i = 0; i < paddedLength;) {
      for (j = 0; j < 16; ++j, i += 4) {
        w[j] = padded[i] | padded[i + 1] << 8 | padded[i + 2] << 16 | padded[i + 3] << 24;
      }
      var a = h0,
          b = h1,
          c = h2,
          d = h3,
          f,
          g;
      for (j = 0; j < 64; ++j) {
        if (j < 16) {
          f = b & c | ~b & d;
          g = j;
        } else if (j < 32) {
          f = d & b | ~d & c;
          g = 5 * j + 1 & 15;
        } else if (j < 48) {
          f = b ^ c ^ d;
          g = 3 * j + 5 & 15;
        } else {
          f = c ^ (b | ~d);
          g = 7 * j & 15;
        }
        var tmp = d,
            rotateArg = a + f + k[j] + w[g] | 0,
            rotate = r[j];
        d = c;
        c = b;
        b = b + (rotateArg << rotate | rotateArg >>> 32 - rotate) | 0;
        a = tmp;
      }
      h0 = h0 + a | 0;
      h1 = h1 + b | 0;
      h2 = h2 + c | 0;
      h3 = h3 + d | 0;
    }
    return new Uint8Array([h0 & 0xFF, h0 >> 8 & 0xFF, h0 >> 16 & 0xFF, h0 >>> 24 & 0xFF, h1 & 0xFF, h1 >> 8 & 0xFF, h1 >> 16 & 0xFF, h1 >>> 24 & 0xFF, h2 & 0xFF, h2 >> 8 & 0xFF, h2 >> 16 & 0xFF, h2 >>> 24 & 0xFF, h3 & 0xFF, h3 >> 8 & 0xFF, h3 >> 16 & 0xFF, h3 >>> 24 & 0xFF]);
  }
  return hash;
}();
var Word64 = function Word64Closure() {
  function Word64(highInteger, lowInteger) {
    this.high = highInteger | 0;
    this.low = lowInteger | 0;
  }
  Word64.prototype = {
    and: function Word64_and(word) {
      this.high &= word.high;
      this.low &= word.low;
    },
    xor: function Word64_xor(word) {
      this.high ^= word.high;
      this.low ^= word.low;
    },
    or: function Word64_or(word) {
      this.high |= word.high;
      this.low |= word.low;
    },
    shiftRight: function Word64_shiftRight(places) {
      if (places >= 32) {
        this.low = this.high >>> places - 32 | 0;
        this.high = 0;
      } else {
        this.low = this.low >>> places | this.high << 32 - places;
        this.high = this.high >>> places | 0;
      }
    },
    shiftLeft: function Word64_shiftLeft(places) {
      if (places >= 32) {
        this.high = this.low << places - 32;
        this.low = 0;
      } else {
        this.high = this.high << places | this.low >>> 32 - places;
        this.low = this.low << places;
      }
    },
    rotateRight: function Word64_rotateRight(places) {
      var low, high;
      if (places & 32) {
        high = this.low;
        low = this.high;
      } else {
        low = this.low;
        high = this.high;
      }
      places &= 31;
      this.low = low >>> places | high << 32 - places;
      this.high = high >>> places | low << 32 - places;
    },
    not: function Word64_not() {
      this.high = ~this.high;
      this.low = ~this.low;
    },
    add: function Word64_add(word) {
      var lowAdd = (this.low >>> 0) + (word.low >>> 0);
      var highAdd = (this.high >>> 0) + (word.high >>> 0);
      if (lowAdd > 0xFFFFFFFF) {
        highAdd += 1;
      }
      this.low = lowAdd | 0;
      this.high = highAdd | 0;
    },
    copyTo: function Word64_copyTo(bytes, offset) {
      bytes[offset] = this.high >>> 24 & 0xFF;
      bytes[offset + 1] = this.high >> 16 & 0xFF;
      bytes[offset + 2] = this.high >> 8 & 0xFF;
      bytes[offset + 3] = this.high & 0xFF;
      bytes[offset + 4] = this.low >>> 24 & 0xFF;
      bytes[offset + 5] = this.low >> 16 & 0xFF;
      bytes[offset + 6] = this.low >> 8 & 0xFF;
      bytes[offset + 7] = this.low & 0xFF;
    },
    assign: function Word64_assign(word) {
      this.high = word.high;
      this.low = word.low;
    }
  };
  return Word64;
}();
var calculateSHA256 = function calculateSHA256Closure() {
  function rotr(x, n) {
    return x >>> n | x << 32 - n;
  }
  function ch(x, y, z) {
    return x & y ^ ~x & z;
  }
  function maj(x, y, z) {
    return x & y ^ x & z ^ y & z;
  }
  function sigma(x) {
    return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
  }
  function sigmaPrime(x) {
    return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
  }
  function littleSigma(x) {
    return rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3;
  }
  function littleSigmaPrime(x) {
    return rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10;
  }
  var k = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
  function hash(data, offset, length) {
    var h0 = 0x6a09e667,
        h1 = 0xbb67ae85,
        h2 = 0x3c6ef372,
        h3 = 0xa54ff53a,
        h4 = 0x510e527f,
        h5 = 0x9b05688c,
        h6 = 0x1f83d9ab,
        h7 = 0x5be0cd19;
    var paddedLength = Math.ceil((length + 9) / 64) * 64;
    var padded = new Uint8Array(paddedLength);
    var i, j, n;
    for (i = 0; i < length; ++i) {
      padded[i] = data[offset++];
    }
    padded[i++] = 0x80;
    n = paddedLength - 8;
    while (i < n) {
      padded[i++] = 0;
    }
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = length >>> 29 & 0xFF;
    padded[i++] = length >> 21 & 0xFF;
    padded[i++] = length >> 13 & 0xFF;
    padded[i++] = length >> 5 & 0xFF;
    padded[i++] = length << 3 & 0xFF;
    var w = new Uint32Array(64);
    for (i = 0; i < paddedLength;) {
      for (j = 0; j < 16; ++j) {
        w[j] = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
        i += 4;
      }
      for (j = 16; j < 64; ++j) {
        w[j] = littleSigmaPrime(w[j - 2]) + w[j - 7] + littleSigma(w[j - 15]) + w[j - 16] | 0;
      }
      var a = h0,
          b = h1,
          c = h2,
          d = h3,
          e = h4,
          f = h5,
          g = h6,
          h = h7,
          t1,
          t2;
      for (j = 0; j < 64; ++j) {
        t1 = h + sigmaPrime(e) + ch(e, f, g) + k[j] + w[j];
        t2 = sigma(a) + maj(a, b, c);
        h = g;
        g = f;
        f = e;
        e = d + t1 | 0;
        d = c;
        c = b;
        b = a;
        a = t1 + t2 | 0;
      }
      h0 = h0 + a | 0;
      h1 = h1 + b | 0;
      h2 = h2 + c | 0;
      h3 = h3 + d | 0;
      h4 = h4 + e | 0;
      h5 = h5 + f | 0;
      h6 = h6 + g | 0;
      h7 = h7 + h | 0;
    }
    return new Uint8Array([h0 >> 24 & 0xFF, h0 >> 16 & 0xFF, h0 >> 8 & 0xFF, h0 & 0xFF, h1 >> 24 & 0xFF, h1 >> 16 & 0xFF, h1 >> 8 & 0xFF, h1 & 0xFF, h2 >> 24 & 0xFF, h2 >> 16 & 0xFF, h2 >> 8 & 0xFF, h2 & 0xFF, h3 >> 24 & 0xFF, h3 >> 16 & 0xFF, h3 >> 8 & 0xFF, h3 & 0xFF, h4 >> 24 & 0xFF, h4 >> 16 & 0xFF, h4 >> 8 & 0xFF, h4 & 0xFF, h5 >> 24 & 0xFF, h5 >> 16 & 0xFF, h5 >> 8 & 0xFF, h5 & 0xFF, h6 >> 24 & 0xFF, h6 >> 16 & 0xFF, h6 >> 8 & 0xFF, h6 & 0xFF, h7 >> 24 & 0xFF, h7 >> 16 & 0xFF, h7 >> 8 & 0xFF, h7 & 0xFF]);
  }
  return hash;
}();
var calculateSHA512 = function calculateSHA512Closure() {
  function ch(result, x, y, z, tmp) {
    result.assign(x);
    result.and(y);
    tmp.assign(x);
    tmp.not();
    tmp.and(z);
    result.xor(tmp);
  }
  function maj(result, x, y, z, tmp) {
    result.assign(x);
    result.and(y);
    tmp.assign(x);
    tmp.and(z);
    result.xor(tmp);
    tmp.assign(y);
    tmp.and(z);
    result.xor(tmp);
  }
  function sigma(result, x, tmp) {
    result.assign(x);
    result.rotateRight(28);
    tmp.assign(x);
    tmp.rotateRight(34);
    result.xor(tmp);
    tmp.assign(x);
    tmp.rotateRight(39);
    result.xor(tmp);
  }
  function sigmaPrime(result, x, tmp) {
    result.assign(x);
    result.rotateRight(14);
    tmp.assign(x);
    tmp.rotateRight(18);
    result.xor(tmp);
    tmp.assign(x);
    tmp.rotateRight(41);
    result.xor(tmp);
  }
  function littleSigma(result, x, tmp) {
    result.assign(x);
    result.rotateRight(1);
    tmp.assign(x);
    tmp.rotateRight(8);
    result.xor(tmp);
    tmp.assign(x);
    tmp.shiftRight(7);
    result.xor(tmp);
  }
  function littleSigmaPrime(result, x, tmp) {
    result.assign(x);
    result.rotateRight(19);
    tmp.assign(x);
    tmp.rotateRight(61);
    result.xor(tmp);
    tmp.assign(x);
    tmp.shiftRight(6);
    result.xor(tmp);
  }
  var k = [new Word64(0x428a2f98, 0xd728ae22), new Word64(0x71374491, 0x23ef65cd), new Word64(0xb5c0fbcf, 0xec4d3b2f), new Word64(0xe9b5dba5, 0x8189dbbc), new Word64(0x3956c25b, 0xf348b538), new Word64(0x59f111f1, 0xb605d019), new Word64(0x923f82a4, 0xaf194f9b), new Word64(0xab1c5ed5, 0xda6d8118), new Word64(0xd807aa98, 0xa3030242), new Word64(0x12835b01, 0x45706fbe), new Word64(0x243185be, 0x4ee4b28c), new Word64(0x550c7dc3, 0xd5ffb4e2), new Word64(0x72be5d74, 0xf27b896f), new Word64(0x80deb1fe, 0x3b1696b1), new Word64(0x9bdc06a7, 0x25c71235), new Word64(0xc19bf174, 0xcf692694), new Word64(0xe49b69c1, 0x9ef14ad2), new Word64(0xefbe4786, 0x384f25e3), new Word64(0x0fc19dc6, 0x8b8cd5b5), new Word64(0x240ca1cc, 0x77ac9c65), new Word64(0x2de92c6f, 0x592b0275), new Word64(0x4a7484aa, 0x6ea6e483), new Word64(0x5cb0a9dc, 0xbd41fbd4), new Word64(0x76f988da, 0x831153b5), new Word64(0x983e5152, 0xee66dfab), new Word64(0xa831c66d, 0x2db43210), new Word64(0xb00327c8, 0x98fb213f), new Word64(0xbf597fc7, 0xbeef0ee4), new Word64(0xc6e00bf3, 0x3da88fc2), new Word64(0xd5a79147, 0x930aa725), new Word64(0x06ca6351, 0xe003826f), new Word64(0x14292967, 0x0a0e6e70), new Word64(0x27b70a85, 0x46d22ffc), new Word64(0x2e1b2138, 0x5c26c926), new Word64(0x4d2c6dfc, 0x5ac42aed), new Word64(0x53380d13, 0x9d95b3df), new Word64(0x650a7354, 0x8baf63de), new Word64(0x766a0abb, 0x3c77b2a8), new Word64(0x81c2c92e, 0x47edaee6), new Word64(0x92722c85, 0x1482353b), new Word64(0xa2bfe8a1, 0x4cf10364), new Word64(0xa81a664b, 0xbc423001), new Word64(0xc24b8b70, 0xd0f89791), new Word64(0xc76c51a3, 0x0654be30), new Word64(0xd192e819, 0xd6ef5218), new Word64(0xd6990624, 0x5565a910), new Word64(0xf40e3585, 0x5771202a), new Word64(0x106aa070, 0x32bbd1b8), new Word64(0x19a4c116, 0xb8d2d0c8), new Word64(0x1e376c08, 0x5141ab53), new Word64(0x2748774c, 0xdf8eeb99), new Word64(0x34b0bcb5, 0xe19b48a8), new Word64(0x391c0cb3, 0xc5c95a63), new Word64(0x4ed8aa4a, 0xe3418acb), new Word64(0x5b9cca4f, 0x7763e373), new Word64(0x682e6ff3, 0xd6b2b8a3), new Word64(0x748f82ee, 0x5defb2fc), new Word64(0x78a5636f, 0x43172f60), new Word64(0x84c87814, 0xa1f0ab72), new Word64(0x8cc70208, 0x1a6439ec), new Word64(0x90befffa, 0x23631e28), new Word64(0xa4506ceb, 0xde82bde9), new Word64(0xbef9a3f7, 0xb2c67915), new Word64(0xc67178f2, 0xe372532b), new Word64(0xca273ece, 0xea26619c), new Word64(0xd186b8c7, 0x21c0c207), new Word64(0xeada7dd6, 0xcde0eb1e), new Word64(0xf57d4f7f, 0xee6ed178), new Word64(0x06f067aa, 0x72176fba), new Word64(0x0a637dc5, 0xa2c898a6), new Word64(0x113f9804, 0xbef90dae), new Word64(0x1b710b35, 0x131c471b), new Word64(0x28db77f5, 0x23047d84), new Word64(0x32caab7b, 0x40c72493), new Word64(0x3c9ebe0a, 0x15c9bebc), new Word64(0x431d67c4, 0x9c100d4c), new Word64(0x4cc5d4be, 0xcb3e42b6), new Word64(0x597f299c, 0xfc657e2a), new Word64(0x5fcb6fab, 0x3ad6faec), new Word64(0x6c44198c, 0x4a475817)];
  function hash(data, offset, length, mode384) {
    mode384 = !!mode384;
    var h0, h1, h2, h3, h4, h5, h6, h7;
    if (!mode384) {
      h0 = new Word64(0x6a09e667, 0xf3bcc908);
      h1 = new Word64(0xbb67ae85, 0x84caa73b);
      h2 = new Word64(0x3c6ef372, 0xfe94f82b);
      h3 = new Word64(0xa54ff53a, 0x5f1d36f1);
      h4 = new Word64(0x510e527f, 0xade682d1);
      h5 = new Word64(0x9b05688c, 0x2b3e6c1f);
      h6 = new Word64(0x1f83d9ab, 0xfb41bd6b);
      h7 = new Word64(0x5be0cd19, 0x137e2179);
    } else {
      h0 = new Word64(0xcbbb9d5d, 0xc1059ed8);
      h1 = new Word64(0x629a292a, 0x367cd507);
      h2 = new Word64(0x9159015a, 0x3070dd17);
      h3 = new Word64(0x152fecd8, 0xf70e5939);
      h4 = new Word64(0x67332667, 0xffc00b31);
      h5 = new Word64(0x8eb44a87, 0x68581511);
      h6 = new Word64(0xdb0c2e0d, 0x64f98fa7);
      h7 = new Word64(0x47b5481d, 0xbefa4fa4);
    }
    var paddedLength = Math.ceil((length + 17) / 128) * 128;
    var padded = new Uint8Array(paddedLength);
    var i, j, n;
    for (i = 0; i < length; ++i) {
      padded[i] = data[offset++];
    }
    padded[i++] = 0x80;
    n = paddedLength - 16;
    while (i < n) {
      padded[i++] = 0;
    }
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = length >>> 29 & 0xFF;
    padded[i++] = length >> 21 & 0xFF;
    padded[i++] = length >> 13 & 0xFF;
    padded[i++] = length >> 5 & 0xFF;
    padded[i++] = length << 3 & 0xFF;
    var w = new Array(80);
    for (i = 0; i < 80; i++) {
      w[i] = new Word64(0, 0);
    }
    var a = new Word64(0, 0),
        b = new Word64(0, 0),
        c = new Word64(0, 0);
    var d = new Word64(0, 0),
        e = new Word64(0, 0),
        f = new Word64(0, 0);
    var g = new Word64(0, 0),
        h = new Word64(0, 0);
    var t1 = new Word64(0, 0),
        t2 = new Word64(0, 0);
    var tmp1 = new Word64(0, 0),
        tmp2 = new Word64(0, 0),
        tmp3;
    for (i = 0; i < paddedLength;) {
      for (j = 0; j < 16; ++j) {
        w[j].high = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
        w[j].low = padded[i + 4] << 24 | padded[i + 5] << 16 | padded[i + 6] << 8 | padded[i + 7];
        i += 8;
      }
      for (j = 16; j < 80; ++j) {
        tmp3 = w[j];
        littleSigmaPrime(tmp3, w[j - 2], tmp2);
        tmp3.add(w[j - 7]);
        littleSigma(tmp1, w[j - 15], tmp2);
        tmp3.add(tmp1);
        tmp3.add(w[j - 16]);
      }
      a.assign(h0);
      b.assign(h1);
      c.assign(h2);
      d.assign(h3);
      e.assign(h4);
      f.assign(h5);
      g.assign(h6);
      h.assign(h7);
      for (j = 0; j < 80; ++j) {
        t1.assign(h);
        sigmaPrime(tmp1, e, tmp2);
        t1.add(tmp1);
        ch(tmp1, e, f, g, tmp2);
        t1.add(tmp1);
        t1.add(k[j]);
        t1.add(w[j]);
        sigma(t2, a, tmp2);
        maj(tmp1, a, b, c, tmp2);
        t2.add(tmp1);
        tmp3 = h;
        h = g;
        g = f;
        f = e;
        d.add(t1);
        e = d;
        d = c;
        c = b;
        b = a;
        tmp3.assign(t1);
        tmp3.add(t2);
        a = tmp3;
      }
      h0.add(a);
      h1.add(b);
      h2.add(c);
      h3.add(d);
      h4.add(e);
      h5.add(f);
      h6.add(g);
      h7.add(h);
    }
    var result;
    if (!mode384) {
      result = new Uint8Array(64);
      h0.copyTo(result, 0);
      h1.copyTo(result, 8);
      h2.copyTo(result, 16);
      h3.copyTo(result, 24);
      h4.copyTo(result, 32);
      h5.copyTo(result, 40);
      h6.copyTo(result, 48);
      h7.copyTo(result, 56);
    } else {
      result = new Uint8Array(48);
      h0.copyTo(result, 0);
      h1.copyTo(result, 8);
      h2.copyTo(result, 16);
      h3.copyTo(result, 24);
      h4.copyTo(result, 32);
      h5.copyTo(result, 40);
    }
    return result;
  }
  return hash;
}();
var calculateSHA384 = function calculateSHA384Closure() {
  function hash(data, offset, length) {
    return calculateSHA512(data, offset, length, true);
  }
  return hash;
}();
var NullCipher = function NullCipherClosure() {
  function NullCipher() {}
  NullCipher.prototype = {
    decryptBlock: function NullCipher_decryptBlock(data) {
      return data;
    }
  };
  return NullCipher;
}();
var AES128Cipher = function AES128CipherClosure() {
  var rcon = new Uint8Array([0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d]);
  var s = new Uint8Array([0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]);
  var inv_s = new Uint8Array([0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]);
  var mixCol = new Uint8Array(256);
  for (var i = 0; i < 256; i++) {
    if (i < 128) {
      mixCol[i] = i << 1;
    } else {
      mixCol[i] = i << 1 ^ 0x1b;
    }
  }
  var mix = new Uint32Array([0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3]);
  function expandKey128(cipherKey) {
    var b = 176,
        result = new Uint8Array(b);
    result.set(cipherKey);
    for (var j = 16, i = 1; j < b; ++i) {
      var t1 = result[j - 3],
          t2 = result[j - 2],
          t3 = result[j - 1],
          t4 = result[j - 4];
      t1 = s[t1];
      t2 = s[t2];
      t3 = s[t3];
      t4 = s[t4];
      t1 = t1 ^ rcon[i];
      for (var n = 0; n < 4; ++n) {
        result[j] = t1 ^= result[j - 16];
        j++;
        result[j] = t2 ^= result[j - 16];
        j++;
        result[j] = t3 ^= result[j - 16];
        j++;
        result[j] = t4 ^= result[j - 16];
        j++;
      }
    }
    return result;
  }
  function decrypt128(input, key) {
    var state = new Uint8Array(16);
    state.set(input);
    var i, j, k;
    var t, u, v;
    for (j = 0, k = 160; j < 16; ++j, ++k) {
      state[j] ^= key[k];
    }
    for (i = 9; i >= 1; --i) {
      t = state[13];
      state[13] = state[9];
      state[9] = state[5];
      state[5] = state[1];
      state[1] = t;
      t = state[14];
      u = state[10];
      state[14] = state[6];
      state[10] = state[2];
      state[6] = t;
      state[2] = u;
      t = state[15];
      u = state[11];
      v = state[7];
      state[15] = state[3];
      state[11] = t;
      state[7] = u;
      state[3] = v;
      for (j = 0; j < 16; ++j) {
        state[j] = inv_s[state[j]];
      }
      for (j = 0, k = i * 16; j < 16; ++j, ++k) {
        state[j] ^= key[k];
      }
      for (j = 0; j < 16; j += 4) {
        var s0 = mix[state[j]],
            s1 = mix[state[j + 1]],
            s2 = mix[state[j + 2]],
            s3 = mix[state[j + 3]];
        t = s0 ^ s1 >>> 8 ^ s1 << 24 ^ s2 >>> 16 ^ s2 << 16 ^ s3 >>> 24 ^ s3 << 8;
        state[j] = t >>> 24 & 0xFF;
        state[j + 1] = t >> 16 & 0xFF;
        state[j + 2] = t >> 8 & 0xFF;
        state[j + 3] = t & 0xFF;
      }
    }
    t = state[13];
    state[13] = state[9];
    state[9] = state[5];
    state[5] = state[1];
    state[1] = t;
    t = state[14];
    u = state[10];
    state[14] = state[6];
    state[10] = state[2];
    state[6] = t;
    state[2] = u;
    t = state[15];
    u = state[11];
    v = state[7];
    state[15] = state[3];
    state[11] = t;
    state[7] = u;
    state[3] = v;
    for (j = 0; j < 16; ++j) {
      state[j] = inv_s[state[j]];
      state[j] ^= key[j];
    }
    return state;
  }
  function encrypt128(input, key) {
    var t, u, v, k;
    var state = new Uint8Array(16);
    state.set(input);
    for (j = 0; j < 16; ++j) {
      state[j] ^= key[j];
    }
    for (i = 1; i < 10; i++) {
      for (j = 0; j < 16; ++j) {
        state[j] = s[state[j]];
      }
      v = state[1];
      state[1] = state[5];
      state[5] = state[9];
      state[9] = state[13];
      state[13] = v;
      v = state[2];
      u = state[6];
      state[2] = state[10];
      state[6] = state[14];
      state[10] = v;
      state[14] = u;
      v = state[3];
      u = state[7];
      t = state[11];
      state[3] = state[15];
      state[7] = v;
      state[11] = u;
      state[15] = t;
      for (var j = 0; j < 16; j += 4) {
        var s0 = state[j + 0],
            s1 = state[j + 1];
        var s2 = state[j + 2],
            s3 = state[j + 3];
        t = s0 ^ s1 ^ s2 ^ s3;
        state[j + 0] ^= t ^ mixCol[s0 ^ s1];
        state[j + 1] ^= t ^ mixCol[s1 ^ s2];
        state[j + 2] ^= t ^ mixCol[s2 ^ s3];
        state[j + 3] ^= t ^ mixCol[s3 ^ s0];
      }
      for (j = 0, k = i * 16; j < 16; ++j, ++k) {
        state[j] ^= key[k];
      }
    }
    for (j = 0; j < 16; ++j) {
      state[j] = s[state[j]];
    }
    v = state[1];
    state[1] = state[5];
    state[5] = state[9];
    state[9] = state[13];
    state[13] = v;
    v = state[2];
    u = state[6];
    state[2] = state[10];
    state[6] = state[14];
    state[10] = v;
    state[14] = u;
    v = state[3];
    u = state[7];
    t = state[11];
    state[3] = state[15];
    state[7] = v;
    state[11] = u;
    state[15] = t;
    for (j = 0, k = 160; j < 16; ++j, ++k) {
      state[j] ^= key[k];
    }
    return state;
  }
  function AES128Cipher(key) {
    this.key = expandKey128(key);
    this.buffer = new Uint8Array(16);
    this.bufferPosition = 0;
  }
  function decryptBlock2(data, finalize) {
    var i,
        j,
        ii,
        sourceLength = data.length,
        buffer = this.buffer,
        bufferLength = this.bufferPosition,
        result = [],
        iv = this.iv;
    for (i = 0; i < sourceLength; ++i) {
      buffer[bufferLength] = data[i];
      ++bufferLength;
      if (bufferLength < 16) {
        continue;
      }
      var plain = decrypt128(buffer, this.key);
      for (j = 0; j < 16; ++j) {
        plain[j] ^= iv[j];
      }
      iv = buffer;
      result.push(plain);
      buffer = new Uint8Array(16);
      bufferLength = 0;
    }
    this.buffer = buffer;
    this.bufferLength = bufferLength;
    this.iv = iv;
    if (result.length === 0) {
      return new Uint8Array([]);
    }
    var outputLength = 16 * result.length;
    if (finalize) {
      var lastBlock = result[result.length - 1];
      var psLen = lastBlock[15];
      if (psLen <= 16) {
        for (i = 15, ii = 16 - psLen; i >= ii; --i) {
          if (lastBlock[i] !== psLen) {
            psLen = 0;
            break;
          }
        }
        outputLength -= psLen;
        result[result.length - 1] = lastBlock.subarray(0, 16 - psLen);
      }
    }
    var output = new Uint8Array(outputLength);
    for (i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
      output.set(result[i], j);
    }
    return output;
  }
  AES128Cipher.prototype = {
    decryptBlock: function AES128Cipher_decryptBlock(data, finalize) {
      var i,
          sourceLength = data.length;
      var buffer = this.buffer,
          bufferLength = this.bufferPosition;
      for (i = 0; bufferLength < 16 && i < sourceLength; ++i, ++bufferLength) {
        buffer[bufferLength] = data[i];
      }
      if (bufferLength < 16) {
        this.bufferLength = bufferLength;
        return new Uint8Array([]);
      }
      this.iv = buffer;
      this.buffer = new Uint8Array(16);
      this.bufferLength = 0;
      this.decryptBlock = decryptBlock2;
      return this.decryptBlock(data.subarray(16), finalize);
    },
    encrypt: function AES128Cipher_encrypt(data, iv) {
      var i,
          j,
          ii,
          sourceLength = data.length,
          buffer = this.buffer,
          bufferLength = this.bufferPosition,
          result = [];
      if (!iv) {
        iv = new Uint8Array(16);
      }
      for (i = 0; i < sourceLength; ++i) {
        buffer[bufferLength] = data[i];
        ++bufferLength;
        if (bufferLength < 16) {
          continue;
        }
        for (j = 0; j < 16; ++j) {
          buffer[j] ^= iv[j];
        }
        var cipher = encrypt128(buffer, this.key);
        iv = cipher;
        result.push(cipher);
        buffer = new Uint8Array(16);
        bufferLength = 0;
      }
      this.buffer = buffer;
      this.bufferLength = bufferLength;
      this.iv = iv;
      if (result.length === 0) {
        return new Uint8Array([]);
      }
      var outputLength = 16 * result.length;
      var output = new Uint8Array(outputLength);
      for (i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
        output.set(result[i], j);
      }
      return output;
    }
  };
  return AES128Cipher;
}();
var AES256Cipher = function AES256CipherClosure() {
  var s = new Uint8Array([0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]);
  var inv_s = new Uint8Array([0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]);
  var mixCol = new Uint8Array(256);
  for (var i = 0; i < 256; i++) {
    if (i < 128) {
      mixCol[i] = i << 1;
    } else {
      mixCol[i] = i << 1 ^ 0x1b;
    }
  }
  var mix = new Uint32Array([0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3]);
  function expandKey256(cipherKey) {
    var b = 240,
        result = new Uint8Array(b);
    var r = 1;
    result.set(cipherKey);
    for (var j = 32, i = 1; j < b; ++i) {
      if (j % 32 === 16) {
        t1 = s[t1];
        t2 = s[t2];
        t3 = s[t3];
        t4 = s[t4];
      } else if (j % 32 === 0) {
        var t1 = result[j - 3],
            t2 = result[j - 2],
            t3 = result[j - 1],
            t4 = result[j - 4];
        t1 = s[t1];
        t2 = s[t2];
        t3 = s[t3];
        t4 = s[t4];
        t1 = t1 ^ r;
        if ((r <<= 1) >= 256) {
          r = (r ^ 0x1b) & 0xFF;
        }
      }
      for (var n = 0; n < 4; ++n) {
        result[j] = t1 ^= result[j - 32];
        j++;
        result[j] = t2 ^= result[j - 32];
        j++;
        result[j] = t3 ^= result[j - 32];
        j++;
        result[j] = t4 ^= result[j - 32];
        j++;
      }
    }
    return result;
  }
  function decrypt256(input, key) {
    var state = new Uint8Array(16);
    state.set(input);
    var i, j, k;
    var t, u, v;
    for (j = 0, k = 224; j < 16; ++j, ++k) {
      state[j] ^= key[k];
    }
    for (i = 13; i >= 1; --i) {
      t = state[13];
      state[13] = state[9];
      state[9] = state[5];
      state[5] = state[1];
      state[1] = t;
      t = state[14];
      u = state[10];
      state[14] = state[6];
      state[10] = state[2];
      state[6] = t;
      state[2] = u;
      t = state[15];
      u = state[11];
      v = state[7];
      state[15] = state[3];
      state[11] = t;
      state[7] = u;
      state[3] = v;
      for (j = 0; j < 16; ++j) {
        state[j] = inv_s[state[j]];
      }
      for (j = 0, k = i * 16; j < 16; ++j, ++k) {
        state[j] ^= key[k];
      }
      for (j = 0; j < 16; j += 4) {
        var s0 = mix[state[j]],
            s1 = mix[state[j + 1]],
            s2 = mix[state[j + 2]],
            s3 = mix[state[j + 3]];
        t = s0 ^ s1 >>> 8 ^ s1 << 24 ^ s2 >>> 16 ^ s2 << 16 ^ s3 >>> 24 ^ s3 << 8;
        state[j] = t >>> 24 & 0xFF;
        state[j + 1] = t >> 16 & 0xFF;
        state[j + 2] = t >> 8 & 0xFF;
        state[j + 3] = t & 0xFF;
      }
    }
    t = state[13];
    state[13] = state[9];
    state[9] = state[5];
    state[5] = state[1];
    state[1] = t;
    t = state[14];
    u = state[10];
    state[14] = state[6];
    state[10] = state[2];
    state[6] = t;
    state[2] = u;
    t = state[15];
    u = state[11];
    v = state[7];
    state[15] = state[3];
    state[11] = t;
    state[7] = u;
    state[3] = v;
    for (j = 0; j < 16; ++j) {
      state[j] = inv_s[state[j]];
      state[j] ^= key[j];
    }
    return state;
  }
  function encrypt256(input, key) {
    var t, u, v, k;
    var state = new Uint8Array(16);
    state.set(input);
    for (j = 0; j < 16; ++j) {
      state[j] ^= key[j];
    }
    for (i = 1; i < 14; i++) {
      for (j = 0; j < 16; ++j) {
        state[j] = s[state[j]];
      }
      v = state[1];
      state[1] = state[5];
      state[5] = state[9];
      state[9] = state[13];
      state[13] = v;
      v = state[2];
      u = state[6];
      state[2] = state[10];
      state[6] = state[14];
      state[10] = v;
      state[14] = u;
      v = state[3];
      u = state[7];
      t = state[11];
      state[3] = state[15];
      state[7] = v;
      state[11] = u;
      state[15] = t;
      for (var j = 0; j < 16; j += 4) {
        var s0 = state[j + 0],
            s1 = state[j + 1];
        var s2 = state[j + 2],
            s3 = state[j + 3];
        t = s0 ^ s1 ^ s2 ^ s3;
        state[j + 0] ^= t ^ mixCol[s0 ^ s1];
        state[j + 1] ^= t ^ mixCol[s1 ^ s2];
        state[j + 2] ^= t ^ mixCol[s2 ^ s3];
        state[j + 3] ^= t ^ mixCol[s3 ^ s0];
      }
      for (j = 0, k = i * 16; j < 16; ++j, ++k) {
        state[j] ^= key[k];
      }
    }
    for (j = 0; j < 16; ++j) {
      state[j] = s[state[j]];
    }
    v = state[1];
    state[1] = state[5];
    state[5] = state[9];
    state[9] = state[13];
    state[13] = v;
    v = state[2];
    u = state[6];
    state[2] = state[10];
    state[6] = state[14];
    state[10] = v;
    state[14] = u;
    v = state[3];
    u = state[7];
    t = state[11];
    state[3] = state[15];
    state[7] = v;
    state[11] = u;
    state[15] = t;
    for (j = 0, k = 224; j < 16; ++j, ++k) {
      state[j] ^= key[k];
    }
    return state;
  }
  function AES256Cipher(key) {
    this.key = expandKey256(key);
    this.buffer = new Uint8Array(16);
    this.bufferPosition = 0;
  }
  function decryptBlock2(data, finalize) {
    var i,
        j,
        ii,
        sourceLength = data.length,
        buffer = this.buffer,
        bufferLength = this.bufferPosition,
        result = [],
        iv = this.iv;
    for (i = 0; i < sourceLength; ++i) {
      buffer[bufferLength] = data[i];
      ++bufferLength;
      if (bufferLength < 16) {
        continue;
      }
      var plain = decrypt256(buffer, this.key);
      for (j = 0; j < 16; ++j) {
        plain[j] ^= iv[j];
      }
      iv = buffer;
      result.push(plain);
      buffer = new Uint8Array(16);
      bufferLength = 0;
    }
    this.buffer = buffer;
    this.bufferLength = bufferLength;
    this.iv = iv;
    if (result.length === 0) {
      return new Uint8Array([]);
    }
    var outputLength = 16 * result.length;
    if (finalize) {
      var lastBlock = result[result.length - 1];
      var psLen = lastBlock[15];
      if (psLen <= 16) {
        for (i = 15, ii = 16 - psLen; i >= ii; --i) {
          if (lastBlock[i] !== psLen) {
            psLen = 0;
            break;
          }
        }
        outputLength -= psLen;
        result[result.length - 1] = lastBlock.subarray(0, 16 - psLen);
      }
    }
    var output = new Uint8Array(outputLength);
    for (i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
      output.set(result[i], j);
    }
    return output;
  }
  AES256Cipher.prototype = {
    decryptBlock: function AES256Cipher_decryptBlock(data, finalize, iv) {
      var i,
          sourceLength = data.length;
      var buffer = this.buffer,
          bufferLength = this.bufferPosition;
      if (iv) {
        this.iv = iv;
      } else {
        for (i = 0; bufferLength < 16 && i < sourceLength; ++i, ++bufferLength) {
          buffer[bufferLength] = data[i];
        }
        if (bufferLength < 16) {
          this.bufferLength = bufferLength;
          return new Uint8Array([]);
        }
        this.iv = buffer;
        data = data.subarray(16);
      }
      this.buffer = new Uint8Array(16);
      this.bufferLength = 0;
      this.decryptBlock = decryptBlock2;
      return this.decryptBlock(data, finalize);
    },
    encrypt: function AES256Cipher_encrypt(data, iv) {
      var i,
          j,
          ii,
          sourceLength = data.length,
          buffer = this.buffer,
          bufferLength = this.bufferPosition,
          result = [];
      if (!iv) {
        iv = new Uint8Array(16);
      }
      for (i = 0; i < sourceLength; ++i) {
        buffer[bufferLength] = data[i];
        ++bufferLength;
        if (bufferLength < 16) {
          continue;
        }
        for (j = 0; j < 16; ++j) {
          buffer[j] ^= iv[j];
        }
        var cipher = encrypt256(buffer, this.key);
        this.iv = cipher;
        result.push(cipher);
        buffer = new Uint8Array(16);
        bufferLength = 0;
      }
      this.buffer = buffer;
      this.bufferLength = bufferLength;
      this.iv = iv;
      if (result.length === 0) {
        return new Uint8Array([]);
      }
      var outputLength = 16 * result.length;
      var output = new Uint8Array(outputLength);
      for (i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
        output.set(result[i], j);
      }
      return output;
    }
  };
  return AES256Cipher;
}();
var PDF17 = function PDF17Closure() {
  function compareByteArrays(array1, array2) {
    if (array1.length !== array2.length) {
      return false;
    }
    for (var i = 0; i < array1.length; i++) {
      if (array1[i] !== array2[i]) {
        return false;
      }
    }
    return true;
  }
  function PDF17() {}
  PDF17.prototype = {
    checkOwnerPassword: function PDF17_checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
      var hashData = new Uint8Array(password.length + 56);
      hashData.set(password, 0);
      hashData.set(ownerValidationSalt, password.length);
      hashData.set(userBytes, password.length + ownerValidationSalt.length);
      var result = calculateSHA256(hashData, 0, hashData.length);
      return compareByteArrays(result, ownerPassword);
    },
    checkUserPassword: function PDF17_checkUserPassword(password, userValidationSalt, userPassword) {
      var hashData = new Uint8Array(password.length + 8);
      hashData.set(password, 0);
      hashData.set(userValidationSalt, password.length);
      var result = calculateSHA256(hashData, 0, hashData.length);
      return compareByteArrays(result, userPassword);
    },
    getOwnerKey: function PDF17_getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
      var hashData = new Uint8Array(password.length + 56);
      hashData.set(password, 0);
      hashData.set(ownerKeySalt, password.length);
      hashData.set(userBytes, password.length + ownerKeySalt.length);
      var key = calculateSHA256(hashData, 0, hashData.length);
      var cipher = new AES256Cipher(key);
      return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
    },
    getUserKey: function PDF17_getUserKey(password, userKeySalt, userEncryption) {
      var hashData = new Uint8Array(password.length + 8);
      hashData.set(password, 0);
      hashData.set(userKeySalt, password.length);
      var key = calculateSHA256(hashData, 0, hashData.length);
      var cipher = new AES256Cipher(key);
      return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
    }
  };
  return PDF17;
}();
var PDF20 = function PDF20Closure() {
  function concatArrays(array1, array2) {
    var t = new Uint8Array(array1.length + array2.length);
    t.set(array1, 0);
    t.set(array2, array1.length);
    return t;
  }
  function calculatePDF20Hash(password, input, userBytes) {
    var k = calculateSHA256(input, 0, input.length).subarray(0, 32);
    var e = [0];
    var i = 0;
    while (i < 64 || e[e.length - 1] > i - 32) {
      var arrayLength = password.length + k.length + userBytes.length;
      var k1 = new Uint8Array(arrayLength * 64);
      var array = concatArrays(password, k);
      array = concatArrays(array, userBytes);
      for (var j = 0, pos = 0; j < 64; j++, pos += arrayLength) {
        k1.set(array, pos);
      }
      var cipher = new AES128Cipher(k.subarray(0, 16));
      e = cipher.encrypt(k1, k.subarray(16, 32));
      var remainder = 0;
      for (var z = 0; z < 16; z++) {
        remainder *= 256 % 3;
        remainder %= 3;
        remainder += (e[z] >>> 0) % 3;
        remainder %= 3;
      }
      if (remainder === 0) {
        k = calculateSHA256(e, 0, e.length);
      } else if (remainder === 1) {
        k = calculateSHA384(e, 0, e.length);
      } else if (remainder === 2) {
        k = calculateSHA512(e, 0, e.length);
      }
      i++;
    }
    return k.subarray(0, 32);
  }
  function PDF20() {}
  function compareByteArrays(array1, array2) {
    if (array1.length !== array2.length) {
      return false;
    }
    for (var i = 0; i < array1.length; i++) {
      if (array1[i] !== array2[i]) {
        return false;
      }
    }
    return true;
  }
  PDF20.prototype = {
    hash: function PDF20_hash(password, concatBytes, userBytes) {
      return calculatePDF20Hash(password, concatBytes, userBytes);
    },
    checkOwnerPassword: function PDF20_checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
      var hashData = new Uint8Array(password.length + 56);
      hashData.set(password, 0);
      hashData.set(ownerValidationSalt, password.length);
      hashData.set(userBytes, password.length + ownerValidationSalt.length);
      var result = calculatePDF20Hash(password, hashData, userBytes);
      return compareByteArrays(result, ownerPassword);
    },
    checkUserPassword: function PDF20_checkUserPassword(password, userValidationSalt, userPassword) {
      var hashData = new Uint8Array(password.length + 8);
      hashData.set(password, 0);
      hashData.set(userValidationSalt, password.length);
      var result = calculatePDF20Hash(password, hashData, []);
      return compareByteArrays(result, userPassword);
    },
    getOwnerKey: function PDF20_getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
      var hashData = new Uint8Array(password.length + 56);
      hashData.set(password, 0);
      hashData.set(ownerKeySalt, password.length);
      hashData.set(userBytes, password.length + ownerKeySalt.length);
      var key = calculatePDF20Hash(password, hashData, userBytes);
      var cipher = new AES256Cipher(key);
      return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
    },
    getUserKey: function PDF20_getUserKey(password, userKeySalt, userEncryption) {
      var hashData = new Uint8Array(password.length + 8);
      hashData.set(password, 0);
      hashData.set(userKeySalt, password.length);
      var key = calculatePDF20Hash(password, hashData, []);
      var cipher = new AES256Cipher(key);
      return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
    }
  };
  return PDF20;
}();
var CipherTransform = function CipherTransformClosure() {
  function CipherTransform(stringCipherConstructor, streamCipherConstructor) {
    this.StringCipherConstructor = stringCipherConstructor;
    this.StreamCipherConstructor = streamCipherConstructor;
  }
  CipherTransform.prototype = {
    createStream: function CipherTransform_createStream(stream, length) {
      var cipher = new this.StreamCipherConstructor();
      return new DecryptStream(stream, length, function cipherTransformDecryptStream(data, finalize) {
        return cipher.decryptBlock(data, finalize);
      });
    },
    decryptString: function CipherTransform_decryptString(s) {
      var cipher = new this.StringCipherConstructor();
      var data = stringToBytes(s);
      data = cipher.decryptBlock(data, true);
      return bytesToString(data);
    }
  };
  return CipherTransform;
}();
var CipherTransformFactory = function CipherTransformFactoryClosure() {
  var defaultPasswordBytes = new Uint8Array([0x28, 0xBF, 0x4E, 0x5E, 0x4E, 0x75, 0x8A, 0x41, 0x64, 0x00, 0x4E, 0x56, 0xFF, 0xFA, 0x01, 0x08, 0x2E, 0x2E, 0x00, 0xB6, 0xD0, 0x68, 0x3E, 0x80, 0x2F, 0x0C, 0xA9, 0xFE, 0x64, 0x53, 0x69, 0x7A]);
  function createEncryptionKey20(revision, password, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms) {
    if (password) {
      var passwordLength = Math.min(127, password.length);
      password = password.subarray(0, passwordLength);
    } else {
      password = [];
    }
    var pdfAlgorithm;
    if (revision === 6) {
      pdfAlgorithm = new PDF20();
    } else {
      pdfAlgorithm = new PDF17();
    }
    if (pdfAlgorithm.checkUserPassword(password, userValidationSalt, userPassword)) {
      return pdfAlgorithm.getUserKey(password, userKeySalt, userEncryption);
    } else if (password.length && pdfAlgorithm.checkOwnerPassword(password, ownerValidationSalt, uBytes, ownerPassword)) {
      return pdfAlgorithm.getOwnerKey(password, ownerKeySalt, uBytes, ownerEncryption);
    }
    return null;
  }
  function prepareKeyData(fileId, password, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata) {
    var hashDataSize = 40 + ownerPassword.length + fileId.length;
    var hashData = new Uint8Array(hashDataSize),
        i = 0,
        j,
        n;
    if (password) {
      n = Math.min(32, password.length);
      for (; i < n; ++i) {
        hashData[i] = password[i];
      }
    }
    j = 0;
    while (i < 32) {
      hashData[i++] = defaultPasswordBytes[j++];
    }
    for (j = 0, n = ownerPassword.length; j < n; ++j) {
      hashData[i++] = ownerPassword[j];
    }
    hashData[i++] = flags & 0xFF;
    hashData[i++] = flags >> 8 & 0xFF;
    hashData[i++] = flags >> 16 & 0xFF;
    hashData[i++] = flags >>> 24 & 0xFF;
    for (j = 0, n = fileId.length; j < n; ++j) {
      hashData[i++] = fileId[j];
    }
    if (revision >= 4 && !encryptMetadata) {
      hashData[i++] = 0xFF;
      hashData[i++] = 0xFF;
      hashData[i++] = 0xFF;
      hashData[i++] = 0xFF;
    }
    var hash = calculateMD5(hashData, 0, i);
    var keyLengthInBytes = keyLength >> 3;
    if (revision >= 3) {
      for (j = 0; j < 50; ++j) {
        hash = calculateMD5(hash, 0, keyLengthInBytes);
      }
    }
    var encryptionKey = hash.subarray(0, keyLengthInBytes);
    var cipher, checkData;
    if (revision >= 3) {
      for (i = 0; i < 32; ++i) {
        hashData[i] = defaultPasswordBytes[i];
      }
      for (j = 0, n = fileId.length; j < n; ++j) {
        hashData[i++] = fileId[j];
      }
      cipher = new ARCFourCipher(encryptionKey);
      checkData = cipher.encryptBlock(calculateMD5(hashData, 0, i));
      n = encryptionKey.length;
      var derivedKey = new Uint8Array(n),
          k;
      for (j = 1; j <= 19; ++j) {
        for (k = 0; k < n; ++k) {
          derivedKey[k] = encryptionKey[k] ^ j;
        }
        cipher = new ARCFourCipher(derivedKey);
        checkData = cipher.encryptBlock(checkData);
      }
      for (j = 0, n = checkData.length; j < n; ++j) {
        if (userPassword[j] !== checkData[j]) {
          return null;
        }
      }
    } else {
      cipher = new ARCFourCipher(encryptionKey);
      checkData = cipher.encryptBlock(defaultPasswordBytes);
      for (j = 0, n = checkData.length; j < n; ++j) {
        if (userPassword[j] !== checkData[j]) {
          return null;
        }
      }
    }
    return encryptionKey;
  }
  function decodeUserPassword(password, ownerPassword, revision, keyLength) {
    var hashData = new Uint8Array(32),
        i = 0,
        j,
        n;
    n = Math.min(32, password.length);
    for (; i < n; ++i) {
      hashData[i] = password[i];
    }
    j = 0;
    while (i < 32) {
      hashData[i++] = defaultPasswordBytes[j++];
    }
    var hash = calculateMD5(hashData, 0, i);
    var keyLengthInBytes = keyLength >> 3;
    if (revision >= 3) {
      for (j = 0; j < 50; ++j) {
        hash = calculateMD5(hash, 0, hash.length);
      }
    }
    var cipher, userPassword;
    if (revision >= 3) {
      userPassword = ownerPassword;
      var derivedKey = new Uint8Array(keyLengthInBytes),
          k;
      for (j = 19; j >= 0; j--) {
        for (k = 0; k < keyLengthInBytes; ++k) {
          derivedKey[k] = hash[k] ^ j;
        }
        cipher = new ARCFourCipher(derivedKey);
        userPassword = cipher.encryptBlock(userPassword);
      }
    } else {
      cipher = new ARCFourCipher(hash.subarray(0, keyLengthInBytes));
      userPassword = cipher.encryptBlock(ownerPassword);
    }
    return userPassword;
  }
  var identityName = Name.get('Identity');
  function CipherTransformFactory(dict, fileId, password) {
    var filter = dict.get('Filter');
    if (!isName(filter, 'Standard')) {
      error('unknown encryption method');
    }
    this.dict = dict;
    var algorithm = dict.get('V');
    if (!isInt(algorithm) || algorithm !== 1 && algorithm !== 2 && algorithm !== 4 && algorithm !== 5) {
      error('unsupported encryption algorithm');
    }
    this.algorithm = algorithm;
    var keyLength = dict.get('Length');
    if (!keyLength) {
      if (algorithm <= 3) {
        keyLength = 40;
      } else {
        var cfDict = dict.get('CF');
        var streamCryptoName = dict.get('StmF');
        if (isDict(cfDict) && isName(streamCryptoName)) {
          cfDict.suppressEncryption = true;
          var handlerDict = cfDict.get(streamCryptoName.name);
          keyLength = handlerDict && handlerDict.get('Length') || 128;
          if (keyLength < 40) {
            keyLength <<= 3;
          }
        }
      }
    }
    if (!isInt(keyLength) || keyLength < 40 || keyLength % 8 !== 0) {
      error('invalid key length');
    }
    var ownerPassword = stringToBytes(dict.get('O')).subarray(0, 32);
    var userPassword = stringToBytes(dict.get('U')).subarray(0, 32);
    var flags = dict.get('P');
    var revision = dict.get('R');
    var encryptMetadata = (algorithm === 4 || algorithm === 5) && dict.get('EncryptMetadata') !== false;
    this.encryptMetadata = encryptMetadata;
    var fileIdBytes = stringToBytes(fileId);
    var passwordBytes;
    if (password) {
      if (revision === 6) {
        try {
          password = utf8StringToString(password);
        } catch (ex) {
          warn('CipherTransformFactory: ' + 'Unable to convert UTF8 encoded password.');
        }
      }
      passwordBytes = stringToBytes(password);
    }
    var encryptionKey;
    if (algorithm !== 5) {
      encryptionKey = prepareKeyData(fileIdBytes, passwordBytes, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
    } else {
      var ownerValidationSalt = stringToBytes(dict.get('O')).subarray(32, 40);
      var ownerKeySalt = stringToBytes(dict.get('O')).subarray(40, 48);
      var uBytes = stringToBytes(dict.get('U')).subarray(0, 48);
      var userValidationSalt = stringToBytes(dict.get('U')).subarray(32, 40);
      var userKeySalt = stringToBytes(dict.get('U')).subarray(40, 48);
      var ownerEncryption = stringToBytes(dict.get('OE'));
      var userEncryption = stringToBytes(dict.get('UE'));
      var perms = stringToBytes(dict.get('Perms'));
      encryptionKey = createEncryptionKey20(revision, passwordBytes, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms);
    }
    if (!encryptionKey && !password) {
      throw new PasswordException('No password given', PasswordResponses.NEED_PASSWORD);
    } else if (!encryptionKey && password) {
      var decodedPassword = decodeUserPassword(passwordBytes, ownerPassword, revision, keyLength);
      encryptionKey = prepareKeyData(fileIdBytes, decodedPassword, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
    }
    if (!encryptionKey) {
      throw new PasswordException('Incorrect Password', PasswordResponses.INCORRECT_PASSWORD);
    }
    this.encryptionKey = encryptionKey;
    if (algorithm >= 4) {
      var cf = dict.get('CF');
      if (isDict(cf)) {
        cf.suppressEncryption = true;
      }
      this.cf = cf;
      this.stmf = dict.get('StmF') || identityName;
      this.strf = dict.get('StrF') || identityName;
      this.eff = dict.get('EFF') || this.stmf;
    }
  }
  function buildObjectKey(num, gen, encryptionKey, isAes) {
    var key = new Uint8Array(encryptionKey.length + 9),
        i,
        n;
    for (i = 0, n = encryptionKey.length; i < n; ++i) {
      key[i] = encryptionKey[i];
    }
    key[i++] = num & 0xFF;
    key[i++] = num >> 8 & 0xFF;
    key[i++] = num >> 16 & 0xFF;
    key[i++] = gen & 0xFF;
    key[i++] = gen >> 8 & 0xFF;
    if (isAes) {
      key[i++] = 0x73;
      key[i++] = 0x41;
      key[i++] = 0x6C;
      key[i++] = 0x54;
    }
    var hash = calculateMD5(key, 0, i);
    return hash.subarray(0, Math.min(encryptionKey.length + 5, 16));
  }
  function buildCipherConstructor(cf, name, num, gen, key) {
    assert(isName(name), 'Invalid crypt filter name.');
    var cryptFilter = cf.get(name.name);
    var cfm;
    if (cryptFilter !== null && cryptFilter !== undefined) {
      cfm = cryptFilter.get('CFM');
    }
    if (!cfm || cfm.name === 'None') {
      return function cipherTransformFactoryBuildCipherConstructorNone() {
        return new NullCipher();
      };
    }
    if (cfm.name === 'V2') {
      return function cipherTransformFactoryBuildCipherConstructorV2() {
        return new ARCFourCipher(buildObjectKey(num, gen, key, false));
      };
    }
    if (cfm.name === 'AESV2') {
      return function cipherTransformFactoryBuildCipherConstructorAESV2() {
        return new AES128Cipher(buildObjectKey(num, gen, key, true));
      };
    }
    if (cfm.name === 'AESV3') {
      return function cipherTransformFactoryBuildCipherConstructorAESV3() {
        return new AES256Cipher(key);
      };
    }
    error('Unknown crypto method');
  }
  CipherTransformFactory.prototype = {
    createCipherTransform: function CipherTransformFactory_createCipherTransform(num, gen) {
      if (this.algorithm === 4 || this.algorithm === 5) {
        return new CipherTransform(buildCipherConstructor(this.cf, this.stmf, num, gen, this.encryptionKey), buildCipherConstructor(this.cf, this.strf, num, gen, this.encryptionKey));
      }
      var key = buildObjectKey(num, gen, this.encryptionKey, false);
      var cipherConstructor = function buildCipherCipherConstructor() {
        return new ARCFourCipher(key);
      };
      return new CipherTransform(cipherConstructor, cipherConstructor);
    }
  };
  return CipherTransformFactory;
}();
exports.AES128Cipher = AES128Cipher;
exports.AES256Cipher = AES256Cipher;
exports.ARCFourCipher = ARCFourCipher;
exports.CipherTransformFactory = CipherTransformFactory;
exports.PDF17 = PDF17;
exports.PDF20 = PDF20;
exports.calculateMD5 = calculateMD5;
exports.calculateSHA256 = calculateSHA256;
exports.calculateSHA384 = calculateSHA384;
exports.calculateSHA512 = calculateSHA512;

/***/ }),
/* 14 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var corePrimitives = __w_pdfjs_require__(1);
var coreStream = __w_pdfjs_require__(2);
var coreParser = __w_pdfjs_require__(5);
var coreImage = __w_pdfjs_require__(27);
var coreColorSpace = __w_pdfjs_require__(3);
var coreMurmurHash3 = __w_pdfjs_require__(31);
var coreFonts = __w_pdfjs_require__(26);
var coreFunction = __w_pdfjs_require__(6);
var corePattern = __w_pdfjs_require__(32);
var coreCMap = __w_pdfjs_require__(23);
var coreMetrics = __w_pdfjs_require__(30);
var coreBidi = __w_pdfjs_require__(21);
var coreEncodings = __w_pdfjs_require__(4);
var coreStandardFonts = __w_pdfjs_require__(17);
var coreUnicode = __w_pdfjs_require__(18);
var coreGlyphList = __w_pdfjs_require__(7);
var FONT_IDENTITY_MATRIX = sharedUtil.FONT_IDENTITY_MATRIX;
var IDENTITY_MATRIX = sharedUtil.IDENTITY_MATRIX;
var UNSUPPORTED_FEATURES = sharedUtil.UNSUPPORTED_FEATURES;
var ImageKind = sharedUtil.ImageKind;
var OPS = sharedUtil.OPS;
var TextRenderingMode = sharedUtil.TextRenderingMode;
var CMapCompressionType = sharedUtil.CMapCompressionType;
var Util = sharedUtil.Util;
var assert = sharedUtil.assert;
var createPromiseCapability = sharedUtil.createPromiseCapability;
var error = sharedUtil.error;
var info = sharedUtil.info;
var isArray = sharedUtil.isArray;
var isNum = sharedUtil.isNum;
var isString = sharedUtil.isString;
var getLookupTableFactory = sharedUtil.getLookupTableFactory;
var warn = sharedUtil.warn;
var Dict = corePrimitives.Dict;
var Name = corePrimitives.Name;
var isEOF = corePrimitives.isEOF;
var isCmd = corePrimitives.isCmd;
var isDict = corePrimitives.isDict;
var isName = corePrimitives.isName;
var isRef = corePrimitives.isRef;
var isStream = corePrimitives.isStream;
var DecodeStream = coreStream.DecodeStream;
var JpegStream = coreStream.JpegStream;
var Stream = coreStream.Stream;
var Lexer = coreParser.Lexer;
var Parser = coreParser.Parser;
var PDFImage = coreImage.PDFImage;
var ColorSpace = coreColorSpace.ColorSpace;
var MurmurHash3_64 = coreMurmurHash3.MurmurHash3_64;
var ErrorFont = coreFonts.ErrorFont;
var FontFlags = coreFonts.FontFlags;
var Font = coreFonts.Font;
var IdentityToUnicodeMap = coreFonts.IdentityToUnicodeMap;
var ToUnicodeMap = coreFonts.ToUnicodeMap;
var getFontType = coreFonts.getFontType;
var isPDFFunction = coreFunction.isPDFFunction;
var PDFFunction = coreFunction.PDFFunction;
var Pattern = corePattern.Pattern;
var getTilingPatternIR = corePattern.getTilingPatternIR;
var CMapFactory = coreCMap.CMapFactory;
var IdentityCMap = coreCMap.IdentityCMap;
var getMetrics = coreMetrics.getMetrics;
var bidi = coreBidi.bidi;
var WinAnsiEncoding = coreEncodings.WinAnsiEncoding;
var StandardEncoding = coreEncodings.StandardEncoding;
var MacRomanEncoding = coreEncodings.MacRomanEncoding;
var SymbolSetEncoding = coreEncodings.SymbolSetEncoding;
var ZapfDingbatsEncoding = coreEncodings.ZapfDingbatsEncoding;
var getEncoding = coreEncodings.getEncoding;
var getStdFontMap = coreStandardFonts.getStdFontMap;
var getSerifFonts = coreStandardFonts.getSerifFonts;
var getSymbolsFonts = coreStandardFonts.getSymbolsFonts;
var getNormalizedUnicodes = coreUnicode.getNormalizedUnicodes;
var reverseIfRtl = coreUnicode.reverseIfRtl;
var getUnicodeForGlyph = coreUnicode.getUnicodeForGlyph;
var getGlyphsUnicode = coreGlyphList.getGlyphsUnicode;
var PartialEvaluator = function PartialEvaluatorClosure() {
  var DefaultPartialEvaluatorOptions = {
    forceDataSchema: false,
    maxImageSize: -1,
    disableFontFace: false,
    disableNativeImageDecoder: false,
    ignoreErrors: false
  };
  function NativeImageDecoder(xref, resources, handler, forceDataSchema) {
    this.xref = xref;
    this.resources = resources;
    this.handler = handler;
    this.forceDataSchema = forceDataSchema;
  }
  NativeImageDecoder.prototype = {
    canDecode: function canDecode(image) {
      return image instanceof JpegStream && NativeImageDecoder.isDecodable(image, this.xref, this.resources);
    },
    decode: function decode(image) {
      var dict = image.dict;
      var colorSpace = dict.get('ColorSpace', 'CS');
      colorSpace = ColorSpace.parse(colorSpace, this.xref, this.resources);
      var numComps = colorSpace.numComps;
      var decodePromise = this.handler.sendWithPromise('JpegDecode', [image.getIR(this.forceDataSchema), numComps]);
      return decodePromise.then(function (message) {
        var data = message.data;
        return new Stream(data, 0, data.length, image.dict);
      });
    }
  };
  NativeImageDecoder.isSupported = function NativeImageDecoder_isSupported(image, xref, res) {
    var dict = image.dict;
    if (dict.has('DecodeParms') || dict.has('DP')) {
      return false;
    }
    var cs = ColorSpace.parse(dict.get('ColorSpace', 'CS'), xref, res);
    return (cs.name === 'DeviceGray' || cs.name === 'DeviceRGB') && cs.isDefaultDecode(dict.getArray('Decode', 'D'));
  };
  NativeImageDecoder.isDecodable = function NativeImageDecoder_isDecodable(image, xref, res) {
    var dict = image.dict;
    if (dict.has('DecodeParms') || dict.has('DP')) {
      return false;
    }
    var cs = ColorSpace.parse(dict.get('ColorSpace', 'CS'), xref, res);
    return (cs.numComps === 1 || cs.numComps === 3) && cs.isDefaultDecode(dict.getArray('Decode', 'D'));
  };
  function PartialEvaluator(pdfManager, xref, handler, pageIndex, idFactory, fontCache, builtInCMapCache, options) {
    this.pdfManager = pdfManager;
    this.xref = xref;
    this.handler = handler;
    this.pageIndex = pageIndex;
    this.idFactory = idFactory;
    this.fontCache = fontCache;
    this.builtInCMapCache = builtInCMapCache;
    this.options = options || DefaultPartialEvaluatorOptions;
    this.fetchBuiltInCMap = function (name) {
      var cachedCMap = builtInCMapCache[name];
      if (cachedCMap) {
        return Promise.resolve(cachedCMap);
      }
      return handler.sendWithPromise('FetchBuiltInCMap', { name: name }).then(function (data) {
        if (data.compressionType !== CMapCompressionType.NONE) {
          builtInCMapCache[name] = data;
        }
        return data;
      });
    };
  }
  var TIME_SLOT_DURATION_MS = 20;
  var CHECK_TIME_EVERY = 100;
  function TimeSlotManager() {
    this.reset();
  }
  TimeSlotManager.prototype = {
    check: function TimeSlotManager_check() {
      if (++this.checked < CHECK_TIME_EVERY) {
        return false;
      }
      this.checked = 0;
      return this.endTime <= Date.now();
    },
    reset: function TimeSlotManager_reset() {
      this.endTime = Date.now() + TIME_SLOT_DURATION_MS;
      this.checked = 0;
    }
  };
  function normalizeBlendMode(value) {
    if (!isName(value)) {
      return 'source-over';
    }
    switch (value.name) {
      case 'Normal':
      case 'Compatible':
        return 'source-over';
      case 'Multiply':
        return 'multiply';
      case 'Screen':
        return 'screen';
      case 'Overlay':
        return 'overlay';
      case 'Darken':
        return 'darken';
      case 'Lighten':
        return 'lighten';
      case 'ColorDodge':
        return 'color-dodge';
      case 'ColorBurn':
        return 'color-burn';
      case 'HardLight':
        return 'hard-light';
      case 'SoftLight':
        return 'soft-light';
      case 'Difference':
        return 'difference';
      case 'Exclusion':
        return 'exclusion';
      case 'Hue':
        return 'hue';
      case 'Saturation':
        return 'saturation';
      case 'Color':
        return 'color';
      case 'Luminosity':
        return 'luminosity';
    }
    warn('Unsupported blend mode: ' + value.name);
    return 'source-over';
  }
  var deferred = Promise.resolve();
  var TILING_PATTERN = 1,
      SHADING_PATTERN = 2;
  PartialEvaluator.prototype = {
    clone: function clone(newOptions) {
      newOptions = newOptions || DefaultPartialEvaluatorOptions;
      var newEvaluator = Object.create(this);
      newEvaluator.options = newOptions;
      return newEvaluator;
    },
    hasBlendModes: function PartialEvaluator_hasBlendModes(resources) {
      if (!isDict(resources)) {
        return false;
      }
      var processed = Object.create(null);
      if (resources.objId) {
        processed[resources.objId] = true;
      }
      var nodes = [resources],
          xref = this.xref;
      while (nodes.length) {
        var key, i, ii;
        var node = nodes.shift();
        var graphicStates = node.get('ExtGState');
        if (isDict(graphicStates)) {
          var graphicStatesKeys = graphicStates.getKeys();
          for (i = 0, ii = graphicStatesKeys.length; i < ii; i++) {
            key = graphicStatesKeys[i];
            var graphicState = graphicStates.get(key);
            var bm = graphicState.get('BM');
            if (isName(bm) && bm.name !== 'Normal') {
              return true;
            }
          }
        }
        var xObjects = node.get('XObject');
        if (!isDict(xObjects)) {
          continue;
        }
        var xObjectsKeys = xObjects.getKeys();
        for (i = 0, ii = xObjectsKeys.length; i < ii; i++) {
          key = xObjectsKeys[i];
          var xObject = xObjects.getRaw(key);
          if (isRef(xObject)) {
            if (processed[xObject.toString()]) {
              continue;
            }
            xObject = xref.fetch(xObject);
          }
          if (!isStream(xObject)) {
            continue;
          }
          if (xObject.dict.objId) {
            if (processed[xObject.dict.objId]) {
              continue;
            }
            processed[xObject.dict.objId] = true;
          }
          var xResources = xObject.dict.get('Resources');
          if (isDict(xResources) && (!xResources.objId || !processed[xResources.objId])) {
            nodes.push(xResources);
            if (xResources.objId) {
              processed[xResources.objId] = true;
            }
          }
        }
      }
      return false;
    },
    buildFormXObject: function PartialEvaluator_buildFormXObject(resources, xobj, smask, operatorList, task, initialState) {
      var dict = xobj.dict;
      var matrix = dict.getArray('Matrix');
      var bbox = dict.getArray('BBox');
      var group = dict.get('Group');
      if (group) {
        var groupOptions = {
          matrix: matrix,
          bbox: bbox,
          smask: smask,
          isolated: false,
          knockout: false
        };
        var groupSubtype = group.get('S');
        var colorSpace;
        if (isName(groupSubtype, 'Transparency')) {
          groupOptions.isolated = group.get('I') || false;
          groupOptions.knockout = group.get('K') || false;
          colorSpace = group.has('CS') ? ColorSpace.parse(group.get('CS'), this.xref, resources) : null;
        }
        if (smask && smask.backdrop) {
          colorSpace = colorSpace || ColorSpace.singletons.rgb;
          smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
        }
        operatorList.addOp(OPS.beginGroup, [groupOptions]);
      }
      operatorList.addOp(OPS.paintFormXObjectBegin, [matrix, bbox]);
      return this.getOperatorList(xobj, task, dict.get('Resources') || resources, operatorList, initialState).then(function () {
        operatorList.addOp(OPS.paintFormXObjectEnd, []);
        if (group) {
          operatorList.addOp(OPS.endGroup, [groupOptions]);
        }
      });
    },
    buildPaintImageXObject: function PartialEvaluator_buildPaintImageXObject(resources, image, inline, operatorList, cacheKey, imageCache) {
      var self = this;
      var dict = image.dict;
      var w = dict.get('Width', 'W');
      var h = dict.get('Height', 'H');
      if (!(w && isNum(w)) || !(h && isNum(h))) {
        warn('Image dimensions are missing, or not numbers.');
        return;
      }
      var maxImageSize = this.options.maxImageSize;
      if (maxImageSize !== -1 && w * h > maxImageSize) {
        warn('Image exceeded maximum allowed size and was removed.');
        return;
      }
      var imageMask = dict.get('ImageMask', 'IM') || false;
      var imgData, args;
      if (imageMask) {
        var width = dict.get('Width', 'W');
        var height = dict.get('Height', 'H');
        var bitStrideLength = width + 7 >> 3;
        var imgArray = image.getBytes(bitStrideLength * height);
        var decode = dict.getArray('Decode', 'D');
        var inverseDecode = !!decode && decode[0] > 0;
        imgData = PDFImage.createMask(imgArray, width, height, image instanceof DecodeStream, inverseDecode);
        imgData.cached = true;
        args = [imgData];
        operatorList.addOp(OPS.paintImageMaskXObject, args);
        if (cacheKey) {
          imageCache[cacheKey] = {
            fn: OPS.paintImageMaskXObject,
            args: args
          };
        }
        return;
      }
      var softMask = dict.get('SMask', 'SM') || false;
      var mask = dict.get('Mask') || false;
      var SMALL_IMAGE_DIMENSIONS = 200;
      if (inline && !softMask && !mask && !(image instanceof JpegStream) && w + h < SMALL_IMAGE_DIMENSIONS) {
        var imageObj = new PDFImage(this.xref, resources, image, inline, null, null);
        imgData = imageObj.createImageData(true);
        operatorList.addOp(OPS.paintInlineImageXObject, [imgData]);
        return;
      }
      var useNativeImageDecoder = !this.options.disableNativeImageDecoder;
      var objId = 'img_' + this.idFactory.createObjId();
      operatorList.addDependency(objId);
      args = [objId, w, h];
      if (useNativeImageDecoder && !softMask && !mask && image instanceof JpegStream && NativeImageDecoder.isSupported(image, this.xref, resources)) {
        operatorList.addOp(OPS.paintJpegXObject, args);
        this.handler.send('obj', [objId, this.pageIndex, 'JpegStream', image.getIR(this.options.forceDataSchema)]);
        return;
      }
      var nativeImageDecoder = null;
      if (useNativeImageDecoder && (image instanceof JpegStream || mask instanceof JpegStream || softMask instanceof JpegStream)) {
        nativeImageDecoder = new NativeImageDecoder(self.xref, resources, self.handler, self.options.forceDataSchema);
      }
      PDFImage.buildImage(self.handler, self.xref, resources, image, inline, nativeImageDecoder).then(function (imageObj) {
        var imgData = imageObj.createImageData(false);
        self.handler.send('obj', [objId, self.pageIndex, 'Image', imgData], [imgData.data.buffer]);
      }).then(undefined, function (reason) {
        warn('Unable to decode image: ' + reason);
        self.handler.send('obj', [objId, self.pageIndex, 'Image', null]);
      });
      operatorList.addOp(OPS.paintImageXObject, args);
      if (cacheKey) {
        imageCache[cacheKey] = {
          fn: OPS.paintImageXObject,
          args: args
        };
      }
    },
    handleSMask: function PartialEvaluator_handleSmask(smask, resources, operatorList, task, stateManager) {
      var smaskContent = smask.get('G');
      var smaskOptions = {
        subtype: smask.get('S').name,
        backdrop: smask.get('BC')
      };
      var transferObj = smask.get('TR');
      if (isPDFFunction(transferObj)) {
        var transferFn = PDFFunction.parse(this.xref, transferObj);
        var transferMap = new Uint8Array(256);
        var tmp = new Float32Array(1);
        for (var i = 0; i < 256; i++) {
          tmp[0] = i / 255;
          transferFn(tmp, 0, tmp, 0);
          transferMap[i] = tmp[0] * 255 | 0;
        }
        smaskOptions.transferMap = transferMap;
      }
      return this.buildFormXObject(resources, smaskContent, smaskOptions, operatorList, task, stateManager.state.clone());
    },
    handleTilingType: function PartialEvaluator_handleTilingType(fn, args, resources, pattern, patternDict, operatorList, task) {
      var tilingOpList = new OperatorList();
      var resourcesArray = [patternDict.get('Resources'), resources];
      var patternResources = Dict.merge(this.xref, resourcesArray);
      return this.getOperatorList(pattern, task, patternResources, tilingOpList).then(function () {
        operatorList.addDependencies(tilingOpList.dependencies);
        operatorList.addOp(fn, getTilingPatternIR({
          fnArray: tilingOpList.fnArray,
          argsArray: tilingOpList.argsArray
        }, patternDict, args));
      });
    },
    handleSetFont: function PartialEvaluator_handleSetFont(resources, fontArgs, fontRef, operatorList, task, state) {
      var fontName;
      if (fontArgs) {
        fontArgs = fontArgs.slice();
        fontName = fontArgs[0].name;
      }
      var self = this;
      return this.loadFont(fontName, fontRef, resources).then(function (translated) {
        if (!translated.font.isType3Font) {
          return translated;
        }
        return translated.loadType3Data(self, resources, operatorList, task).then(function () {
          return translated;
        }, function (reason) {
          self.handler.send('UnsupportedFeature', { featureId: UNSUPPORTED_FEATURES.font });
          return new TranslatedFont('g_font_error', new ErrorFont('Type3 font load error: ' + reason), translated.font);
        });
      }).then(function (translated) {
        state.font = translated.font;
        translated.send(self.handler);
        return translated.loadedName;
      });
    },
    handleText: function PartialEvaluator_handleText(chars, state) {
      var font = state.font;
      var glyphs = font.charsToGlyphs(chars);
      var isAddToPathSet = !!(state.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);
      if (font.data && (isAddToPathSet || this.options.disableFontFace)) {
        var buildPath = function (fontChar) {
          if (!font.renderer.hasBuiltPath(fontChar)) {
            var path = font.renderer.getPathJs(fontChar);
            this.handler.send('commonobj', [font.loadedName + '_path_' + fontChar, 'FontPath', path]);
          }
        }.bind(this);
        for (var i = 0, ii = glyphs.length; i < ii; i++) {
          var glyph = glyphs[i];
          buildPath(glyph.fontChar);
          var accent = glyph.accent;
          if (accent && accent.fontChar) {
            buildPath(accent.fontChar);
          }
        }
      }
      return glyphs;
    },
    setGState: function PartialEvaluator_setGState(resources, gState, operatorList, task, stateManager) {
      var gStateObj = [];
      var gStateKeys = gState.getKeys();
      var self = this;
      var promise = Promise.resolve();
      for (var i = 0, ii = gStateKeys.length; i < ii; i++) {
        var key = gStateKeys[i];
        var value = gState.get(key);
        switch (key) {
          case 'Type':
            break;
          case 'LW':
          case 'LC':
          case 'LJ':
          case 'ML':
          case 'D':
          case 'RI':
          case 'FL':
          case 'CA':
          case 'ca':
            gStateObj.push([key, value]);
            break;
          case 'Font':
            promise = promise.then(function () {
              return self.handleSetFont(resources, null, value[0], operatorList, task, stateManager.state).then(function (loadedName) {
                operatorList.addDependency(loadedName);
                gStateObj.push([key, [loadedName, value[1]]]);
              });
            });
            break;
          case 'BM':
            gStateObj.push([key, normalizeBlendMode(value)]);
            break;
          case 'SMask':
            if (isName(value, 'None')) {
              gStateObj.push([key, false]);
              break;
            }
            if (isDict(value)) {
              promise = promise.then(function (dict) {
                return self.handleSMask(dict, resources, operatorList, task, stateManager);
              }.bind(this, value));
              gStateObj.push([key, true]);
            } else {
              warn('Unsupported SMask type');
            }
            break;
          case 'OP':
          case 'op':
          case 'OPM':
          case 'BG':
          case 'BG2':
          case 'UCR':
          case 'UCR2':
          case 'TR':
          case 'TR2':
          case 'HT':
          case 'SM':
          case 'SA':
          case 'AIS':
          case 'TK':
            info('graphic state operator ' + key);
            break;
          default:
            info('Unknown graphic state operator ' + key);
            break;
        }
      }
      return promise.then(function () {
        if (gStateObj.length > 0) {
          operatorList.addOp(OPS.setGState, [gStateObj]);
        }
      });
    },
    loadFont: function PartialEvaluator_loadFont(fontName, font, resources) {
      function errorFont() {
        return Promise.resolve(new TranslatedFont('g_font_error', new ErrorFont('Font ' + fontName + ' is not available'), font));
      }
      var fontRef,
          xref = this.xref;
      if (font) {
        assert(isRef(font));
        fontRef = font;
      } else {
        var fontRes = resources.get('Font');
        if (fontRes) {
          fontRef = fontRes.getRaw(fontName);
        } else {
          warn('fontRes not available');
          return errorFont();
        }
      }
      if (!fontRef) {
        warn('fontRef not available');
        return errorFont();
      }
      if (this.fontCache.has(fontRef)) {
        return this.fontCache.get(fontRef);
      }
      font = xref.fetchIfRef(fontRef);
      if (!isDict(font)) {
        return errorFont();
      }
      if (font.translated) {
        return font.translated;
      }
      var fontCapability = createPromiseCapability();
      var preEvaluatedFont = this.preEvaluateFont(font);
      var descriptor = preEvaluatedFont.descriptor;
      var fontRefIsRef = isRef(fontRef),
          fontID;
      if (fontRefIsRef) {
        fontID = fontRef.toString();
      }
      if (isDict(descriptor)) {
        if (!descriptor.fontAliases) {
          descriptor.fontAliases = Object.create(null);
        }
        var fontAliases = descriptor.fontAliases;
        var hash = preEvaluatedFont.hash;
        if (fontAliases[hash]) {
          var aliasFontRef = fontAliases[hash].aliasRef;
          if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
            this.fontCache.putAlias(fontRef, aliasFontRef);
            return this.fontCache.get(fontRef);
          }
        } else {
          fontAliases[hash] = { fontID: Font.getFontID() };
        }
        if (fontRefIsRef) {
          fontAliases[hash].aliasRef = fontRef;
        }
        fontID = fontAliases[hash].fontID;
      }
      if (fontRefIsRef) {
        this.fontCache.put(fontRef, fontCapability.promise);
      } else {
        if (!fontID) {
          fontID = this.idFactory.createObjId();
        }
        this.fontCache.put('id_' + fontID, fontCapability.promise);
      }
      assert(fontID, 'The "fontID" must be defined.');
      font.loadedName = 'g_' + this.pdfManager.docId + '_f' + fontID;
      font.translated = fontCapability.promise;
      var translatedPromise;
      try {
        translatedPromise = this.translateFont(preEvaluatedFont);
      } catch (e) {
        translatedPromise = Promise.reject(e);
      }
      var self = this;
      translatedPromise.then(function (translatedFont) {
        if (translatedFont.fontType !== undefined) {
          var xrefFontStats = xref.stats.fontTypes;
          xrefFontStats[translatedFont.fontType] = true;
        }
        fontCapability.resolve(new TranslatedFont(font.loadedName, translatedFont, font));
      }, function (reason) {
        self.handler.send('UnsupportedFeature', { featureId: UNSUPPORTED_FEATURES.font });
        try {
          var descriptor = preEvaluatedFont.descriptor;
          var fontFile3 = descriptor && descriptor.get('FontFile3');
          var subtype = fontFile3 && fontFile3.get('Subtype');
          var fontType = getFontType(preEvaluatedFont.type, subtype && subtype.name);
          var xrefFontStats = xref.stats.fontTypes;
          xrefFontStats[fontType] = true;
        } catch (ex) {}
        fontCapability.resolve(new TranslatedFont(font.loadedName, new ErrorFont(reason instanceof Error ? reason.message : reason), font));
      });
      return fontCapability.promise;
    },
    buildPath: function PartialEvaluator_buildPath(operatorList, fn, args) {
      var lastIndex = operatorList.length - 1;
      if (!args) {
        args = [];
      }
      if (lastIndex < 0 || operatorList.fnArray[lastIndex] !== OPS.constructPath) {
        operatorList.addOp(OPS.constructPath, [[fn], args]);
      } else {
        var opArgs = operatorList.argsArray[lastIndex];
        opArgs[0].push(fn);
        Array.prototype.push.apply(opArgs[1], args);
      }
    },
    handleColorN: function PartialEvaluator_handleColorN(operatorList, fn, args, cs, patterns, resources, task) {
      var patternName = args[args.length - 1];
      var pattern;
      if (isName(patternName) && (pattern = patterns.get(patternName.name))) {
        var dict = isStream(pattern) ? pattern.dict : pattern;
        var typeNum = dict.get('PatternType');
        if (typeNum === TILING_PATTERN) {
          var color = cs.base ? cs.base.getRgb(args, 0) : null;
          return this.handleTilingType(fn, color, resources, pattern, dict, operatorList, task);
        } else if (typeNum === SHADING_PATTERN) {
          var shading = dict.get('Shading');
          var matrix = dict.getArray('Matrix');
          pattern = Pattern.parseShading(shading, matrix, this.xref, resources, this.handler);
          operatorList.addOp(fn, pattern.getIR());
          return Promise.resolve();
        }
        return Promise.reject(new Error('Unknown PatternType: ' + typeNum));
      }
      operatorList.addOp(fn, args);
      return Promise.resolve();
    },
    getOperatorList: function PartialEvaluator_getOperatorList(stream, task, resources, operatorList, initialState) {
      var self = this;
      var xref = this.xref;
      var imageCache = Object.create(null);
      assert(operatorList);
      resources = resources || Dict.empty;
      var xobjs = resources.get('XObject') || Dict.empty;
      var patterns = resources.get('Pattern') || Dict.empty;
      var stateManager = new StateManager(initialState || new EvalState());
      var preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
      var timeSlotManager = new TimeSlotManager();
      function closePendingRestoreOPS(argument) {
        for (var i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
          operatorList.addOp(OPS.restore, []);
        }
      }
      return new Promise(function promiseBody(resolve, reject) {
        var next = function next(promise) {
          promise.then(function () {
            try {
              promiseBody(resolve, reject);
            } catch (ex) {
              reject(ex);
            }
          }, reject);
        };
        task.ensureNotTerminated();
        timeSlotManager.reset();
        var stop,
            operation = {},
            i,
            ii,
            cs;
        while (!(stop = timeSlotManager.check())) {
          operation.args = null;
          if (!preprocessor.read(operation)) {
            break;
          }
          var args = operation.args;
          var fn = operation.fn;
          switch (fn | 0) {
            case OPS.paintXObject:
              if (args[0].code) {
                break;
              }
              var name = args[0].name;
              if (!name) {
                warn('XObject must be referred to by name.');
                continue;
              }
              if (imageCache[name] !== undefined) {
                operatorList.addOp(imageCache[name].fn, imageCache[name].args);
                args = null;
                continue;
              }
              var xobj = xobjs.get(name);
              if (xobj) {
                assert(isStream(xobj), 'XObject should be a stream');
                var type = xobj.dict.get('Subtype');
                assert(isName(type), 'XObject should have a Name subtype');
                if (type.name === 'Form') {
                  stateManager.save();
                  next(self.buildFormXObject(resources, xobj, null, operatorList, task, stateManager.state.clone()).then(function () {
                    stateManager.restore();
                  }));
                  return;
                } else if (type.name === 'Image') {
                  self.buildPaintImageXObject(resources, xobj, false, operatorList, name, imageCache);
                  args = null;
                  continue;
                } else if (type.name === 'PS') {
                  info('Ignored XObject subtype PS');
                  continue;
                } else {
                  error('Unhandled XObject subtype ' + type.name);
                }
              }
              break;
            case OPS.setFont:
              var fontSize = args[1];
              next(self.handleSetFont(resources, args, null, operatorList, task, stateManager.state).then(function (loadedName) {
                operatorList.addDependency(loadedName);
                operatorList.addOp(OPS.setFont, [loadedName, fontSize]);
              }));
              return;
            case OPS.endInlineImage:
              var cacheKey = args[0].cacheKey;
              if (cacheKey) {
                var cacheEntry = imageCache[cacheKey];
                if (cacheEntry !== undefined) {
                  operatorList.addOp(cacheEntry.fn, cacheEntry.args);
                  args = null;
                  continue;
                }
              }
              self.buildPaintImageXObject(resources, args[0], true, operatorList, cacheKey, imageCache);
              args = null;
              continue;
            case OPS.showText:
              args[0] = self.handleText(args[0], stateManager.state);
              break;
            case OPS.showSpacedText:
              var arr = args[0];
              var combinedGlyphs = [];
              var arrLength = arr.length;
              var state = stateManager.state;
              for (i = 0; i < arrLength; ++i) {
                var arrItem = arr[i];
                if (isString(arrItem)) {
                  Array.prototype.push.apply(combinedGlyphs, self.handleText(arrItem, state));
                } else if (isNum(arrItem)) {
                  combinedGlyphs.push(arrItem);
                }
              }
              args[0] = combinedGlyphs;
              fn = OPS.showText;
              break;
            case OPS.nextLineShowText:
              operatorList.addOp(OPS.nextLine);
              args[0] = self.handleText(args[0], stateManager.state);
              fn = OPS.showText;
              break;
            case OPS.nextLineSetSpacingShowText:
              operatorList.addOp(OPS.nextLine);
              operatorList.addOp(OPS.setWordSpacing, [args.shift()]);
              operatorList.addOp(OPS.setCharSpacing, [args.shift()]);
              args[0] = self.handleText(args[0], stateManager.state);
              fn = OPS.showText;
              break;
            case OPS.setTextRenderingMode:
              stateManager.state.textRenderingMode = args[0];
              break;
            case OPS.setFillColorSpace:
              stateManager.state.fillColorSpace = ColorSpace.parse(args[0], xref, resources);
              continue;
            case OPS.setStrokeColorSpace:
              stateManager.state.strokeColorSpace = ColorSpace.parse(args[0], xref, resources);
              continue;
            case OPS.setFillColor:
              cs = stateManager.state.fillColorSpace;
              args = cs.getRgb(args, 0);
              fn = OPS.setFillRGBColor;
              break;
            case OPS.setStrokeColor:
              cs = stateManager.state.strokeColorSpace;
              args = cs.getRgb(args, 0);
              fn = OPS.setStrokeRGBColor;
              break;
            case OPS.setFillGray:
              stateManager.state.fillColorSpace = ColorSpace.singletons.gray;
              args = ColorSpace.singletons.gray.getRgb(args, 0);
              fn = OPS.setFillRGBColor;
              break;
            case OPS.setStrokeGray:
              stateManager.state.strokeColorSpace = ColorSpace.singletons.gray;
              args = ColorSpace.singletons.gray.getRgb(args, 0);
              fn = OPS.setStrokeRGBColor;
              break;
            case OPS.setFillCMYKColor:
              stateManager.state.fillColorSpace = ColorSpace.singletons.cmyk;
              args = ColorSpace.singletons.cmyk.getRgb(args, 0);
              fn = OPS.setFillRGBColor;
              break;
            case OPS.setStrokeCMYKColor:
              stateManager.state.strokeColorSpace = ColorSpace.singletons.cmyk;
              args = ColorSpace.singletons.cmyk.getRgb(args, 0);
              fn = OPS.setStrokeRGBColor;
              break;
            case OPS.setFillRGBColor:
              stateManager.state.fillColorSpace = ColorSpace.singletons.rgb;
              args = ColorSpace.singletons.rgb.getRgb(args, 0);
              break;
            case OPS.setStrokeRGBColor:
              stateManager.state.strokeColorSpace = ColorSpace.singletons.rgb;
              args = ColorSpace.singletons.rgb.getRgb(args, 0);
              break;
            case OPS.setFillColorN:
              cs = stateManager.state.fillColorSpace;
              if (cs.name === 'Pattern') {
                next(self.handleColorN(operatorList, OPS.setFillColorN, args, cs, patterns, resources, task));
                return;
              }
              args = cs.getRgb(args, 0);
              fn = OPS.setFillRGBColor;
              break;
            case OPS.setStrokeColorN:
              cs = stateManager.state.strokeColorSpace;
              if (cs.name === 'Pattern') {
                next(self.handleColorN(operatorList, OPS.setStrokeColorN, args, cs, patterns, resources, task));
                return;
              }
              args = cs.getRgb(args, 0);
              fn = OPS.setStrokeRGBColor;
              break;
            case OPS.shadingFill:
              var shadingRes = resources.get('Shading');
              assert(shadingRes, 'No shading resource found');
              var shading = shadingRes.get(args[0].name);
              assert(shading, 'No shading object found');
              var shadingFill = Pattern.parseShading(shading, null, xref, resources, self.handler);
              var patternIR = shadingFill.getIR();
              args = [patternIR];
              fn = OPS.shadingFill;
              break;
            case OPS.setGState:
              var dictName = args[0];
              var extGState = resources.get('ExtGState');
              if (!isDict(extGState) || !extGState.has(dictName.name)) {
                break;
              }
              var gState = extGState.get(dictName.name);
              next(self.setGState(resources, gState, operatorList, task, stateManager));
              return;
            case OPS.moveTo:
            case OPS.lineTo:
            case OPS.curveTo:
            case OPS.curveTo2:
            case OPS.curveTo3:
            case OPS.closePath:
              self.buildPath(operatorList, fn, args);
              continue;
            case OPS.rectangle:
              self.buildPath(operatorList, fn, args);
              continue;
            case OPS.markPoint:
            case OPS.markPointProps:
            case OPS.beginMarkedContent:
            case OPS.beginMarkedContentProps:
            case OPS.endMarkedContent:
            case OPS.beginCompat:
            case OPS.endCompat:
              continue;
            default:
              if (args !== null) {
                for (i = 0, ii = args.length; i < ii; i++) {
                  if (args[i] instanceof Dict) {
                    break;
                  }
                }
                if (i < ii) {
                  warn('getOperatorList - ignoring operator: ' + fn);
                  continue;
                }
              }
          }
          operatorList.addOp(fn, args);
        }
        if (stop) {
          next(deferred);
          return;
        }
        closePendingRestoreOPS();
        resolve();
      }).catch(function (reason) {
        if (this.options.ignoreErrors) {
          this.handler.send('UnsupportedFeature', { featureId: UNSUPPORTED_FEATURES.unknown });
          warn('getOperatorList - ignoring errors during task: ' + task.name);
          closePendingRestoreOPS();
          return;
        }
        throw reason;
      }.bind(this));
    },
    getTextContent: function PartialEvaluator_getTextContent(stream, task, resources, stateManager, normalizeWhitespace, combineTextItems) {
      stateManager = stateManager || new StateManager(new TextState());
      var WhitespaceRegexp = /\s/g;
      var textContent = {
        items: [],
        styles: Object.create(null)
      };
      var textContentItem = {
        initialized: false,
        str: [],
        width: 0,
        height: 0,
        vertical: false,
        lastAdvanceWidth: 0,
        lastAdvanceHeight: 0,
        textAdvanceScale: 0,
        spaceWidth: 0,
        fakeSpaceMin: Infinity,
        fakeMultiSpaceMin: Infinity,
        fakeMultiSpaceMax: -0,
        textRunBreakAllowed: false,
        transform: null,
        fontName: null
      };
      var SPACE_FACTOR = 0.3;
      var MULTI_SPACE_FACTOR = 1.5;
      var MULTI_SPACE_FACTOR_MAX = 4;
      var self = this;
      var xref = this.xref;
      resources = xref.fetchIfRef(resources) || Dict.empty;
      var xobjs = null;
      var xobjsCache = Object.create(null);
      var preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
      var textState;
      function ensureTextContentItem() {
        if (textContentItem.initialized) {
          return textContentItem;
        }
        var font = textState.font;
        if (!(font.loadedName in textContent.styles)) {
          textContent.styles[font.loadedName] = {
            fontFamily: font.fallbackName,
            ascent: font.ascent,
            descent: font.descent,
            vertical: font.vertical
          };
        }
        textContentItem.fontName = font.loadedName;
        var tsm = [textState.fontSize * textState.textHScale, 0, 0, textState.fontSize, 0, textState.textRise];
        if (font.isType3Font && textState.fontMatrix !== FONT_IDENTITY_MATRIX && textState.fontSize === 1) {
          var glyphHeight = font.bbox[3] - font.bbox[1];
          if (glyphHeight > 0) {
            glyphHeight = glyphHeight * textState.fontMatrix[3];
            tsm[3] *= glyphHeight;
          }
        }
        var trm = Util.transform(textState.ctm, Util.transform(textState.textMatrix, tsm));
        textContentItem.transform = trm;
        if (!font.vertical) {
          textContentItem.width = 0;
          textContentItem.height = Math.sqrt(trm[2] * trm[2] + trm[3] * trm[3]);
          textContentItem.vertical = false;
        } else {
          textContentItem.width = Math.sqrt(trm[0] * trm[0] + trm[1] * trm[1]);
          textContentItem.height = 0;
          textContentItem.vertical = true;
        }
        var a = textState.textLineMatrix[0];
        var b = textState.textLineMatrix[1];
        var scaleLineX = Math.sqrt(a * a + b * b);
        a = textState.ctm[0];
        b = textState.ctm[1];
        var scaleCtmX = Math.sqrt(a * a + b * b);
        textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
        textContentItem.lastAdvanceWidth = 0;
        textContentItem.lastAdvanceHeight = 0;
        var spaceWidth = font.spaceWidth / 1000 * textState.fontSize;
        if (spaceWidth) {
          textContentItem.spaceWidth = spaceWidth;
          textContentItem.fakeSpaceMin = spaceWidth * SPACE_FACTOR;
          textContentItem.fakeMultiSpaceMin = spaceWidth * MULTI_SPACE_FACTOR;
          textContentItem.fakeMultiSpaceMax = spaceWidth * MULTI_SPACE_FACTOR_MAX;
          textContentItem.textRunBreakAllowed = !font.isMonospace;
        } else {
          textContentItem.spaceWidth = 0;
          textContentItem.fakeSpaceMin = Infinity;
          textContentItem.fakeMultiSpaceMin = Infinity;
          textContentItem.fakeMultiSpaceMax = 0;
          textContentItem.textRunBreakAllowed = false;
        }
        textContentItem.initialized = true;
        return textContentItem;
      }
      function replaceWhitespace(str) {
        var i = 0,
            ii = str.length,
            code;
        while (i < ii && (code = str.charCodeAt(i)) >= 0x20 && code <= 0x7F) {
          i++;
        }
        return i < ii ? str.replace(WhitespaceRegexp, ' ') : str;
      }
      function runBidiTransform(textChunk) {
        var str = textChunk.str.join('');
        var bidiResult = bidi(str, -1, textChunk.vertical);
        return {
          str: normalizeWhitespace ? replaceWhitespace(bidiResult.str) : bidiResult.str,
          dir: bidiResult.dir,
          width: textChunk.width,
          height: textChunk.height,
          transform: textChunk.transform,
          fontName: textChunk.fontName
        };
      }
      function handleSetFont(fontName, fontRef) {
        return self.loadFont(fontName, fontRef, resources).then(function (translated) {
          textState.font = translated.font;
          textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
        });
      }
      function buildTextContentItem(chars) {
        var font = textState.font;
        var textChunk = ensureTextContentItem();
        var width = 0;
        var height = 0;
        var glyphs = font.charsToGlyphs(chars);
        for (var i = 0; i < glyphs.length; i++) {
          var glyph = glyphs[i];
          var glyphWidth = null;
          if (font.vertical && glyph.vmetric) {
            glyphWidth = glyph.vmetric[0];
          } else {
            glyphWidth = glyph.width;
          }
          var glyphUnicode = glyph.unicode;
          var NormalizedUnicodes = getNormalizedUnicodes();
          if (NormalizedUnicodes[glyphUnicode] !== undefined) {
            glyphUnicode = NormalizedUnicodes[glyphUnicode];
          }
          glyphUnicode = reverseIfRtl(glyphUnicode);
          var charSpacing = textState.charSpacing;
          if (glyph.isSpace) {
            var wordSpacing = textState.wordSpacing;
            charSpacing += wordSpacing;
            if (wordSpacing > 0) {
              addFakeSpaces(wordSpacing, textChunk.str);
            }
          }
          var tx = 0;
          var ty = 0;
          if (!font.vertical) {
            var w0 = glyphWidth * textState.fontMatrix[0];
            tx = (w0 * textState.fontSize + charSpacing) * textState.textHScale;
            width += tx;
          } else {
            var w1 = glyphWidth * textState.fontMatrix[0];
            ty = w1 * textState.fontSize + charSpacing;
            height += ty;
          }
          textState.translateTextMatrix(tx, ty);
          textChunk.str.push(glyphUnicode);
        }
        if (!font.vertical) {
          textChunk.lastAdvanceWidth = width;
          textChunk.width += width;
        } else {
          textChunk.lastAdvanceHeight = height;
          textChunk.height += Math.abs(height);
        }
        return textChunk;
      }
      function addFakeSpaces(width, strBuf) {
        if (width < textContentItem.fakeSpaceMin) {
          return;
        }
        if (width < textContentItem.fakeMultiSpaceMin) {
          strBuf.push(' ');
          return;
        }
        var fakeSpaces = Math.round(width / textContentItem.spaceWidth);
        while (fakeSpaces-- > 0) {
          strBuf.push(' ');
        }
      }
      function flushTextContentItem() {
        if (!textContentItem.initialized) {
          return;
        }
        textContentItem.width *= textContentItem.textAdvanceScale;
        textContentItem.height *= textContentItem.textAdvanceScale;
        textContent.items.push(runBidiTransform(textContentItem));
        textContentItem.initialized = false;
        textContentItem.str.length = 0;
      }
      var timeSlotManager = new TimeSlotManager();
      return new Promise(function promiseBody(resolve, reject) {
        var next = function next(promise) {
          promise.then(function () {
            try {
              promiseBody(resolve, reject);
            } catch (ex) {
              reject(ex);
            }
          }, reject);
        };
        task.ensureNotTerminated();
        timeSlotManager.reset();
        var stop,
            operation = {},
            args = [];
        while (!(stop = timeSlotManager.check())) {
          args.length = 0;
          operation.args = args;
          if (!preprocessor.read(operation)) {
            break;
          }
          textState = stateManager.state;
          var fn = operation.fn;
          args = operation.args;
          var advance, diff;
          switch (fn | 0) {
            case OPS.setFont:
              var fontNameArg = args[0].name,
                  fontSizeArg = args[1];
              if (textState.font && fontNameArg === textState.fontName && fontSizeArg === textState.fontSize) {
                break;
              }
              flushTextContentItem();
              textState.fontName = fontNameArg;
              textState.fontSize = fontSizeArg;
              next(handleSetFont(fontNameArg, null));
              return;
            case OPS.setTextRise:
              flushTextContentItem();
              textState.textRise = args[0];
              break;
            case OPS.setHScale:
              flushTextContentItem();
              textState.textHScale = args[0] / 100;
              break;
            case OPS.setLeading:
              flushTextContentItem();
              textState.leading = args[0];
              break;
            case OPS.moveText:
              var isSameTextLine = !textState.font ? false : (textState.font.vertical ? args[0] : args[1]) === 0;
              advance = args[0] - args[1];
              if (combineTextItems && isSameTextLine && textContentItem.initialized && advance > 0 && advance <= textContentItem.fakeMultiSpaceMax) {
                textState.translateTextLineMatrix(args[0], args[1]);
                textContentItem.width += args[0] - textContentItem.lastAdvanceWidth;
                textContentItem.height += args[1] - textContentItem.lastAdvanceHeight;
                diff = args[0] - textContentItem.lastAdvanceWidth - (args[1] - textContentItem.lastAdvanceHeight);
                addFakeSpaces(diff, textContentItem.str);
                break;
              }
              flushTextContentItem();
              textState.translateTextLineMatrix(args[0], args[1]);
              textState.textMatrix = textState.textLineMatrix.slice();
              break;
            case OPS.setLeadingMoveText:
              flushTextContentItem();
              textState.leading = -args[1];
              textState.translateTextLineMatrix(args[0], args[1]);
              textState.textMatrix = textState.textLineMatrix.slice();
              break;
            case OPS.nextLine:
              flushTextContentItem();
              textState.carriageReturn();
              break;
            case OPS.setTextMatrix:
              advance = textState.calcTextLineMatrixAdvance(args[0], args[1], args[2], args[3], args[4], args[5]);
              if (combineTextItems && advance !== null && textContentItem.initialized && advance.value > 0 && advance.value <= textContentItem.fakeMultiSpaceMax) {
                textState.translateTextLineMatrix(advance.width, advance.height);
                textContentItem.width += advance.width - textContentItem.lastAdvanceWidth;
                textContentItem.height += advance.height - textContentItem.lastAdvanceHeight;
                diff = advance.width - textContentItem.lastAdvanceWidth - (advance.height - textContentItem.lastAdvanceHeight);
                addFakeSpaces(diff, textContentItem.str);
                break;
              }
              flushTextContentItem();
              textState.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
              textState.setTextLineMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
              break;
            case OPS.setCharSpacing:
              textState.charSpacing = args[0];
              break;
            case OPS.setWordSpacing:
              textState.wordSpacing = args[0];
              break;
            case OPS.beginText:
              flushTextContentItem();
              textState.textMatrix = IDENTITY_MATRIX.slice();
              textState.textLineMatrix = IDENTITY_MATRIX.slice();
              break;
            case OPS.showSpacedText:
              var items = args[0];
              var offset;
              for (var j = 0, jj = items.length; j < jj; j++) {
                if (typeof items[j] === 'string') {
                  buildTextContentItem(items[j]);
                } else if (isNum(items[j])) {
                  ensureTextContentItem();
                  advance = items[j] * textState.fontSize / 1000;
                  var breakTextRun = false;
                  if (textState.font.vertical) {
                    offset = advance;
                    textState.translateTextMatrix(0, offset);
                    breakTextRun = textContentItem.textRunBreakAllowed && advance > textContentItem.fakeMultiSpaceMax;
                    if (!breakTextRun) {
                      textContentItem.height += offset;
                    }
                  } else {
                    advance = -advance;
                    offset = advance * textState.textHScale;
                    textState.translateTextMatrix(offset, 0);
                    breakTextRun = textContentItem.textRunBreakAllowed && advance > textContentItem.fakeMultiSpaceMax;
                    if (!breakTextRun) {
                      textContentItem.width += offset;
                    }
                  }
                  if (breakTextRun) {
                    flushTextContentItem();
                  } else if (advance > 0) {
                    addFakeSpaces(advance, textContentItem.str);
                  }
                }
              }
              break;
            case OPS.showText:
              buildTextContentItem(args[0]);
              break;
            case OPS.nextLineShowText:
              flushTextContentItem();
              textState.carriageReturn();
              buildTextContentItem(args[0]);
              break;
            case OPS.nextLineSetSpacingShowText:
              flushTextContentItem();
              textState.wordSpacing = args[0];
              textState.charSpacing = args[1];
              textState.carriageReturn();
              buildTextContentItem(args[2]);
              break;
            case OPS.paintXObject:
              flushTextContentItem();
              if (args[0].code) {
                break;
              }
              if (!xobjs) {
                xobjs = resources.get('XObject') || Dict.empty;
              }
              var name = args[0].name;
              if (xobjsCache.key === name) {
                if (xobjsCache.texts) {
                  Util.appendToArray(textContent.items, xobjsCache.texts.items);
                  Util.extendObj(textContent.styles, xobjsCache.texts.styles);
                }
                break;
              }
              var xobj = xobjs.get(name);
              if (!xobj) {
                break;
              }
              assert(isStream(xobj), 'XObject should be a stream');
              var type = xobj.dict.get('Subtype');
              assert(isName(type), 'XObject should have a Name subtype');
              if (type.name !== 'Form') {
                xobjsCache.key = name;
                xobjsCache.texts = null;
                break;
              }
              var currentState = stateManager.state.clone();
              var xObjStateManager = new StateManager(currentState);
              var matrix = xobj.dict.getArray('Matrix');
              if (isArray(matrix) && matrix.length === 6) {
                xObjStateManager.transform(matrix);
              }
              next(self.getTextContent(xobj, task, xobj.dict.get('Resources') || resources, xObjStateManager, normalizeWhitespace, combineTextItems).then(function (formTextContent) {
                Util.appendToArray(textContent.items, formTextContent.items);
                Util.extendObj(textContent.styles, formTextContent.styles);
                xobjsCache.key = name;
                xobjsCache.texts = formTextContent;
              }));
              return;
            case OPS.setGState:
              flushTextContentItem();
              var dictName = args[0];
              var extGState = resources.get('ExtGState');
              if (!isDict(extGState) || !isName(dictName)) {
                break;
              }
              var gState = extGState.get(dictName.name);
              if (!isDict(gState)) {
                break;
              }
              var gStateFont = gState.get('Font');
              if (gStateFont) {
                textState.fontName = null;
                textState.fontSize = gStateFont[1];
                next(handleSetFont(null, gStateFont[0]));
                return;
              }
              break;
          }
        }
        if (stop) {
          next(deferred);
          return;
        }
        flushTextContentItem();
        resolve(textContent);
      }).catch(function (reason) {
        if (this.options.ignoreErrors) {
          warn('getTextContent - ignoring errors during task: ' + task.name);
          flushTextContentItem();
          return textContent;
        }
        throw reason;
      }.bind(this));
    },
    extractDataStructures: function PartialEvaluator_extractDataStructures(dict, baseDict, properties) {
      var xref = this.xref;
      var toUnicode = dict.get('ToUnicode') || baseDict.get('ToUnicode');
      var toUnicodePromise = toUnicode ? this.readToUnicode(toUnicode) : Promise.resolve(undefined);
      if (properties.composite) {
        var cidSystemInfo = dict.get('CIDSystemInfo');
        if (isDict(cidSystemInfo)) {
          properties.cidSystemInfo = {
            registry: cidSystemInfo.get('Registry'),
            ordering: cidSystemInfo.get('Ordering'),
            supplement: cidSystemInfo.get('Supplement')
          };
        }
        var cidToGidMap = dict.get('CIDToGIDMap');
        if (isStream(cidToGidMap)) {
          properties.cidToGidMap = this.readCidToGidMap(cidToGidMap);
        }
      }
      var differences = [];
      var baseEncodingName = null;
      var encoding;
      if (dict.has('Encoding')) {
        encoding = dict.get('Encoding');
        if (isDict(encoding)) {
          baseEncodingName = encoding.get('BaseEncoding');
          baseEncodingName = isName(baseEncodingName) ? baseEncodingName.name : null;
          if (encoding.has('Differences')) {
            var diffEncoding = encoding.get('Differences');
            var index = 0;
            for (var j = 0, jj = diffEncoding.length; j < jj; j++) {
              var data = xref.fetchIfRef(diffEncoding[j]);
              if (isNum(data)) {
                index = data;
              } else if (isName(data)) {
                differences[index++] = data.name;
              } else {
                error('Invalid entry in \'Differences\' array: ' + data);
              }
            }
          }
        } else if (isName(encoding)) {
          baseEncodingName = encoding.name;
        } else {
          error('Encoding is not a Name nor a Dict');
        }
        if (baseEncodingName !== 'MacRomanEncoding' && baseEncodingName !== 'MacExpertEncoding' && baseEncodingName !== 'WinAnsiEncoding') {
          baseEncodingName = null;
        }
      }
      if (baseEncodingName) {
        properties.defaultEncoding = getEncoding(baseEncodingName).slice();
      } else {
        var isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
        var isNonsymbolicFont = !!(properties.flags & FontFlags.Nonsymbolic);
        encoding = StandardEncoding;
        if (properties.type === 'TrueType' && !isNonsymbolicFont) {
          encoding = WinAnsiEncoding;
        }
        if (isSymbolicFont) {
          encoding = MacRomanEncoding;
          if (!properties.file) {
            if (/Symbol/i.test(properties.name)) {
              encoding = SymbolSetEncoding;
            } else if (/Dingbats/i.test(properties.name)) {
              encoding = ZapfDingbatsEncoding;
            }
          }
        }
        properties.defaultEncoding = encoding;
      }
      properties.differences = differences;
      properties.baseEncodingName = baseEncodingName;
      properties.hasEncoding = !!baseEncodingName || differences.length > 0;
      properties.dict = dict;
      return toUnicodePromise.then(function (toUnicode) {
        properties.toUnicode = toUnicode;
        return this.buildToUnicode(properties);
      }.bind(this)).then(function (toUnicode) {
        properties.toUnicode = toUnicode;
        return properties;
      });
    },
    buildToUnicode: function PartialEvaluator_buildToUnicode(properties) {
      properties.hasIncludedToUnicodeMap = !!properties.toUnicode && properties.toUnicode.length > 0;
      if (properties.hasIncludedToUnicodeMap) {
        return Promise.resolve(properties.toUnicode);
      }
      var toUnicode, charcode, glyphName;
      if (!properties.composite) {
        toUnicode = [];
        var encoding = properties.defaultEncoding.slice();
        var baseEncodingName = properties.baseEncodingName;
        var differences = properties.differences;
        for (charcode in differences) {
          glyphName = differences[charcode];
          if (glyphName === '.notdef') {
            continue;
          }
          encoding[charcode] = glyphName;
        }
        var glyphsUnicodeMap = getGlyphsUnicode();
        for (charcode in encoding) {
          glyphName = encoding[charcode];
          if (glyphName === '') {
            continue;
          } else if (glyphsUnicodeMap[glyphName] === undefined) {
            var code = 0;
            switch (glyphName[0]) {
              case 'G':
                if (glyphName.length === 3) {
                  code = parseInt(glyphName.substr(1), 16);
                }
                break;
              case 'g':
                if (glyphName.length === 5) {
                  code = parseInt(glyphName.substr(1), 16);
                }
                break;
              case 'C':
              case 'c':
                if (glyphName.length >= 3) {
                  code = +glyphName.substr(1);
                }
                break;
              default:
                var unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
                if (unicode !== -1) {
                  code = unicode;
                }
            }
            if (code) {
              if (baseEncodingName && code === +charcode) {
                var baseEncoding = getEncoding(baseEncodingName);
                if (baseEncoding && (glyphName = baseEncoding[charcode])) {
                  toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]);
                  continue;
                }
              }
              toUnicode[charcode] = String.fromCharCode(code);
            }
            continue;
          }
          toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]);
        }
        return Promise.resolve(new ToUnicodeMap(toUnicode));
      }
      if (properties.composite && (properties.cMap.builtInCMap && !(properties.cMap instanceof IdentityCMap) || properties.cidSystemInfo.registry === 'Adobe' && (properties.cidSystemInfo.ordering === 'GB1' || properties.cidSystemInfo.ordering === 'CNS1' || properties.cidSystemInfo.ordering === 'Japan1' || properties.cidSystemInfo.ordering === 'Korea1'))) {
        var registry = properties.cidSystemInfo.registry;
        var ordering = properties.cidSystemInfo.ordering;
        var ucs2CMapName = Name.get(registry + '-' + ordering + '-UCS2');
        return CMapFactory.create({
          encoding: ucs2CMapName,
          fetchBuiltInCMap: this.fetchBuiltInCMap,
          useCMap: null
        }).then(function (ucs2CMap) {
          var cMap = properties.cMap;
          toUnicode = [];
          cMap.forEach(function (charcode, cid) {
            assert(cid <= 0xffff, 'Max size of CID is 65,535');
            var ucs2 = ucs2CMap.lookup(cid);
            if (ucs2) {
              toUnicode[charcode] = String.fromCharCode((ucs2.charCodeAt(0) << 8) + ucs2.charCodeAt(1));
            }
          });
          return new ToUnicodeMap(toUnicode);
        });
      }
      return Promise.resolve(new IdentityToUnicodeMap(properties.firstChar, properties.lastChar));
    },
    readToUnicode: function PartialEvaluator_readToUnicode(toUnicode) {
      var cmapObj = toUnicode;
      if (isName(cmapObj)) {
        return CMapFactory.create({
          encoding: cmapObj,
          fetchBuiltInCMap: this.fetchBuiltInCMap,
          useCMap: null
        }).then(function (cmap) {
          if (cmap instanceof IdentityCMap) {
            return new IdentityToUnicodeMap(0, 0xFFFF);
          }
          return new ToUnicodeMap(cmap.getMap());
        });
      } else if (isStream(cmapObj)) {
        return CMapFactory.create({
          encoding: cmapObj,
          fetchBuiltInCMap: this.fetchBuiltInCMap,
          useCMap: null
        }).then(function (cmap) {
          if (cmap instanceof IdentityCMap) {
            return new IdentityToUnicodeMap(0, 0xFFFF);
          }
          var map = new Array(cmap.length);
          cmap.forEach(function (charCode, token) {
            var str = [];
            for (var k = 0; k < token.length; k += 2) {
              var w1 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);
              if ((w1 & 0xF800) !== 0xD800) {
                str.push(w1);
                continue;
              }
              k += 2;
              var w2 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);
              str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);
            }
            map[charCode] = String.fromCharCode.apply(String, str);
          });
          return new ToUnicodeMap(map);
        });
      }
      return Promise.resolve(null);
    },
    readCidToGidMap: function PartialEvaluator_readCidToGidMap(cidToGidStream) {
      var glyphsData = cidToGidStream.getBytes();
      var result = [];
      for (var j = 0, jj = glyphsData.length; j < jj; j++) {
        var glyphID = glyphsData[j++] << 8 | glyphsData[j];
        if (glyphID === 0) {
          continue;
        }
        var code = j >> 1;
        result[code] = glyphID;
      }
      return result;
    },
    extractWidths: function PartialEvaluator_extractWidths(dict, descriptor, properties) {
      var xref = this.xref;
      var glyphsWidths = [];
      var defaultWidth = 0;
      var glyphsVMetrics = [];
      var defaultVMetrics;
      var i, ii, j, jj, start, code, widths;
      if (properties.composite) {
        defaultWidth = dict.get('DW') || 1000;
        widths = dict.get('W');
        if (widths) {
          for (i = 0, ii = widths.length; i < ii; i++) {
            start = xref.fetchIfRef(widths[i++]);
            code = xref.fetchIfRef(widths[i]);
            if (isArray(code)) {
              for (j = 0, jj = code.length; j < jj; j++) {
                glyphsWidths[start++] = xref.fetchIfRef(code[j]);
              }
            } else {
              var width = xref.fetchIfRef(widths[++i]);
              for (j = start; j <= code; j++) {
                glyphsWidths[j] = width;
              }
            }
          }
        }
        if (properties.vertical) {
          var vmetrics = dict.getArray('DW2') || [880, -1000];
          defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
          vmetrics = dict.get('W2');
          if (vmetrics) {
            for (i = 0, ii = vmetrics.length; i < ii; i++) {
              start = xref.fetchIfRef(vmetrics[i++]);
              code = xref.fetchIfRef(vmetrics[i]);
              if (isArray(code)) {
                for (j = 0, jj = code.length; j < jj; j++) {
                  glyphsVMetrics[start++] = [xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j])];
                }
              } else {
                var vmetric = [xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i])];
                for (j = start; j <= code; j++) {
                  glyphsVMetrics[j] = vmetric;
                }
              }
            }
          }
        }
      } else {
        var firstChar = properties.firstChar;
        widths = dict.get('Widths');
        if (widths) {
          j = firstChar;
          for (i = 0, ii = widths.length; i < ii; i++) {
            glyphsWidths[j++] = xref.fetchIfRef(widths[i]);
          }
          defaultWidth = parseFloat(descriptor.get('MissingWidth')) || 0;
        } else {
          var baseFontName = dict.get('BaseFont');
          if (isName(baseFontName)) {
            var metrics = this.getBaseFontMetrics(baseFontName.name);
            glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
            defaultWidth = metrics.defaultWidth;
          }
        }
      }
      var isMonospace = true;
      var firstWidth = defaultWidth;
      for (var glyph in glyphsWidths) {
        var glyphWidth = glyphsWidths[glyph];
        if (!glyphWidth) {
          continue;
        }
        if (!firstWidth) {
          firstWidth = glyphWidth;
          continue;
        }
        if (firstWidth !== glyphWidth) {
          isMonospace = false;
          break;
        }
      }
      if (isMonospace) {
        properties.flags |= FontFlags.FixedPitch;
      }
      properties.defaultWidth = defaultWidth;
      properties.widths = glyphsWidths;
      properties.defaultVMetrics = defaultVMetrics;
      properties.vmetrics = glyphsVMetrics;
    },
    isSerifFont: function PartialEvaluator_isSerifFont(baseFontName) {
      var fontNameWoStyle = baseFontName.split('-')[0];
      return fontNameWoStyle in getSerifFonts() || fontNameWoStyle.search(/serif/gi) !== -1;
    },
    getBaseFontMetrics: function PartialEvaluator_getBaseFontMetrics(name) {
      var defaultWidth = 0;
      var widths = [];
      var monospace = false;
      var stdFontMap = getStdFontMap();
      var lookupName = stdFontMap[name] || name;
      var Metrics = getMetrics();
      if (!(lookupName in Metrics)) {
        if (this.isSerifFont(name)) {
          lookupName = 'Times-Roman';
        } else {
          lookupName = 'Helvetica';
        }
      }
      var glyphWidths = Metrics[lookupName];
      if (isNum(glyphWidths)) {
        defaultWidth = glyphWidths;
        monospace = true;
      } else {
        widths = glyphWidths();
      }
      return {
        defaultWidth: defaultWidth,
        monospace: monospace,
        widths: widths
      };
    },
    buildCharCodeToWidth: function PartialEvaluator_bulildCharCodeToWidth(widthsByGlyphName, properties) {
      var widths = Object.create(null);
      var differences = properties.differences;
      var encoding = properties.defaultEncoding;
      for (var charCode = 0; charCode < 256; charCode++) {
        if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
          widths[charCode] = widthsByGlyphName[differences[charCode]];
          continue;
        }
        if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
          widths[charCode] = widthsByGlyphName[encoding[charCode]];
          continue;
        }
      }
      return widths;
    },
    preEvaluateFont: function PartialEvaluator_preEvaluateFont(dict) {
      var baseDict = dict;
      var type = dict.get('Subtype');
      assert(isName(type), 'invalid font Subtype');
      var composite = false;
      var uint8array;
      if (type.name === 'Type0') {
        var df = dict.get('DescendantFonts');
        assert(df, 'Descendant fonts are not specified');
        dict = isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
        type = dict.get('Subtype');
        assert(isName(type), 'invalid font Subtype');
        composite = true;
      }
      var descriptor = dict.get('FontDescriptor');
      if (descriptor) {
        var hash = new MurmurHash3_64();
        var encoding = baseDict.getRaw('Encoding');
        if (isName(encoding)) {
          hash.update(encoding.name);
        } else if (isRef(encoding)) {
          hash.update(encoding.toString());
        } else if (isDict(encoding)) {
          var keys = encoding.getKeys();
          for (var i = 0, ii = keys.length; i < ii; i++) {
            var entry = encoding.getRaw(keys[i]);
            if (isName(entry)) {
              hash.update(entry.name);
            } else if (isRef(entry)) {
              hash.update(entry.toString());
            } else if (isArray(entry)) {
              var diffLength = entry.length,
                  diffBuf = new Array(diffLength);
              for (var j = 0; j < diffLength; j++) {
                var diffEntry = entry[j];
                if (isName(diffEntry)) {
                  diffBuf[j] = diffEntry.name;
                } else if (isNum(diffEntry) || isRef(diffEntry)) {
                  diffBuf[j] = diffEntry.toString();
                }
              }
              hash.update(diffBuf.join());
            }
          }
        }
        var toUnicode = dict.get('ToUnicode') || baseDict.get('ToUnicode');
        if (isStream(toUnicode)) {
          var stream = toUnicode.str || toUnicode;
          uint8array = stream.buffer ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength) : new Uint8Array(stream.bytes.buffer, stream.start, stream.end - stream.start);
          hash.update(uint8array);
        } else if (isName(toUnicode)) {
          hash.update(toUnicode.name);
        }
        var widths = dict.get('Widths') || baseDict.get('Widths');
        if (widths) {
          uint8array = new Uint8Array(new Uint32Array(widths).buffer);
          hash.update(uint8array);
        }
      }
      return {
        descriptor: descriptor,
        dict: dict,
        baseDict: baseDict,
        composite: composite,
        type: type.name,
        hash: hash ? hash.hexdigest() : ''
      };
    },
    translateFont: function PartialEvaluator_translateFont(preEvaluatedFont) {
      var baseDict = preEvaluatedFont.baseDict;
      var dict = preEvaluatedFont.dict;
      var composite = preEvaluatedFont.composite;
      var descriptor = preEvaluatedFont.descriptor;
      var type = preEvaluatedFont.type;
      var maxCharIndex = composite ? 0xFFFF : 0xFF;
      var properties;
      if (!descriptor) {
        if (type === 'Type3') {
          descriptor = new Dict(null);
          descriptor.set('FontName', Name.get(type));
          descriptor.set('FontBBox', dict.getArray('FontBBox'));
        } else {
          var baseFontName = dict.get('BaseFont');
          assert(isName(baseFontName), 'Base font is not specified');
          baseFontName = baseFontName.name.replace(/[,_]/g, '-');
          var metrics = this.getBaseFontMetrics(baseFontName);
          var fontNameWoStyle = baseFontName.split('-')[0];
          var flags = (this.isSerifFont(fontNameWoStyle) ? FontFlags.Serif : 0) | (metrics.monospace ? FontFlags.FixedPitch : 0) | (getSymbolsFonts()[fontNameWoStyle] ? FontFlags.Symbolic : FontFlags.Nonsymbolic);
          properties = {
            type: type,
            name: baseFontName,
            widths: metrics.widths,
            defaultWidth: metrics.defaultWidth,
            flags: flags,
            firstChar: 0,
            lastChar: maxCharIndex
          };
          return this.extractDataStructures(dict, dict, properties).then(function (properties) {
            properties.widths = this.buildCharCodeToWidth(metrics.widths, properties);
            return new Font(baseFontName, null, properties);
          }.bind(this));
        }
      }
      var firstChar = dict.get('FirstChar') || 0;
      var lastChar = dict.get('LastChar') || maxCharIndex;
      var fontName = descriptor.get('FontName');
      var baseFont = dict.get('BaseFont');
      if (isString(fontName)) {
        fontName = Name.get(fontName);
      }
      if (isString(baseFont)) {
        baseFont = Name.get(baseFont);
      }
      if (type !== 'Type3') {
        var fontNameStr = fontName && fontName.name;
        var baseFontStr = baseFont && baseFont.name;
        if (fontNameStr !== baseFontStr) {
          info('The FontDescriptor\'s FontName is "' + fontNameStr + '" but should be the same as the Font\'s BaseFont "' + baseFontStr + '"');
          if (fontNameStr && baseFontStr && baseFontStr.indexOf(fontNameStr) === 0) {
            fontName = baseFont;
          }
        }
      }
      fontName = fontName || baseFont;
      assert(isName(fontName), 'invalid font name');
      var fontFile = descriptor.get('FontFile', 'FontFile2', 'FontFile3');
      if (fontFile) {
        if (fontFile.dict) {
          var subtype = fontFile.dict.get('Subtype');
          if (subtype) {
            subtype = subtype.name;
          }
          var length1 = fontFile.dict.get('Length1');
          var length2 = fontFile.dict.get('Length2');
          var length3 = fontFile.dict.get('Length3');
        }
      }
      properties = {
        type: type,
        name: fontName.name,
        subtype: subtype,
        file: fontFile,
        length1: length1,
        length2: length2,
        length3: length3,
        loadedName: baseDict.loadedName,
        composite: composite,
        wideChars: composite,
        fixedPitch: false,
        fontMatrix: dict.getArray('FontMatrix') || FONT_IDENTITY_MATRIX,
        firstChar: firstChar || 0,
        lastChar: lastChar || maxCharIndex,
        bbox: descriptor.getArray('FontBBox'),
        ascent: descriptor.get('Ascent'),
        descent: descriptor.get('Descent'),
        xHeight: descriptor.get('XHeight'),
        capHeight: descriptor.get('CapHeight'),
        flags: descriptor.get('Flags'),
        italicAngle: descriptor.get('ItalicAngle'),
        coded: false
      };
      var cMapPromise;
      if (composite) {
        var cidEncoding = baseDict.get('Encoding');
        if (isName(cidEncoding)) {
          properties.cidEncoding = cidEncoding.name;
        }
        cMapPromise = CMapFactory.create({
          encoding: cidEncoding,
          fetchBuiltInCMap: this.fetchBuiltInCMap,
          useCMap: null
        }).then(function (cMap) {
          properties.cMap = cMap;
          properties.vertical = properties.cMap.vertical;
        });
      } else {
        cMapPromise = Promise.resolve(undefined);
      }
      return cMapPromise.then(function () {
        return this.extractDataStructures(dict, baseDict, properties);
      }.bind(this)).then(function (properties) {
        this.extractWidths(dict, descriptor, properties);
        if (type === 'Type3') {
          properties.isType3Font = true;
        }
        return new Font(fontName.name, fontFile, properties);
      }.bind(this));
    }
  };
  return PartialEvaluator;
}();
var TranslatedFont = function TranslatedFontClosure() {
  function TranslatedFont(loadedName, font, dict) {
    this.loadedName = loadedName;
    this.font = font;
    this.dict = dict;
    this.type3Loaded = null;
    this.sent = false;
  }
  TranslatedFont.prototype = {
    send: function send(handler) {
      if (this.sent) {
        return;
      }
      var fontData = this.font.exportData();
      handler.send('commonobj', [this.loadedName, 'Font', fontData]);
      this.sent = true;
    },
    loadType3Data: function loadType3Data(evaluator, resources, parentOperatorList, task) {
      assert(this.font.isType3Font);
      if (this.type3Loaded) {
        return this.type3Loaded;
      }
      var type3Options = Object.create(evaluator.options);
      type3Options.ignoreErrors = false;
      var type3Evaluator = evaluator.clone(type3Options);
      var translatedFont = this.font;
      var loadCharProcsPromise = Promise.resolve();
      var charProcs = this.dict.get('CharProcs');
      var fontResources = this.dict.get('Resources') || resources;
      var charProcKeys = charProcs.getKeys();
      var charProcOperatorList = Object.create(null);
      for (var i = 0, n = charProcKeys.length; i < n; ++i) {
        loadCharProcsPromise = loadCharProcsPromise.then(function (key) {
          var glyphStream = charProcs.get(key);
          var operatorList = new OperatorList();
          return type3Evaluator.getOperatorList(glyphStream, task, fontResources, operatorList).then(function () {
            charProcOperatorList[key] = operatorList.getIR();
            parentOperatorList.addDependencies(operatorList.dependencies);
          }, function (reason) {
            warn('Type3 font resource \"' + key + '\" is not available');
            var operatorList = new OperatorList();
            charProcOperatorList[key] = operatorList.getIR();
          });
        }.bind(this, charProcKeys[i]));
      }
      this.type3Loaded = loadCharProcsPromise.then(function () {
        translatedFont.charProcOperatorList = charProcOperatorList;
      });
      return this.type3Loaded;
    }
  };
  return TranslatedFont;
}();
var OperatorList = function OperatorListClosure() {
  var CHUNK_SIZE = 1000;
  var CHUNK_SIZE_ABOUT = CHUNK_SIZE - 5;
  function getTransfers(queue) {
    var transfers = [];
    var fnArray = queue.fnArray,
        argsArray = queue.argsArray;
    for (var i = 0, ii = queue.length; i < ii; i++) {
      switch (fnArray[i]) {
        case OPS.paintInlineImageXObject:
        case OPS.paintInlineImageXObjectGroup:
        case OPS.paintImageMaskXObject:
          var arg = argsArray[i][0];
          if (!arg.cached) {
            transfers.push(arg.data.buffer);
          }
          break;
      }
    }
    return transfers;
  }
  function OperatorList(intent, messageHandler, pageIndex) {
    this.messageHandler = messageHandler;
    this.fnArray = [];
    this.argsArray = [];
    this.dependencies = Object.create(null);
    this._totalLength = 0;
    this.pageIndex = pageIndex;
    this.intent = intent;
  }
  OperatorList.prototype = {
    get length() {
      return this.argsArray.length;
    },
    get totalLength() {
      return this._totalLength + this.length;
    },
    addOp: function addOp(fn, args) {
      this.fnArray.push(fn);
      this.argsArray.push(args);
      if (this.messageHandler) {
        if (this.fnArray.length >= CHUNK_SIZE) {
          this.flush();
        } else if (this.fnArray.length >= CHUNK_SIZE_ABOUT && (fn === OPS.restore || fn === OPS.endText)) {
          this.flush();
        }
      }
    },
    addDependency: function addDependency(dependency) {
      if (dependency in this.dependencies) {
        return;
      }
      this.dependencies[dependency] = true;
      this.addOp(OPS.dependency, [dependency]);
    },
    addDependencies: function addDependencies(dependencies) {
      for (var key in dependencies) {
        this.addDependency(key);
      }
    },
    addOpList: function addOpList(opList) {
      Util.extendObj(this.dependencies, opList.dependencies);
      for (var i = 0, ii = opList.length; i < ii; i++) {
        this.addOp(opList.fnArray[i], opList.argsArray[i]);
      }
    },
    getIR: function getIR() {
      return {
        fnArray: this.fnArray,
        argsArray: this.argsArray,
        length: this.length
      };
    },
    flush: function flush(lastChunk) {
      if (this.intent !== 'oplist') {
        new QueueOptimizer().optimize(this);
      }
      var transfers = getTransfers(this);
      var length = this.length;
      this._totalLength += length;
      this.messageHandler.send('RenderPageChunk', {
        operatorList: {
          fnArray: this.fnArray,
          argsArray: this.argsArray,
          lastChunk: lastChunk,
          length: length
        },
        pageIndex: this.pageIndex,
        intent: this.intent
      }, transfers);
      this.dependencies = Object.create(null);
      this.fnArray.length = 0;
      this.argsArray.length = 0;
    }
  };
  return OperatorList;
}();
var StateManager = function StateManagerClosure() {
  function StateManager(initialState) {
    this.state = initialState;
    this.stateStack = [];
  }
  StateManager.prototype = {
    save: function save() {
      var old = this.state;
      this.stateStack.push(this.state);
      this.state = old.clone();
    },
    restore: function restore() {
      var prev = this.stateStack.pop();
      if (prev) {
        this.state = prev;
      }
    },
    transform: function transform(args) {
      this.state.ctm = Util.transform(this.state.ctm, args);
    }
  };
  return StateManager;
}();
var TextState = function TextStateClosure() {
  function TextState() {
    this.ctm = new Float32Array(IDENTITY_MATRIX);
    this.fontName = null;
    this.fontSize = 0;
    this.font = null;
    this.fontMatrix = FONT_IDENTITY_MATRIX;
    this.textMatrix = IDENTITY_MATRIX.slice();
    this.textLineMatrix = IDENTITY_MATRIX.slice();
    this.charSpacing = 0;
    this.wordSpacing = 0;
    this.leading = 0;
    this.textHScale = 1;
    this.textRise = 0;
  }
  TextState.prototype = {
    setTextMatrix: function TextState_setTextMatrix(a, b, c, d, e, f) {
      var m = this.textMatrix;
      m[0] = a;
      m[1] = b;
      m[2] = c;
      m[3] = d;
      m[4] = e;
      m[5] = f;
    },
    setTextLineMatrix: function TextState_setTextMatrix(a, b, c, d, e, f) {
      var m = this.textLineMatrix;
      m[0] = a;
      m[1] = b;
      m[2] = c;
      m[3] = d;
      m[4] = e;
      m[5] = f;
    },
    translateTextMatrix: function TextState_translateTextMatrix(x, y) {
      var m = this.textMatrix;
      m[4] = m[0] * x + m[2] * y + m[4];
      m[5] = m[1] * x + m[3] * y + m[5];
    },
    translateTextLineMatrix: function TextState_translateTextMatrix(x, y) {
      var m = this.textLineMatrix;
      m[4] = m[0] * x + m[2] * y + m[4];
      m[5] = m[1] * x + m[3] * y + m[5];
    },
    calcTextLineMatrixAdvance: function TextState_calcTextLineMatrixAdvance(a, b, c, d, e, f) {
      var font = this.font;
      if (!font) {
        return null;
      }
      var m = this.textLineMatrix;
      if (!(a === m[0] && b === m[1] && c === m[2] && d === m[3])) {
        return null;
      }
      var txDiff = e - m[4],
          tyDiff = f - m[5];
      if (font.vertical && txDiff !== 0 || !font.vertical && tyDiff !== 0) {
        return null;
      }
      var tx,
          ty,
          denominator = a * d - b * c;
      if (font.vertical) {
        tx = -tyDiff * c / denominator;
        ty = tyDiff * a / denominator;
      } else {
        tx = txDiff * d / denominator;
        ty = -txDiff * b / denominator;
      }
      return {
        width: tx,
        height: ty,
        value: font.vertical ? ty : tx
      };
    },
    calcRenderMatrix: function TextState_calcRendeMatrix(ctm) {
      var tsm = [this.fontSize * this.textHScale, 0, 0, this.fontSize, 0, this.textRise];
      return Util.transform(ctm, Util.transform(this.textMatrix, tsm));
    },
    carriageReturn: function TextState_carriageReturn() {
      this.translateTextLineMatrix(0, -this.leading);
      this.textMatrix = this.textLineMatrix.slice();
    },
    clone: function TextState_clone() {
      var clone = Object.create(this);
      clone.textMatrix = this.textMatrix.slice();
      clone.textLineMatrix = this.textLineMatrix.slice();
      clone.fontMatrix = this.fontMatrix.slice();
      return clone;
    }
  };
  return TextState;
}();
var EvalState = function EvalStateClosure() {
  function EvalState() {
    this.ctm = new Float32Array(IDENTITY_MATRIX);
    this.font = null;
    this.textRenderingMode = TextRenderingMode.FILL;
    this.fillColorSpace = ColorSpace.singletons.gray;
    this.strokeColorSpace = ColorSpace.singletons.gray;
  }
  EvalState.prototype = {
    clone: function CanvasExtraState_clone() {
      return Object.create(this);
    }
  };
  return EvalState;
}();
var EvaluatorPreprocessor = function EvaluatorPreprocessorClosure() {
  var getOPMap = getLookupTableFactory(function (t) {
    t['w'] = {
      id: OPS.setLineWidth,
      numArgs: 1,
      variableArgs: false
    };
    t['J'] = {
      id: OPS.setLineCap,
      numArgs: 1,
      variableArgs: false
    };
    t['j'] = {
      id: OPS.setLineJoin,
      numArgs: 1,
      variableArgs: false
    };
    t['M'] = {
      id: OPS.setMiterLimit,
      numArgs: 1,
      variableArgs: false
    };
    t['d'] = {
      id: OPS.setDash,
      numArgs: 2,
      variableArgs: false
    };
    t['ri'] = {
      id: OPS.setRenderingIntent,
      numArgs: 1,
      variableArgs: false
    };
    t['i'] = {
      id: OPS.setFlatness,
      numArgs: 1,
      variableArgs: false
    };
    t['gs'] = {
      id: OPS.setGState,
      numArgs: 1,
      variableArgs: false
    };
    t['q'] = {
      id: OPS.save,
      numArgs: 0,
      variableArgs: false
    };
    t['Q'] = {
      id: OPS.restore,
      numArgs: 0,
      variableArgs: false
    };
    t['cm'] = {
      id: OPS.transform,
      numArgs: 6,
      variableArgs: false
    };
    t['m'] = {
      id: OPS.moveTo,
      numArgs: 2,
      variableArgs: false
    };
    t['l'] = {
      id: OPS.lineTo,
      numArgs: 2,
      variableArgs: false
    };
    t['c'] = {
      id: OPS.curveTo,
      numArgs: 6,
      variableArgs: false
    };
    t['v'] = {
      id: OPS.curveTo2,
      numArgs: 4,
      variableArgs: false
    };
    t['y'] = {
      id: OPS.curveTo3,
      numArgs: 4,
      variableArgs: false
    };
    t['h'] = {
      id: OPS.closePath,
      numArgs: 0,
      variableArgs: false
    };
    t['re'] = {
      id: OPS.rectangle,
      numArgs: 4,
      variableArgs: false
    };
    t['S'] = {
      id: OPS.stroke,
      numArgs: 0,
      variableArgs: false
    };
    t['s'] = {
      id: OPS.closeStroke,
      numArgs: 0,
      variableArgs: false
    };
    t['f'] = {
      id: OPS.fill,
      numArgs: 0,
      variableArgs: false
    };
    t['F'] = {
      id: OPS.fill,
      numArgs: 0,
      variableArgs: false
    };
    t['f*'] = {
      id: OPS.eoFill,
      numArgs: 0,
      variableArgs: false
    };
    t['B'] = {
      id: OPS.fillStroke,
      numArgs: 0,
      variableArgs: false
    };
    t['B*'] = {
      id: OPS.eoFillStroke,
      numArgs: 0,
      variableArgs: false
    };
    t['b'] = {
      id: OPS.closeFillStroke,
      numArgs: 0,
      variableArgs: false
    };
    t['b*'] = {
      id: OPS.closeEOFillStroke,
      numArgs: 0,
      variableArgs: false
    };
    t['n'] = {
      id: OPS.endPath,
      numArgs: 0,
      variableArgs: false
    };
    t['W'] = {
      id: OPS.clip,
      numArgs: 0,
      variableArgs: false
    };
    t['W*'] = {
      id: OPS.eoClip,
      numArgs: 0,
      variableArgs: false
    };
    t['BT'] = {
      id: OPS.beginText,
      numArgs: 0,
      variableArgs: false
    };
    t['ET'] = {
      id: OPS.endText,
      numArgs: 0,
      variableArgs: false
    };
    t['Tc'] = {
      id: OPS.setCharSpacing,
      numArgs: 1,
      variableArgs: false
    };
    t['Tw'] = {
      id: OPS.setWordSpacing,
      numArgs: 1,
      variableArgs: false
    };
    t['Tz'] = {
      id: OPS.setHScale,
      numArgs: 1,
      variableArgs: false
    };
    t['TL'] = {
      id: OPS.setLeading,
      numArgs: 1,
      variableArgs: false
    };
    t['Tf'] = {
      id: OPS.setFont,
      numArgs: 2,
      variableArgs: false
    };
    t['Tr'] = {
      id: OPS.setTextRenderingMode,
      numArgs: 1,
      variableArgs: false
    };
    t['Ts'] = {
      id: OPS.setTextRise,
      numArgs: 1,
      variableArgs: false
    };
    t['Td'] = {
      id: OPS.moveText,
      numArgs: 2,
      variableArgs: false
    };
    t['TD'] = {
      id: OPS.setLeadingMoveText,
      numArgs: 2,
      variableArgs: false
    };
    t['Tm'] = {
      id: OPS.setTextMatrix,
      numArgs: 6,
      variableArgs: false
    };
    t['T*'] = {
      id: OPS.nextLine,
      numArgs: 0,
      variableArgs: false
    };
    t['Tj'] = {
      id: OPS.showText,
      numArgs: 1,
      variableArgs: false
    };
    t['TJ'] = {
      id: OPS.showSpacedText,
      numArgs: 1,
      variableArgs: false
    };
    t['\''] = {
      id: OPS.nextLineShowText,
      numArgs: 1,
      variableArgs: false
    };
    t['"'] = {
      id: OPS.nextLineSetSpacingShowText,
      numArgs: 3,
      variableArgs: false
    };
    t['d0'] = {
      id: OPS.setCharWidth,
      numArgs: 2,
      variableArgs: false
    };
    t['d1'] = {
      id: OPS.setCharWidthAndBounds,
      numArgs: 6,
      variableArgs: false
    };
    t['CS'] = {
      id: OPS.setStrokeColorSpace,
      numArgs: 1,
      variableArgs: false
    };
    t['cs'] = {
      id: OPS.setFillColorSpace,
      numArgs: 1,
      variableArgs: false
    };
    t['SC'] = {
      id: OPS.setStrokeColor,
      numArgs: 4,
      variableArgs: true
    };
    t['SCN'] = {
      id: OPS.setStrokeColorN,
      numArgs: 33,
      variableArgs: true
    };
    t['sc'] = {
      id: OPS.setFillColor,
      numArgs: 4,
      variableArgs: true
    };
    t['scn'] = {
      id: OPS.setFillColorN,
      numArgs: 33,
      variableArgs: true
    };
    t['G'] = {
      id: OPS.setStrokeGray,
      numArgs: 1,
      variableArgs: false
    };
    t['g'] = {
      id: OPS.setFillGray,
      numArgs: 1,
      variableArgs: false
    };
    t['RG'] = {
      id: OPS.setStrokeRGBColor,
      numArgs: 3,
      variableArgs: false
    };
    t['rg'] = {
      id: OPS.setFillRGBColor,
      numArgs: 3,
      variableArgs: false
    };
    t['K'] = {
      id: OPS.setStrokeCMYKColor,
      numArgs: 4,
      variableArgs: false
    };
    t['k'] = {
      id: OPS.setFillCMYKColor,
      numArgs: 4,
      variableArgs: false
    };
    t['sh'] = {
      id: OPS.shadingFill,
      numArgs: 1,
      variableArgs: false
    };
    t['BI'] = {
      id: OPS.beginInlineImage,
      numArgs: 0,
      variableArgs: false
    };
    t['ID'] = {
      id: OPS.beginImageData,
      numArgs: 0,
      variableArgs: false
    };
    t['EI'] = {
      id: OPS.endInlineImage,
      numArgs: 1,
      variableArgs: false
    };
    t['Do'] = {
      id: OPS.paintXObject,
      numArgs: 1,
      variableArgs: false
    };
    t['MP'] = {
      id: OPS.markPoint,
      numArgs: 1,
      variableArgs: false
    };
    t['DP'] = {
      id: OPS.markPointProps,
      numArgs: 2,
      variableArgs: false
    };
    t['BMC'] = {
      id: OPS.beginMarkedContent,
      numArgs: 1,
      variableArgs: false
    };
    t['BDC'] = {
      id: OPS.beginMarkedContentProps,
      numArgs: 2,
      variableArgs: false
    };
    t['EMC'] = {
      id: OPS.endMarkedContent,
      numArgs: 0,
      variableArgs: false
    };
    t['BX'] = {
      id: OPS.beginCompat,
      numArgs: 0,
      variableArgs: false
    };
    t['EX'] = {
      id: OPS.endCompat,
      numArgs: 0,
      variableArgs: false
    };
    t['BM'] = null;
    t['BD'] = null;
    t['true'] = null;
    t['fa'] = null;
    t['fal'] = null;
    t['fals'] = null;
    t['false'] = null;
    t['nu'] = null;
    t['nul'] = null;
    t['null'] = null;
  });
  function EvaluatorPreprocessor(stream, xref, stateManager) {
    this.opMap = getOPMap();
    this.parser = new Parser(new Lexer(stream, this.opMap), false, xref);
    this.stateManager = stateManager;
    this.nonProcessedArgs = [];
  }
  EvaluatorPreprocessor.prototype = {
    get savedStatesDepth() {
      return this.stateManager.stateStack.length;
    },
    read: function EvaluatorPreprocessor_read(operation) {
      var args = operation.args;
      while (true) {
        var obj = this.parser.getObj();
        if (isCmd(obj)) {
          var cmd = obj.cmd;
          var opSpec = this.opMap[cmd];
          if (!opSpec) {
            warn('Unknown command "' + cmd + '"');
            continue;
          }
          var fn = opSpec.id;
          var numArgs = opSpec.numArgs;
          var argsLength = args !== null ? args.length : 0;
          if (!opSpec.variableArgs) {
            if (argsLength !== numArgs) {
              var nonProcessedArgs = this.nonProcessedArgs;
              while (argsLength > numArgs) {
                nonProcessedArgs.push(args.shift());
                argsLength--;
              }
              while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
                if (args === null) {
                  args = [];
                }
                args.unshift(nonProcessedArgs.pop());
                argsLength++;
              }
            }
            if (argsLength < numArgs) {
              warn('Skipping command ' + fn + ': expected ' + numArgs + ' args, but received ' + argsLength + ' args.');
              if (args !== null) {
                args.length = 0;
              }
              continue;
            }
          } else if (argsLength > numArgs) {
            info('Command ' + fn + ': expected [0,' + numArgs + '] args, but received ' + argsLength + ' args.');
          }
          this.preprocessCommand(fn, args);
          operation.fn = fn;
          operation.args = args;
          return true;
        }
        if (isEOF(obj)) {
          return false;
        }
        if (obj !== null) {
          if (args === null) {
            args = [];
          }
          args.push(obj);
          assert(args.length <= 33, 'Too many arguments');
        }
      }
    },
    preprocessCommand: function EvaluatorPreprocessor_preprocessCommand(fn, args) {
      switch (fn | 0) {
        case OPS.save:
          this.stateManager.save();
          break;
        case OPS.restore:
          this.stateManager.restore();
          break;
        case OPS.transform:
          this.stateManager.transform(args);
          break;
      }
    }
  };
  return EvaluatorPreprocessor;
}();
var QueueOptimizer = function QueueOptimizerClosure() {
  function addState(parentState, pattern, fn) {
    var state = parentState;
    for (var i = 0, ii = pattern.length - 1; i < ii; i++) {
      var item = pattern[i];
      state = state[item] || (state[item] = []);
    }
    state[pattern[pattern.length - 1]] = fn;
  }
  function handlePaintSolidColorImageMask(iFirstSave, count, fnArray, argsArray) {
    var iFirstPIMXO = iFirstSave + 2;
    for (var i = 0; i < count; i++) {
      var arg = argsArray[iFirstPIMXO + 4 * i];
      var imageMask = arg.length === 1 && arg[0];
      if (imageMask && imageMask.width === 1 && imageMask.height === 1 && (!imageMask.data.length || imageMask.data.length === 1 && imageMask.data[0] === 0)) {
        fnArray[iFirstPIMXO + 4 * i] = OPS.paintSolidColorImageMask;
        continue;
      }
      break;
    }
    return count - i;
  }
  var InitialState = [];
  addState(InitialState, [OPS.save, OPS.transform, OPS.paintInlineImageXObject, OPS.restore], function foundInlineImageGroup(context) {
    var MIN_IMAGES_IN_INLINE_IMAGES_BLOCK = 10;
    var MAX_IMAGES_IN_INLINE_IMAGES_BLOCK = 200;
    var MAX_WIDTH = 1000;
    var IMAGE_PADDING = 1;
    var fnArray = context.fnArray,
        argsArray = context.argsArray;
    var curr = context.iCurr;
    var iFirstSave = curr - 3;
    var iFirstTransform = curr - 2;
    var iFirstPIIXO = curr - 1;
    var i = iFirstSave + 4;
    var ii = fnArray.length;
    while (i + 3 < ii) {
      if (fnArray[i] !== OPS.save || fnArray[i + 1] !== OPS.transform || fnArray[i + 2] !== OPS.paintInlineImageXObject || fnArray[i + 3] !== OPS.restore) {
        break;
      }
      i += 4;
    }
    var count = Math.min((i - iFirstSave) / 4, MAX_IMAGES_IN_INLINE_IMAGES_BLOCK);
    if (count < MIN_IMAGES_IN_INLINE_IMAGES_BLOCK) {
      return i;
    }
    var maxX = 0;
    var map = [],
        maxLineHeight = 0;
    var currentX = IMAGE_PADDING,
        currentY = IMAGE_PADDING;
    var q;
    for (q = 0; q < count; q++) {
      var transform = argsArray[iFirstTransform + (q << 2)];
      var img = argsArray[iFirstPIIXO + (q << 2)][0];
      if (currentX + img.width > MAX_WIDTH) {
        maxX = Math.max(maxX, currentX);
        currentY += maxLineHeight + 2 * IMAGE_PADDING;
        currentX = 0;
        maxLineHeight = 0;
      }
      map.push({
        transform: transform,
        x: currentX,
        y: currentY,
        w: img.width,
        h: img.height
      });
      currentX += img.width + 2 * IMAGE_PADDING;
      maxLineHeight = Math.max(maxLineHeight, img.height);
    }
    var imgWidth = Math.max(maxX, currentX) + IMAGE_PADDING;
    var imgHeight = currentY + maxLineHeight + IMAGE_PADDING;
    var imgData = new Uint8Array(imgWidth * imgHeight * 4);
    var imgRowSize = imgWidth << 2;
    for (q = 0; q < count; q++) {
      var data = argsArray[iFirstPIIXO + (q << 2)][0].data;
      var rowSize = map[q].w << 2;
      var dataOffset = 0;
      var offset = map[q].x + map[q].y * imgWidth << 2;
      imgData.set(data.subarray(0, rowSize), offset - imgRowSize);
      for (var k = 0, kk = map[q].h; k < kk; k++) {
        imgData.set(data.subarray(dataOffset, dataOffset + rowSize), offset);
        dataOffset += rowSize;
        offset += imgRowSize;
      }
      imgData.set(data.subarray(dataOffset - rowSize, dataOffset), offset);
      while (offset >= 0) {
        data[offset - 4] = data[offset];
        data[offset - 3] = data[offset + 1];
        data[offset - 2] = data[offset + 2];
        data[offset - 1] = data[offset + 3];
        data[offset + rowSize] = data[offset + rowSize - 4];
        data[offset + rowSize + 1] = data[offset + rowSize - 3];
        data[offset + rowSize + 2] = data[offset + rowSize - 2];
        data[offset + rowSize + 3] = data[offset + rowSize - 1];
        offset -= imgRowSize;
      }
    }
    fnArray.splice(iFirstSave, count * 4, OPS.paintInlineImageXObjectGroup);
    argsArray.splice(iFirstSave, count * 4, [{
      width: imgWidth,
      height: imgHeight,
      kind: ImageKind.RGBA_32BPP,
      data: imgData
    }, map]);
    return iFirstSave + 1;
  });
  addState(InitialState, [OPS.save, OPS.transform, OPS.paintImageMaskXObject, OPS.restore], function foundImageMaskGroup(context) {
    var MIN_IMAGES_IN_MASKS_BLOCK = 10;
    var MAX_IMAGES_IN_MASKS_BLOCK = 100;
    var MAX_SAME_IMAGES_IN_MASKS_BLOCK = 1000;
    var fnArray = context.fnArray,
        argsArray = context.argsArray;
    var curr = context.iCurr;
    var iFirstSave = curr - 3;
    var iFirstTransform = curr - 2;
    var iFirstPIMXO = curr - 1;
    var i = iFirstSave + 4;
    var ii = fnArray.length;
    while (i + 3 < ii) {
      if (fnArray[i] !== OPS.save || fnArray[i + 1] !== OPS.transform || fnArray[i + 2] !== OPS.paintImageMaskXObject || fnArray[i + 3] !== OPS.restore) {
        break;
      }
      i += 4;
    }
    var count = (i - iFirstSave) / 4;
    count = handlePaintSolidColorImageMask(iFirstSave, count, fnArray, argsArray);
    if (count < MIN_IMAGES_IN_MASKS_BLOCK) {
      return i;
    }
    var q;
    var isSameImage = false;
    var iTransform, transformArgs;
    var firstPIMXOArg0 = argsArray[iFirstPIMXO][0];
    if (argsArray[iFirstTransform][1] === 0 && argsArray[iFirstTransform][2] === 0) {
      isSameImage = true;
      var firstTransformArg0 = argsArray[iFirstTransform][0];
      var firstTransformArg3 = argsArray[iFirstTransform][3];
      iTransform = iFirstTransform + 4;
      var iPIMXO = iFirstPIMXO + 4;
      for (q = 1; q < count; q++, iTransform += 4, iPIMXO += 4) {
        transformArgs = argsArray[iTransform];
        if (argsArray[iPIMXO][0] !== firstPIMXOArg0 || transformArgs[0] !== firstTransformArg0 || transformArgs[1] !== 0 || transformArgs[2] !== 0 || transformArgs[3] !== firstTransformArg3) {
          if (q < MIN_IMAGES_IN_MASKS_BLOCK) {
            isSameImage = false;
          } else {
            count = q;
          }
          break;
        }
      }
    }
    if (isSameImage) {
      count = Math.min(count, MAX_SAME_IMAGES_IN_MASKS_BLOCK);
      var positions = new Float32Array(count * 2);
      iTransform = iFirstTransform;
      for (q = 0; q < count; q++, iTransform += 4) {
        transformArgs = argsArray[iTransform];
        positions[q << 1] = transformArgs[4];
        positions[(q << 1) + 1] = transformArgs[5];
      }
      fnArray.splice(iFirstSave, count * 4, OPS.paintImageMaskXObjectRepeat);
      argsArray.splice(iFirstSave, count * 4, [firstPIMXOArg0, firstTransformArg0, firstTransformArg3, positions]);
    } else {
      count = Math.min(count, MAX_IMAGES_IN_MASKS_BLOCK);
      var images = [];
      for (q = 0; q < count; q++) {
        transformArgs = argsArray[iFirstTransform + (q << 2)];
        var maskParams = argsArray[iFirstPIMXO + (q << 2)][0];
        images.push({
          data: maskParams.data,
          width: maskParams.width,
          height: maskParams.height,
          transform: transformArgs
        });
      }
      fnArray.splice(iFirstSave, count * 4, OPS.paintImageMaskXObjectGroup);
      argsArray.splice(iFirstSave, count * 4, [images]);
    }
    return iFirstSave + 1;
  });
  addState(InitialState, [OPS.save, OPS.transform, OPS.paintImageXObject, OPS.restore], function (context) {
    var MIN_IMAGES_IN_BLOCK = 3;
    var MAX_IMAGES_IN_BLOCK = 1000;
    var fnArray = context.fnArray,
        argsArray = context.argsArray;
    var curr = context.iCurr;
    var iFirstSave = curr - 3;
    var iFirstTransform = curr - 2;
    var iFirstPIXO = curr - 1;
    var iFirstRestore = curr;
    if (argsArray[iFirstTransform][1] !== 0 || argsArray[iFirstTransform][2] !== 0) {
      return iFirstRestore + 1;
    }
    var firstPIXOArg0 = argsArray[iFirstPIXO][0];
    var firstTransformArg0 = argsArray[iFirstTransform][0];
    var firstTransformArg3 = argsArray[iFirstTransform][3];
    var i = iFirstSave + 4;
    var ii = fnArray.length;
    while (i + 3 < ii) {
      if (fnArray[i] !== OPS.save || fnArray[i + 1] !== OPS.transform || fnArray[i + 2] !== OPS.paintImageXObject || fnArray[i + 3] !== OPS.restore) {
        break;
      }
      if (argsArray[i + 1][0] !== firstTransformArg0 || argsArray[i + 1][1] !== 0 || argsArray[i + 1][2] !== 0 || argsArray[i + 1][3] !== firstTransformArg3) {
        break;
      }
      if (argsArray[i + 2][0] !== firstPIXOArg0) {
        break;
      }
      i += 4;
    }
    var count = Math.min((i - iFirstSave) / 4, MAX_IMAGES_IN_BLOCK);
    if (count < MIN_IMAGES_IN_BLOCK) {
      return i;
    }
    var positions = new Float32Array(count * 2);
    var iTransform = iFirstTransform;
    for (var q = 0; q < count; q++, iTransform += 4) {
      var transformArgs = argsArray[iTransform];
      positions[q << 1] = transformArgs[4];
      positions[(q << 1) + 1] = transformArgs[5];
    }
    var args = [firstPIXOArg0, firstTransformArg0, firstTransformArg3, positions];
    fnArray.splice(iFirstSave, count * 4, OPS.paintImageXObjectRepeat);
    argsArray.splice(iFirstSave, count * 4, args);
    return iFirstSave + 1;
  });
  addState(InitialState, [OPS.beginText, OPS.setFont, OPS.setTextMatrix, OPS.showText, OPS.endText], function (context) {
    var MIN_CHARS_IN_BLOCK = 3;
    var MAX_CHARS_IN_BLOCK = 1000;
    var fnArray = context.fnArray,
        argsArray = context.argsArray;
    var curr = context.iCurr;
    var iFirstBeginText = curr - 4;
    var iFirstSetFont = curr - 3;
    var iFirstSetTextMatrix = curr - 2;
    var iFirstShowText = curr - 1;
    var iFirstEndText = curr;
    var firstSetFontArg0 = argsArray[iFirstSetFont][0];
    var firstSetFontArg1 = argsArray[iFirstSetFont][1];
    var i = iFirstBeginText + 5;
    var ii = fnArray.length;
    while (i + 4 < ii) {
      if (fnArray[i] !== OPS.beginText || fnArray[i + 1] !== OPS.setFont || fnArray[i + 2] !== OPS.setTextMatrix || fnArray[i + 3] !== OPS.showText || fnArray[i + 4] !== OPS.endText) {
        break;
      }
      if (argsArray[i + 1][0] !== firstSetFontArg0 || argsArray[i + 1][1] !== firstSetFontArg1) {
        break;
      }
      i += 5;
    }
    var count = Math.min((i - iFirstBeginText) / 5, MAX_CHARS_IN_BLOCK);
    if (count < MIN_CHARS_IN_BLOCK) {
      return i;
    }
    var iFirst = iFirstBeginText;
    if (iFirstBeginText >= 4 && fnArray[iFirstBeginText - 4] === fnArray[iFirstSetFont] && fnArray[iFirstBeginText - 3] === fnArray[iFirstSetTextMatrix] && fnArray[iFirstBeginText - 2] === fnArray[iFirstShowText] && fnArray[iFirstBeginText - 1] === fnArray[iFirstEndText] && argsArray[iFirstBeginText - 4][0] === firstSetFontArg0 && argsArray[iFirstBeginText - 4][1] === firstSetFontArg1) {
      count++;
      iFirst -= 5;
    }
    var iEndText = iFirst + 4;
    for (var q = 1; q < count; q++) {
      fnArray.splice(iEndText, 3);
      argsArray.splice(iEndText, 3);
      iEndText += 2;
    }
    return iEndText + 1;
  });
  function QueueOptimizer() {}
  QueueOptimizer.prototype = {
    optimize: function QueueOptimizer_optimize(queue) {
      var fnArray = queue.fnArray,
          argsArray = queue.argsArray;
      var context = {
        iCurr: 0,
        fnArray: fnArray,
        argsArray: argsArray
      };
      var state;
      var i = 0,
          ii = fnArray.length;
      while (i < ii) {
        state = (state || InitialState)[fnArray[i]];
        if (typeof state === 'function') {
          context.iCurr = i;
          i = state(context);
          state = undefined;
          ii = context.fnArray.length;
        } else {
          i++;
        }
      }
    }
  };
  return QueueOptimizer;
}();
exports.OperatorList = OperatorList;
exports.PartialEvaluator = PartialEvaluator;

/***/ }),
/* 15 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var coreArithmeticDecoder = __w_pdfjs_require__(10);
var info = sharedUtil.info;
var warn = sharedUtil.warn;
var error = sharedUtil.error;
var log2 = sharedUtil.log2;
var readUint16 = sharedUtil.readUint16;
var readUint32 = sharedUtil.readUint32;
var ArithmeticDecoder = coreArithmeticDecoder.ArithmeticDecoder;
var JpxImage = function JpxImageClosure() {
  var SubbandsGainLog2 = {
    'LL': 0,
    'LH': 1,
    'HL': 1,
    'HH': 2
  };
  function JpxImage() {
    this.failOnCorruptedImage = false;
  }
  JpxImage.prototype = {
    parse: function JpxImage_parse(data) {
      var head = readUint16(data, 0);
      if (head === 0xFF4F) {
        this.parseCodestream(data, 0, data.length);
        return;
      }
      var position = 0,
          length = data.length;
      while (position < length) {
        var headerSize = 8;
        var lbox = readUint32(data, position);
        var tbox = readUint32(data, position + 4);
        position += headerSize;
        if (lbox === 1) {
          lbox = readUint32(data, position) * 4294967296 + readUint32(data, position + 4);
          position += 8;
          headerSize += 8;
        }
        if (lbox === 0) {
          lbox = length - position + headerSize;
        }
        if (lbox < headerSize) {
          error('JPX Error: Invalid box field size');
        }
        var dataLength = lbox - headerSize;
        var jumpDataLength = true;
        switch (tbox) {
          case 0x6A703268:
            jumpDataLength = false;
            break;
          case 0x636F6C72:
            var method = data[position];
            if (method === 1) {
              var colorspace = readUint32(data, position + 3);
              switch (colorspace) {
                case 16:
                case 17:
                case 18:
                  break;
                default:
                  warn('Unknown colorspace ' + colorspace);
                  break;
              }
            } else if (method === 2) {
              info('ICC profile not supported');
            }
            break;
          case 0x6A703263:
            this.parseCodestream(data, position, position + dataLength);
            break;
          case 0x6A502020:
            if (readUint32(data, position) !== 0x0d0a870a) {
              warn('Invalid JP2 signature');
            }
            break;
          case 0x6A501A1A:
          case 0x66747970:
          case 0x72726571:
          case 0x72657320:
          case 0x69686472:
            break;
          default:
            var headerType = String.fromCharCode(tbox >> 24 & 0xFF, tbox >> 16 & 0xFF, tbox >> 8 & 0xFF, tbox & 0xFF);
            warn('Unsupported header type ' + tbox + ' (' + headerType + ')');
            break;
        }
        if (jumpDataLength) {
          position += dataLength;
        }
      }
    },
    parseImageProperties: function JpxImage_parseImageProperties(stream) {
      var newByte = stream.getByte();
      while (newByte >= 0) {
        var oldByte = newByte;
        newByte = stream.getByte();
        var code = oldByte << 8 | newByte;
        if (code === 0xFF51) {
          stream.skip(4);
          var Xsiz = stream.getInt32() >>> 0;
          var Ysiz = stream.getInt32() >>> 0;
          var XOsiz = stream.getInt32() >>> 0;
          var YOsiz = stream.getInt32() >>> 0;
          stream.skip(16);
          var Csiz = stream.getUint16();
          this.width = Xsiz - XOsiz;
          this.height = Ysiz - YOsiz;
          this.componentsCount = Csiz;
          this.bitsPerComponent = 8;
          return;
        }
      }
      error('JPX Error: No size marker found in JPX stream');
    },
    parseCodestream: function JpxImage_parseCodestream(data, start, end) {
      var context = {};
      var doNotRecover = false;
      try {
        var position = start;
        while (position + 1 < end) {
          var code = readUint16(data, position);
          position += 2;
          var length = 0,
              j,
              sqcd,
              spqcds,
              spqcdSize,
              scalarExpounded,
              tile;
          switch (code) {
            case 0xFF4F:
              context.mainHeader = true;
              break;
            case 0xFFD9:
              break;
            case 0xFF51:
              length = readUint16(data, position);
              var siz = {};
              siz.Xsiz = readUint32(data, position + 4);
              siz.Ysiz = readUint32(data, position + 8);
              siz.XOsiz = readUint32(data, position + 12);
              siz.YOsiz = readUint32(data, position + 16);
              siz.XTsiz = readUint32(data, position + 20);
              siz.YTsiz = readUint32(data, position + 24);
              siz.XTOsiz = readUint32(data, position + 28);
              siz.YTOsiz = readUint32(data, position + 32);
              var componentsCount = readUint16(data, position + 36);
              siz.Csiz = componentsCount;
              var components = [];
              j = position + 38;
              for (var i = 0; i < componentsCount; i++) {
                var component = {
                  precision: (data[j] & 0x7F) + 1,
                  isSigned: !!(data[j] & 0x80),
                  XRsiz: data[j + 1],
                  YRsiz: data[j + 1]
                };
                calculateComponentDimensions(component, siz);
                components.push(component);
              }
              context.SIZ = siz;
              context.components = components;
              calculateTileGrids(context, components);
              context.QCC = [];
              context.COC = [];
              break;
            case 0xFF5C:
              length = readUint16(data, position);
              var qcd = {};
              j = position + 2;
              sqcd = data[j++];
              switch (sqcd & 0x1F) {
                case 0:
                  spqcdSize = 8;
                  scalarExpounded = true;
                  break;
                case 1:
                  spqcdSize = 16;
                  scalarExpounded = false;
                  break;
                case 2:
                  spqcdSize = 16;
                  scalarExpounded = true;
                  break;
                default:
                  throw new Error('Invalid SQcd value ' + sqcd);
              }
              qcd.noQuantization = spqcdSize === 8;
              qcd.scalarExpounded = scalarExpounded;
              qcd.guardBits = sqcd >> 5;
              spqcds = [];
              while (j < length + position) {
                var spqcd = {};
                if (spqcdSize === 8) {
                  spqcd.epsilon = data[j++] >> 3;
                  spqcd.mu = 0;
                } else {
                  spqcd.epsilon = data[j] >> 3;
                  spqcd.mu = (data[j] & 0x7) << 8 | data[j + 1];
                  j += 2;
                }
                spqcds.push(spqcd);
              }
              qcd.SPqcds = spqcds;
              if (context.mainHeader) {
                context.QCD = qcd;
              } else {
                context.currentTile.QCD = qcd;
                context.currentTile.QCC = [];
              }
              break;
            case 0xFF5D:
              length = readUint16(data, position);
              var qcc = {};
              j = position + 2;
              var cqcc;
              if (context.SIZ.Csiz < 257) {
                cqcc = data[j++];
              } else {
                cqcc = readUint16(data, j);
                j += 2;
              }
              sqcd = data[j++];
              switch (sqcd & 0x1F) {
                case 0:
                  spqcdSize = 8;
                  scalarExpounded = true;
                  break;
                case 1:
                  spqcdSize = 16;
                  scalarExpounded = false;
                  break;
                case 2:
                  spqcdSize = 16;
                  scalarExpounded = true;
                  break;
                default:
                  throw new Error('Invalid SQcd value ' + sqcd);
              }
              qcc.noQuantization = spqcdSize === 8;
              qcc.scalarExpounded = scalarExpounded;
              qcc.guardBits = sqcd >> 5;
              spqcds = [];
              while (j < length + position) {
                spqcd = {};
                if (spqcdSize === 8) {
                  spqcd.epsilon = data[j++] >> 3;
                  spqcd.mu = 0;
                } else {
                  spqcd.epsilon = data[j] >> 3;
                  spqcd.mu = (data[j] & 0x7) << 8 | data[j + 1];
                  j += 2;
                }
                spqcds.push(spqcd);
              }
              qcc.SPqcds = spqcds;
              if (context.mainHeader) {
                context.QCC[cqcc] = qcc;
              } else {
                context.currentTile.QCC[cqcc] = qcc;
              }
              break;
            case 0xFF52:
              length = readUint16(data, position);
              var cod = {};
              j = position + 2;
              var scod = data[j++];
              cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
              cod.sopMarkerUsed = !!(scod & 2);
              cod.ephMarkerUsed = !!(scod & 4);
              cod.progressionOrder = data[j++];
              cod.layersCount = readUint16(data, j);
              j += 2;
              cod.multipleComponentTransform = data[j++];
              cod.decompositionLevelsCount = data[j++];
              cod.xcb = (data[j++] & 0xF) + 2;
              cod.ycb = (data[j++] & 0xF) + 2;
              var blockStyle = data[j++];
              cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
              cod.resetContextProbabilities = !!(blockStyle & 2);
              cod.terminationOnEachCodingPass = !!(blockStyle & 4);
              cod.verticalyStripe = !!(blockStyle & 8);
              cod.predictableTermination = !!(blockStyle & 16);
              cod.segmentationSymbolUsed = !!(blockStyle & 32);
              cod.reversibleTransformation = data[j++];
              if (cod.entropyCoderWithCustomPrecincts) {
                var precinctsSizes = [];
                while (j < length + position) {
                  var precinctsSize = data[j++];
                  precinctsSizes.push({
                    PPx: precinctsSize & 0xF,
                    PPy: precinctsSize >> 4
                  });
                }
                cod.precinctsSizes = precinctsSizes;
              }
              var unsupported = [];
              if (cod.selectiveArithmeticCodingBypass) {
                unsupported.push('selectiveArithmeticCodingBypass');
              }
              if (cod.resetContextProbabilities) {
                unsupported.push('resetContextProbabilities');
              }
              if (cod.terminationOnEachCodingPass) {
                unsupported.push('terminationOnEachCodingPass');
              }
              if (cod.verticalyStripe) {
                unsupported.push('verticalyStripe');
              }
              if (cod.predictableTermination) {
                unsupported.push('predictableTermination');
              }
              if (unsupported.length > 0) {
                doNotRecover = true;
                throw new Error('Unsupported COD options (' + unsupported.join(', ') + ')');
              }
              if (context.mainHeader) {
                context.COD = cod;
              } else {
                context.currentTile.COD = cod;
                context.currentTile.COC = [];
              }
              break;
            case 0xFF90:
              length = readUint16(data, position);
              tile = {};
              tile.index = readUint16(data, position + 2);
              tile.length = readUint32(data, position + 4);
              tile.dataEnd = tile.length + position - 2;
              tile.partIndex = data[position + 8];
              tile.partsCount = data[position + 9];
              context.mainHeader = false;
              if (tile.partIndex === 0) {
                tile.COD = context.COD;
                tile.COC = context.COC.slice(0);
                tile.QCD = context.QCD;
                tile.QCC = context.QCC.slice(0);
              }
              context.currentTile = tile;
              break;
            case 0xFF93:
              tile = context.currentTile;
              if (tile.partIndex === 0) {
                initializeTile(context, tile.index);
                buildPackets(context);
              }
              length = tile.dataEnd - position;
              parseTilePackets(context, data, position, length);
              break;
            case 0xFF55:
            case 0xFF57:
            case 0xFF58:
            case 0xFF64:
              length = readUint16(data, position);
              break;
            case 0xFF53:
              throw new Error('Codestream code 0xFF53 (COC) is ' + 'not implemented');
            default:
              throw new Error('Unknown codestream code: ' + code.toString(16));
          }
          position += length;
        }
      } catch (e) {
        if (doNotRecover || this.failOnCorruptedImage) {
          error('JPX Error: ' + e.message);
        } else {
          warn('JPX: Trying to recover from: ' + e.message);
        }
      }
      this.tiles = transformComponents(context);
      this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;
      this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;
      this.componentsCount = context.SIZ.Csiz;
    }
  };
  function calculateComponentDimensions(component, siz) {
    component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);
    component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);
    component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);
    component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);
    component.width = component.x1 - component.x0;
    component.height = component.y1 - component.y0;
  }
  function calculateTileGrids(context, components) {
    var siz = context.SIZ;
    var tile,
        tiles = [];
    var numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
    var numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);
    for (var q = 0; q < numYtiles; q++) {
      for (var p = 0; p < numXtiles; p++) {
        tile = {};
        tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
        tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);
        tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
        tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);
        tile.width = tile.tx1 - tile.tx0;
        tile.height = tile.ty1 - tile.ty0;
        tile.components = [];
        tiles.push(tile);
      }
    }
    context.tiles = tiles;
    var componentsCount = siz.Csiz;
    for (var i = 0, ii = componentsCount; i < ii; i++) {
      var component = components[i];
      for (var j = 0, jj = tiles.length; j < jj; j++) {
        var tileComponent = {};
        tile = tiles[j];
        tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
        tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
        tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
        tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
        tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
        tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
        tile.components[i] = tileComponent;
      }
    }
  }
  function getBlocksDimensions(context, component, r) {
    var codOrCoc = component.codingStyleParameters;
    var result = {};
    if (!codOrCoc.entropyCoderWithCustomPrecincts) {
      result.PPx = 15;
      result.PPy = 15;
    } else {
      result.PPx = codOrCoc.precinctsSizes[r].PPx;
      result.PPy = codOrCoc.precinctsSizes[r].PPy;
    }
    result.xcb_ = r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) : Math.min(codOrCoc.xcb, result.PPx);
    result.ycb_ = r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) : Math.min(codOrCoc.ycb, result.PPy);
    return result;
  }
  function buildPrecincts(context, resolution, dimensions) {
    var precinctWidth = 1 << dimensions.PPx;
    var precinctHeight = 1 << dimensions.PPy;
    var isZeroRes = resolution.resLevel === 0;
    var precinctWidthInSubband = 1 << dimensions.PPx + (isZeroRes ? 0 : -1);
    var precinctHeightInSubband = 1 << dimensions.PPy + (isZeroRes ? 0 : -1);
    var numprecinctswide = resolution.trx1 > resolution.trx0 ? Math.ceil(resolution.trx1 / precinctWidth) - Math.floor(resolution.trx0 / precinctWidth) : 0;
    var numprecinctshigh = resolution.try1 > resolution.try0 ? Math.ceil(resolution.try1 / precinctHeight) - Math.floor(resolution.try0 / precinctHeight) : 0;
    var numprecincts = numprecinctswide * numprecinctshigh;
    resolution.precinctParameters = {
      precinctWidth: precinctWidth,
      precinctHeight: precinctHeight,
      numprecinctswide: numprecinctswide,
      numprecinctshigh: numprecinctshigh,
      numprecincts: numprecincts,
      precinctWidthInSubband: precinctWidthInSubband,
      precinctHeightInSubband: precinctHeightInSubband
    };
  }
  function buildCodeblocks(context, subband, dimensions) {
    var xcb_ = dimensions.xcb_;
    var ycb_ = dimensions.ycb_;
    var codeblockWidth = 1 << xcb_;
    var codeblockHeight = 1 << ycb_;
    var cbx0 = subband.tbx0 >> xcb_;
    var cby0 = subband.tby0 >> ycb_;
    var cbx1 = subband.tbx1 + codeblockWidth - 1 >> xcb_;
    var cby1 = subband.tby1 + codeblockHeight - 1 >> ycb_;
    var precinctParameters = subband.resolution.precinctParameters;
    var codeblocks = [];
    var precincts = [];
    var i, j, codeblock, precinctNumber;
    for (j = cby0; j < cby1; j++) {
      for (i = cbx0; i < cbx1; i++) {
        codeblock = {
          cbx: i,
          cby: j,
          tbx0: codeblockWidth * i,
          tby0: codeblockHeight * j,
          tbx1: codeblockWidth * (i + 1),
          tby1: codeblockHeight * (j + 1)
        };
        codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);
        codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);
        codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);
        codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);
        var pi = Math.floor((codeblock.tbx0_ - subband.tbx0) / precinctParameters.precinctWidthInSubband);
        var pj = Math.floor((codeblock.tby0_ - subband.tby0) / precinctParameters.precinctHeightInSubband);
        precinctNumber = pi + pj * precinctParameters.numprecinctswide;
        codeblock.precinctNumber = precinctNumber;
        codeblock.subbandType = subband.type;
        codeblock.Lblock = 3;
        if (codeblock.tbx1_ <= codeblock.tbx0_ || codeblock.tby1_ <= codeblock.tby0_) {
          continue;
        }
        codeblocks.push(codeblock);
        var precinct = precincts[precinctNumber];
        if (precinct !== undefined) {
          if (i < precinct.cbxMin) {
            precinct.cbxMin = i;
          } else if (i > precinct.cbxMax) {
            precinct.cbxMax = i;
          }
          if (j < precinct.cbyMin) {
            precinct.cbxMin = j;
          } else if (j > precinct.cbyMax) {
            precinct.cbyMax = j;
          }
        } else {
          precincts[precinctNumber] = precinct = {
            cbxMin: i,
            cbyMin: j,
            cbxMax: i,
            cbyMax: j
          };
        }
        codeblock.precinct = precinct;
      }
    }
    subband.codeblockParameters = {
      codeblockWidth: xcb_,
      codeblockHeight: ycb_,
      numcodeblockwide: cbx1 - cbx0 + 1,
      numcodeblockhigh: cby1 - cby0 + 1
    };
    subband.codeblocks = codeblocks;
    subband.precincts = precincts;
  }
  function createPacket(resolution, precinctNumber, layerNumber) {
    var precinctCodeblocks = [];
    var subbands = resolution.subbands;
    for (var i = 0, ii = subbands.length; i < ii; i++) {
      var subband = subbands[i];
      var codeblocks = subband.codeblocks;
      for (var j = 0, jj = codeblocks.length; j < jj; j++) {
        var codeblock = codeblocks[j];
        if (codeblock.precinctNumber !== precinctNumber) {
          continue;
        }
        precinctCodeblocks.push(codeblock);
      }
    }
    return {
      layerNumber: layerNumber,
      codeblocks: precinctCodeblocks
    };
  }
  function LayerResolutionComponentPositionIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var maxDecompositionLevelsCount = 0;
    for (var q = 0; q < componentsCount; q++) {
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
    }
    var l = 0,
        r = 0,
        i = 0,
        k = 0;
    this.nextPacket = function JpxImage_nextPacket() {
      for (; l < layersCount; l++) {
        for (; r <= maxDecompositionLevelsCount; r++) {
          for (; i < componentsCount; i++) {
            var component = tile.components[i];
            if (r > component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }
            var resolution = component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;
            for (; k < numprecincts;) {
              var packet = createPacket(resolution, k, l);
              k++;
              return packet;
            }
            k = 0;
          }
          i = 0;
        }
        r = 0;
      }
      error('JPX Error: Out of packets');
    };
  }
  function ResolutionLayerComponentPositionIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var maxDecompositionLevelsCount = 0;
    for (var q = 0; q < componentsCount; q++) {
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
    }
    var r = 0,
        l = 0,
        i = 0,
        k = 0;
    this.nextPacket = function JpxImage_nextPacket() {
      for (; r <= maxDecompositionLevelsCount; r++) {
        for (; l < layersCount; l++) {
          for (; i < componentsCount; i++) {
            var component = tile.components[i];
            if (r > component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }
            var resolution = component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;
            for (; k < numprecincts;) {
              var packet = createPacket(resolution, k, l);
              k++;
              return packet;
            }
            k = 0;
          }
          i = 0;
        }
        l = 0;
      }
      error('JPX Error: Out of packets');
    };
  }
  function ResolutionPositionComponentLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var l, r, c, p;
    var maxDecompositionLevelsCount = 0;
    for (c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, component.codingStyleParameters.decompositionLevelsCount);
    }
    var maxNumPrecinctsInLevel = new Int32Array(maxDecompositionLevelsCount + 1);
    for (r = 0; r <= maxDecompositionLevelsCount; ++r) {
      var maxNumPrecincts = 0;
      for (c = 0; c < componentsCount; ++c) {
        var resolutions = tile.components[c].resolutions;
        if (r < resolutions.length) {
          maxNumPrecincts = Math.max(maxNumPrecincts, resolutions[r].precinctParameters.numprecincts);
        }
      }
      maxNumPrecinctsInLevel[r] = maxNumPrecincts;
    }
    l = 0;
    r = 0;
    c = 0;
    p = 0;
    this.nextPacket = function JpxImage_nextPacket() {
      for (; r <= maxDecompositionLevelsCount; r++) {
        for (; p < maxNumPrecinctsInLevel[r]; p++) {
          for (; c < componentsCount; c++) {
            var component = tile.components[c];
            if (r > component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }
            var resolution = component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;
            if (p >= numprecincts) {
              continue;
            }
            for (; l < layersCount;) {
              var packet = createPacket(resolution, p, l);
              l++;
              return packet;
            }
            l = 0;
          }
          c = 0;
        }
        p = 0;
      }
      error('JPX Error: Out of packets');
    };
  }
  function PositionComponentResolutionLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var precinctsSizes = getPrecinctSizesInImageScale(tile);
    var precinctsIterationSizes = precinctsSizes;
    var l = 0,
        r = 0,
        c = 0,
        px = 0,
        py = 0;
    this.nextPacket = function JpxImage_nextPacket() {
      for (; py < precinctsIterationSizes.maxNumHigh; py++) {
        for (; px < precinctsIterationSizes.maxNumWide; px++) {
          for (; c < componentsCount; c++) {
            var component = tile.components[c];
            var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
            for (; r <= decompositionLevelsCount; r++) {
              var resolution = component.resolutions[r];
              var sizeInImageScale = precinctsSizes.components[c].resolutions[r];
              var k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
              if (k === null) {
                continue;
              }
              for (; l < layersCount;) {
                var packet = createPacket(resolution, k, l);
                l++;
                return packet;
              }
              l = 0;
            }
            r = 0;
          }
          c = 0;
        }
        px = 0;
      }
      error('JPX Error: Out of packets');
    };
  }
  function ComponentPositionResolutionLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var precinctsSizes = getPrecinctSizesInImageScale(tile);
    var l = 0,
        r = 0,
        c = 0,
        px = 0,
        py = 0;
    this.nextPacket = function JpxImage_nextPacket() {
      for (; c < componentsCount; ++c) {
        var component = tile.components[c];
        var precinctsIterationSizes = precinctsSizes.components[c];
        var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
        for (; py < precinctsIterationSizes.maxNumHigh; py++) {
          for (; px < precinctsIterationSizes.maxNumWide; px++) {
            for (; r <= decompositionLevelsCount; r++) {
              var resolution = component.resolutions[r];
              var sizeInImageScale = precinctsIterationSizes.resolutions[r];
              var k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
              if (k === null) {
                continue;
              }
              for (; l < layersCount;) {
                var packet = createPacket(resolution, k, l);
                l++;
                return packet;
              }
              l = 0;
            }
            r = 0;
          }
          px = 0;
        }
        py = 0;
      }
      error('JPX Error: Out of packets');
    };
  }
  function getPrecinctIndexIfExist(pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) {
    var posX = pxIndex * precinctIterationSizes.minWidth;
    var posY = pyIndex * precinctIterationSizes.minHeight;
    if (posX % sizeInImageScale.width !== 0 || posY % sizeInImageScale.height !== 0) {
      return null;
    }
    var startPrecinctRowIndex = posY / sizeInImageScale.width * resolution.precinctParameters.numprecinctswide;
    return posX / sizeInImageScale.height + startPrecinctRowIndex;
  }
  function getPrecinctSizesInImageScale(tile) {
    var componentsCount = tile.components.length;
    var minWidth = Number.MAX_VALUE;
    var minHeight = Number.MAX_VALUE;
    var maxNumWide = 0;
    var maxNumHigh = 0;
    var sizePerComponent = new Array(componentsCount);
    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
      var sizePerResolution = new Array(decompositionLevelsCount + 1);
      var minWidthCurrentComponent = Number.MAX_VALUE;
      var minHeightCurrentComponent = Number.MAX_VALUE;
      var maxNumWideCurrentComponent = 0;
      var maxNumHighCurrentComponent = 0;
      var scale = 1;
      for (var r = decompositionLevelsCount; r >= 0; --r) {
        var resolution = component.resolutions[r];
        var widthCurrentResolution = scale * resolution.precinctParameters.precinctWidth;
        var heightCurrentResolution = scale * resolution.precinctParameters.precinctHeight;
        minWidthCurrentComponent = Math.min(minWidthCurrentComponent, widthCurrentResolution);
        minHeightCurrentComponent = Math.min(minHeightCurrentComponent, heightCurrentResolution);
        maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent, resolution.precinctParameters.numprecinctswide);
        maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent, resolution.precinctParameters.numprecinctshigh);
        sizePerResolution[r] = {
          width: widthCurrentResolution,
          height: heightCurrentResolution
        };
        scale <<= 1;
      }
      minWidth = Math.min(minWidth, minWidthCurrentComponent);
      minHeight = Math.min(minHeight, minHeightCurrentComponent);
      maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
      maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
      sizePerComponent[c] = {
        resolutions: sizePerResolution,
        minWidth: minWidthCurrentComponent,
        minHeight: minHeightCurrentComponent,
        maxNumWide: maxNumWideCurrentComponent,
        maxNumHigh: maxNumHighCurrentComponent
      };
    }
    return {
      components: sizePerComponent,
      minWidth: minWidth,
      minHeight: minHeight,
      maxNumWide: maxNumWide,
      maxNumHigh: maxNumHigh
    };
  }
  function buildPackets(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var componentsCount = siz.Csiz;
    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
      var resolutions = [];
      var subbands = [];
      for (var r = 0; r <= decompositionLevelsCount; r++) {
        var blocksDimensions = getBlocksDimensions(context, component, r);
        var resolution = {};
        var scale = 1 << decompositionLevelsCount - r;
        resolution.trx0 = Math.ceil(component.tcx0 / scale);
        resolution.try0 = Math.ceil(component.tcy0 / scale);
        resolution.trx1 = Math.ceil(component.tcx1 / scale);
        resolution.try1 = Math.ceil(component.tcy1 / scale);
        resolution.resLevel = r;
        buildPrecincts(context, resolution, blocksDimensions);
        resolutions.push(resolution);
        var subband;
        if (r === 0) {
          subband = {};
          subband.type = 'LL';
          subband.tbx0 = Math.ceil(component.tcx0 / scale);
          subband.tby0 = Math.ceil(component.tcy0 / scale);
          subband.tbx1 = Math.ceil(component.tcx1 / scale);
          subband.tby1 = Math.ceil(component.tcy1 / scale);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolution.subbands = [subband];
        } else {
          var bscale = 1 << decompositionLevelsCount - r + 1;
          var resolutionSubbands = [];
          subband = {};
          subband.type = 'HL';
          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
          subband.tby0 = Math.ceil(component.tcy0 / bscale);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
          subband.tby1 = Math.ceil(component.tcy1 / bscale);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);
          subband = {};
          subband.type = 'LH';
          subband.tbx0 = Math.ceil(component.tcx0 / bscale);
          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale);
          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);
          subband = {};
          subband.type = 'HH';
          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);
          resolution.subbands = resolutionSubbands;
        }
      }
      component.resolutions = resolutions;
      component.subbands = subbands;
    }
    var progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;
    switch (progressionOrder) {
      case 0:
        tile.packetsIterator = new LayerResolutionComponentPositionIterator(context);
        break;
      case 1:
        tile.packetsIterator = new ResolutionLayerComponentPositionIterator(context);
        break;
      case 2:
        tile.packetsIterator = new ResolutionPositionComponentLayerIterator(context);
        break;
      case 3:
        tile.packetsIterator = new PositionComponentResolutionLayerIterator(context);
        break;
      case 4:
        tile.packetsIterator = new ComponentPositionResolutionLayerIterator(context);
        break;
      default:
        error('JPX Error: Unsupported progression order ' + progressionOrder);
    }
  }
  function parseTilePackets(context, data, offset, dataLength) {
    var position = 0;
    var buffer,
        bufferSize = 0,
        skipNextBit = false;
    function readBits(count) {
      while (bufferSize < count) {
        var b = data[offset + position];
        position++;
        if (skipNextBit) {
          buffer = buffer << 7 | b;
          bufferSize += 7;
          skipNextBit = false;
        } else {
          buffer = buffer << 8 | b;
          bufferSize += 8;
        }
        if (b === 0xFF) {
          skipNextBit = true;
        }
      }
      bufferSize -= count;
      return buffer >>> bufferSize & (1 << count) - 1;
    }
    function skipMarkerIfEqual(value) {
      if (data[offset + position - 1] === 0xFF && data[offset + position] === value) {
        skipBytes(1);
        return true;
      } else if (data[offset + position] === 0xFF && data[offset + position + 1] === value) {
        skipBytes(2);
        return true;
      }
      return false;
    }
    function skipBytes(count) {
      position += count;
    }
    function alignToByte() {
      bufferSize = 0;
      if (skipNextBit) {
        position++;
        skipNextBit = false;
      }
    }
    function readCodingpasses() {
      if (readBits(1) === 0) {
        return 1;
      }
      if (readBits(1) === 0) {
        return 2;
      }
      var value = readBits(2);
      if (value < 3) {
        return value + 3;
      }
      value = readBits(5);
      if (value < 31) {
        return value + 6;
      }
      value = readBits(7);
      return value + 37;
    }
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var sopMarkerUsed = context.COD.sopMarkerUsed;
    var ephMarkerUsed = context.COD.ephMarkerUsed;
    var packetsIterator = tile.packetsIterator;
    while (position < dataLength) {
      alignToByte();
      if (sopMarkerUsed && skipMarkerIfEqual(0x91)) {
        skipBytes(4);
      }
      var packet = packetsIterator.nextPacket();
      if (!readBits(1)) {
        continue;
      }
      var layerNumber = packet.layerNumber;
      var queue = [],
          codeblock;
      for (var i = 0, ii = packet.codeblocks.length; i < ii; i++) {
        codeblock = packet.codeblocks[i];
        var precinct = codeblock.precinct;
        var codeblockColumn = codeblock.cbx - precinct.cbxMin;
        var codeblockRow = codeblock.cby - precinct.cbyMin;
        var codeblockIncluded = false;
        var firstTimeInclusion = false;
        var valueReady;
        if (codeblock['included'] !== undefined) {
          codeblockIncluded = !!readBits(1);
        } else {
          precinct = codeblock.precinct;
          var inclusionTree, zeroBitPlanesTree;
          if (precinct['inclusionTree'] !== undefined) {
            inclusionTree = precinct.inclusionTree;
          } else {
            var width = precinct.cbxMax - precinct.cbxMin + 1;
            var height = precinct.cbyMax - precinct.cbyMin + 1;
            inclusionTree = new InclusionTree(width, height, layerNumber);
            zeroBitPlanesTree = new TagTree(width, height);
            precinct.inclusionTree = inclusionTree;
            precinct.zeroBitPlanesTree = zeroBitPlanesTree;
          }
          if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {
            while (true) {
              if (readBits(1)) {
                valueReady = !inclusionTree.nextLevel();
                if (valueReady) {
                  codeblock.included = true;
                  codeblockIncluded = firstTimeInclusion = true;
                  break;
                }
              } else {
                inclusionTree.incrementValue(layerNumber);
                break;
              }
            }
          }
        }
        if (!codeblockIncluded) {
          continue;
        }
        if (firstTimeInclusion) {
          zeroBitPlanesTree = precinct.zeroBitPlanesTree;
          zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);
          while (true) {
            if (readBits(1)) {
              valueReady = !zeroBitPlanesTree.nextLevel();
              if (valueReady) {
                break;
              }
            } else {
              zeroBitPlanesTree.incrementValue();
            }
          }
          codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
        }
        var codingpasses = readCodingpasses();
        while (readBits(1)) {
          codeblock.Lblock++;
        }
        var codingpassesLog2 = log2(codingpasses);
        var bits = (codingpasses < 1 << codingpassesLog2 ? codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;
        var codedDataLength = readBits(bits);
        queue.push({
          codeblock: codeblock,
          codingpasses: codingpasses,
          dataLength: codedDataLength
        });
      }
      alignToByte();
      if (ephMarkerUsed) {
        skipMarkerIfEqual(0x92);
      }
      while (queue.length > 0) {
        var packetItem = queue.shift();
        codeblock = packetItem.codeblock;
        if (codeblock['data'] === undefined) {
          codeblock.data = [];
        }
        codeblock.data.push({
          data: data,
          start: offset + position,
          end: offset + position + packetItem.dataLength,
          codingpasses: packetItem.codingpasses
        });
        position += packetItem.dataLength;
      }
    }
    return position;
  }
  function copyCoefficients(coefficients, levelWidth, levelHeight, subband, delta, mb, reversible, segmentationSymbolUsed) {
    var x0 = subband.tbx0;
    var y0 = subband.tby0;
    var width = subband.tbx1 - subband.tbx0;
    var codeblocks = subband.codeblocks;
    var right = subband.type.charAt(0) === 'H' ? 1 : 0;
    var bottom = subband.type.charAt(1) === 'H' ? levelWidth : 0;
    for (var i = 0, ii = codeblocks.length; i < ii; ++i) {
      var codeblock = codeblocks[i];
      var blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
      var blockHeight = codeblock.tby1_ - codeblock.tby0_;
      if (blockWidth === 0 || blockHeight === 0) {
        continue;
      }
      if (codeblock['data'] === undefined) {
        continue;
      }
      var bitModel, currentCodingpassType;
      bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType, codeblock.zeroBitPlanes, mb);
      currentCodingpassType = 2;
      var data = codeblock.data,
          totalLength = 0,
          codingpasses = 0;
      var j, jj, dataItem;
      for (j = 0, jj = data.length; j < jj; j++) {
        dataItem = data[j];
        totalLength += dataItem.end - dataItem.start;
        codingpasses += dataItem.codingpasses;
      }
      var encodedData = new Uint8Array(totalLength);
      var position = 0;
      for (j = 0, jj = data.length; j < jj; j++) {
        dataItem = data[j];
        var chunk = dataItem.data.subarray(dataItem.start, dataItem.end);
        encodedData.set(chunk, position);
        position += chunk.length;
      }
      var decoder = new ArithmeticDecoder(encodedData, 0, totalLength);
      bitModel.setDecoder(decoder);
      for (j = 0; j < codingpasses; j++) {
        switch (currentCodingpassType) {
          case 0:
            bitModel.runSignificancePropagationPass();
            break;
          case 1:
            bitModel.runMagnitudeRefinementPass();
            break;
          case 2:
            bitModel.runCleanupPass();
            if (segmentationSymbolUsed) {
              bitModel.checkSegmentationSymbol();
            }
            break;
        }
        currentCodingpassType = (currentCodingpassType + 1) % 3;
      }
      var offset = codeblock.tbx0_ - x0 + (codeblock.tby0_ - y0) * width;
      var sign = bitModel.coefficentsSign;
      var magnitude = bitModel.coefficentsMagnitude;
      var bitsDecoded = bitModel.bitsDecoded;
      var magnitudeCorrection = reversible ? 0 : 0.5;
      var k, n, nb;
      position = 0;
      var interleave = subband.type !== 'LL';
      for (j = 0; j < blockHeight; j++) {
        var row = offset / width | 0;
        var levelOffset = 2 * row * (levelWidth - width) + right + bottom;
        for (k = 0; k < blockWidth; k++) {
          n = magnitude[position];
          if (n !== 0) {
            n = (n + magnitudeCorrection) * delta;
            if (sign[position] !== 0) {
              n = -n;
            }
            nb = bitsDecoded[position];
            var pos = interleave ? levelOffset + (offset << 1) : offset;
            if (reversible && nb >= mb) {
              coefficients[pos] = n;
            } else {
              coefficients[pos] = n * (1 << mb - nb);
            }
          }
          offset++;
          position++;
        }
        offset += width - blockWidth;
      }
    }
  }
  function transformTile(context, tile, c) {
    var component = tile.components[c];
    var codingStyleParameters = component.codingStyleParameters;
    var quantizationParameters = component.quantizationParameters;
    var decompositionLevelsCount = codingStyleParameters.decompositionLevelsCount;
    var spqcds = quantizationParameters.SPqcds;
    var scalarExpounded = quantizationParameters.scalarExpounded;
    var guardBits = quantizationParameters.guardBits;
    var segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
    var precision = context.components[c].precision;
    var reversible = codingStyleParameters.reversibleTransformation;
    var transform = reversible ? new ReversibleTransform() : new IrreversibleTransform();
    var subbandCoefficients = [];
    var b = 0;
    for (var i = 0; i <= decompositionLevelsCount; i++) {
      var resolution = component.resolutions[i];
      var width = resolution.trx1 - resolution.trx0;
      var height = resolution.try1 - resolution.try0;
      var coefficients = new Float32Array(width * height);
      for (var j = 0, jj = resolution.subbands.length; j < jj; j++) {
        var mu, epsilon;
        if (!scalarExpounded) {
          mu = spqcds[0].mu;
          epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);
        } else {
          mu = spqcds[b].mu;
          epsilon = spqcds[b].epsilon;
          b++;
        }
        var subband = resolution.subbands[j];
        var gainLog2 = SubbandsGainLog2[subband.type];
        var delta = reversible ? 1 : Math.pow(2, precision + gainLog2 - epsilon) * (1 + mu / 2048);
        var mb = guardBits + epsilon - 1;
        copyCoefficients(coefficients, width, height, subband, delta, mb, reversible, segmentationSymbolUsed);
      }
      subbandCoefficients.push({
        width: width,
        height: height,
        items: coefficients
      });
    }
    var result = transform.calculate(subbandCoefficients, component.tcx0, component.tcy0);
    return {
      left: component.tcx0,
      top: component.tcy0,
      width: result.width,
      height: result.height,
      items: result.items
    };
  }
  function transformComponents(context) {
    var siz = context.SIZ;
    var components = context.components;
    var componentsCount = siz.Csiz;
    var resultImages = [];
    for (var i = 0, ii = context.tiles.length; i < ii; i++) {
      var tile = context.tiles[i];
      var transformedTiles = [];
      var c;
      for (c = 0; c < componentsCount; c++) {
        transformedTiles[c] = transformTile(context, tile, c);
      }
      var tile0 = transformedTiles[0];
      var out = new Uint8Array(tile0.items.length * componentsCount);
      var result = {
        left: tile0.left,
        top: tile0.top,
        width: tile0.width,
        height: tile0.height,
        items: out
      };
      var shift, offset, max, min, maxK;
      var pos = 0,
          j,
          jj,
          y0,
          y1,
          y2,
          r,
          g,
          b,
          k,
          val;
      if (tile.codingStyleDefaultParameters.multipleComponentTransform) {
        var fourComponents = componentsCount === 4;
        var y0items = transformedTiles[0].items;
        var y1items = transformedTiles[1].items;
        var y2items = transformedTiles[2].items;
        var y3items = fourComponents ? transformedTiles[3].items : null;
        shift = components[0].precision - 8;
        offset = (128 << shift) + 0.5;
        max = 255 * (1 << shift);
        maxK = max * 0.5;
        min = -maxK;
        var component0 = tile.components[0];
        var alpha01 = componentsCount - 3;
        jj = y0items.length;
        if (!component0.codingStyleParameters.reversibleTransformation) {
          for (j = 0; j < jj; j++, pos += alpha01) {
            y0 = y0items[j] + offset;
            y1 = y1items[j];
            y2 = y2items[j];
            r = y0 + 1.402 * y2;
            g = y0 - 0.34413 * y1 - 0.71414 * y2;
            b = y0 + 1.772 * y1;
            out[pos++] = r <= 0 ? 0 : r >= max ? 255 : r >> shift;
            out[pos++] = g <= 0 ? 0 : g >= max ? 255 : g >> shift;
            out[pos++] = b <= 0 ? 0 : b >= max ? 255 : b >> shift;
          }
        } else {
          for (j = 0; j < jj; j++, pos += alpha01) {
            y0 = y0items[j] + offset;
            y1 = y1items[j];
            y2 = y2items[j];
            g = y0 - (y2 + y1 >> 2);
            r = g + y2;
            b = g + y1;
            out[pos++] = r <= 0 ? 0 : r >= max ? 255 : r >> shift;
            out[pos++] = g <= 0 ? 0 : g >= max ? 255 : g >> shift;
            out[pos++] = b <= 0 ? 0 : b >= max ? 255 : b >> shift;
          }
        }
        if (fourComponents) {
          for (j = 0, pos = 3; j < jj; j++, pos += 4) {
            k = y3items[j];
            out[pos] = k <= min ? 0 : k >= maxK ? 255 : k + offset >> shift;
          }
        }
      } else {
        for (c = 0; c < componentsCount; c++) {
          var items = transformedTiles[c].items;
          shift = components[c].precision - 8;
          offset = (128 << shift) + 0.5;
          max = 127.5 * (1 << shift);
          min = -max;
          for (pos = c, j = 0, jj = items.length; j < jj; j++) {
            val = items[j];
            out[pos] = val <= min ? 0 : val >= max ? 255 : val + offset >> shift;
            pos += componentsCount;
          }
        }
      }
      resultImages.push(result);
    }
    return resultImages;
  }
  function initializeTile(context, tileIndex) {
    var siz = context.SIZ;
    var componentsCount = siz.Csiz;
    var tile = context.tiles[tileIndex];
    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var qcdOrQcc = context.currentTile.QCC[c] !== undefined ? context.currentTile.QCC[c] : context.currentTile.QCD;
      component.quantizationParameters = qcdOrQcc;
      var codOrCoc = context.currentTile.COC[c] !== undefined ? context.currentTile.COC[c] : context.currentTile.COD;
      component.codingStyleParameters = codOrCoc;
    }
    tile.codingStyleDefaultParameters = context.currentTile.COD;
  }
  var TagTree = function TagTreeClosure() {
    function TagTree(width, height) {
      var levelsLength = log2(Math.max(width, height)) + 1;
      this.levels = [];
      for (var i = 0; i < levelsLength; i++) {
        var level = {
          width: width,
          height: height,
          items: []
        };
        this.levels.push(level);
        width = Math.ceil(width / 2);
        height = Math.ceil(height / 2);
      }
    }
    TagTree.prototype = {
      reset: function TagTree_reset(i, j) {
        var currentLevel = 0,
            value = 0,
            level;
        while (currentLevel < this.levels.length) {
          level = this.levels[currentLevel];
          var index = i + j * level.width;
          if (level.items[index] !== undefined) {
            value = level.items[index];
            break;
          }
          level.index = index;
          i >>= 1;
          j >>= 1;
          currentLevel++;
        }
        currentLevel--;
        level = this.levels[currentLevel];
        level.items[level.index] = value;
        this.currentLevel = currentLevel;
        delete this.value;
      },
      incrementValue: function TagTree_incrementValue() {
        var level = this.levels[this.currentLevel];
        level.items[level.index]++;
      },
      nextLevel: function TagTree_nextLevel() {
        var currentLevel = this.currentLevel;
        var level = this.levels[currentLevel];
        var value = level.items[level.index];
        currentLevel--;
        if (currentLevel < 0) {
          this.value = value;
          return false;
        }
        this.currentLevel = currentLevel;
        level = this.levels[currentLevel];
        level.items[level.index] = value;
        return true;
      }
    };
    return TagTree;
  }();
  var InclusionTree = function InclusionTreeClosure() {
    function InclusionTree(width, height, defaultValue) {
      var levelsLength = log2(Math.max(width, height)) + 1;
      this.levels = [];
      for (var i = 0; i < levelsLength; i++) {
        var items = new Uint8Array(width * height);
        for (var j = 0, jj = items.length; j < jj; j++) {
          items[j] = defaultValue;
        }
        var level = {
          width: width,
          height: height,
          items: items
        };
        this.levels.push(level);
        width = Math.ceil(width / 2);
        height = Math.ceil(height / 2);
      }
    }
    InclusionTree.prototype = {
      reset: function InclusionTree_reset(i, j, stopValue) {
        var currentLevel = 0;
        while (currentLevel < this.levels.length) {
          var level = this.levels[currentLevel];
          var index = i + j * level.width;
          level.index = index;
          var value = level.items[index];
          if (value === 0xFF) {
            break;
          }
          if (value > stopValue) {
            this.currentLevel = currentLevel;
            this.propagateValues();
            return false;
          }
          i >>= 1;
          j >>= 1;
          currentLevel++;
        }
        this.currentLevel = currentLevel - 1;
        return true;
      },
      incrementValue: function InclusionTree_incrementValue(stopValue) {
        var level = this.levels[this.currentLevel];
        level.items[level.index] = stopValue + 1;
        this.propagateValues();
      },
      propagateValues: function InclusionTree_propagateValues() {
        var levelIndex = this.currentLevel;
        var level = this.levels[levelIndex];
        var currentValue = level.items[level.index];
        while (--levelIndex >= 0) {
          level = this.levels[levelIndex];
          level.items[level.index] = currentValue;
        }
      },
      nextLevel: function InclusionTree_nextLevel() {
        var currentLevel = this.currentLevel;
        var level = this.levels[currentLevel];
        var value = level.items[level.index];
        level.items[level.index] = 0xFF;
        currentLevel--;
        if (currentLevel < 0) {
          return false;
        }
        this.currentLevel = currentLevel;
        level = this.levels[currentLevel];
        level.items[level.index] = value;
        return true;
      }
    };
    return InclusionTree;
  }();
  var BitModel = function BitModelClosure() {
    var UNIFORM_CONTEXT = 17;
    var RUNLENGTH_CONTEXT = 18;
    var LLAndLHContextsLabel = new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8]);
    var HLContextLabel = new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8]);
    var HHContextLabel = new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]);
    function BitModel(width, height, subband, zeroBitPlanes, mb) {
      this.width = width;
      this.height = height;
      this.contextLabelTable = subband === 'HH' ? HHContextLabel : subband === 'HL' ? HLContextLabel : LLAndLHContextsLabel;
      var coefficientCount = width * height;
      this.neighborsSignificance = new Uint8Array(coefficientCount);
      this.coefficentsSign = new Uint8Array(coefficientCount);
      this.coefficentsMagnitude = mb > 14 ? new Uint32Array(coefficientCount) : mb > 6 ? new Uint16Array(coefficientCount) : new Uint8Array(coefficientCount);
      this.processingFlags = new Uint8Array(coefficientCount);
      var bitsDecoded = new Uint8Array(coefficientCount);
      if (zeroBitPlanes !== 0) {
        for (var i = 0; i < coefficientCount; i++) {
          bitsDecoded[i] = zeroBitPlanes;
        }
      }
      this.bitsDecoded = bitsDecoded;
      this.reset();
    }
    BitModel.prototype = {
      setDecoder: function BitModel_setDecoder(decoder) {
        this.decoder = decoder;
      },
      reset: function BitModel_reset() {
        this.contexts = new Int8Array(19);
        this.contexts[0] = 4 << 1 | 0;
        this.contexts[UNIFORM_CONTEXT] = 46 << 1 | 0;
        this.contexts[RUNLENGTH_CONTEXT] = 3 << 1 | 0;
      },
      setNeighborsSignificance: function BitModel_setNeighborsSignificance(row, column, index) {
        var neighborsSignificance = this.neighborsSignificance;
        var width = this.width,
            height = this.height;
        var left = column > 0;
        var right = column + 1 < width;
        var i;
        if (row > 0) {
          i = index - width;
          if (left) {
            neighborsSignificance[i - 1] += 0x10;
          }
          if (right) {
            neighborsSignificance[i + 1] += 0x10;
          }
          neighborsSignificance[i] += 0x04;
        }
        if (row + 1 < height) {
          i = index + width;
          if (left) {
            neighborsSignificance[i - 1] += 0x10;
          }
          if (right) {
            neighborsSignificance[i + 1] += 0x10;
          }
          neighborsSignificance[i] += 0x04;
        }
        if (left) {
          neighborsSignificance[index - 1] += 0x01;
        }
        if (right) {
          neighborsSignificance[index + 1] += 0x01;
        }
        neighborsSignificance[index] |= 0x80;
      },
      runSignificancePropagationPass: function BitModel_runSignificancePropagationPass() {
        var decoder = this.decoder;
        var width = this.width,
            height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var neighborsSignificance = this.neighborsSignificance;
        var processingFlags = this.processingFlags;
        var contexts = this.contexts;
        var labels = this.contextLabelTable;
        var bitsDecoded = this.bitsDecoded;
        var processedInverseMask = ~1;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;
        for (var i0 = 0; i0 < height; i0 += 4) {
          for (var j = 0; j < width; j++) {
            var index = i0 * width + j;
            for (var i1 = 0; i1 < 4; i1++, index += width) {
              var i = i0 + i1;
              if (i >= height) {
                break;
              }
              processingFlags[index] &= processedInverseMask;
              if (coefficentsMagnitude[index] || !neighborsSignificance[index]) {
                continue;
              }
              var contextLabel = labels[neighborsSignificance[index]];
              var decision = decoder.readBit(contexts, contextLabel);
              if (decision) {
                var sign = this.decodeSignBit(i, j, index);
                coefficentsSign[index] = sign;
                coefficentsMagnitude[index] = 1;
                this.setNeighborsSignificance(i, j, index);
                processingFlags[index] |= firstMagnitudeBitMask;
              }
              bitsDecoded[index]++;
              processingFlags[index] |= processedMask;
            }
          }
        }
      },
      decodeSignBit: function BitModel_decodeSignBit(row, column, index) {
        var width = this.width,
            height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var contribution, sign0, sign1, significance1;
        var contextLabel, decoded;
        significance1 = column > 0 && coefficentsMagnitude[index - 1] !== 0;
        if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {
          sign1 = coefficentsSign[index + 1];
          if (significance1) {
            sign0 = coefficentsSign[index - 1];
            contribution = 1 - sign1 - sign0;
          } else {
            contribution = 1 - sign1 - sign1;
          }
        } else if (significance1) {
          sign0 = coefficentsSign[index - 1];
          contribution = 1 - sign0 - sign0;
        } else {
          contribution = 0;
        }
        var horizontalContribution = 3 * contribution;
        significance1 = row > 0 && coefficentsMagnitude[index - width] !== 0;
        if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {
          sign1 = coefficentsSign[index + width];
          if (significance1) {
            sign0 = coefficentsSign[index - width];
            contribution = 1 - sign1 - sign0 + horizontalContribution;
          } else {
            contribution = 1 - sign1 - sign1 + horizontalContribution;
          }
        } else if (significance1) {
          sign0 = coefficentsSign[index - width];
          contribution = 1 - sign0 - sign0 + horizontalContribution;
        } else {
          contribution = horizontalContribution;
        }
        if (contribution >= 0) {
          contextLabel = 9 + contribution;
          decoded = this.decoder.readBit(this.contexts, contextLabel);
        } else {
          contextLabel = 9 - contribution;
          decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
        }
        return decoded;
      },
      runMagnitudeRefinementPass: function BitModel_runMagnitudeRefinementPass() {
        var decoder = this.decoder;
        var width = this.width,
            height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var neighborsSignificance = this.neighborsSignificance;
        var contexts = this.contexts;
        var bitsDecoded = this.bitsDecoded;
        var processingFlags = this.processingFlags;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;
        var length = width * height;
        var width4 = width * 4;
        for (var index0 = 0, indexNext; index0 < length; index0 = indexNext) {
          indexNext = Math.min(length, index0 + width4);
          for (var j = 0; j < width; j++) {
            for (var index = index0 + j; index < indexNext; index += width) {
              if (!coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
                continue;
              }
              var contextLabel = 16;
              if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {
                processingFlags[index] ^= firstMagnitudeBitMask;
                var significance = neighborsSignificance[index] & 127;
                contextLabel = significance === 0 ? 15 : 14;
              }
              var bit = decoder.readBit(contexts, contextLabel);
              coefficentsMagnitude[index] = coefficentsMagnitude[index] << 1 | bit;
              bitsDecoded[index]++;
              processingFlags[index] |= processedMask;
            }
          }
        }
      },
      runCleanupPass: function BitModel_runCleanupPass() {
        var decoder = this.decoder;
        var width = this.width,
            height = this.height;
        var neighborsSignificance = this.neighborsSignificance;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var contexts = this.contexts;
        var labels = this.contextLabelTable;
        var bitsDecoded = this.bitsDecoded;
        var processingFlags = this.processingFlags;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;
        var oneRowDown = width;
        var twoRowsDown = width * 2;
        var threeRowsDown = width * 3;
        var iNext;
        for (var i0 = 0; i0 < height; i0 = iNext) {
          iNext = Math.min(i0 + 4, height);
          var indexBase = i0 * width;
          var checkAllEmpty = i0 + 3 < height;
          for (var j = 0; j < width; j++) {
            var index0 = indexBase + j;
            var allEmpty = checkAllEmpty && processingFlags[index0] === 0 && processingFlags[index0 + oneRowDown] === 0 && processingFlags[index0 + twoRowsDown] === 0 && processingFlags[index0 + threeRowsDown] === 0 && neighborsSignificance[index0] === 0 && neighborsSignificance[index0 + oneRowDown] === 0 && neighborsSignificance[index0 + twoRowsDown] === 0 && neighborsSignificance[index0 + threeRowsDown] === 0;
            var i1 = 0,
                index = index0;
            var i = i0,
                sign;
            if (allEmpty) {
              var hasSignificantCoefficent = decoder.readBit(contexts, RUNLENGTH_CONTEXT);
              if (!hasSignificantCoefficent) {
                bitsDecoded[index0]++;
                bitsDecoded[index0 + oneRowDown]++;
                bitsDecoded[index0 + twoRowsDown]++;
                bitsDecoded[index0 + threeRowsDown]++;
                continue;
              }
              i1 = decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);
              if (i1 !== 0) {
                i = i0 + i1;
                index += i1 * width;
              }
              sign = this.decodeSignBit(i, j, index);
              coefficentsSign[index] = sign;
              coefficentsMagnitude[index] = 1;
              this.setNeighborsSignificance(i, j, index);
              processingFlags[index] |= firstMagnitudeBitMask;
              index = index0;
              for (var i2 = i0; i2 <= i; i2++, index += width) {
                bitsDecoded[index]++;
              }
              i1++;
            }
            for (i = i0 + i1; i < iNext; i++, index += width) {
              if (coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
                continue;
              }
              var contextLabel = labels[neighborsSignificance[index]];
              var decision = decoder.readBit(contexts, contextLabel);
              if (decision === 1) {
                sign = this.decodeSignBit(i, j, index);
                coefficentsSign[index] = sign;
                coefficentsMagnitude[index] = 1;
                this.setNeighborsSignificance(i, j, index);
                processingFlags[index] |= firstMagnitudeBitMask;
              }
              bitsDecoded[index]++;
            }
          }
        }
      },
      checkSegmentationSymbol: function BitModel_checkSegmentationSymbol() {
        var decoder = this.decoder;
        var contexts = this.contexts;
        var symbol = decoder.readBit(contexts, UNIFORM_CONTEXT) << 3 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 2 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);
        if (symbol !== 0xA) {
          error('JPX Error: Invalid segmentation symbol');
        }
      }
    };
    return BitModel;
  }();
  var Transform = function TransformClosure() {
    function Transform() {}
    Transform.prototype.calculate = function transformCalculate(subbands, u0, v0) {
      var ll = subbands[0];
      for (var i = 1, ii = subbands.length; i < ii; i++) {
        ll = this.iterate(ll, subbands[i], u0, v0);
      }
      return ll;
    };
    Transform.prototype.extend = function extend(buffer, offset, size) {
      var i1 = offset - 1,
          j1 = offset + 1;
      var i2 = offset + size - 2,
          j2 = offset + size;
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1] = buffer[j1];
      buffer[j2] = buffer[i2];
    };
    Transform.prototype.iterate = function Transform_iterate(ll, hl_lh_hh, u0, v0) {
      var llWidth = ll.width,
          llHeight = ll.height,
          llItems = ll.items;
      var width = hl_lh_hh.width;
      var height = hl_lh_hh.height;
      var items = hl_lh_hh.items;
      var i, j, k, l, u, v;
      for (k = 0, i = 0; i < llHeight; i++) {
        l = i * 2 * width;
        for (j = 0; j < llWidth; j++, k++, l += 2) {
          items[l] = llItems[k];
        }
      }
      llItems = ll.items = null;
      var bufferPadding = 4;
      var rowBuffer = new Float32Array(width + 2 * bufferPadding);
      if (width === 1) {
        if ((u0 & 1) !== 0) {
          for (v = 0, k = 0; v < height; v++, k += width) {
            items[k] *= 0.5;
          }
        }
      } else {
        for (v = 0, k = 0; v < height; v++, k += width) {
          rowBuffer.set(items.subarray(k, k + width), bufferPadding);
          this.extend(rowBuffer, bufferPadding, width);
          this.filter(rowBuffer, bufferPadding, width);
          items.set(rowBuffer.subarray(bufferPadding, bufferPadding + width), k);
        }
      }
      var numBuffers = 16;
      var colBuffers = [];
      for (i = 0; i < numBuffers; i++) {
        colBuffers.push(new Float32Array(height + 2 * bufferPadding));
      }
      var b,
          currentBuffer = 0;
      ll = bufferPadding + height;
      if (height === 1) {
        if ((v0 & 1) !== 0) {
          for (u = 0; u < width; u++) {
            items[u] *= 0.5;
          }
        }
      } else {
        for (u = 0; u < width; u++) {
          if (currentBuffer === 0) {
            numBuffers = Math.min(width - u, numBuffers);
            for (k = u, l = bufferPadding; l < ll; k += width, l++) {
              for (b = 0; b < numBuffers; b++) {
                colBuffers[b][l] = items[k + b];
              }
            }
            currentBuffer = numBuffers;
          }
          currentBuffer--;
          var buffer = colBuffers[currentBuffer];
          this.extend(buffer, bufferPadding, height);
          this.filter(buffer, bufferPadding, height);
          if (currentBuffer === 0) {
            k = u - numBuffers + 1;
            for (l = bufferPadding; l < ll; k += width, l++) {
              for (b = 0; b < numBuffers; b++) {
                items[k + b] = colBuffers[b][l];
              }
            }
          }
        }
      }
      return {
        width: width,
        height: height,
        items: items
      };
    };
    return Transform;
  }();
  var IrreversibleTransform = function IrreversibleTransformClosure() {
    function IrreversibleTransform() {
      Transform.call(this);
    }
    IrreversibleTransform.prototype = Object.create(Transform.prototype);
    IrreversibleTransform.prototype.filter = function irreversibleTransformFilter(x, offset, length) {
      var len = length >> 1;
      offset = offset | 0;
      var j, n, current, next;
      var alpha = -1.586134342059924;
      var beta = -0.052980118572961;
      var gamma = 0.882911075530934;
      var delta = 0.443506852043971;
      var K = 1.230174104914001;
      var K_ = 1 / K;
      j = offset - 3;
      for (n = len + 4; n--; j += 2) {
        x[j] *= K_;
      }
      j = offset - 2;
      current = delta * x[j - 1];
      for (n = len + 3; n--; j += 2) {
        next = delta * x[j + 1];
        x[j] = K * x[j] - current - next;
        if (n--) {
          j += 2;
          current = delta * x[j + 1];
          x[j] = K * x[j] - current - next;
        } else {
          break;
        }
      }
      j = offset - 1;
      current = gamma * x[j - 1];
      for (n = len + 2; n--; j += 2) {
        next = gamma * x[j + 1];
        x[j] -= current + next;
        if (n--) {
          j += 2;
          current = gamma * x[j + 1];
          x[j] -= current + next;
        } else {
          break;
        }
      }
      j = offset;
      current = beta * x[j - 1];
      for (n = len + 1; n--; j += 2) {
        next = beta * x[j + 1];
        x[j] -= current + next;
        if (n--) {
          j += 2;
          current = beta * x[j + 1];
          x[j] -= current + next;
        } else {
          break;
        }
      }
      if (len !== 0) {
        j = offset + 1;
        current = alpha * x[j - 1];
        for (n = len; n--; j += 2) {
          next = alpha * x[j + 1];
          x[j] -= current + next;
          if (n--) {
            j += 2;
            current = alpha * x[j + 1];
            x[j] -= current + next;
          } else {
            break;
          }
        }
      }
    };
    return IrreversibleTransform;
  }();
  var ReversibleTransform = function ReversibleTransformClosure() {
    function ReversibleTransform() {
      Transform.call(this);
    }
    ReversibleTransform.prototype = Object.create(Transform.prototype);
    ReversibleTransform.prototype.filter = function reversibleTransformFilter(x, offset, length) {
      var len = length >> 1;
      offset = offset | 0;
      var j, n;
      for (j = offset, n = len + 1; n--; j += 2) {
        x[j] -= x[j - 1] + x[j + 1] + 2 >> 2;
      }
      for (j = offset + 1, n = len; n--; j += 2) {
        x[j] += x[j - 1] + x[j + 1] >> 1;
      }
    };
    return ReversibleTransform;
  }();
  return JpxImage;
}();
exports.JpxImage = JpxImage;

/***/ }),
/* 16 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var sharedUtil = __w_pdfjs_require__(0);
var corePrimitives = __w_pdfjs_require__(1);
var coreCrypto = __w_pdfjs_require__(13);
var coreParser = __w_pdfjs_require__(5);
var coreChunkedStream = __w_pdfjs_require__(12);
var coreColorSpace = __w_pdfjs_require__(3);
var InvalidPDFException = sharedUtil.InvalidPDFException;
var MissingDataException = sharedUtil.MissingDataException;
var XRefParseException = sharedUtil.XRefParseException;
var assert = sharedUtil.assert;
var bytesToString = sharedUtil.bytesToString;
var createPromiseCapability = sharedUtil.createPromiseCapability;
var error = sharedUtil.error;
var info = sharedUtil.info;
var isArray = sharedUtil.isArray;
var isBool = sharedUtil.isBool;
var isInt = sharedUtil.isInt;
var isString = sharedUtil.isString;
var shadow = sharedUtil.shadow;
var stringToPDFString = sharedUtil.stringToPDFString;
var stringToUTF8String = sharedUtil.stringToUTF8String;
var warn = sharedUtil.warn;
var createValidAbsoluteUrl = sharedUtil.createValidAbsoluteUrl;
var Util = sharedUtil.Util;
var Dict = corePrimitives.Dict;
var Ref = corePrimitives.Ref;
var RefSet = corePrimitives.RefSet;
var RefSetCache = corePrimitives.RefSetCache;
var isName = corePrimitives.isName;
var isCmd = corePrimitives.isCmd;
var isDict = corePrimitives.isDict;
var isRef = corePrimitives.isRef;
var isRefsEqual = corePrimitives.isRefsEqual;
var isStream = corePrimitives.isStream;
var CipherTransformFactory = coreCrypto.CipherTransformFactory;
var Lexer = coreParser.Lexer;
var Parser = coreParser.Parser;
var ChunkedStream = coreChunkedStream.ChunkedStream;
var ColorSpace = coreColorSpace.ColorSpace;
var Catalog = function CatalogClosure() {
  function Catalog(pdfManager, xref, pageFactory) {
    this.pdfManager = pdfManager;
    this.xref = xref;
    this.catDict = xref.getCatalogObj();
    assert(isDict(this.catDict), 'catalog object is not a dictionary');
    this.fontCache = new RefSetCache();
    this.builtInCMapCache = Object.create(null);
    this.pageKidsCountCache = new RefSetCache();
    this.pageFactory = pageFactory;
    this.pagePromises = [];
  }
  Catalog.prototype = {
    get metadata() {
      var streamRef = this.catDict.getRaw('Metadata');
      if (!isRef(streamRef)) {
        return shadow(this, 'metadata', null);
      }
      var encryptMetadata = !this.xref.encrypt ? false : this.xref.encrypt.encryptMetadata;
      var stream = this.xref.fetch(streamRef, !encryptMetadata);
      var metadata;
      if (stream && isDict(stream.dict)) {
        var type = stream.dict.get('Type');
        var subtype = stream.dict.get('Subtype');
        if (isName(type, 'Metadata') && isName(subtype, 'XML')) {
          try {
            metadata = stringToUTF8String(bytesToString(stream.getBytes()));
          } catch (e) {
            if (e instanceof MissingDataException) {
              throw e;
            }
            info('Skipping invalid metadata.');
          }
        }
      }
      return shadow(this, 'metadata', metadata);
    },
    get toplevelPagesDict() {
      var pagesObj = this.catDict.get('Pages');
      assert(isDict(pagesObj), 'invalid top-level pages dictionary');
      return shadow(this, 'toplevelPagesDict', pagesObj);
    },
    get documentOutline() {
      var obj = null;
      try {
        obj = this.readDocumentOutline();
      } catch (ex) {
        if (ex instanceof MissingDataException) {
          throw ex;
        }
        warn('Unable to read document outline');
      }
      return shadow(this, 'documentOutline', obj);
    },
    readDocumentOutline: function Catalog_readDocumentOutline() {
      var obj = this.catDict.get('Outlines');
      if (!isDict(obj)) {
        return null;
      }
      obj = obj.getRaw('First');
      if (!isRef(obj)) {
        return null;
      }
      var root = { items: [] };
      var queue = [{
        obj: obj,
        parent: root
      }];
      var processed = new RefSet();
      processed.put(obj);
      var xref = this.xref,
          blackColor = new Uint8Array(3);
      while (queue.length > 0) {
        var i = queue.shift();
        var outlineDict = xref.fetchIfRef(i.obj);
        if (outlineDict === null) {
          continue;
        }
        assert(outlineDict.has('Title'), 'Invalid outline item');
        var data = {
          url: null,
          dest: null
        };
        Catalog.parseDestDictionary({
          destDict: outlineDict,
          resultObj: data,
          docBaseUrl: this.pdfManager.docBaseUrl
        });
        var title = outlineDict.get('Title');
        var flags = outlineDict.get('F') || 0;
        var color = outlineDict.getArray('C'),
            rgbColor = blackColor;
        if (isArray(color) && color.length === 3 && (color[0] !== 0 || color[1] !== 0 || color[2] !== 0)) {
          rgbColor = ColorSpace.singletons.rgb.getRgb(color, 0);
        }
        var outlineItem = {
          dest: data.dest,
          url: data.url,
          unsafeUrl: data.unsafeUrl,
          newWindow: data.newWindow,
          title: stringToPDFString(title),
          color: rgbColor,
          count: outlineDict.get('Count'),
          bold: !!(flags & 2),
          italic: !!(flags & 1),
          items: []
        };
        i.parent.items.push(outlineItem);
        obj = outlineDict.getRaw('First');
        if (isRef(obj) && !processed.has(obj)) {
          queue.push({
            obj: obj,
            parent: outlineItem
          });
          processed.put(obj);
        }
        obj = outlineDict.getRaw('Next');
        if (isRef(obj) && !processed.has(obj)) {
          queue.push({
            obj: obj,
            parent: i.parent
          });
          processed.put(obj);
        }
      }
      return root.items.length > 0 ? root.items : null;
    },
    get numPages() {
      var obj = this.toplevelPagesDict.get('Count');
      assert(isInt(obj), 'page count in top level pages object is not an integer');
      return shadow(this, 'num', obj);
    },
    get destinations() {
      function fetchDestination(dest) {
        return isDict(dest) ? dest.get('D') : dest;
      }
      var xref = this.xref;
      var dests = {},
          nameTreeRef,
          nameDictionaryRef;
      var obj = this.catDict.get('Names');
      if (obj && obj.has('Dests')) {
        nameTreeRef = obj.getRaw('Dests');
      } else if (this.catDict.has('Dests')) {
        nameDictionaryRef = this.catDict.get('Dests');
      }
      if (nameDictionaryRef) {
        obj = nameDictionaryRef;
        obj.forEach(function catalogForEach(key, value) {
          if (!value) {
            return;
          }
          dests[key] = fetchDestination(value);
        });
      }
      if (nameTreeRef) {
        var nameTree = new NameTree(nameTreeRef, xref);
        var names = nameTree.getAll();
        for (var name in names) {
          dests[name] = fetchDestination(names[name]);
        }
      }
      return shadow(this, 'destinations', dests);
    },
    getDestination: function Catalog_getDestination(destinationId) {
      function fetchDestination(dest) {
        return isDict(dest) ? dest.get('D') : dest;
      }
      var xref = this.xref;
      var dest = null,
          nameTreeRef,
          nameDictionaryRef;
      var obj = this.catDict.get('Names');
      if (obj && obj.has('Dests')) {
        nameTreeRef = obj.getRaw('Dests');
      } else if (this.catDict.has('Dests')) {
        nameDictionaryRef = this.catDict.get('Dests');
      }
      if (nameDictionaryRef) {
        var value = nameDictionaryRef.get(destinationId);
        if (value) {
          dest = fetchDestination(value);
        }
      }
      if (nameTreeRef) {
        var nameTree = new NameTree(nameTreeRef, xref);
        dest = fetchDestination(nameTree.get(destinationId));
      }
      return dest;
    },
    get pageLabels() {
      var obj = null;
      try {
        obj = this.readPageLabels();
      } catch (ex) {
        if (ex instanceof MissingDataException) {
          throw ex;
        }
        warn('Unable to read page labels.');
      }
      return shadow(this, 'pageLabels', obj);
    },
    readPageLabels: function Catalog_readPageLabels() {
      var obj = this.catDict.getRaw('PageLabels');
      if (!obj) {
        return null;
      }
      var pageLabels = new Array(this.numPages);
      var style = null;
      var prefix = '';
      var numberTree = new NumberTree(obj, this.xref);
      var nums = numberTree.getAll();
      var currentLabel = '',
          currentIndex = 1;
      for (var i = 0, ii = this.numPages; i < ii; i++) {
        if (i in nums) {
          var labelDict = nums[i];
          assert(isDict(labelDict), 'The PageLabel is not a dictionary.');
          var type = labelDict.get('Type');
          assert(!type || isName(type, 'PageLabel'), 'Invalid type in PageLabel dictionary.');
          var s = labelDict.get('S');
          assert(!s || isName(s), 'Invalid style in PageLabel dictionary.');
          style = s ? s.name : null;
          var p = labelDict.get('P');
          assert(!p || isString(p), 'Invalid prefix in PageLabel dictionary.');
          prefix = p ? stringToPDFString(p) : '';
          var st = labelDict.get('St');
          assert(!st || isInt(st) && st >= 1, 'Invalid start in PageLabel dictionary.');
          currentIndex = st || 1;
        }
        switch (style) {
          case 'D':
            currentLabel = currentIndex;
            break;
          case 'R':
          case 'r':
            currentLabel = Util.toRoman(currentIndex, style === 'r');
            break;
          case 'A':
          case 'a':
            var LIMIT = 26;
            var A_UPPER_CASE = 0x41,
                A_LOWER_CASE = 0x61;
            var baseCharCode = style === 'a' ? A_LOWER_CASE : A_UPPER_CASE;
            var letterIndex = currentIndex - 1;
            var character = String.fromCharCode(baseCharCode + letterIndex % LIMIT);
            var charBuf = [];
            for (var j = 0, jj = letterIndex / LIMIT | 0; j <= jj; j++) {
              charBuf.push(character);
            }
            currentLabel = charBuf.join('');
            break;
          default:
            assert(!style, 'Invalid style "' + style + '" in PageLabel dictionary.');
        }
        pageLabels[i] = prefix + currentLabel;
        currentLabel = '';
        currentIndex++;
      }
      return pageLabels;
    },
    get attachments() {
      var xref = this.xref;
      var attachments = null,
          nameTreeRef;
      var obj = this.catDict.get('Names');
      if (obj) {
        nameTreeRef = obj.getRaw('EmbeddedFiles');
      }
      if (nameTreeRef) {
        var nameTree = new NameTree(nameTreeRef, xref);
        var names = nameTree.getAll();
        for (var name in names) {
          var fs = new FileSpec(names[name], xref);
          if (!attachments) {
            attachments = Object.create(null);
          }
          attachments[stringToPDFString(name)] = fs.serializable;
        }
      }
      return shadow(this, 'attachments', attachments);
    },
    get javaScript() {
      var xref = this.xref;
      var obj = this.catDict.get('Names');
      var javaScript = [];
      function appendIfJavaScriptDict(jsDict) {
        var type = jsDict.get('S');
        if (!isName(type, 'JavaScript')) {
          return;
        }
        var js = jsDict.get('JS');
        if (isStream(js)) {
          js = bytesToString(js.getBytes());
        } else if (!isString(js)) {
          return;
        }
        javaScript.push(stringToPDFString(js));
      }
      if (obj && obj.has('JavaScript')) {
        var nameTree = new NameTree(obj.getRaw('JavaScript'), xref);
        var names = nameTree.getAll();
        for (var name in names) {
          var jsDict = names[name];
          if (isDict(jsDict)) {
            appendIfJavaScriptDict(jsDict);
          }
        }
      }
      var openactionDict = this.catDict.get('OpenAction');
      if (isDict(openactionDict, 'Action')) {
        var actionType = openactionDict.get('S');
        if (isName(actionType, 'Named')) {
          var action = openactionDict.get('N');
          if (isName(action, 'Print')) {
            javaScript.push('print({});');
          }
        } else {
          appendIfJavaScriptDict(openactionDict);
        }
      }
      return shadow(this, 'javaScript', javaScript);
    },
    cleanup: function Catalog_cleanup() {
      this.pageKidsCountCache.clear();
      var promises = [];
      this.fontCache.forEach(function (promise) {
        promises.push(promise);
      });
      return Promise.all(promises).then(function (translatedFonts) {
        for (var i = 0, ii = translatedFonts.length; i < ii; i++) {
          var font = translatedFonts[i].dict;
          delete font.translated;
        }
        this.fontCache.clear();
        this.builtInCMapCache = Object.create(null);
      }.bind(this));
    },
    getPage: function Catalog_getPage(pageIndex) {
      if (!(pageIndex in this.pagePromises)) {
        this.pagePromises[pageIndex] = this.getPageDict(pageIndex).then(function (a) {
          var dict = a[0];
          var ref = a[1];
          return this.pageFactory.createPage(pageIndex, dict, ref, this.fontCache, this.builtInCMapCache);
        }.bind(this));
      }
      return this.pagePromises[pageIndex];
    },
    getPageDict: function Catalog_getPageDict(pageIndex) {
      var capability = createPromiseCapability();
      var nodesToVisit = [this.catDict.getRaw('Pages')];
      var count,
          currentPageIndex = 0;
      var xref = this.xref,
          pageKidsCountCache = this.pageKidsCountCache;
      function next() {
        while (nodesToVisit.length) {
          var currentNode = nodesToVisit.pop();
          if (isRef(currentNode)) {
            count = pageKidsCountCache.get(currentNode);
            if (count > 0 && currentPageIndex + count < pageIndex) {
              currentPageIndex += count;
              continue;
            }
            xref.fetchAsync(currentNode).then(function (obj) {
              if (isDict(obj, 'Page') || isDict(obj) && !obj.has('Kids')) {
                if (pageIndex === currentPageIndex) {
                  if (currentNode && !pageKidsCountCache.has(currentNode)) {
                    pageKidsCountCache.put(currentNode, 1);
                  }
                  capability.resolve([obj, currentNode]);
                } else {
                  currentPageIndex++;
                  next();
                }
                return;
              }
              nodesToVisit.push(obj);
              next();
            }, capability.reject);
            return;
          }
          assert(isDict(currentNode), 'page dictionary kid reference points to wrong type of object');
          count = currentNode.get('Count');
          var objId = currentNode.objId;
          if (objId && !pageKidsCountCache.has(objId)) {
            pageKidsCountCache.put(objId, count);
          }
          if (currentPageIndex + count <= pageIndex) {
            currentPageIndex += count;
            continue;
          }
          var kids = currentNode.get('Kids');
          assert(isArray(kids), 'page dictionary kids object is not an array');
          for (var last = kids.length - 1; last >= 0; last--) {
            nodesToVisit.push(kids[last]);
          }
        }
        capability.reject('Page index ' + pageIndex + ' not found.');
      }
      next();
      return capability.promise;
    },
    getPageIndex: function Catalog_getPageIndex(pageRef) {
      var xref = this.xref;
      function pagesBeforeRef(kidRef) {
        var total = 0;
        var parentRef;
        return xref.fetchAsync(kidRef).then(function (node) {
          if (isRefsEqual(kidRef, pageRef) && !isDict(node, 'Page') && !(isDict(node) && !node.has('Type') && node.has('Contents'))) {
            throw new Error('The reference does not point to a /Page Dict.');
          }
          if (!node) {
            return null;
          }
          assert(isDict(node), 'node must be a Dict.');
          parentRef = node.getRaw('Parent');
          return node.getAsync('Parent');
        }).then(function (parent) {
          if (!parent) {
            return null;
          }
          assert(isDict(parent), 'parent must be a Dict.');
          return parent.getAsync('Kids');
        }).then(function (kids) {
          if (!kids) {
            return null;
          }
          var kidPromises = [];
          var found = false;
          for (var i = 0; i < kids.length; i++) {
            var kid = kids[i];
            assert(isRef(kid), 'kid must be a Ref.');
            if (kid.num === kidRef.num) {
              found = true;
              break;
            }
            kidPromises.push(xref.fetchAsync(kid).then(function (kid) {
              if (kid.has('Count')) {
                var count = kid.get('Count');
                total += count;
              } else {
                total++;
              }
            }));
          }
          if (!found) {
            error('kid ref not found in parents kids');
          }
          return Promise.all(kidPromises).then(function () {
            return [total, parentRef];
          });
        });
      }
      var total = 0;
      function next(ref) {
        return pagesBeforeRef(ref).then(function (args) {
          if (!args) {
            return total;
          }
          var count = args[0];
          var parentRef = args[1];
          total += count;
          return next(parentRef);
        });
      }
      return next(pageRef);
    }
  };
  Catalog.parseDestDictionary = function Catalog_parseDestDictionary(params) {
    function addDefaultProtocolToUrl(url) {
      if (url.indexOf('www.') === 0) {
        return 'http://' + url;
      }
      return url;
    }
    function tryConvertUrlEncoding(url) {
      try {
        return stringToUTF8String(url);
      } catch (e) {
        return url;
      }
    }
    var destDict = params.destDict;
    if (!isDict(destDict)) {
      warn('Catalog_parseDestDictionary: "destDict" must be a dictionary.');
      return;
    }
    var resultObj = params.resultObj;
    if ((typeof resultObj === 'undefined' ? 'undefined' : _typeof(resultObj)) !== 'object') {
      warn('Catalog_parseDestDictionary: "resultObj" must be an object.');
      return;
    }
    var docBaseUrl = params.docBaseUrl || null;
    var action = destDict.get('A'),
        url,
        dest;
    if (isDict(action)) {
      var linkType = action.get('S').name;
      switch (linkType) {
        case 'URI':
          url = action.get('URI');
          if (isName(url)) {
            url = '/' + url.name;
          } else if (isString(url)) {
            url = addDefaultProtocolToUrl(url);
          }
          break;
        case 'GoTo':
          dest = action.get('D');
          break;
        case 'Launch':
        case 'GoToR':
          var urlDict = action.get('F');
          if (isDict(urlDict)) {
            url = urlDict.get('F') || null;
          } else if (isString(urlDict)) {
            url = urlDict;
          }
          var remoteDest = action.get('D');
          if (remoteDest) {
            if (isName(remoteDest)) {
              remoteDest = remoteDest.name;
            }
            if (isString(url)) {
              var baseUrl = url.split('#')[0];
              if (isString(remoteDest)) {
                url = baseUrl + '#' + (/^\d+$/.test(remoteDest) ? 'nameddest=' : '') + remoteDest;
              } else if (isArray(remoteDest)) {
                url = baseUrl + '#' + JSON.stringify(remoteDest);
              }
            }
          }
          var newWindow = action.get('NewWindow');
          if (isBool(newWindow)) {
            resultObj.newWindow = newWindow;
          }
          break;
        case 'Named':
          var namedAction = action.get('N');
          if (isName(namedAction)) {
            resultObj.action = namedAction.name;
          }
          break;
        case 'JavaScript':
          var jsAction = action.get('JS'),
              js;
          if (isStream(jsAction)) {
            js = bytesToString(jsAction.getBytes());
          } else if (isString(jsAction)) {
            js = jsAction;
          }
          if (js) {
            var URL_OPEN_METHODS = ['app.launchURL', 'window.open'];
            var regex = new RegExp('^\\s*(' + URL_OPEN_METHODS.join('|').split('.').join('\\.') + ')\\((?:\'|\")([^\'\"]*)(?:\'|\")(?:,\\s*(\\w+)\\)|\\))', 'i');
            var jsUrl = regex.exec(stringToPDFString(js));
            if (jsUrl && jsUrl[2]) {
              url = jsUrl[2];
              if (jsUrl[3] === 'true' && jsUrl[1] === 'app.launchURL') {
                resultObj.newWindow = true;
              }
              break;
            }
          }
        default:
          warn('Catalog_parseDestDictionary: Unrecognized link type "' + linkType + '".');
          break;
      }
    } else if (destDict.has('Dest')) {
      dest = destDict.get('Dest');
    }
    if (isString(url)) {
      url = tryConvertUrlEncoding(url);
      var absoluteUrl = createValidAbsoluteUrl(url, docBaseUrl);
      if (absoluteUrl) {
        resultObj.url = absoluteUrl.href;
      }
      resultObj.unsafeUrl = url;
    }
    if (dest) {
      if (isName(dest)) {
        dest = dest.name;
      }
      if (isString(dest) || isArray(dest)) {
        resultObj.dest = dest;
      }
    }
  };
  return Catalog;
}();
var XRef = function XRefClosure() {
  function XRef(stream, pdfManager) {
    this.stream = stream;
    this.pdfManager = pdfManager;
    this.entries = [];
    this.xrefstms = Object.create(null);
    this.cache = [];
    this.stats = {
      streamTypes: [],
      fontTypes: []
    };
  }
  XRef.prototype = {
    setStartXRef: function XRef_setStartXRef(startXRef) {
      this.startXRefQueue = [startXRef];
    },
    parse: function XRef_parse(recoveryMode) {
      var trailerDict;
      if (!recoveryMode) {
        trailerDict = this.readXRef();
      } else {
        warn('Indexing all PDF objects');
        trailerDict = this.indexObjects();
      }
      trailerDict.assignXref(this);
      this.trailer = trailerDict;
      var encrypt = trailerDict.get('Encrypt');
      if (isDict(encrypt)) {
        var ids = trailerDict.get('ID');
        var fileId = ids && ids.length ? ids[0] : '';
        encrypt.suppressEncryption = true;
        this.encrypt = new CipherTransformFactory(encrypt, fileId, this.pdfManager.password);
      }
      if (!(this.root = trailerDict.get('Root'))) {
        error('Invalid root reference');
      }
    },
    processXRefTable: function XRef_processXRefTable(parser) {
      if (!('tableState' in this)) {
        this.tableState = {
          entryNum: 0,
          streamPos: parser.lexer.stream.pos,
          parserBuf1: parser.buf1,
          parserBuf2: parser.buf2
        };
      }
      var obj = this.readXRefTable(parser);
      if (!isCmd(obj, 'trailer')) {
        error('Invalid XRef table: could not find trailer dictionary');
      }
      var dict = parser.getObj();
      if (!isDict(dict) && dict.dict) {
        dict = dict.dict;
      }
      if (!isDict(dict)) {
        error('Invalid XRef table: could not parse trailer dictionary');
      }
      delete this.tableState;
      return dict;
    },
    readXRefTable: function XRef_readXRefTable(parser) {
      var stream = parser.lexer.stream;
      var tableState = this.tableState;
      stream.pos = tableState.streamPos;
      parser.buf1 = tableState.parserBuf1;
      parser.buf2 = tableState.parserBuf2;
      var obj;
      while (true) {
        if (!('firstEntryNum' in tableState) || !('entryCount' in tableState)) {
          if (isCmd(obj = parser.getObj(), 'trailer')) {
            break;
          }
          tableState.firstEntryNum = obj;
          tableState.entryCount = parser.getObj();
        }
        var first = tableState.firstEntryNum;
        var count = tableState.entryCount;
        if (!isInt(first) || !isInt(count)) {
          error('Invalid XRef table: wrong types in subsection header');
        }
        for (var i = tableState.entryNum; i < count; i++) {
          tableState.streamPos = stream.pos;
          tableState.entryNum = i;
          tableState.parserBuf1 = parser.buf1;
          tableState.parserBuf2 = parser.buf2;
          var entry = {};
          entry.offset = parser.getObj();
          entry.gen = parser.getObj();
          var type = parser.getObj();
          if (isCmd(type, 'f')) {
            entry.free = true;
          } else if (isCmd(type, 'n')) {
            entry.uncompressed = true;
          }
          if (!isInt(entry.offset) || !isInt(entry.gen) || !(entry.free || entry.uncompressed)) {
            error('Invalid entry in XRef subsection: ' + first + ', ' + count);
          }
          if (i === 0 && entry.free && first === 1) {
            first = 0;
          }
          if (!this.entries[i + first]) {
            this.entries[i + first] = entry;
          }
        }
        tableState.entryNum = 0;
        tableState.streamPos = stream.pos;
        tableState.parserBuf1 = parser.buf1;
        tableState.parserBuf2 = parser.buf2;
        delete tableState.firstEntryNum;
        delete tableState.entryCount;
      }
      if (this.entries[0] && !this.entries[0].free) {
        error('Invalid XRef table: unexpected first object');
      }
      return obj;
    },
    processXRefStream: function XRef_processXRefStream(stream) {
      if (!('streamState' in this)) {
        var streamParameters = stream.dict;
        var byteWidths = streamParameters.get('W');
        var range = streamParameters.get('Index');
        if (!range) {
          range = [0, streamParameters.get('Size')];
        }
        this.streamState = {
          entryRanges: range,
          byteWidths: byteWidths,
          entryNum: 0,
          streamPos: stream.pos
        };
      }
      this.readXRefStream(stream);
      delete this.streamState;
      return stream.dict;
    },
    readXRefStream: function XRef_readXRefStream(stream) {
      var i, j;
      var streamState = this.streamState;
      stream.pos = streamState.streamPos;
      var byteWidths = streamState.byteWidths;
      var typeFieldWidth = byteWidths[0];
      var offsetFieldWidth = byteWidths[1];
      var generationFieldWidth = byteWidths[2];
      var entryRanges = streamState.entryRanges;
      while (entryRanges.length > 0) {
        var first = entryRanges[0];
        var n = entryRanges[1];
        if (!isInt(first) || !isInt(n)) {
          error('Invalid XRef range fields: ' + first + ', ' + n);
        }
        if (!isInt(typeFieldWidth) || !isInt(offsetFieldWidth) || !isInt(generationFieldWidth)) {
          error('Invalid XRef entry fields length: ' + first + ', ' + n);
        }
        for (i = streamState.entryNum; i < n; ++i) {
          streamState.entryNum = i;
          streamState.streamPos = stream.pos;
          var type = 0,
              offset = 0,
              generation = 0;
          for (j = 0; j < typeFieldWidth; ++j) {
            type = type << 8 | stream.getByte();
          }
          if (typeFieldWidth === 0) {
            type = 1;
          }
          for (j = 0; j < offsetFieldWidth; ++j) {
            offset = offset << 8 | stream.getByte();
          }
          for (j = 0; j < generationFieldWidth; ++j) {
            generation = generation << 8 | stream.getByte();
          }
          var entry = {};
          entry.offset = offset;
          entry.gen = generation;
          switch (type) {
            case 0:
              entry.free = true;
              break;
            case 1:
              entry.uncompressed = true;
              break;
            case 2:
              break;
            default:
              error('Invalid XRef entry type: ' + type);
          }
          if (!this.entries[first + i]) {
            this.entries[first + i] = entry;
          }
        }
        streamState.entryNum = 0;
        streamState.streamPos = stream.pos;
        entryRanges.splice(0, 2);
      }
    },
    indexObjects: function XRef_indexObjects() {
      var TAB = 0x9,
          LF = 0xA,
          CR = 0xD,
          SPACE = 0x20;
      var PERCENT = 0x25,
          LT = 0x3C;
      function readToken(data, offset) {
        var token = '',
            ch = data[offset];
        while (ch !== LF && ch !== CR && ch !== LT) {
          if (++offset >= data.length) {
            break;
          }
          token += String.fromCharCode(ch);
          ch = data[offset];
        }
        return token;
      }
      function skipUntil(data, offset, what) {
        var length = what.length,
            dataLength = data.length;
        var skipped = 0;
        while (offset < dataLength) {
          var i = 0;
          while (i < length && data[offset + i] === what[i]) {
            ++i;
          }
          if (i >= length) {
            break;
          }
          offset++;
          skipped++;
        }
        return skipped;
      }
      var objRegExp = /^(\d+)\s+(\d+)\s+obj\b/;
      var trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);
      var startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
      var endobjBytes = new Uint8Array([101, 110, 100, 111, 98, 106]);
      var xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);
      this.entries.length = 0;
      var stream = this.stream;
      stream.pos = 0;
      var buffer = stream.getBytes();
      var position = stream.start,
          length = buffer.length;
      var trailers = [],
          xrefStms = [];
      while (position < length) {
        var ch = buffer[position];
        if (ch === TAB || ch === LF || ch === CR || ch === SPACE) {
          ++position;
          continue;
        }
        if (ch === PERCENT) {
          do {
            ++position;
            if (position >= length) {
              break;
            }
            ch = buffer[position];
          } while (ch !== LF && ch !== CR);
          continue;
        }
        var token = readToken(buffer, position);
        var m;
        if (token.indexOf('xref') === 0 && (token.length === 4 || /\s/.test(token[4]))) {
          position += skipUntil(buffer, position, trailerBytes);
          trailers.push(position);
          position += skipUntil(buffer, position, startxrefBytes);
        } else if (m = objRegExp.exec(token)) {
          if (typeof this.entries[m[1]] === 'undefined') {
            this.entries[m[1]] = {
              offset: position - stream.start,
              gen: m[2] | 0,
              uncompressed: true
            };
          }
          var contentLength = skipUntil(buffer, position, endobjBytes) + 7;
          var content = buffer.subarray(position, position + contentLength);
          var xrefTagOffset = skipUntil(content, 0, xrefBytes);
          if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {
            xrefStms.push(position - stream.start);
            this.xrefstms[position - stream.start] = 1;
          }
          position += contentLength;
        } else if (token.indexOf('trailer') === 0 && (token.length === 7 || /\s/.test(token[7]))) {
          trailers.push(position);
          position += skipUntil(buffer, position, startxrefBytes);
        } else {
          position += token.length + 1;
        }
      }
      var i, ii;
      for (i = 0, ii = xrefStms.length; i < ii; ++i) {
        this.startXRefQueue.push(xrefStms[i]);
        this.readXRef(true);
      }
      var dict;
      for (i = 0, ii = trailers.length; i < ii; ++i) {
        stream.pos = trailers[i];
        var parser = new Parser(new Lexer(stream), true, this, true);
        var obj = parser.getObj();
        if (!isCmd(obj, 'trailer')) {
          continue;
        }
        dict = parser.getObj();
        if (!isDict(dict)) {
          continue;
        }
        if (dict.has('ID')) {
          return dict;
        }
      }
      if (dict) {
        return dict;
      }
      throw new InvalidPDFException('Invalid PDF structure');
    },
    readXRef: function XRef_readXRef(recoveryMode) {
      var stream = this.stream;
      try {
        while (this.startXRefQueue.length) {
          var startXRef = this.startXRefQueue[0];
          stream.pos = startXRef + stream.start;
          var parser = new Parser(new Lexer(stream), true, this);
          var obj = parser.getObj();
          var dict;
          if (isCmd(obj, 'xref')) {
            dict = this.processXRefTable(parser);
            if (!this.topDict) {
              this.topDict = dict;
            }
            obj = dict.get('XRefStm');
            if (isInt(obj)) {
              var pos = obj;
              if (!(pos in this.xrefstms)) {
                this.xrefstms[pos] = 1;
                this.startXRefQueue.push(pos);
              }
            }
          } else if (isInt(obj)) {
            if (!isInt(parser.getObj()) || !isCmd(parser.getObj(), 'obj') || !isStream(obj = parser.getObj())) {
              error('Invalid XRef stream');
            }
            dict = this.processXRefStream(obj);
            if (!this.topDict) {
              this.topDict = dict;
            }
            if (!dict) {
              error('Failed to read XRef stream');
            }
          } else {
            error('Invalid XRef stream header');
          }
          obj = dict.get('Prev');
          if (isInt(obj)) {
            this.startXRefQueue.push(obj);
          } else if (isRef(obj)) {
            this.startXRefQueue.push(obj.num);
          }
          this.startXRefQueue.shift();
        }
        return this.topDict;
      } catch (e) {
        if (e instanceof MissingDataException) {
          throw e;
        }
        info('(while reading XRef): ' + e);
      }
      if (recoveryMode) {
        return;
      }
      throw new XRefParseException();
    },
    getEntry: function XRef_getEntry(i) {
      var xrefEntry = this.entries[i];
      if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {
        return xrefEntry;
      }
      return null;
    },
    fetchIfRef: function XRef_fetchIfRef(obj, suppressEncryption) {
      if (!isRef(obj)) {
        return obj;
      }
      return this.fetch(obj, suppressEncryption);
    },
    fetch: function XRef_fetch(ref, suppressEncryption) {
      assert(isRef(ref), 'ref object is not a reference');
      var num = ref.num;
      if (num in this.cache) {
        var cacheEntry = this.cache[num];
        if (cacheEntry instanceof Dict && !cacheEntry.objId) {
          cacheEntry.objId = ref.toString();
        }
        return cacheEntry;
      }
      var xrefEntry = this.getEntry(num);
      if (xrefEntry === null) {
        return this.cache[num] = null;
      }
      if (xrefEntry.uncompressed) {
        xrefEntry = this.fetchUncompressed(ref, xrefEntry, suppressEncryption);
      } else {
        xrefEntry = this.fetchCompressed(xrefEntry, suppressEncryption);
      }
      if (isDict(xrefEntry)) {
        xrefEntry.objId = ref.toString();
      } else if (isStream(xrefEntry)) {
        xrefEntry.dict.objId = ref.toString();
      }
      return xrefEntry;
    },
    fetchUncompressed: function XRef_fetchUncompressed(ref, xrefEntry, suppressEncryption) {
      var gen = ref.gen;
      var num = ref.num;
      if (xrefEntry.gen !== gen) {
        error('inconsistent generation in XRef');
      }
      var stream = this.stream.makeSubStream(xrefEntry.offset + this.stream.start);
      var parser = new Parser(new Lexer(stream), true, this);
      var obj1 = parser.getObj();
      var obj2 = parser.getObj();
      var obj3 = parser.getObj();
      if (!isInt(obj1) || parseInt(obj1, 10) !== num || !isInt(obj2) || parseInt(obj2, 10) !== gen || !isCmd(obj3)) {
        error('bad XRef entry');
      }
      if (!isCmd(obj3, 'obj')) {
        if (obj3.cmd.indexOf('obj') === 0) {
          num = parseInt(obj3.cmd.substring(3), 10);
          if (!isNaN(num)) {
            return num;
          }
        }
        error('bad XRef entry');
      }
      if (this.encrypt && !suppressEncryption) {
        xrefEntry = parser.getObj(this.encrypt.createCipherTransform(num, gen));
      } else {
        xrefEntry = parser.getObj();
      }
      if (!isStream(xrefEntry)) {
        this.cache[num] = xrefEntry;
      }
      return xrefEntry;
    },
    fetchCompressed: function XRef_fetchCompressed(xrefEntry, suppressEncryption) {
      var tableOffset = xrefEntry.offset;
      var stream = this.fetch(new Ref(tableOffset, 0));
      if (!isStream(stream)) {
        error('bad ObjStm stream');
      }
      var first = stream.dict.get('First');
      var n = stream.dict.get('N');
      if (!isInt(first) || !isInt(n)) {
        error('invalid first and n parameters for ObjStm stream');
      }
      var parser = new Parser(new Lexer(stream), false, this);
      parser.allowStreams = true;
      var i,
          entries = [],
          num,
          nums = [];
      for (i = 0; i < n; ++i) {
        num = parser.getObj();
        if (!isInt(num)) {
          error('invalid object number in the ObjStm stream: ' + num);
        }
        nums.push(num);
        var offset = parser.getObj();
        if (!isInt(offset)) {
          error('invalid object offset in the ObjStm stream: ' + offset);
        }
      }
      for (i = 0; i < n; ++i) {
        entries.push(parser.getObj());
        if (isCmd(parser.buf1, 'endobj')) {
          parser.shift();
        }
        num = nums[i];
        var entry = this.entries[num];
        if (entry && entry.offset === tableOffset && entry.gen === i) {
          this.cache[num] = entries[i];
        }
      }
      xrefEntry = entries[xrefEntry.gen];
      if (xrefEntry === undefined) {
        error('bad XRef entry for compressed object');
      }
      return xrefEntry;
    },
    fetchIfRefAsync: function XRef_fetchIfRefAsync(obj, suppressEncryption) {
      if (!isRef(obj)) {
        return Promise.resolve(obj);
      }
      return this.fetchAsync(obj, suppressEncryption);
    },
    fetchAsync: function XRef_fetchAsync(ref, suppressEncryption) {
      var streamManager = this.stream.manager;
      var xref = this;
      return new Promise(function tryFetch(resolve, reject) {
        try {
          resolve(xref.fetch(ref, suppressEncryption));
        } catch (e) {
          if (e instanceof MissingDataException) {
            streamManager.requestRange(e.begin, e.end).then(function () {
              tryFetch(resolve, reject);
            }, reject);
            return;
          }
          reject(e);
        }
      });
    },
    getCatalogObj: function XRef_getCatalogObj() {
      return this.root;
    }
  };
  return XRef;
}();
var NameOrNumberTree = function NameOrNumberTreeClosure() {
  function NameOrNumberTree(root, xref) {
    throw new Error('Cannot initialize NameOrNumberTree.');
  }
  NameOrNumberTree.prototype = {
    getAll: function NameOrNumberTree_getAll() {
      var dict = Object.create(null);
      if (!this.root) {
        return dict;
      }
      var xref = this.xref;
      var processed = new RefSet();
      processed.put(this.root);
      var queue = [this.root];
      while (queue.length > 0) {
        var i, n;
        var obj = xref.fetchIfRef(queue.shift());
        if (!isDict(obj)) {
          continue;
        }
        if (obj.has('Kids')) {
          var kids = obj.get('Kids');
          for (i = 0, n = kids.length; i < n; i++) {
            var kid = kids[i];
            assert(!processed.has(kid), 'Duplicate entry in "' + this._type + '" tree.');
            queue.push(kid);
            processed.put(kid);
          }
          continue;
        }
        var entries = obj.get(this._type);
        if (isArray(entries)) {
          for (i = 0, n = entries.length; i < n; i += 2) {
            dict[xref.fetchIfRef(entries[i])] = xref.fetchIfRef(entries[i + 1]);
          }
        }
      }
      return dict;
    },
    get: function NameOrNumberTree_get(key) {
      if (!this.root) {
        return null;
      }
      var xref = this.xref;
      var kidsOrEntries = xref.fetchIfRef(this.root);
      var loopCount = 0;
      var MAX_LEVELS = 10;
      var l, r, m;
      while (kidsOrEntries.has('Kids')) {
        if (++loopCount > MAX_LEVELS) {
          warn('Search depth limit reached for "' + this._type + '" tree.');
          return null;
        }
        var kids = kidsOrEntries.get('Kids');
        if (!isArray(kids)) {
          return null;
        }
        l = 0;
        r = kids.length - 1;
        while (l <= r) {
          m = l + r >> 1;
          var kid = xref.fetchIfRef(kids[m]);
          var limits = kid.get('Limits');
          if (key < xref.fetchIfRef(limits[0])) {
            r = m - 1;
          } else if (key > xref.fetchIfRef(limits[1])) {
            l = m + 1;
          } else {
            kidsOrEntries = xref.fetchIfRef(kids[m]);
            break;
          }
        }
        if (l > r) {
          return null;
        }
      }
      var entries = kidsOrEntries.get(this._type);
      if (isArray(entries)) {
        l = 0;
        r = entries.length - 2;
        while (l <= r) {
          m = l + r & ~1;
          var currentKey = xref.fetchIfRef(entries[m]);
          if (key < currentKey) {
            r = m - 2;
          } else if (key > currentKey) {
            l = m + 2;
          } else {
            return xref.fetchIfRef(entries[m + 1]);
          }
        }
      }
      return null;
    }
  };
  return NameOrNumberTree;
}();
var NameTree = function NameTreeClosure() {
  function NameTree(root, xref) {
    this.root = root;
    this.xref = xref;
    this._type = 'Names';
  }
  Util.inherit(NameTree, NameOrNumberTree, {});
  return NameTree;
}();
var NumberTree = function NumberTreeClosure() {
  function NumberTree(root, xref) {
    this.root = root;
    this.xref = xref;
    this._type = 'Nums';
  }
  Util.inherit(NumberTree, NameOrNumberTree, {});
  return NumberTree;
}();
var FileSpec = function FileSpecClosure() {
  function FileSpec(root, xref) {
    if (!root || !isDict(root)) {
      return;
    }
    this.xref = xref;
    this.root = root;
    if (root.has('FS')) {
      this.fs = root.get('FS');
    }
    this.description = root.has('Desc') ? stringToPDFString(root.get('Desc')) : '';
    if (root.has('RF')) {
      warn('Related file specifications are not supported');
    }
    this.contentAvailable = true;
    if (!root.has('EF')) {
      this.contentAvailable = false;
      warn('Non-embedded file specifications are not supported');
    }
  }
  function pickPlatformItem(dict) {
    if (dict.has('UF')) {
      return dict.get('UF');
    } else if (dict.has('F')) {
      return dict.get('F');
    } else if (dict.has('Unix')) {
      return dict.get('Unix');
    } else if (dict.has('Mac')) {
      return dict.get('Mac');
    } else if (dict.has('DOS')) {
      return dict.get('DOS');
    }
    return null;
  }
  FileSpec.prototype = {
    get filename() {
      if (!this._filename && this.root) {
        var filename = pickPlatformItem(this.root) || 'unnamed';
        this._filename = stringToPDFString(filename).replace(/\\\\/g, '\\').replace(/\\\//g, '/').replace(/\\/g, '/');
      }
      return this._filename;
    },
    get content() {
      if (!this.contentAvailable) {
        return null;
      }
      if (!this.contentRef && this.root) {
        this.contentRef = pickPlatformItem(this.root.get('EF'));
      }
      var content = null;
      if (this.contentRef) {
        var xref = this.xref;
        var fileObj = xref.fetchIfRef(this.contentRef);
        if (fileObj && isStream(fileObj)) {
          content = fileObj.getBytes();
        } else {
          warn('Embedded file specification points to non-existing/invalid ' + 'content');
        }
      } else {
        warn('Embedded file specification does not have a content');
      }
      return content;
    },
    get serializable() {
      return {
        filename: this.filename,
        content: this.content
      };
    }
  };
  return FileSpec;
}();
var ObjectLoader = function () {
  function mayHaveChildren(value) {
    return isRef(value) || isDict(value) || isArray(value) || isStream(value);
  }
  function addChildren(node, nodesToVisit) {
    var value;
    if (isDict(node) || isStream(node)) {
      var map;
      if (isDict(node)) {
        map = node.map;
      } else {
        map = node.dict.map;
      }
      for (var key in map) {
        value = map[key];
        if (mayHaveChildren(value)) {
          nodesToVisit.push(value);
        }
      }
    } else if (isArray(node)) {
      for (var i = 0, ii = node.length; i < ii; i++) {
        value = node[i];
        if (mayHaveChildren(value)) {
          nodesToVisit.push(value);
        }
      }
    }
  }
  function ObjectLoader(obj, keys, xref) {
    this.obj = obj;
    this.keys = keys;
    this.xref = xref;
    this.refSet = null;
    this.capability = null;
  }
  ObjectLoader.prototype = {
    load: function ObjectLoader_load() {
      var keys = this.keys;
      this.capability = createPromiseCapability();
      if (!(this.xref.stream instanceof ChunkedStream) || this.xref.stream.getMissingChunks().length === 0) {
        this.capability.resolve();
        return this.capability.promise;
      }
      this.refSet = new RefSet();
      var nodesToVisit = [];
      for (var i = 0; i < keys.length; i++) {
        nodesToVisit.push(this.obj[keys[i]]);
      }
      this._walk(nodesToVisit);
      return this.capability.promise;
    },
    _walk: function ObjectLoader_walk(nodesToVisit) {
      var nodesToRevisit = [];
      var pendingRequests = [];
      while (nodesToVisit.length) {
        var currentNode = nodesToVisit.pop();
        if (isRef(currentNode)) {
          if (this.refSet.has(currentNode)) {
            continue;
          }
          try {
            var ref = currentNode;
            this.refSet.put(ref);
            currentNode = this.xref.fetch(currentNode);
          } catch (e) {
            if (!(e instanceof MissingDataException)) {
              throw e;
            }
            nodesToRevisit.push(currentNode);
            pendingRequests.push({
              begin: e.begin,
              end: e.end
            });
          }
        }
        if (currentNode && currentNode.getBaseStreams) {
          var baseStreams = currentNode.getBaseStreams();
          var foundMissingData = false;
          for (var i = 0; i < baseStreams.length; i++) {
            var stream = baseStreams[i];
            if (stream.getMissingChunks && stream.getMissingChunks().length) {
              foundMissingData = true;
              pendingRequests.push({
                begin: stream.start,
                end: stream.end
              });
            }
          }
          if (foundMissingData) {
            nodesToRevisit.push(currentNode);
          }
        }
        addChildren(currentNode, nodesToVisit);
      }
      if (pendingRequests.length) {
        this.xref.stream.manager.requestRanges(pendingRequests).then(function pendingRequestCallback() {
          nodesToVisit = nodesToRevisit;
          for (var i = 0; i < nodesToRevisit.length; i++) {
            var node = nodesToRevisit[i];
            if (isRef(node)) {
              this.refSet.remove(node);
            }
          }
          this._walk(nodesToVisit);
        }.bind(this), this.capability.reject);
        return;
      }
      this.refSet = null;
      this.capability.resolve();
    }
  };
  return ObjectLoader;
}();
exports.Catalog = Catalog;
exports.ObjectLoader = ObjectLoader;
exports.XRef = XRef;
exports.FileSpec = FileSpec;

/***/ }),
/* 17 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var getLookupTableFactory = sharedUtil.getLookupTableFactory;
var getStdFontMap = getLookupTableFactory(function (t) {
  t['ArialNarrow'] = 'Helvetica';
  t['ArialNarrow-Bold'] = 'Helvetica-Bold';
  t['ArialNarrow-BoldItalic'] = 'Helvetica-BoldOblique';
  t['ArialNarrow-Italic'] = 'Helvetica-Oblique';
  t['ArialBlack'] = 'Helvetica';
  t['ArialBlack-Bold'] = 'Helvetica-Bold';
  t['ArialBlack-BoldItalic'] = 'Helvetica-BoldOblique';
  t['ArialBlack-Italic'] = 'Helvetica-Oblique';
  t['Arial-Black'] = 'Helvetica';
  t['Arial-Black-Bold'] = 'Helvetica-Bold';
  t['Arial-Black-BoldItalic'] = 'Helvetica-BoldOblique';
  t['Arial-Black-Italic'] = 'Helvetica-Oblique';
  t['Arial'] = 'Helvetica';
  t['Arial-Bold'] = 'Helvetica-Bold';
  t['Arial-BoldItalic'] = 'Helvetica-BoldOblique';
  t['Arial-Italic'] = 'Helvetica-Oblique';
  t['Arial-BoldItalicMT'] = 'Helvetica-BoldOblique';
  t['Arial-BoldMT'] = 'Helvetica-Bold';
  t['Arial-ItalicMT'] = 'Helvetica-Oblique';
  t['ArialMT'] = 'Helvetica';
  t['Courier-Bold'] = 'Courier-Bold';
  t['Courier-BoldItalic'] = 'Courier-BoldOblique';
  t['Courier-Italic'] = 'Courier-Oblique';
  t['CourierNew'] = 'Courier';
  t['CourierNew-Bold'] = 'Courier-Bold';
  t['CourierNew-BoldItalic'] = 'Courier-BoldOblique';
  t['CourierNew-Italic'] = 'Courier-Oblique';
  t['CourierNewPS-BoldItalicMT'] = 'Courier-BoldOblique';
  t['CourierNewPS-BoldMT'] = 'Courier-Bold';
  t['CourierNewPS-ItalicMT'] = 'Courier-Oblique';
  t['CourierNewPSMT'] = 'Courier';
  t['Helvetica'] = 'Helvetica';
  t['Helvetica-Bold'] = 'Helvetica-Bold';
  t['Helvetica-BoldItalic'] = 'Helvetica-BoldOblique';
  t['Helvetica-BoldOblique'] = 'Helvetica-BoldOblique';
  t['Helvetica-Italic'] = 'Helvetica-Oblique';
  t['Helvetica-Oblique'] = 'Helvetica-Oblique';
  t['Symbol-Bold'] = 'Symbol';
  t['Symbol-BoldItalic'] = 'Symbol';
  t['Symbol-Italic'] = 'Symbol';
  t['TimesNewRoman'] = 'Times-Roman';
  t['TimesNewRoman-Bold'] = 'Times-Bold';
  t['TimesNewRoman-BoldItalic'] = 'Times-BoldItalic';
  t['TimesNewRoman-Italic'] = 'Times-Italic';
  t['TimesNewRomanPS'] = 'Times-Roman';
  t['TimesNewRomanPS-Bold'] = 'Times-Bold';
  t['TimesNewRomanPS-BoldItalic'] = 'Times-BoldItalic';
  t['TimesNewRomanPS-BoldItalicMT'] = 'Times-BoldItalic';
  t['TimesNewRomanPS-BoldMT'] = 'Times-Bold';
  t['TimesNewRomanPS-Italic'] = 'Times-Italic';
  t['TimesNewRomanPS-ItalicMT'] = 'Times-Italic';
  t['TimesNewRomanPSMT'] = 'Times-Roman';
  t['TimesNewRomanPSMT-Bold'] = 'Times-Bold';
  t['TimesNewRomanPSMT-BoldItalic'] = 'Times-BoldItalic';
  t['TimesNewRomanPSMT-Italic'] = 'Times-Italic';
});
var getNonStdFontMap = getLookupTableFactory(function (t) {
  t['CenturyGothic'] = 'Helvetica';
  t['CenturyGothic-Bold'] = 'Helvetica-Bold';
  t['CenturyGothic-BoldItalic'] = 'Helvetica-BoldOblique';
  t['CenturyGothic-Italic'] = 'Helvetica-Oblique';
  t['ComicSansMS'] = 'Comic Sans MS';
  t['ComicSansMS-Bold'] = 'Comic Sans MS-Bold';
  t['ComicSansMS-BoldItalic'] = 'Comic Sans MS-BoldItalic';
  t['ComicSansMS-Italic'] = 'Comic Sans MS-Italic';
  t['LucidaConsole'] = 'Courier';
  t['LucidaConsole-Bold'] = 'Courier-Bold';
  t['LucidaConsole-BoldItalic'] = 'Courier-BoldOblique';
  t['LucidaConsole-Italic'] = 'Courier-Oblique';
  t['MS-Gothic'] = 'MS Gothic';
  t['MS-Gothic-Bold'] = 'MS Gothic-Bold';
  t['MS-Gothic-BoldItalic'] = 'MS Gothic-BoldItalic';
  t['MS-Gothic-Italic'] = 'MS Gothic-Italic';
  t['MS-Mincho'] = 'MS Mincho';
  t['MS-Mincho-Bold'] = 'MS Mincho-Bold';
  t['MS-Mincho-BoldItalic'] = 'MS Mincho-BoldItalic';
  t['MS-Mincho-Italic'] = 'MS Mincho-Italic';
  t['MS-PGothic'] = 'MS PGothic';
  t['MS-PGothic-Bold'] = 'MS PGothic-Bold';
  t['MS-PGothic-BoldItalic'] = 'MS PGothic-BoldItalic';
  t['MS-PGothic-Italic'] = 'MS PGothic-Italic';
  t['MS-PMincho'] = 'MS PMincho';
  t['MS-PMincho-Bold'] = 'MS PMincho-Bold';
  t['MS-PMincho-BoldItalic'] = 'MS PMincho-BoldItalic';
  t['MS-PMincho-Italic'] = 'MS PMincho-Italic';
  t['NuptialScript'] = 'Times-Italic';
  t['Wingdings'] = 'ZapfDingbats';
});
var getSerifFonts = getLookupTableFactory(function (t) {
  t['Adobe Jenson'] = true;
  t['Adobe Text'] = true;
  t['Albertus'] = true;
  t['Aldus'] = true;
  t['Alexandria'] = true;
  t['Algerian'] = true;
  t['American Typewriter'] = true;
  t['Antiqua'] = true;
  t['Apex'] = true;
  t['Arno'] = true;
  t['Aster'] = true;
  t['Aurora'] = true;
  t['Baskerville'] = true;
  t['Bell'] = true;
  t['Bembo'] = true;
  t['Bembo Schoolbook'] = true;
  t['Benguiat'] = true;
  t['Berkeley Old Style'] = true;
  t['Bernhard Modern'] = true;
  t['Berthold City'] = true;
  t['Bodoni'] = true;
  t['Bauer Bodoni'] = true;
  t['Book Antiqua'] = true;
  t['Bookman'] = true;
  t['Bordeaux Roman'] = true;
  t['Californian FB'] = true;
  t['Calisto'] = true;
  t['Calvert'] = true;
  t['Capitals'] = true;
  t['Cambria'] = true;
  t['Cartier'] = true;
  t['Caslon'] = true;
  t['Catull'] = true;
  t['Centaur'] = true;
  t['Century Old Style'] = true;
  t['Century Schoolbook'] = true;
  t['Chaparral'] = true;
  t['Charis SIL'] = true;
  t['Cheltenham'] = true;
  t['Cholla Slab'] = true;
  t['Clarendon'] = true;
  t['Clearface'] = true;
  t['Cochin'] = true;
  t['Colonna'] = true;
  t['Computer Modern'] = true;
  t['Concrete Roman'] = true;
  t['Constantia'] = true;
  t['Cooper Black'] = true;
  t['Corona'] = true;
  t['Ecotype'] = true;
  t['Egyptienne'] = true;
  t['Elephant'] = true;
  t['Excelsior'] = true;
  t['Fairfield'] = true;
  t['FF Scala'] = true;
  t['Folkard'] = true;
  t['Footlight'] = true;
  t['FreeSerif'] = true;
  t['Friz Quadrata'] = true;
  t['Garamond'] = true;
  t['Gentium'] = true;
  t['Georgia'] = true;
  t['Gloucester'] = true;
  t['Goudy Old Style'] = true;
  t['Goudy Schoolbook'] = true;
  t['Goudy Pro Font'] = true;
  t['Granjon'] = true;
  t['Guardian Egyptian'] = true;
  t['Heather'] = true;
  t['Hercules'] = true;
  t['High Tower Text'] = true;
  t['Hiroshige'] = true;
  t['Hoefler Text'] = true;
  t['Humana Serif'] = true;
  t['Imprint'] = true;
  t['Ionic No. 5'] = true;
  t['Janson'] = true;
  t['Joanna'] = true;
  t['Korinna'] = true;
  t['Lexicon'] = true;
  t['Liberation Serif'] = true;
  t['Linux Libertine'] = true;
  t['Literaturnaya'] = true;
  t['Lucida'] = true;
  t['Lucida Bright'] = true;
  t['Melior'] = true;
  t['Memphis'] = true;
  t['Miller'] = true;
  t['Minion'] = true;
  t['Modern'] = true;
  t['Mona Lisa'] = true;
  t['Mrs Eaves'] = true;
  t['MS Serif'] = true;
  t['Museo Slab'] = true;
  t['New York'] = true;
  t['Nimbus Roman'] = true;
  t['NPS Rawlinson Roadway'] = true;
  t['NuptialScript'] = true;
  t['Palatino'] = true;
  t['Perpetua'] = true;
  t['Plantin'] = true;
  t['Plantin Schoolbook'] = true;
  t['Playbill'] = true;
  t['Poor Richard'] = true;
  t['Rawlinson Roadway'] = true;
  t['Renault'] = true;
  t['Requiem'] = true;
  t['Rockwell'] = true;
  t['Roman'] = true;
  t['Rotis Serif'] = true;
  t['Sabon'] = true;
  t['Scala'] = true;
  t['Seagull'] = true;
  t['Sistina'] = true;
  t['Souvenir'] = true;
  t['STIX'] = true;
  t['Stone Informal'] = true;
  t['Stone Serif'] = true;
  t['Sylfaen'] = true;
  t['Times'] = true;
  t['Trajan'] = true;
  t['Trinité'] = true;
  t['Trump Mediaeval'] = true;
  t['Utopia'] = true;
  t['Vale Type'] = true;
  t['Bitstream Vera'] = true;
  t['Vera Serif'] = true;
  t['Versailles'] = true;
  t['Wanted'] = true;
  t['Weiss'] = true;
  t['Wide Latin'] = true;
  t['Windsor'] = true;
  t['XITS'] = true;
});
var getSymbolsFonts = getLookupTableFactory(function (t) {
  t['Dingbats'] = true;
  t['Symbol'] = true;
  t['ZapfDingbats'] = true;
});
var getGlyphMapForStandardFonts = getLookupTableFactory(function (t) {
  t[2] = 10;
  t[3] = 32;
  t[4] = 33;
  t[5] = 34;
  t[6] = 35;
  t[7] = 36;
  t[8] = 37;
  t[9] = 38;
  t[10] = 39;
  t[11] = 40;
  t[12] = 41;
  t[13] = 42;
  t[14] = 43;
  t[15] = 44;
  t[16] = 45;
  t[17] = 46;
  t[18] = 47;
  t[19] = 48;
  t[20] = 49;
  t[21] = 50;
  t[22] = 51;
  t[23] = 52;
  t[24] = 53;
  t[25] = 54;
  t[26] = 55;
  t[27] = 56;
  t[28] = 57;
  t[29] = 58;
  t[30] = 894;
  t[31] = 60;
  t[32] = 61;
  t[33] = 62;
  t[34] = 63;
  t[35] = 64;
  t[36] = 65;
  t[37] = 66;
  t[38] = 67;
  t[39] = 68;
  t[40] = 69;
  t[41] = 70;
  t[42] = 71;
  t[43] = 72;
  t[44] = 73;
  t[45] = 74;
  t[46] = 75;
  t[47] = 76;
  t[48] = 77;
  t[49] = 78;
  t[50] = 79;
  t[51] = 80;
  t[52] = 81;
  t[53] = 82;
  t[54] = 83;
  t[55] = 84;
  t[56] = 85;
  t[57] = 86;
  t[58] = 87;
  t[59] = 88;
  t[60] = 89;
  t[61] = 90;
  t[62] = 91;
  t[63] = 92;
  t[64] = 93;
  t[65] = 94;
  t[66] = 95;
  t[67] = 96;
  t[68] = 97;
  t[69] = 98;
  t[70] = 99;
  t[71] = 100;
  t[72] = 101;
  t[73] = 102;
  t[74] = 103;
  t[75] = 104;
  t[76] = 105;
  t[77] = 106;
  t[78] = 107;
  t[79] = 108;
  t[80] = 109;
  t[81] = 110;
  t[82] = 111;
  t[83] = 112;
  t[84] = 113;
  t[85] = 114;
  t[86] = 115;
  t[87] = 116;
  t[88] = 117;
  t[89] = 118;
  t[90] = 119;
  t[91] = 120;
  t[92] = 121;
  t[93] = 122;
  t[94] = 123;
  t[95] = 124;
  t[96] = 125;
  t[97] = 126;
  t[98] = 196;
  t[99] = 197;
  t[100] = 199;
  t[101] = 201;
  t[102] = 209;
  t[103] = 214;
  t[104] = 220;
  t[105] = 225;
  t[106] = 224;
  t[107] = 226;
  t[108] = 228;
  t[109] = 227;
  t[110] = 229;
  t[111] = 231;
  t[112] = 233;
  t[113] = 232;
  t[114] = 234;
  t[115] = 235;
  t[116] = 237;
  t[117] = 236;
  t[118] = 238;
  t[119] = 239;
  t[120] = 241;
  t[121] = 243;
  t[122] = 242;
  t[123] = 244;
  t[124] = 246;
  t[125] = 245;
  t[126] = 250;
  t[127] = 249;
  t[128] = 251;
  t[129] = 252;
  t[130] = 8224;
  t[131] = 176;
  t[132] = 162;
  t[133] = 163;
  t[134] = 167;
  t[135] = 8226;
  t[136] = 182;
  t[137] = 223;
  t[138] = 174;
  t[139] = 169;
  t[140] = 8482;
  t[141] = 180;
  t[142] = 168;
  t[143] = 8800;
  t[144] = 198;
  t[145] = 216;
  t[146] = 8734;
  t[147] = 177;
  t[148] = 8804;
  t[149] = 8805;
  t[150] = 165;
  t[151] = 181;
  t[152] = 8706;
  t[153] = 8721;
  t[154] = 8719;
  t[156] = 8747;
  t[157] = 170;
  t[158] = 186;
  t[159] = 8486;
  t[160] = 230;
  t[161] = 248;
  t[162] = 191;
  t[163] = 161;
  t[164] = 172;
  t[165] = 8730;
  t[166] = 402;
  t[167] = 8776;
  t[168] = 8710;
  t[169] = 171;
  t[170] = 187;
  t[171] = 8230;
  t[210] = 218;
  t[223] = 711;
  t[224] = 321;
  t[225] = 322;
  t[227] = 353;
  t[229] = 382;
  t[234] = 253;
  t[252] = 263;
  t[253] = 268;
  t[254] = 269;
  t[258] = 258;
  t[260] = 260;
  t[261] = 261;
  t[265] = 280;
  t[266] = 281;
  t[268] = 283;
  t[269] = 313;
  t[275] = 323;
  t[276] = 324;
  t[278] = 328;
  t[284] = 345;
  t[285] = 346;
  t[286] = 347;
  t[292] = 367;
  t[295] = 377;
  t[296] = 378;
  t[298] = 380;
  t[305] = 963;
  t[306] = 964;
  t[307] = 966;
  t[308] = 8215;
  t[309] = 8252;
  t[310] = 8319;
  t[311] = 8359;
  t[312] = 8592;
  t[313] = 8593;
  t[337] = 9552;
  t[493] = 1039;
  t[494] = 1040;
  t[705] = 1524;
  t[706] = 8362;
  t[710] = 64288;
  t[711] = 64298;
  t[759] = 1617;
  t[761] = 1776;
  t[763] = 1778;
  t[775] = 1652;
  t[777] = 1764;
  t[778] = 1780;
  t[779] = 1781;
  t[780] = 1782;
  t[782] = 771;
  t[783] = 64726;
  t[786] = 8363;
  t[788] = 8532;
  t[790] = 768;
  t[791] = 769;
  t[792] = 768;
  t[795] = 803;
  t[797] = 64336;
  t[798] = 64337;
  t[799] = 64342;
  t[800] = 64343;
  t[801] = 64344;
  t[802] = 64345;
  t[803] = 64362;
  t[804] = 64363;
  t[805] = 64364;
  t[2424] = 7821;
  t[2425] = 7822;
  t[2426] = 7823;
  t[2427] = 7824;
  t[2428] = 7825;
  t[2429] = 7826;
  t[2430] = 7827;
  t[2433] = 7682;
  t[2678] = 8045;
  t[2679] = 8046;
  t[2830] = 1552;
  t[2838] = 686;
  t[2840] = 751;
  t[2842] = 753;
  t[2843] = 754;
  t[2844] = 755;
  t[2846] = 757;
  t[2856] = 767;
  t[2857] = 848;
  t[2858] = 849;
  t[2862] = 853;
  t[2863] = 854;
  t[2864] = 855;
  t[2865] = 861;
  t[2866] = 862;
  t[2906] = 7460;
  t[2908] = 7462;
  t[2909] = 7463;
  t[2910] = 7464;
  t[2912] = 7466;
  t[2913] = 7467;
  t[2914] = 7468;
  t[2916] = 7470;
  t[2917] = 7471;
  t[2918] = 7472;
  t[2920] = 7474;
  t[2921] = 7475;
  t[2922] = 7476;
  t[2924] = 7478;
  t[2925] = 7479;
  t[2926] = 7480;
  t[2928] = 7482;
  t[2929] = 7483;
  t[2930] = 7484;
  t[2932] = 7486;
  t[2933] = 7487;
  t[2934] = 7488;
  t[2936] = 7490;
  t[2937] = 7491;
  t[2938] = 7492;
  t[2940] = 7494;
  t[2941] = 7495;
  t[2942] = 7496;
  t[2944] = 7498;
  t[2946] = 7500;
  t[2948] = 7502;
  t[2950] = 7504;
  t[2951] = 7505;
  t[2952] = 7506;
  t[2954] = 7508;
  t[2955] = 7509;
  t[2956] = 7510;
  t[2958] = 7512;
  t[2959] = 7513;
  t[2960] = 7514;
  t[2962] = 7516;
  t[2963] = 7517;
  t[2964] = 7518;
  t[2966] = 7520;
  t[2967] = 7521;
  t[2968] = 7522;
  t[2970] = 7524;
  t[2971] = 7525;
  t[2972] = 7526;
  t[2974] = 7528;
  t[2975] = 7529;
  t[2976] = 7530;
  t[2978] = 1537;
  t[2979] = 1538;
  t[2980] = 1539;
  t[2982] = 1549;
  t[2983] = 1551;
  t[2984] = 1552;
  t[2986] = 1554;
  t[2987] = 1555;
  t[2988] = 1556;
  t[2990] = 1623;
  t[2991] = 1624;
  t[2995] = 1775;
  t[2999] = 1791;
  t[3002] = 64290;
  t[3003] = 64291;
  t[3004] = 64292;
  t[3006] = 64294;
  t[3007] = 64295;
  t[3008] = 64296;
  t[3011] = 1900;
  t[3014] = 8223;
  t[3015] = 8244;
  t[3017] = 7532;
  t[3018] = 7533;
  t[3019] = 7534;
  t[3075] = 7590;
  t[3076] = 7591;
  t[3079] = 7594;
  t[3080] = 7595;
  t[3083] = 7598;
  t[3084] = 7599;
  t[3087] = 7602;
  t[3088] = 7603;
  t[3091] = 7606;
  t[3092] = 7607;
  t[3095] = 7610;
  t[3096] = 7611;
  t[3099] = 7614;
  t[3100] = 7615;
  t[3103] = 7618;
  t[3104] = 7619;
  t[3107] = 8337;
  t[3108] = 8338;
  t[3116] = 1884;
  t[3119] = 1885;
  t[3120] = 1885;
  t[3123] = 1886;
  t[3124] = 1886;
  t[3127] = 1887;
  t[3128] = 1887;
  t[3131] = 1888;
  t[3132] = 1888;
  t[3135] = 1889;
  t[3136] = 1889;
  t[3139] = 1890;
  t[3140] = 1890;
  t[3143] = 1891;
  t[3144] = 1891;
  t[3147] = 1892;
  t[3148] = 1892;
  t[3153] = 580;
  t[3154] = 581;
  t[3157] = 584;
  t[3158] = 585;
  t[3161] = 588;
  t[3162] = 589;
  t[3165] = 891;
  t[3166] = 892;
  t[3169] = 1274;
  t[3170] = 1275;
  t[3173] = 1278;
  t[3174] = 1279;
  t[3181] = 7622;
  t[3182] = 7623;
  t[3282] = 11799;
  t[3316] = 578;
  t[3379] = 42785;
  t[3393] = 1159;
  t[3416] = 8377;
});
var getSupplementalGlyphMapForArialBlack = getLookupTableFactory(function (t) {
  t[227] = 322;
  t[264] = 261;
  t[291] = 346;
});
exports.getStdFontMap = getStdFontMap;
exports.getNonStdFontMap = getNonStdFontMap;
exports.getSerifFonts = getSerifFonts;
exports.getSymbolsFonts = getSymbolsFonts;
exports.getGlyphMapForStandardFonts = getGlyphMapForStandardFonts;
exports.getSupplementalGlyphMapForArialBlack = getSupplementalGlyphMapForArialBlack;

/***/ }),
/* 18 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var getLookupTableFactory = sharedUtil.getLookupTableFactory;
var getSpecialPUASymbols = getLookupTableFactory(function (t) {
  t[63721] = 0x00A9;
  t[63193] = 0x00A9;
  t[63720] = 0x00AE;
  t[63194] = 0x00AE;
  t[63722] = 0x2122;
  t[63195] = 0x2122;
  t[63729] = 0x23A7;
  t[63730] = 0x23A8;
  t[63731] = 0x23A9;
  t[63740] = 0x23AB;
  t[63741] = 0x23AC;
  t[63742] = 0x23AD;
  t[63726] = 0x23A1;
  t[63727] = 0x23A2;
  t[63728] = 0x23A3;
  t[63737] = 0x23A4;
  t[63738] = 0x23A5;
  t[63739] = 0x23A6;
  t[63723] = 0x239B;
  t[63724] = 0x239C;
  t[63725] = 0x239D;
  t[63734] = 0x239E;
  t[63735] = 0x239F;
  t[63736] = 0x23A0;
});
function mapSpecialUnicodeValues(code) {
  if (code >= 0xFFF0 && code <= 0xFFFF) {
    return 0;
  } else if (code >= 0xF600 && code <= 0xF8FF) {
    return getSpecialPUASymbols()[code] || code;
  }
  return code;
}
function getUnicodeForGlyph(name, glyphsUnicodeMap) {
  var unicode = glyphsUnicodeMap[name];
  if (unicode !== undefined) {
    return unicode;
  }
  if (!name) {
    return -1;
  }
  if (name[0] === 'u') {
    var nameLen = name.length,
        hexStr;
    if (nameLen === 7 && name[1] === 'n' && name[2] === 'i') {
      hexStr = name.substr(3);
    } else if (nameLen >= 5 && nameLen <= 7) {
      hexStr = name.substr(1);
    } else {
      return -1;
    }
    if (hexStr === hexStr.toUpperCase()) {
      unicode = parseInt(hexStr, 16);
      if (unicode >= 0) {
        return unicode;
      }
    }
  }
  return -1;
}
var UnicodeRanges = [{
  'begin': 0x0000,
  'end': 0x007F
}, {
  'begin': 0x0080,
  'end': 0x00FF
}, {
  'begin': 0x0100,
  'end': 0x017F
}, {
  'begin': 0x0180,
  'end': 0x024F
}, {
  'begin': 0x0250,
  'end': 0x02AF
}, {
  'begin': 0x02B0,
  'end': 0x02FF
}, {
  'begin': 0x0300,
  'end': 0x036F
}, {
  'begin': 0x0370,
  'end': 0x03FF
}, {
  'begin': 0x2C80,
  'end': 0x2CFF
}, {
  'begin': 0x0400,
  'end': 0x04FF
}, {
  'begin': 0x0530,
  'end': 0x058F
}, {
  'begin': 0x0590,
  'end': 0x05FF
}, {
  'begin': 0xA500,
  'end': 0xA63F
}, {
  'begin': 0x0600,
  'end': 0x06FF
}, {
  'begin': 0x07C0,
  'end': 0x07FF
}, {
  'begin': 0x0900,
  'end': 0x097F
}, {
  'begin': 0x0980,
  'end': 0x09FF
}, {
  'begin': 0x0A00,
  'end': 0x0A7F
}, {
  'begin': 0x0A80,
  'end': 0x0AFF
}, {
  'begin': 0x0B00,
  'end': 0x0B7F
}, {
  'begin': 0x0B80,
  'end': 0x0BFF
}, {
  'begin': 0x0C00,
  'end': 0x0C7F
}, {
  'begin': 0x0C80,
  'end': 0x0CFF
}, {
  'begin': 0x0D00,
  'end': 0x0D7F
}, {
  'begin': 0x0E00,
  'end': 0x0E7F
}, {
  'begin': 0x0E80,
  'end': 0x0EFF
}, {
  'begin': 0x10A0,
  'end': 0x10FF
}, {
  'begin': 0x1B00,
  'end': 0x1B7F
}, {
  'begin': 0x1100,
  'end': 0x11FF
}, {
  'begin': 0x1E00,
  'end': 0x1EFF
}, {
  'begin': 0x1F00,
  'end': 0x1FFF
}, {
  'begin': 0x2000,
  'end': 0x206F
}, {
  'begin': 0x2070,
  'end': 0x209F
}, {
  'begin': 0x20A0,
  'end': 0x20CF
}, {
  'begin': 0x20D0,
  'end': 0x20FF
}, {
  'begin': 0x2100,
  'end': 0x214F
}, {
  'begin': 0x2150,
  'end': 0x218F
}, {
  'begin': 0x2190,
  'end': 0x21FF
}, {
  'begin': 0x2200,
  'end': 0x22FF
}, {
  'begin': 0x2300,
  'end': 0x23FF
}, {
  'begin': 0x2400,
  'end': 0x243F
}, {
  'begin': 0x2440,
  'end': 0x245F
}, {
  'begin': 0x2460,
  'end': 0x24FF
}, {
  'begin': 0x2500,
  'end': 0x257F
}, {
  'begin': 0x2580,
  'end': 0x259F
}, {
  'begin': 0x25A0,
  'end': 0x25FF
}, {
  'begin': 0x2600,
  'end': 0x26FF
}, {
  'begin': 0x2700,
  'end': 0x27BF
}, {
  'begin': 0x3000,
  'end': 0x303F
}, {
  'begin': 0x3040,
  'end': 0x309F
}, {
  'begin': 0x30A0,
  'end': 0x30FF
}, {
  'begin': 0x3100,
  'end': 0x312F
}, {
  'begin': 0x3130,
  'end': 0x318F
}, {
  'begin': 0xA840,
  'end': 0xA87F
}, {
  'begin': 0x3200,
  'end': 0x32FF
}, {
  'begin': 0x3300,
  'end': 0x33FF
}, {
  'begin': 0xAC00,
  'end': 0xD7AF
}, {
  'begin': 0xD800,
  'end': 0xDFFF
}, {
  'begin': 0x10900,
  'end': 0x1091F
}, {
  'begin': 0x4E00,
  'end': 0x9FFF
}, {
  'begin': 0xE000,
  'end': 0xF8FF
}, {
  'begin': 0x31C0,
  'end': 0x31EF
}, {
  'begin': 0xFB00,
  'end': 0xFB4F
}, {
  'begin': 0xFB50,
  'end': 0xFDFF
}, {
  'begin': 0xFE20,
  'end': 0xFE2F
}, {
  'begin': 0xFE10,
  'end': 0xFE1F
}, {
  'begin': 0xFE50,
  'end': 0xFE6F
}, {
  'begin': 0xFE70,
  'end': 0xFEFF
}, {
  'begin': 0xFF00,
  'end': 0xFFEF
}, {
  'begin': 0xFFF0,
  'end': 0xFFFF
}, {
  'begin': 0x0F00,
  'end': 0x0FFF
}, {
  'begin': 0x0700,
  'end': 0x074F
}, {
  'begin': 0x0780,
  'end': 0x07BF
}, {
  'begin': 0x0D80,
  'end': 0x0DFF
}, {
  'begin': 0x1000,
  'end': 0x109F
}, {
  'begin': 0x1200,
  'end': 0x137F
}, {
  'begin': 0x13A0,
  'end': 0x13FF
}, {
  'begin': 0x1400,
  'end': 0x167F
}, {
  'begin': 0x1680,
  'end': 0x169F
}, {
  'begin': 0x16A0,
  'end': 0x16FF
}, {
  'begin': 0x1780,
  'end': 0x17FF
}, {
  'begin': 0x1800,
  'end': 0x18AF
}, {
  'begin': 0x2800,
  'end': 0x28FF
}, {
  'begin': 0xA000,
  'end': 0xA48F
}, {
  'begin': 0x1700,
  'end': 0x171F
}, {
  'begin': 0x10300,
  'end': 0x1032F
}, {
  'begin': 0x10330,
  'end': 0x1034F
}, {
  'begin': 0x10400,
  'end': 0x1044F
}, {
  'begin': 0x1D000,
  'end': 0x1D0FF
}, {
  'begin': 0x1D400,
  'end': 0x1D7FF
}, {
  'begin': 0xFF000,
  'end': 0xFFFFD
}, {
  'begin': 0xFE00,
  'end': 0xFE0F
}, {
  'begin': 0xE0000,
  'end': 0xE007F
}, {
  'begin': 0x1900,
  'end': 0x194F
}, {
  'begin': 0x1950,
  'end': 0x197F
}, {
  'begin': 0x1980,
  'end': 0x19DF
}, {
  'begin': 0x1A00,
  'end': 0x1A1F
}, {
  'begin': 0x2C00,
  'end': 0x2C5F
}, {
  'begin': 0x2D30,
  'end': 0x2D7F
}, {
  'begin': 0x4DC0,
  'end': 0x4DFF
}, {
  'begin': 0xA800,
  'end': 0xA82F
}, {
  'begin': 0x10000,
  'end': 0x1007F
}, {
  'begin': 0x10140,
  'end': 0x1018F
}, {
  'begin': 0x10380,
  'end': 0x1039F
}, {
  'begin': 0x103A0,
  'end': 0x103DF
}, {
  'begin': 0x10450,
  'end': 0x1047F
}, {
  'begin': 0x10480,
  'end': 0x104AF
}, {
  'begin': 0x10800,
  'end': 0x1083F
}, {
  'begin': 0x10A00,
  'end': 0x10A5F
}, {
  'begin': 0x1D300,
  'end': 0x1D35F
}, {
  'begin': 0x12000,
  'end': 0x123FF
}, {
  'begin': 0x1D360,
  'end': 0x1D37F
}, {
  'begin': 0x1B80,
  'end': 0x1BBF
}, {
  'begin': 0x1C00,
  'end': 0x1C4F
}, {
  'begin': 0x1C50,
  'end': 0x1C7F
}, {
  'begin': 0xA880,
  'end': 0xA8DF
}, {
  'begin': 0xA900,
  'end': 0xA92F
}, {
  'begin': 0xA930,
  'end': 0xA95F
}, {
  'begin': 0xAA00,
  'end': 0xAA5F
}, {
  'begin': 0x10190,
  'end': 0x101CF
}, {
  'begin': 0x101D0,
  'end': 0x101FF
}, {
  'begin': 0x102A0,
  'end': 0x102DF
}, {
  'begin': 0x1F030,
  'end': 0x1F09F
}];
function getUnicodeRangeFor(value) {
  for (var i = 0, ii = UnicodeRanges.length; i < ii; i++) {
    var range = UnicodeRanges[i];
    if (value >= range.begin && value < range.end) {
      return i;
    }
  }
  return -1;
}
function isRTLRangeFor(value) {
  var range = UnicodeRanges[13];
  if (value >= range.begin && value < range.end) {
    return true;
  }
  range = UnicodeRanges[11];
  if (value >= range.begin && value < range.end) {
    return true;
  }
  return false;
}
var getNormalizedUnicodes = getLookupTableFactory(function (t) {
  t['\xA8'] = ' \u0308';
  t['\xAF'] = ' \u0304';
  t['\xB4'] = ' \u0301';
  t['\xB5'] = '\u03BC';
  t['\xB8'] = ' \u0327';
  t['\u0132'] = 'IJ';
  t['\u0133'] = 'ij';
  t['\u013F'] = 'L\xB7';
  t['\u0140'] = 'l\xB7';
  t['\u0149'] = '\u02BCn';
  t['\u017F'] = 's';
  t['\u01C4'] = 'D\u017D';
  t['\u01C5'] = 'D\u017E';
  t['\u01C6'] = 'd\u017E';
  t['\u01C7'] = 'LJ';
  t['\u01C8'] = 'Lj';
  t['\u01C9'] = 'lj';
  t['\u01CA'] = 'NJ';
  t['\u01CB'] = 'Nj';
  t['\u01CC'] = 'nj';
  t['\u01F1'] = 'DZ';
  t['\u01F2'] = 'Dz';
  t['\u01F3'] = 'dz';
  t['\u02D8'] = ' \u0306';
  t['\u02D9'] = ' \u0307';
  t['\u02DA'] = ' \u030A';
  t['\u02DB'] = ' \u0328';
  t['\u02DC'] = ' \u0303';
  t['\u02DD'] = ' \u030B';
  t['\u037A'] = ' \u0345';
  t['\u0384'] = ' \u0301';
  t['\u03D0'] = '\u03B2';
  t['\u03D1'] = '\u03B8';
  t['\u03D2'] = '\u03A5';
  t['\u03D5'] = '\u03C6';
  t['\u03D6'] = '\u03C0';
  t['\u03F0'] = '\u03BA';
  t['\u03F1'] = '\u03C1';
  t['\u03F2'] = '\u03C2';
  t['\u03F4'] = '\u0398';
  t['\u03F5'] = '\u03B5';
  t['\u03F9'] = '\u03A3';
  t['\u0587'] = '\u0565\u0582';
  t['\u0675'] = '\u0627\u0674';
  t['\u0676'] = '\u0648\u0674';
  t['\u0677'] = '\u06C7\u0674';
  t['\u0678'] = '\u064A\u0674';
  t['\u0E33'] = '\u0E4D\u0E32';
  t['\u0EB3'] = '\u0ECD\u0EB2';
  t['\u0EDC'] = '\u0EAB\u0E99';
  t['\u0EDD'] = '\u0EAB\u0EA1';
  t['\u0F77'] = '\u0FB2\u0F81';
  t['\u0F79'] = '\u0FB3\u0F81';
  t['\u1E9A'] = 'a\u02BE';
  t['\u1FBD'] = ' \u0313';
  t['\u1FBF'] = ' \u0313';
  t['\u1FC0'] = ' \u0342';
  t['\u1FFE'] = ' \u0314';
  t['\u2002'] = ' ';
  t['\u2003'] = ' ';
  t['\u2004'] = ' ';
  t['\u2005'] = ' ';
  t['\u2006'] = ' ';
  t['\u2008'] = ' ';
  t['\u2009'] = ' ';
  t['\u200A'] = ' ';
  t['\u2017'] = ' \u0333';
  t['\u2024'] = '.';
  t['\u2025'] = '..';
  t['\u2026'] = '...';
  t['\u2033'] = '\u2032\u2032';
  t['\u2034'] = '\u2032\u2032\u2032';
  t['\u2036'] = '\u2035\u2035';
  t['\u2037'] = '\u2035\u2035\u2035';
  t['\u203C'] = '!!';
  t['\u203E'] = ' \u0305';
  t['\u2047'] = '??';
  t['\u2048'] = '?!';
  t['\u2049'] = '!?';
  t['\u2057'] = '\u2032\u2032\u2032\u2032';
  t['\u205F'] = ' ';
  t['\u20A8'] = 'Rs';
  t['\u2100'] = 'a/c';
  t['\u2101'] = 'a/s';
  t['\u2103'] = '\xB0C';
  t['\u2105'] = 'c/o';
  t['\u2106'] = 'c/u';
  t['\u2107'] = '\u0190';
  t['\u2109'] = '\xB0F';
  t['\u2116'] = 'No';
  t['\u2121'] = 'TEL';
  t['\u2135'] = '\u05D0';
  t['\u2136'] = '\u05D1';
  t['\u2137'] = '\u05D2';
  t['\u2138'] = '\u05D3';
  t['\u213B'] = 'FAX';
  t['\u2160'] = 'I';
  t['\u2161'] = 'II';
  t['\u2162'] = 'III';
  t['\u2163'] = 'IV';
  t['\u2164'] = 'V';
  t['\u2165'] = 'VI';
  t['\u2166'] = 'VII';
  t['\u2167'] = 'VIII';
  t['\u2168'] = 'IX';
  t['\u2169'] = 'X';
  t['\u216A'] = 'XI';
  t['\u216B'] = 'XII';
  t['\u216C'] = 'L';
  t['\u216D'] = 'C';
  t['\u216E'] = 'D';
  t['\u216F'] = 'M';
  t['\u2170'] = 'i';
  t['\u2171'] = 'ii';
  t['\u2172'] = 'iii';
  t['\u2173'] = 'iv';
  t['\u2174'] = 'v';
  t['\u2175'] = 'vi';
  t['\u2176'] = 'vii';
  t['\u2177'] = 'viii';
  t['\u2178'] = 'ix';
  t['\u2179'] = 'x';
  t['\u217A'] = 'xi';
  t['\u217B'] = 'xii';
  t['\u217C'] = 'l';
  t['\u217D'] = 'c';
  t['\u217E'] = 'd';
  t['\u217F'] = 'm';
  t['\u222C'] = '\u222B\u222B';
  t['\u222D'] = '\u222B\u222B\u222B';
  t['\u222F'] = '\u222E\u222E';
  t['\u2230'] = '\u222E\u222E\u222E';
  t['\u2474'] = '(1)';
  t['\u2475'] = '(2)';
  t['\u2476'] = '(3)';
  t['\u2477'] = '(4)';
  t['\u2478'] = '(5)';
  t['\u2479'] = '(6)';
  t['\u247A'] = '(7)';
  t['\u247B'] = '(8)';
  t['\u247C'] = '(9)';
  t['\u247D'] = '(10)';
  t['\u247E'] = '(11)';
  t['\u247F'] = '(12)';
  t['\u2480'] = '(13)';
  t['\u2481'] = '(14)';
  t['\u2482'] = '(15)';
  t['\u2483'] = '(16)';
  t['\u2484'] = '(17)';
  t['\u2485'] = '(18)';
  t['\u2486'] = '(19)';
  t['\u2487'] = '(20)';
  t['\u2488'] = '1.';
  t['\u2489'] = '2.';
  t['\u248A'] = '3.';
  t['\u248B'] = '4.';
  t['\u248C'] = '5.';
  t['\u248D'] = '6.';
  t['\u248E'] = '7.';
  t['\u248F'] = '8.';
  t['\u2490'] = '9.';
  t['\u2491'] = '10.';
  t['\u2492'] = '11.';
  t['\u2493'] = '12.';
  t['\u2494'] = '13.';
  t['\u2495'] = '14.';
  t['\u2496'] = '15.';
  t['\u2497'] = '16.';
  t['\u2498'] = '17.';
  t['\u2499'] = '18.';
  t['\u249A'] = '19.';
  t['\u249B'] = '20.';
  t['\u249C'] = '(a)';
  t['\u249D'] = '(b)';
  t['\u249E'] = '(c)';
  t['\u249F'] = '(d)';
  t['\u24A0'] = '(e)';
  t['\u24A1'] = '(f)';
  t['\u24A2'] = '(g)';
  t['\u24A3'] = '(h)';
  t['\u24A4'] = '(i)';
  t['\u24A5'] = '(j)';
  t['\u24A6'] = '(k)';
  t['\u24A7'] = '(l)';
  t['\u24A8'] = '(m)';
  t['\u24A9'] = '(n)';
  t['\u24AA'] = '(o)';
  t['\u24AB'] = '(p)';
  t['\u24AC'] = '(q)';
  t['\u24AD'] = '(r)';
  t['\u24AE'] = '(s)';
  t['\u24AF'] = '(t)';
  t['\u24B0'] = '(u)';
  t['\u24B1'] = '(v)';
  t['\u24B2'] = '(w)';
  t['\u24B3'] = '(x)';
  t['\u24B4'] = '(y)';
  t['\u24B5'] = '(z)';
  t['\u2A0C'] = '\u222B\u222B\u222B\u222B';
  t['\u2A74'] = '::=';
  t['\u2A75'] = '==';
  t['\u2A76'] = '===';
  t['\u2E9F'] = '\u6BCD';
  t['\u2EF3'] = '\u9F9F';
  t['\u2F00'] = '\u4E00';
  t['\u2F01'] = '\u4E28';
  t['\u2F02'] = '\u4E36';
  t['\u2F03'] = '\u4E3F';
  t['\u2F04'] = '\u4E59';
  t['\u2F05'] = '\u4E85';
  t['\u2F06'] = '\u4E8C';
  t['\u2F07'] = '\u4EA0';
  t['\u2F08'] = '\u4EBA';
  t['\u2F09'] = '\u513F';
  t['\u2F0A'] = '\u5165';
  t['\u2F0B'] = '\u516B';
  t['\u2F0C'] = '\u5182';
  t['\u2F0D'] = '\u5196';
  t['\u2F0E'] = '\u51AB';
  t['\u2F0F'] = '\u51E0';
  t['\u2F10'] = '\u51F5';
  t['\u2F11'] = '\u5200';
  t['\u2F12'] = '\u529B';
  t['\u2F13'] = '\u52F9';
  t['\u2F14'] = '\u5315';
  t['\u2F15'] = '\u531A';
  t['\u2F16'] = '\u5338';
  t['\u2F17'] = '\u5341';
  t['\u2F18'] = '\u535C';
  t['\u2F19'] = '\u5369';
  t['\u2F1A'] = '\u5382';
  t['\u2F1B'] = '\u53B6';
  t['\u2F1C'] = '\u53C8';
  t['\u2F1D'] = '\u53E3';
  t['\u2F1E'] = '\u56D7';
  t['\u2F1F'] = '\u571F';
  t['\u2F20'] = '\u58EB';
  t['\u2F21'] = '\u5902';
  t['\u2F22'] = '\u590A';
  t['\u2F23'] = '\u5915';
  t['\u2F24'] = '\u5927';
  t['\u2F25'] = '\u5973';
  t['\u2F26'] = '\u5B50';
  t['\u2F27'] = '\u5B80';
  t['\u2F28'] = '\u5BF8';
  t['\u2F29'] = '\u5C0F';
  t['\u2F2A'] = '\u5C22';
  t['\u2F2B'] = '\u5C38';
  t['\u2F2C'] = '\u5C6E';
  t['\u2F2D'] = '\u5C71';
  t['\u2F2E'] = '\u5DDB';
  t['\u2F2F'] = '\u5DE5';
  t['\u2F30'] = '\u5DF1';
  t['\u2F31'] = '\u5DFE';
  t['\u2F32'] = '\u5E72';
  t['\u2F33'] = '\u5E7A';
  t['\u2F34'] = '\u5E7F';
  t['\u2F35'] = '\u5EF4';
  t['\u2F36'] = '\u5EFE';
  t['\u2F37'] = '\u5F0B';
  t['\u2F38'] = '\u5F13';
  t['\u2F39'] = '\u5F50';
  t['\u2F3A'] = '\u5F61';
  t['\u2F3B'] = '\u5F73';
  t['\u2F3C'] = '\u5FC3';
  t['\u2F3D'] = '\u6208';
  t['\u2F3E'] = '\u6236';
  t['\u2F3F'] = '\u624B';
  t['\u2F40'] = '\u652F';
  t['\u2F41'] = '\u6534';
  t['\u2F42'] = '\u6587';
  t['\u2F43'] = '\u6597';
  t['\u2F44'] = '\u65A4';
  t['\u2F45'] = '\u65B9';
  t['\u2F46'] = '\u65E0';
  t['\u2F47'] = '\u65E5';
  t['\u2F48'] = '\u66F0';
  t['\u2F49'] = '\u6708';
  t['\u2F4A'] = '\u6728';
  t['\u2F4B'] = '\u6B20';
  t['\u2F4C'] = '\u6B62';
  t['\u2F4D'] = '\u6B79';
  t['\u2F4E'] = '\u6BB3';
  t['\u2F4F'] = '\u6BCB';
  t['\u2F50'] = '\u6BD4';
  t['\u2F51'] = '\u6BDB';
  t['\u2F52'] = '\u6C0F';
  t['\u2F53'] = '\u6C14';
  t['\u2F54'] = '\u6C34';
  t['\u2F55'] = '\u706B';
  t['\u2F56'] = '\u722A';
  t['\u2F57'] = '\u7236';
  t['\u2F58'] = '\u723B';
  t['\u2F59'] = '\u723F';
  t['\u2F5A'] = '\u7247';
  t['\u2F5B'] = '\u7259';
  t['\u2F5C'] = '\u725B';
  t['\u2F5D'] = '\u72AC';
  t['\u2F5E'] = '\u7384';
  t['\u2F5F'] = '\u7389';
  t['\u2F60'] = '\u74DC';
  t['\u2F61'] = '\u74E6';
  t['\u2F62'] = '\u7518';
  t['\u2F63'] = '\u751F';
  t['\u2F64'] = '\u7528';
  t['\u2F65'] = '\u7530';
  t['\u2F66'] = '\u758B';
  t['\u2F67'] = '\u7592';
  t['\u2F68'] = '\u7676';
  t['\u2F69'] = '\u767D';
  t['\u2F6A'] = '\u76AE';
  t['\u2F6B'] = '\u76BF';
  t['\u2F6C'] = '\u76EE';
  t['\u2F6D'] = '\u77DB';
  t['\u2F6E'] = '\u77E2';
  t['\u2F6F'] = '\u77F3';
  t['\u2F70'] = '\u793A';
  t['\u2F71'] = '\u79B8';
  t['\u2F72'] = '\u79BE';
  t['\u2F73'] = '\u7A74';
  t['\u2F74'] = '\u7ACB';
  t['\u2F75'] = '\u7AF9';
  t['\u2F76'] = '\u7C73';
  t['\u2F77'] = '\u7CF8';
  t['\u2F78'] = '\u7F36';
  t['\u2F79'] = '\u7F51';
  t['\u2F7A'] = '\u7F8A';
  t['\u2F7B'] = '\u7FBD';
  t['\u2F7C'] = '\u8001';
  t['\u2F7D'] = '\u800C';
  t['\u2F7E'] = '\u8012';
  t['\u2F7F'] = '\u8033';
  t['\u2F80'] = '\u807F';
  t['\u2F81'] = '\u8089';
  t['\u2F82'] = '\u81E3';
  t['\u2F83'] = '\u81EA';
  t['\u2F84'] = '\u81F3';
  t['\u2F85'] = '\u81FC';
  t['\u2F86'] = '\u820C';
  t['\u2F87'] = '\u821B';
  t['\u2F88'] = '\u821F';
  t['\u2F89'] = '\u826E';
  t['\u2F8A'] = '\u8272';
  t['\u2F8B'] = '\u8278';
  t['\u2F8C'] = '\u864D';
  t['\u2F8D'] = '\u866B';
  t['\u2F8E'] = '\u8840';
  t['\u2F8F'] = '\u884C';
  t['\u2F90'] = '\u8863';
  t['\u2F91'] = '\u897E';
  t['\u2F92'] = '\u898B';
  t['\u2F93'] = '\u89D2';
  t['\u2F94'] = '\u8A00';
  t['\u2F95'] = '\u8C37';
  t['\u2F96'] = '\u8C46';
  t['\u2F97'] = '\u8C55';
  t['\u2F98'] = '\u8C78';
  t['\u2F99'] = '\u8C9D';
  t['\u2F9A'] = '\u8D64';
  t['\u2F9B'] = '\u8D70';
  t['\u2F9C'] = '\u8DB3';
  t['\u2F9D'] = '\u8EAB';
  t['\u2F9E'] = '\u8ECA';
  t['\u2F9F'] = '\u8F9B';
  t['\u2FA0'] = '\u8FB0';
  t['\u2FA1'] = '\u8FB5';
  t['\u2FA2'] = '\u9091';
  t['\u2FA3'] = '\u9149';
  t['\u2FA4'] = '\u91C6';
  t['\u2FA5'] = '\u91CC';
  t['\u2FA6'] = '\u91D1';
  t['\u2FA7'] = '\u9577';
  t['\u2FA8'] = '\u9580';
  t['\u2FA9'] = '\u961C';
  t['\u2FAA'] = '\u96B6';
  t['\u2FAB'] = '\u96B9';
  t['\u2FAC'] = '\u96E8';
  t['\u2FAD'] = '\u9751';
  t['\u2FAE'] = '\u975E';
  t['\u2FAF'] = '\u9762';
  t['\u2FB0'] = '\u9769';
  t['\u2FB1'] = '\u97CB';
  t['\u2FB2'] = '\u97ED';
  t['\u2FB3'] = '\u97F3';
  t['\u2FB4'] = '\u9801';
  t['\u2FB5'] = '\u98A8';
  t['\u2FB6'] = '\u98DB';
  t['\u2FB7'] = '\u98DF';
  t['\u2FB8'] = '\u9996';
  t['\u2FB9'] = '\u9999';
  t['\u2FBA'] = '\u99AC';
  t['\u2FBB'] = '\u9AA8';
  t['\u2FBC'] = '\u9AD8';
  t['\u2FBD'] = '\u9ADF';
  t['\u2FBE'] = '\u9B25';
  t['\u2FBF'] = '\u9B2F';
  t['\u2FC0'] = '\u9B32';
  t['\u2FC1'] = '\u9B3C';
  t['\u2FC2'] = '\u9B5A';
  t['\u2FC3'] = '\u9CE5';
  t['\u2FC4'] = '\u9E75';
  t['\u2FC5'] = '\u9E7F';
  t['\u2FC6'] = '\u9EA5';
  t['\u2FC7'] = '\u9EBB';
  t['\u2FC8'] = '\u9EC3';
  t['\u2FC9'] = '\u9ECD';
  t['\u2FCA'] = '\u9ED1';
  t['\u2FCB'] = '\u9EF9';
  t['\u2FCC'] = '\u9EFD';
  t['\u2FCD'] = '\u9F0E';
  t['\u2FCE'] = '\u9F13';
  t['\u2FCF'] = '\u9F20';
  t['\u2FD0'] = '\u9F3B';
  t['\u2FD1'] = '\u9F4A';
  t['\u2FD2'] = '\u9F52';
  t['\u2FD3'] = '\u9F8D';
  t['\u2FD4'] = '\u9F9C';
  t['\u2FD5'] = '\u9FA0';
  t['\u3036'] = '\u3012';
  t['\u3038'] = '\u5341';
  t['\u3039'] = '\u5344';
  t['\u303A'] = '\u5345';
  t['\u309B'] = ' \u3099';
  t['\u309C'] = ' \u309A';
  t['\u3131'] = '\u1100';
  t['\u3132'] = '\u1101';
  t['\u3133'] = '\u11AA';
  t['\u3134'] = '\u1102';
  t['\u3135'] = '\u11AC';
  t['\u3136'] = '\u11AD';
  t['\u3137'] = '\u1103';
  t['\u3138'] = '\u1104';
  t['\u3139'] = '\u1105';
  t['\u313A'] = '\u11B0';
  t['\u313B'] = '\u11B1';
  t['\u313C'] = '\u11B2';
  t['\u313D'] = '\u11B3';
  t['\u313E'] = '\u11B4';
  t['\u313F'] = '\u11B5';
  t['\u3140'] = '\u111A';
  t['\u3141'] = '\u1106';
  t['\u3142'] = '\u1107';
  t['\u3143'] = '\u1108';
  t['\u3144'] = '\u1121';
  t['\u3145'] = '\u1109';
  t['\u3146'] = '\u110A';
  t['\u3147'] = '\u110B';
  t['\u3148'] = '\u110C';
  t['\u3149'] = '\u110D';
  t['\u314A'] = '\u110E';
  t['\u314B'] = '\u110F';
  t['\u314C'] = '\u1110';
  t['\u314D'] = '\u1111';
  t['\u314E'] = '\u1112';
  t['\u314F'] = '\u1161';
  t['\u3150'] = '\u1162';
  t['\u3151'] = '\u1163';
  t['\u3152'] = '\u1164';
  t['\u3153'] = '\u1165';
  t['\u3154'] = '\u1166';
  t['\u3155'] = '\u1167';
  t['\u3156'] = '\u1168';
  t['\u3157'] = '\u1169';
  t['\u3158'] = '\u116A';
  t['\u3159'] = '\u116B';
  t['\u315A'] = '\u116C';
  t['\u315B'] = '\u116D';
  t['\u315C'] = '\u116E';
  t['\u315D'] = '\u116F';
  t['\u315E'] = '\u1170';
  t['\u315F'] = '\u1171';
  t['\u3160'] = '\u1172';
  t['\u3161'] = '\u1173';
  t['\u3162'] = '\u1174';
  t['\u3163'] = '\u1175';
  t['\u3164'] = '\u1160';
  t['\u3165'] = '\u1114';
  t['\u3166'] = '\u1115';
  t['\u3167'] = '\u11C7';
  t['\u3168'] = '\u11C8';
  t['\u3169'] = '\u11CC';
  t['\u316A'] = '\u11CE';
  t['\u316B'] = '\u11D3';
  t['\u316C'] = '\u11D7';
  t['\u316D'] = '\u11D9';
  t['\u316E'] = '\u111C';
  t['\u316F'] = '\u11DD';
  t['\u3170'] = '\u11DF';
  t['\u3171'] = '\u111D';
  t['\u3172'] = '\u111E';
  t['\u3173'] = '\u1120';
  t['\u3174'] = '\u1122';
  t['\u3175'] = '\u1123';
  t['\u3176'] = '\u1127';
  t['\u3177'] = '\u1129';
  t['\u3178'] = '\u112B';
  t['\u3179'] = '\u112C';
  t['\u317A'] = '\u112D';
  t['\u317B'] = '\u112E';
  t['\u317C'] = '\u112F';
  t['\u317D'] = '\u1132';
  t['\u317E'] = '\u1136';
  t['\u317F'] = '\u1140';
  t['\u3180'] = '\u1147';
  t['\u3181'] = '\u114C';
  t['\u3182'] = '\u11F1';
  t['\u3183'] = '\u11F2';
  t['\u3184'] = '\u1157';
  t['\u3185'] = '\u1158';
  t['\u3186'] = '\u1159';
  t['\u3187'] = '\u1184';
  t['\u3188'] = '\u1185';
  t['\u3189'] = '\u1188';
  t['\u318A'] = '\u1191';
  t['\u318B'] = '\u1192';
  t['\u318C'] = '\u1194';
  t['\u318D'] = '\u119E';
  t['\u318E'] = '\u11A1';
  t['\u3200'] = '(\u1100)';
  t['\u3201'] = '(\u1102)';
  t['\u3202'] = '(\u1103)';
  t['\u3203'] = '(\u1105)';
  t['\u3204'] = '(\u1106)';
  t['\u3205'] = '(\u1107)';
  t['\u3206'] = '(\u1109)';
  t['\u3207'] = '(\u110B)';
  t['\u3208'] = '(\u110C)';
  t['\u3209'] = '(\u110E)';
  t['\u320A'] = '(\u110F)';
  t['\u320B'] = '(\u1110)';
  t['\u320C'] = '(\u1111)';
  t['\u320D'] = '(\u1112)';
  t['\u320E'] = '(\u1100\u1161)';
  t['\u320F'] = '(\u1102\u1161)';
  t['\u3210'] = '(\u1103\u1161)';
  t['\u3211'] = '(\u1105\u1161)';
  t['\u3212'] = '(\u1106\u1161)';
  t['\u3213'] = '(\u1107\u1161)';
  t['\u3214'] = '(\u1109\u1161)';
  t['\u3215'] = '(\u110B\u1161)';
  t['\u3216'] = '(\u110C\u1161)';
  t['\u3217'] = '(\u110E\u1161)';
  t['\u3218'] = '(\u110F\u1161)';
  t['\u3219'] = '(\u1110\u1161)';
  t['\u321A'] = '(\u1111\u1161)';
  t['\u321B'] = '(\u1112\u1161)';
  t['\u321C'] = '(\u110C\u116E)';
  t['\u321D'] = '(\u110B\u1169\u110C\u1165\u11AB)';
  t['\u321E'] = '(\u110B\u1169\u1112\u116E)';
  t['\u3220'] = '(\u4E00)';
  t['\u3221'] = '(\u4E8C)';
  t['\u3222'] = '(\u4E09)';
  t['\u3223'] = '(\u56DB)';
  t['\u3224'] = '(\u4E94)';
  t['\u3225'] = '(\u516D)';
  t['\u3226'] = '(\u4E03)';
  t['\u3227'] = '(\u516B)';
  t['\u3228'] = '(\u4E5D)';
  t['\u3229'] = '(\u5341)';
  t['\u322A'] = '(\u6708)';
  t['\u322B'] = '(\u706B)';
  t['\u322C'] = '(\u6C34)';
  t['\u322D'] = '(\u6728)';
  t['\u322E'] = '(\u91D1)';
  t['\u322F'] = '(\u571F)';
  t['\u3230'] = '(\u65E5)';
  t['\u3231'] = '(\u682A)';
  t['\u3232'] = '(\u6709)';
  t['\u3233'] = '(\u793E)';
  t['\u3234'] = '(\u540D)';
  t['\u3235'] = '(\u7279)';
  t['\u3236'] = '(\u8CA1)';
  t['\u3237'] = '(\u795D)';
  t['\u3238'] = '(\u52B4)';
  t['\u3239'] = '(\u4EE3)';
  t['\u323A'] = '(\u547C)';
  t['\u323B'] = '(\u5B66)';
  t['\u323C'] = '(\u76E3)';
  t['\u323D'] = '(\u4F01)';
  t['\u323E'] = '(\u8CC7)';
  t['\u323F'] = '(\u5354)';
  t['\u3240'] = '(\u796D)';
  t['\u3241'] = '(\u4F11)';
  t['\u3242'] = '(\u81EA)';
  t['\u3243'] = '(\u81F3)';
  t['\u32C0'] = '1\u6708';
  t['\u32C1'] = '2\u6708';
  t['\u32C2'] = '3\u6708';
  t['\u32C3'] = '4\u6708';
  t['\u32C4'] = '5\u6708';
  t['\u32C5'] = '6\u6708';
  t['\u32C6'] = '7\u6708';
  t['\u32C7'] = '8\u6708';
  t['\u32C8'] = '9\u6708';
  t['\u32C9'] = '10\u6708';
  t['\u32CA'] = '11\u6708';
  t['\u32CB'] = '12\u6708';
  t['\u3358'] = '0\u70B9';
  t['\u3359'] = '1\u70B9';
  t['\u335A'] = '2\u70B9';
  t['\u335B'] = '3\u70B9';
  t['\u335C'] = '4\u70B9';
  t['\u335D'] = '5\u70B9';
  t['\u335E'] = '6\u70B9';
  t['\u335F'] = '7\u70B9';
  t['\u3360'] = '8\u70B9';
  t['\u3361'] = '9\u70B9';
  t['\u3362'] = '10\u70B9';
  t['\u3363'] = '11\u70B9';
  t['\u3364'] = '12\u70B9';
  t['\u3365'] = '13\u70B9';
  t['\u3366'] = '14\u70B9';
  t['\u3367'] = '15\u70B9';
  t['\u3368'] = '16\u70B9';
  t['\u3369'] = '17\u70B9';
  t['\u336A'] = '18\u70B9';
  t['\u336B'] = '19\u70B9';
  t['\u336C'] = '20\u70B9';
  t['\u336D'] = '21\u70B9';
  t['\u336E'] = '22\u70B9';
  t['\u336F'] = '23\u70B9';
  t['\u3370'] = '24\u70B9';
  t['\u33E0'] = '1\u65E5';
  t['\u33E1'] = '2\u65E5';
  t['\u33E2'] = '3\u65E5';
  t['\u33E3'] = '4\u65E5';
  t['\u33E4'] = '5\u65E5';
  t['\u33E5'] = '6\u65E5';
  t['\u33E6'] = '7\u65E5';
  t['\u33E7'] = '8\u65E5';
  t['\u33E8'] = '9\u65E5';
  t['\u33E9'] = '10\u65E5';
  t['\u33EA'] = '11\u65E5';
  t['\u33EB'] = '12\u65E5';
  t['\u33EC'] = '13\u65E5';
  t['\u33ED'] = '14\u65E5';
  t['\u33EE'] = '15\u65E5';
  t['\u33EF'] = '16\u65E5';
  t['\u33F0'] = '17\u65E5';
  t['\u33F1'] = '18\u65E5';
  t['\u33F2'] = '19\u65E5';
  t['\u33F3'] = '20\u65E5';
  t['\u33F4'] = '21\u65E5';
  t['\u33F5'] = '22\u65E5';
  t['\u33F6'] = '23\u65E5';
  t['\u33F7'] = '24\u65E5';
  t['\u33F8'] = '25\u65E5';
  t['\u33F9'] = '26\u65E5';
  t['\u33FA'] = '27\u65E5';
  t['\u33FB'] = '28\u65E5';
  t['\u33FC'] = '29\u65E5';
  t['\u33FD'] = '30\u65E5';
  t['\u33FE'] = '31\u65E5';
  t['\uFB00'] = 'ff';
  t['\uFB01'] = 'fi';
  t['\uFB02'] = 'fl';
  t['\uFB03'] = 'ffi';
  t['\uFB04'] = 'ffl';
  t['\uFB05'] = '\u017Ft';
  t['\uFB06'] = 'st';
  t['\uFB13'] = '\u0574\u0576';
  t['\uFB14'] = '\u0574\u0565';
  t['\uFB15'] = '\u0574\u056B';
  t['\uFB16'] = '\u057E\u0576';
  t['\uFB17'] = '\u0574\u056D';
  t['\uFB4F'] = '\u05D0\u05DC';
  t['\uFB50'] = '\u0671';
  t['\uFB51'] = '\u0671';
  t['\uFB52'] = '\u067B';
  t['\uFB53'] = '\u067B';
  t['\uFB54'] = '\u067B';
  t['\uFB55'] = '\u067B';
  t['\uFB56'] = '\u067E';
  t['\uFB57'] = '\u067E';
  t['\uFB58'] = '\u067E';
  t['\uFB59'] = '\u067E';
  t['\uFB5A'] = '\u0680';
  t['\uFB5B'] = '\u0680';
  t['\uFB5C'] = '\u0680';
  t['\uFB5D'] = '\u0680';
  t['\uFB5E'] = '\u067A';
  t['\uFB5F'] = '\u067A';
  t['\uFB60'] = '\u067A';
  t['\uFB61'] = '\u067A';
  t['\uFB62'] = '\u067F';
  t['\uFB63'] = '\u067F';
  t['\uFB64'] = '\u067F';
  t['\uFB65'] = '\u067F';
  t['\uFB66'] = '\u0679';
  t['\uFB67'] = '\u0679';
  t['\uFB68'] = '\u0679';
  t['\uFB69'] = '\u0679';
  t['\uFB6A'] = '\u06A4';
  t['\uFB6B'] = '\u06A4';
  t['\uFB6C'] = '\u06A4';
  t['\uFB6D'] = '\u06A4';
  t['\uFB6E'] = '\u06A6';
  t['\uFB6F'] = '\u06A6';
  t['\uFB70'] = '\u06A6';
  t['\uFB71'] = '\u06A6';
  t['\uFB72'] = '\u0684';
  t['\uFB73'] = '\u0684';
  t['\uFB74'] = '\u0684';
  t['\uFB75'] = '\u0684';
  t['\uFB76'] = '\u0683';
  t['\uFB77'] = '\u0683';
  t['\uFB78'] = '\u0683';
  t['\uFB79'] = '\u0683';
  t['\uFB7A'] = '\u0686';
  t['\uFB7B'] = '\u0686';
  t['\uFB7C'] = '\u0686';
  t['\uFB7D'] = '\u0686';
  t['\uFB7E'] = '\u0687';
  t['\uFB7F'] = '\u0687';
  t['\uFB80'] = '\u0687';
  t['\uFB81'] = '\u0687';
  t['\uFB82'] = '\u068D';
  t['\uFB83'] = '\u068D';
  t['\uFB84'] = '\u068C';
  t['\uFB85'] = '\u068C';
  t['\uFB86'] = '\u068E';
  t['\uFB87'] = '\u068E';
  t['\uFB88'] = '\u0688';
  t['\uFB89'] = '\u0688';
  t['\uFB8A'] = '\u0698';
  t['\uFB8B'] = '\u0698';
  t['\uFB8C'] = '\u0691';
  t['\uFB8D'] = '\u0691';
  t['\uFB8E'] = '\u06A9';
  t['\uFB8F'] = '\u06A9';
  t['\uFB90'] = '\u06A9';
  t['\uFB91'] = '\u06A9';
  t['\uFB92'] = '\u06AF';
  t['\uFB93'] = '\u06AF';
  t['\uFB94'] = '\u06AF';
  t['\uFB95'] = '\u06AF';
  t['\uFB96'] = '\u06B3';
  t['\uFB97'] = '\u06B3';
  t['\uFB98'] = '\u06B3';
  t['\uFB99'] = '\u06B3';
  t['\uFB9A'] = '\u06B1';
  t['\uFB9B'] = '\u06B1';
  t['\uFB9C'] = '\u06B1';
  t['\uFB9D'] = '\u06B1';
  t['\uFB9E'] = '\u06BA';
  t['\uFB9F'] = '\u06BA';
  t['\uFBA0'] = '\u06BB';
  t['\uFBA1'] = '\u06BB';
  t['\uFBA2'] = '\u06BB';
  t['\uFBA3'] = '\u06BB';
  t['\uFBA4'] = '\u06C0';
  t['\uFBA5'] = '\u06C0';
  t['\uFBA6'] = '\u06C1';
  t['\uFBA7'] = '\u06C1';
  t['\uFBA8'] = '\u06C1';
  t['\uFBA9'] = '\u06C1';
  t['\uFBAA'] = '\u06BE';
  t['\uFBAB'] = '\u06BE';
  t['\uFBAC'] = '\u06BE';
  t['\uFBAD'] = '\u06BE';
  t['\uFBAE'] = '\u06D2';
  t['\uFBAF'] = '\u06D2';
  t['\uFBB0'] = '\u06D3';
  t['\uFBB1'] = '\u06D3';
  t['\uFBD3'] = '\u06AD';
  t['\uFBD4'] = '\u06AD';
  t['\uFBD5'] = '\u06AD';
  t['\uFBD6'] = '\u06AD';
  t['\uFBD7'] = '\u06C7';
  t['\uFBD8'] = '\u06C7';
  t['\uFBD9'] = '\u06C6';
  t['\uFBDA'] = '\u06C6';
  t['\uFBDB'] = '\u06C8';
  t['\uFBDC'] = '\u06C8';
  t['\uFBDD'] = '\u0677';
  t['\uFBDE'] = '\u06CB';
  t['\uFBDF'] = '\u06CB';
  t['\uFBE0'] = '\u06C5';
  t['\uFBE1'] = '\u06C5';
  t['\uFBE2'] = '\u06C9';
  t['\uFBE3'] = '\u06C9';
  t['\uFBE4'] = '\u06D0';
  t['\uFBE5'] = '\u06D0';
  t['\uFBE6'] = '\u06D0';
  t['\uFBE7'] = '\u06D0';
  t['\uFBE8'] = '\u0649';
  t['\uFBE9'] = '\u0649';
  t['\uFBEA'] = '\u0626\u0627';
  t['\uFBEB'] = '\u0626\u0627';
  t['\uFBEC'] = '\u0626\u06D5';
  t['\uFBED'] = '\u0626\u06D5';
  t['\uFBEE'] = '\u0626\u0648';
  t['\uFBEF'] = '\u0626\u0648';
  t['\uFBF0'] = '\u0626\u06C7';
  t['\uFBF1'] = '\u0626\u06C7';
  t['\uFBF2'] = '\u0626\u06C6';
  t['\uFBF3'] = '\u0626\u06C6';
  t['\uFBF4'] = '\u0626\u06C8';
  t['\uFBF5'] = '\u0626\u06C8';
  t['\uFBF6'] = '\u0626\u06D0';
  t['\uFBF7'] = '\u0626\u06D0';
  t['\uFBF8'] = '\u0626\u06D0';
  t['\uFBF9'] = '\u0626\u0649';
  t['\uFBFA'] = '\u0626\u0649';
  t['\uFBFB'] = '\u0626\u0649';
  t['\uFBFC'] = '\u06CC';
  t['\uFBFD'] = '\u06CC';
  t['\uFBFE'] = '\u06CC';
  t['\uFBFF'] = '\u06CC';
  t['\uFC00'] = '\u0626\u062C';
  t['\uFC01'] = '\u0626\u062D';
  t['\uFC02'] = '\u0626\u0645';
  t['\uFC03'] = '\u0626\u0649';
  t['\uFC04'] = '\u0626\u064A';
  t['\uFC05'] = '\u0628\u062C';
  t['\uFC06'] = '\u0628\u062D';
  t['\uFC07'] = '\u0628\u062E';
  t['\uFC08'] = '\u0628\u0645';
  t['\uFC09'] = '\u0628\u0649';
  t['\uFC0A'] = '\u0628\u064A';
  t['\uFC0B'] = '\u062A\u062C';
  t['\uFC0C'] = '\u062A\u062D';
  t['\uFC0D'] = '\u062A\u062E';
  t['\uFC0E'] = '\u062A\u0645';
  t['\uFC0F'] = '\u062A\u0649';
  t['\uFC10'] = '\u062A\u064A';
  t['\uFC11'] = '\u062B\u062C';
  t['\uFC12'] = '\u062B\u0645';
  t['\uFC13'] = '\u062B\u0649';
  t['\uFC14'] = '\u062B\u064A';
  t['\uFC15'] = '\u062C\u062D';
  t['\uFC16'] = '\u062C\u0645';
  t['\uFC17'] = '\u062D\u062C';
  t['\uFC18'] = '\u062D\u0645';
  t['\uFC19'] = '\u062E\u062C';
  t['\uFC1A'] = '\u062E\u062D';
  t['\uFC1B'] = '\u062E\u0645';
  t['\uFC1C'] = '\u0633\u062C';
  t['\uFC1D'] = '\u0633\u062D';
  t['\uFC1E'] = '\u0633\u062E';
  t['\uFC1F'] = '\u0633\u0645';
  t['\uFC20'] = '\u0635\u062D';
  t['\uFC21'] = '\u0635\u0645';
  t['\uFC22'] = '\u0636\u062C';
  t['\uFC23'] = '\u0636\u062D';
  t['\uFC24'] = '\u0636\u062E';
  t['\uFC25'] = '\u0636\u0645';
  t['\uFC26'] = '\u0637\u062D';
  t['\uFC27'] = '\u0637\u0645';
  t['\uFC28'] = '\u0638\u0645';
  t['\uFC29'] = '\u0639\u062C';
  t['\uFC2A'] = '\u0639\u0645';
  t['\uFC2B'] = '\u063A\u062C';
  t['\uFC2C'] = '\u063A\u0645';
  t['\uFC2D'] = '\u0641\u062C';
  t['\uFC2E'] = '\u0641\u062D';
  t['\uFC2F'] = '\u0641\u062E';
  t['\uFC30'] = '\u0641\u0645';
  t['\uFC31'] = '\u0641\u0649';
  t['\uFC32'] = '\u0641\u064A';
  t['\uFC33'] = '\u0642\u062D';
  t['\uFC34'] = '\u0642\u0645';
  t['\uFC35'] = '\u0642\u0649';
  t['\uFC36'] = '\u0642\u064A';
  t['\uFC37'] = '\u0643\u0627';
  t['\uFC38'] = '\u0643\u062C';
  t['\uFC39'] = '\u0643\u062D';
  t['\uFC3A'] = '\u0643\u062E';
  t['\uFC3B'] = '\u0643\u0644';
  t['\uFC3C'] = '\u0643\u0645';
  t['\uFC3D'] = '\u0643\u0649';
  t['\uFC3E'] = '\u0643\u064A';
  t['\uFC3F'] = '\u0644\u062C';
  t['\uFC40'] = '\u0644\u062D';
  t['\uFC41'] = '\u0644\u062E';
  t['\uFC42'] = '\u0644\u0645';
  t['\uFC43'] = '\u0644\u0649';
  t['\uFC44'] = '\u0644\u064A';
  t['\uFC45'] = '\u0645\u062C';
  t['\uFC46'] = '\u0645\u062D';
  t['\uFC47'] = '\u0645\u062E';
  t['\uFC48'] = '\u0645\u0645';
  t['\uFC49'] = '\u0645\u0649';
  t['\uFC4A'] = '\u0645\u064A';
  t['\uFC4B'] = '\u0646\u062C';
  t['\uFC4C'] = '\u0646\u062D';
  t['\uFC4D'] = '\u0646\u062E';
  t['\uFC4E'] = '\u0646\u0645';
  t['\uFC4F'] = '\u0646\u0649';
  t['\uFC50'] = '\u0646\u064A';
  t['\uFC51'] = '\u0647\u062C';
  t['\uFC52'] = '\u0647\u0645';
  t['\uFC53'] = '\u0647\u0649';
  t['\uFC54'] = '\u0647\u064A';
  t['\uFC55'] = '\u064A\u062C';
  t['\uFC56'] = '\u064A\u062D';
  t['\uFC57'] = '\u064A\u062E';
  t['\uFC58'] = '\u064A\u0645';
  t['\uFC59'] = '\u064A\u0649';
  t['\uFC5A'] = '\u064A\u064A';
  t['\uFC5B'] = '\u0630\u0670';
  t['\uFC5C'] = '\u0631\u0670';
  t['\uFC5D'] = '\u0649\u0670';
  t['\uFC5E'] = ' \u064C\u0651';
  t['\uFC5F'] = ' \u064D\u0651';
  t['\uFC60'] = ' \u064E\u0651';
  t['\uFC61'] = ' \u064F\u0651';
  t['\uFC62'] = ' \u0650\u0651';
  t['\uFC63'] = ' \u0651\u0670';
  t['\uFC64'] = '\u0626\u0631';
  t['\uFC65'] = '\u0626\u0632';
  t['\uFC66'] = '\u0626\u0645';
  t['\uFC67'] = '\u0626\u0646';
  t['\uFC68'] = '\u0626\u0649';
  t['\uFC69'] = '\u0626\u064A';
  t['\uFC6A'] = '\u0628\u0631';
  t['\uFC6B'] = '\u0628\u0632';
  t['\uFC6C'] = '\u0628\u0645';
  t['\uFC6D'] = '\u0628\u0646';
  t['\uFC6E'] = '\u0628\u0649';
  t['\uFC6F'] = '\u0628\u064A';
  t['\uFC70'] = '\u062A\u0631';
  t['\uFC71'] = '\u062A\u0632';
  t['\uFC72'] = '\u062A\u0645';
  t['\uFC73'] = '\u062A\u0646';
  t['\uFC74'] = '\u062A\u0649';
  t['\uFC75'] = '\u062A\u064A';
  t['\uFC76'] = '\u062B\u0631';
  t['\uFC77'] = '\u062B\u0632';
  t['\uFC78'] = '\u062B\u0645';
  t['\uFC79'] = '\u062B\u0646';
  t['\uFC7A'] = '\u062B\u0649';
  t['\uFC7B'] = '\u062B\u064A';
  t['\uFC7C'] = '\u0641\u0649';
  t['\uFC7D'] = '\u0641\u064A';
  t['\uFC7E'] = '\u0642\u0649';
  t['\uFC7F'] = '\u0642\u064A';
  t['\uFC80'] = '\u0643\u0627';
  t['\uFC81'] = '\u0643\u0644';
  t['\uFC82'] = '\u0643\u0645';
  t['\uFC83'] = '\u0643\u0649';
  t['\uFC84'] = '\u0643\u064A';
  t['\uFC85'] = '\u0644\u0645';
  t['\uFC86'] = '\u0644\u0649';
  t['\uFC87'] = '\u0644\u064A';
  t['\uFC88'] = '\u0645\u0627';
  t['\uFC89'] = '\u0645\u0645';
  t['\uFC8A'] = '\u0646\u0631';
  t['\uFC8B'] = '\u0646\u0632';
  t['\uFC8C'] = '\u0646\u0645';
  t['\uFC8D'] = '\u0646\u0646';
  t['\uFC8E'] = '\u0646\u0649';
  t['\uFC8F'] = '\u0646\u064A';
  t['\uFC90'] = '\u0649\u0670';
  t['\uFC91'] = '\u064A\u0631';
  t['\uFC92'] = '\u064A\u0632';
  t['\uFC93'] = '\u064A\u0645';
  t['\uFC94'] = '\u064A\u0646';
  t['\uFC95'] = '\u064A\u0649';
  t['\uFC96'] = '\u064A\u064A';
  t['\uFC97'] = '\u0626\u062C';
  t['\uFC98'] = '\u0626\u062D';
  t['\uFC99'] = '\u0626\u062E';
  t['\uFC9A'] = '\u0626\u0645';
  t['\uFC9B'] = '\u0626\u0647';
  t['\uFC9C'] = '\u0628\u062C';
  t['\uFC9D'] = '\u0628\u062D';
  t['\uFC9E'] = '\u0628\u062E';
  t['\uFC9F'] = '\u0628\u0645';
  t['\uFCA0'] = '\u0628\u0647';
  t['\uFCA1'] = '\u062A\u062C';
  t['\uFCA2'] = '\u062A\u062D';
  t['\uFCA3'] = '\u062A\u062E';
  t['\uFCA4'] = '\u062A\u0645';
  t['\uFCA5'] = '\u062A\u0647';
  t['\uFCA6'] = '\u062B\u0645';
  t['\uFCA7'] = '\u062C\u062D';
  t['\uFCA8'] = '\u062C\u0645';
  t['\uFCA9'] = '\u062D\u062C';
  t['\uFCAA'] = '\u062D\u0645';
  t['\uFCAB'] = '\u062E\u062C';
  t['\uFCAC'] = '\u062E\u0645';
  t['\uFCAD'] = '\u0633\u062C';
  t['\uFCAE'] = '\u0633\u062D';
  t['\uFCAF'] = '\u0633\u062E';
  t['\uFCB0'] = '\u0633\u0645';
  t['\uFCB1'] = '\u0635\u062D';
  t['\uFCB2'] = '\u0635\u062E';
  t['\uFCB3'] = '\u0635\u0645';
  t['\uFCB4'] = '\u0636\u062C';
  t['\uFCB5'] = '\u0636\u062D';
  t['\uFCB6'] = '\u0636\u062E';
  t['\uFCB7'] = '\u0636\u0645';
  t['\uFCB8'] = '\u0637\u062D';
  t['\uFCB9'] = '\u0638\u0645';
  t['\uFCBA'] = '\u0639\u062C';
  t['\uFCBB'] = '\u0639\u0645';
  t['\uFCBC'] = '\u063A\u062C';
  t['\uFCBD'] = '\u063A\u0645';
  t['\uFCBE'] = '\u0641\u062C';
  t['\uFCBF'] = '\u0641\u062D';
  t['\uFCC0'] = '\u0641\u062E';
  t['\uFCC1'] = '\u0641\u0645';
  t['\uFCC2'] = '\u0642\u062D';
  t['\uFCC3'] = '\u0642\u0645';
  t['\uFCC4'] = '\u0643\u062C';
  t['\uFCC5'] = '\u0643\u062D';
  t['\uFCC6'] = '\u0643\u062E';
  t['\uFCC7'] = '\u0643\u0644';
  t['\uFCC8'] = '\u0643\u0645';
  t['\uFCC9'] = '\u0644\u062C';
  t['\uFCCA'] = '\u0644\u062D';
  t['\uFCCB'] = '\u0644\u062E';
  t['\uFCCC'] = '\u0644\u0645';
  t['\uFCCD'] = '\u0644\u0647';
  t['\uFCCE'] = '\u0645\u062C';
  t['\uFCCF'] = '\u0645\u062D';
  t['\uFCD0'] = '\u0645\u062E';
  t['\uFCD1'] = '\u0645\u0645';
  t['\uFCD2'] = '\u0646\u062C';
  t['\uFCD3'] = '\u0646\u062D';
  t['\uFCD4'] = '\u0646\u062E';
  t['\uFCD5'] = '\u0646\u0645';
  t['\uFCD6'] = '\u0646\u0647';
  t['\uFCD7'] = '\u0647\u062C';
  t['\uFCD8'] = '\u0647\u0645';
  t['\uFCD9'] = '\u0647\u0670';
  t['\uFCDA'] = '\u064A\u062C';
  t['\uFCDB'] = '\u064A\u062D';
  t['\uFCDC'] = '\u064A\u062E';
  t['\uFCDD'] = '\u064A\u0645';
  t['\uFCDE'] = '\u064A\u0647';
  t['\uFCDF'] = '\u0626\u0645';
  t['\uFCE0'] = '\u0626\u0647';
  t['\uFCE1'] = '\u0628\u0645';
  t['\uFCE2'] = '\u0628\u0647';
  t['\uFCE3'] = '\u062A\u0645';
  t['\uFCE4'] = '\u062A\u0647';
  t['\uFCE5'] = '\u062B\u0645';
  t['\uFCE6'] = '\u062B\u0647';
  t['\uFCE7'] = '\u0633\u0645';
  t['\uFCE8'] = '\u0633\u0647';
  t['\uFCE9'] = '\u0634\u0645';
  t['\uFCEA'] = '\u0634\u0647';
  t['\uFCEB'] = '\u0643\u0644';
  t['\uFCEC'] = '\u0643\u0645';
  t['\uFCED'] = '\u0644\u0645';
  t['\uFCEE'] = '\u0646\u0645';
  t['\uFCEF'] = '\u0646\u0647';
  t['\uFCF0'] = '\u064A\u0645';
  t['\uFCF1'] = '\u064A\u0647';
  t['\uFCF2'] = '\u0640\u064E\u0651';
  t['\uFCF3'] = '\u0640\u064F\u0651';
  t['\uFCF4'] = '\u0640\u0650\u0651';
  t['\uFCF5'] = '\u0637\u0649';
  t['\uFCF6'] = '\u0637\u064A';
  t['\uFCF7'] = '\u0639\u0649';
  t['\uFCF8'] = '\u0639\u064A';
  t['\uFCF9'] = '\u063A\u0649';
  t['\uFCFA'] = '\u063A\u064A';
  t['\uFCFB'] = '\u0633\u0649';
  t['\uFCFC'] = '\u0633\u064A';
  t['\uFCFD'] = '\u0634\u0649';
  t['\uFCFE'] = '\u0634\u064A';
  t['\uFCFF'] = '\u062D\u0649';
  t['\uFD00'] = '\u062D\u064A';
  t['\uFD01'] = '\u062C\u0649';
  t['\uFD02'] = '\u062C\u064A';
  t['\uFD03'] = '\u062E\u0649';
  t['\uFD04'] = '\u062E\u064A';
  t['\uFD05'] = '\u0635\u0649';
  t['\uFD06'] = '\u0635\u064A';
  t['\uFD07'] = '\u0636\u0649';
  t['\uFD08'] = '\u0636\u064A';
  t['\uFD09'] = '\u0634\u062C';
  t['\uFD0A'] = '\u0634\u062D';
  t['\uFD0B'] = '\u0634\u062E';
  t['\uFD0C'] = '\u0634\u0645';
  t['\uFD0D'] = '\u0634\u0631';
  t['\uFD0E'] = '\u0633\u0631';
  t['\uFD0F'] = '\u0635\u0631';
  t['\uFD10'] = '\u0636\u0631';
  t['\uFD11'] = '\u0637\u0649';
  t['\uFD12'] = '\u0637\u064A';
  t['\uFD13'] = '\u0639\u0649';
  t['\uFD14'] = '\u0639\u064A';
  t['\uFD15'] = '\u063A\u0649';
  t['\uFD16'] = '\u063A\u064A';
  t['\uFD17'] = '\u0633\u0649';
  t['\uFD18'] = '\u0633\u064A';
  t['\uFD19'] = '\u0634\u0649';
  t['\uFD1A'] = '\u0634\u064A';
  t['\uFD1B'] = '\u062D\u0649';
  t['\uFD1C'] = '\u062D\u064A';
  t['\uFD1D'] = '\u062C\u0649';
  t['\uFD1E'] = '\u062C\u064A';
  t['\uFD1F'] = '\u062E\u0649';
  t['\uFD20'] = '\u062E\u064A';
  t['\uFD21'] = '\u0635\u0649';
  t['\uFD22'] = '\u0635\u064A';
  t['\uFD23'] = '\u0636\u0649';
  t['\uFD24'] = '\u0636\u064A';
  t['\uFD25'] = '\u0634\u062C';
  t['\uFD26'] = '\u0634\u062D';
  t['\uFD27'] = '\u0634\u062E';
  t['\uFD28'] = '\u0634\u0645';
  t['\uFD29'] = '\u0634\u0631';
  t['\uFD2A'] = '\u0633\u0631';
  t['\uFD2B'] = '\u0635\u0631';
  t['\uFD2C'] = '\u0636\u0631';
  t['\uFD2D'] = '\u0634\u062C';
  t['\uFD2E'] = '\u0634\u062D';
  t['\uFD2F'] = '\u0634\u062E';
  t['\uFD30'] = '\u0634\u0645';
  t['\uFD31'] = '\u0633\u0647';
  t['\uFD32'] = '\u0634\u0647';
  t['\uFD33'] = '\u0637\u0645';
  t['\uFD34'] = '\u0633\u062C';
  t['\uFD35'] = '\u0633\u062D';
  t['\uFD36'] = '\u0633\u062E';
  t['\uFD37'] = '\u0634\u062C';
  t['\uFD38'] = '\u0634\u062D';
  t['\uFD39'] = '\u0634\u062E';
  t['\uFD3A'] = '\u0637\u0645';
  t['\uFD3B'] = '\u0638\u0645';
  t['\uFD3C'] = '\u0627\u064B';
  t['\uFD3D'] = '\u0627\u064B';
  t['\uFD50'] = '\u062A\u062C\u0645';
  t['\uFD51'] = '\u062A\u062D\u062C';
  t['\uFD52'] = '\u062A\u062D\u062C';
  t['\uFD53'] = '\u062A\u062D\u0645';
  t['\uFD54'] = '\u062A\u062E\u0645';
  t['\uFD55'] = '\u062A\u0645\u062C';
  t['\uFD56'] = '\u062A\u0645\u062D';
  t['\uFD57'] = '\u062A\u0645\u062E';
  t['\uFD58'] = '\u062C\u0645\u062D';
  t['\uFD59'] = '\u062C\u0645\u062D';
  t['\uFD5A'] = '\u062D\u0645\u064A';
  t['\uFD5B'] = '\u062D\u0645\u0649';
  t['\uFD5C'] = '\u0633\u062D\u062C';
  t['\uFD5D'] = '\u0633\u062C\u062D';
  t['\uFD5E'] = '\u0633\u062C\u0649';
  t['\uFD5F'] = '\u0633\u0645\u062D';
  t['\uFD60'] = '\u0633\u0645\u062D';
  t['\uFD61'] = '\u0633\u0645\u062C';
  t['\uFD62'] = '\u0633\u0645\u0645';
  t['\uFD63'] = '\u0633\u0645\u0645';
  t['\uFD64'] = '\u0635\u062D\u062D';
  t['\uFD65'] = '\u0635\u062D\u062D';
  t['\uFD66'] = '\u0635\u0645\u0645';
  t['\uFD67'] = '\u0634\u062D\u0645';
  t['\uFD68'] = '\u0634\u062D\u0645';
  t['\uFD69'] = '\u0634\u062C\u064A';
  t['\uFD6A'] = '\u0634\u0645\u062E';
  t['\uFD6B'] = '\u0634\u0645\u062E';
  t['\uFD6C'] = '\u0634\u0645\u0645';
  t['\uFD6D'] = '\u0634\u0645\u0645';
  t['\uFD6E'] = '\u0636\u062D\u0649';
  t['\uFD6F'] = '\u0636\u062E\u0645';
  t['\uFD70'] = '\u0636\u062E\u0645';
  t['\uFD71'] = '\u0637\u0645\u062D';
  t['\uFD72'] = '\u0637\u0645\u062D';
  t['\uFD73'] = '\u0637\u0645\u0645';
  t['\uFD74'] = '\u0637\u0645\u064A';
  t['\uFD75'] = '\u0639\u062C\u0645';
  t['\uFD76'] = '\u0639\u0645\u0645';
  t['\uFD77'] = '\u0639\u0645\u0645';
  t['\uFD78'] = '\u0639\u0645\u0649';
  t['\uFD79'] = '\u063A\u0645\u0645';
  t['\uFD7A'] = '\u063A\u0645\u064A';
  t['\uFD7B'] = '\u063A\u0645\u0649';
  t['\uFD7C'] = '\u0641\u062E\u0645';
  t['\uFD7D'] = '\u0641\u062E\u0645';
  t['\uFD7E'] = '\u0642\u0645\u062D';
  t['\uFD7F'] = '\u0642\u0645\u0645';
  t['\uFD80'] = '\u0644\u062D\u0645';
  t['\uFD81'] = '\u0644\u062D\u064A';
  t['\uFD82'] = '\u0644\u062D\u0649';
  t['\uFD83'] = '\u0644\u062C\u062C';
  t['\uFD84'] = '\u0644\u062C\u062C';
  t['\uFD85'] = '\u0644\u062E\u0645';
  t['\uFD86'] = '\u0644\u062E\u0645';
  t['\uFD87'] = '\u0644\u0645\u062D';
  t['\uFD88'] = '\u0644\u0645\u062D';
  t['\uFD89'] = '\u0645\u062D\u062C';
  t['\uFD8A'] = '\u0645\u062D\u0645';
  t['\uFD8B'] = '\u0645\u062D\u064A';
  t['\uFD8C'] = '\u0645\u062C\u062D';
  t['\uFD8D'] = '\u0645\u062C\u0645';
  t['\uFD8E'] = '\u0645\u062E\u062C';
  t['\uFD8F'] = '\u0645\u062E\u0645';
  t['\uFD92'] = '\u0645\u062C\u062E';
  t['\uFD93'] = '\u0647\u0645\u062C';
  t['\uFD94'] = '\u0647\u0645\u0645';
  t['\uFD95'] = '\u0646\u062D\u0645';
  t['\uFD96'] = '\u0646\u062D\u0649';
  t['\uFD97'] = '\u0646\u062C\u0645';
  t['\uFD98'] = '\u0646\u062C\u0645';
  t['\uFD99'] = '\u0646\u062C\u0649';
  t['\uFD9A'] = '\u0646\u0645\u064A';
  t['\uFD9B'] = '\u0646\u0645\u0649';
  t['\uFD9C'] = '\u064A\u0645\u0645';
  t['\uFD9D'] = '\u064A\u0645\u0645';
  t['\uFD9E'] = '\u0628\u062E\u064A';
  t['\uFD9F'] = '\u062A\u062C\u064A';
  t['\uFDA0'] = '\u062A\u062C\u0649';
  t['\uFDA1'] = '\u062A\u062E\u064A';
  t['\uFDA2'] = '\u062A\u062E\u0649';
  t['\uFDA3'] = '\u062A\u0645\u064A';
  t['\uFDA4'] = '\u062A\u0645\u0649';
  t['\uFDA5'] = '\u062C\u0645\u064A';
  t['\uFDA6'] = '\u062C\u062D\u0649';
  t['\uFDA7'] = '\u062C\u0645\u0649';
  t['\uFDA8'] = '\u0633\u062E\u0649';
  t['\uFDA9'] = '\u0635\u062D\u064A';
  t['\uFDAA'] = '\u0634\u062D\u064A';
  t['\uFDAB'] = '\u0636\u062D\u064A';
  t['\uFDAC'] = '\u0644\u062C\u064A';
  t['\uFDAD'] = '\u0644\u0645\u064A';
  t['\uFDAE'] = '\u064A\u062D\u064A';
  t['\uFDAF'] = '\u064A\u062C\u064A';
  t['\uFDB0'] = '\u064A\u0645\u064A';
  t['\uFDB1'] = '\u0645\u0645\u064A';
  t['\uFDB2'] = '\u0642\u0645\u064A';
  t['\uFDB3'] = '\u0646\u062D\u064A';
  t['\uFDB4'] = '\u0642\u0645\u062D';
  t['\uFDB5'] = '\u0644\u062D\u0645';
  t['\uFDB6'] = '\u0639\u0645\u064A';
  t['\uFDB7'] = '\u0643\u0645\u064A';
  t['\uFDB8'] = '\u0646\u062C\u062D';
  t['\uFDB9'] = '\u0645\u062E\u064A';
  t['\uFDBA'] = '\u0644\u062C\u0645';
  t['\uFDBB'] = '\u0643\u0645\u0645';
  t['\uFDBC'] = '\u0644\u062C\u0645';
  t['\uFDBD'] = '\u0646\u062C\u062D';
  t['\uFDBE'] = '\u062C\u062D\u064A';
  t['\uFDBF'] = '\u062D\u062C\u064A';
  t['\uFDC0'] = '\u0645\u062C\u064A';
  t['\uFDC1'] = '\u0641\u0645\u064A';
  t['\uFDC2'] = '\u0628\u062D\u064A';
  t['\uFDC3'] = '\u0643\u0645\u0645';
  t['\uFDC4'] = '\u0639\u062C\u0645';
  t['\uFDC5'] = '\u0635\u0645\u0645';
  t['\uFDC6'] = '\u0633\u062E\u064A';
  t['\uFDC7'] = '\u0646\u062C\u064A';
  t['\uFE49'] = '\u203E';
  t['\uFE4A'] = '\u203E';
  t['\uFE4B'] = '\u203E';
  t['\uFE4C'] = '\u203E';
  t['\uFE4D'] = '_';
  t['\uFE4E'] = '_';
  t['\uFE4F'] = '_';
  t['\uFE80'] = '\u0621';
  t['\uFE81'] = '\u0622';
  t['\uFE82'] = '\u0622';
  t['\uFE83'] = '\u0623';
  t['\uFE84'] = '\u0623';
  t['\uFE85'] = '\u0624';
  t['\uFE86'] = '\u0624';
  t['\uFE87'] = '\u0625';
  t['\uFE88'] = '\u0625';
  t['\uFE89'] = '\u0626';
  t['\uFE8A'] = '\u0626';
  t['\uFE8B'] = '\u0626';
  t['\uFE8C'] = '\u0626';
  t['\uFE8D'] = '\u0627';
  t['\uFE8E'] = '\u0627';
  t['\uFE8F'] = '\u0628';
  t['\uFE90'] = '\u0628';
  t['\uFE91'] = '\u0628';
  t['\uFE92'] = '\u0628';
  t['\uFE93'] = '\u0629';
  t['\uFE94'] = '\u0629';
  t['\uFE95'] = '\u062A';
  t['\uFE96'] = '\u062A';
  t['\uFE97'] = '\u062A';
  t['\uFE98'] = '\u062A';
  t['\uFE99'] = '\u062B';
  t['\uFE9A'] = '\u062B';
  t['\uFE9B'] = '\u062B';
  t['\uFE9C'] = '\u062B';
  t['\uFE9D'] = '\u062C';
  t['\uFE9E'] = '\u062C';
  t['\uFE9F'] = '\u062C';
  t['\uFEA0'] = '\u062C';
  t['\uFEA1'] = '\u062D';
  t['\uFEA2'] = '\u062D';
  t['\uFEA3'] = '\u062D';
  t['\uFEA4'] = '\u062D';
  t['\uFEA5'] = '\u062E';
  t['\uFEA6'] = '\u062E';
  t['\uFEA7'] = '\u062E';
  t['\uFEA8'] = '\u062E';
  t['\uFEA9'] = '\u062F';
  t['\uFEAA'] = '\u062F';
  t['\uFEAB'] = '\u0630';
  t['\uFEAC'] = '\u0630';
  t['\uFEAD'] = '\u0631';
  t['\uFEAE'] = '\u0631';
  t['\uFEAF'] = '\u0632';
  t['\uFEB0'] = '\u0632';
  t['\uFEB1'] = '\u0633';
  t['\uFEB2'] = '\u0633';
  t['\uFEB3'] = '\u0633';
  t['\uFEB4'] = '\u0633';
  t['\uFEB5'] = '\u0634';
  t['\uFEB6'] = '\u0634';
  t['\uFEB7'] = '\u0634';
  t['\uFEB8'] = '\u0634';
  t['\uFEB9'] = '\u0635';
  t['\uFEBA'] = '\u0635';
  t['\uFEBB'] = '\u0635';
  t['\uFEBC'] = '\u0635';
  t['\uFEBD'] = '\u0636';
  t['\uFEBE'] = '\u0636';
  t['\uFEBF'] = '\u0636';
  t['\uFEC0'] = '\u0636';
  t['\uFEC1'] = '\u0637';
  t['\uFEC2'] = '\u0637';
  t['\uFEC3'] = '\u0637';
  t['\uFEC4'] = '\u0637';
  t['\uFEC5'] = '\u0638';
  t['\uFEC6'] = '\u0638';
  t['\uFEC7'] = '\u0638';
  t['\uFEC8'] = '\u0638';
  t['\uFEC9'] = '\u0639';
  t['\uFECA'] = '\u0639';
  t['\uFECB'] = '\u0639';
  t['\uFECC'] = '\u0639';
  t['\uFECD'] = '\u063A';
  t['\uFECE'] = '\u063A';
  t['\uFECF'] = '\u063A';
  t['\uFED0'] = '\u063A';
  t['\uFED1'] = '\u0641';
  t['\uFED2'] = '\u0641';
  t['\uFED3'] = '\u0641';
  t['\uFED4'] = '\u0641';
  t['\uFED5'] = '\u0642';
  t['\uFED6'] = '\u0642';
  t['\uFED7'] = '\u0642';
  t['\uFED8'] = '\u0642';
  t['\uFED9'] = '\u0643';
  t['\uFEDA'] = '\u0643';
  t['\uFEDB'] = '\u0643';
  t['\uFEDC'] = '\u0643';
  t['\uFEDD'] = '\u0644';
  t['\uFEDE'] = '\u0644';
  t['\uFEDF'] = '\u0644';
  t['\uFEE0'] = '\u0644';
  t['\uFEE1'] = '\u0645';
  t['\uFEE2'] = '\u0645';
  t['\uFEE3'] = '\u0645';
  t['\uFEE4'] = '\u0645';
  t['\uFEE5'] = '\u0646';
  t['\uFEE6'] = '\u0646';
  t['\uFEE7'] = '\u0646';
  t['\uFEE8'] = '\u0646';
  t['\uFEE9'] = '\u0647';
  t['\uFEEA'] = '\u0647';
  t['\uFEEB'] = '\u0647';
  t['\uFEEC'] = '\u0647';
  t['\uFEED'] = '\u0648';
  t['\uFEEE'] = '\u0648';
  t['\uFEEF'] = '\u0649';
  t['\uFEF0'] = '\u0649';
  t['\uFEF1'] = '\u064A';
  t['\uFEF2'] = '\u064A';
  t['\uFEF3'] = '\u064A';
  t['\uFEF4'] = '\u064A';
  t['\uFEF5'] = '\u0644\u0622';
  t['\uFEF6'] = '\u0644\u0622';
  t['\uFEF7'] = '\u0644\u0623';
  t['\uFEF8'] = '\u0644\u0623';
  t['\uFEF9'] = '\u0644\u0625';
  t['\uFEFA'] = '\u0644\u0625';
  t['\uFEFB'] = '\u0644\u0627';
  t['\uFEFC'] = '\u0644\u0627';
});
function reverseIfRtl(chars) {
  var charsLength = chars.length;
  if (charsLength <= 1 || !isRTLRangeFor(chars.charCodeAt(0))) {
    return chars;
  }
  var s = '';
  for (var ii = charsLength - 1; ii >= 0; ii--) {
    s += chars[ii];
  }
  return s;
}
exports.mapSpecialUnicodeValues = mapSpecialUnicodeValues;
exports.reverseIfRtl = reverseIfRtl;
exports.getUnicodeRangeFor = getUnicodeRangeFor;
exports.getNormalizedUnicodes = getNormalizedUnicodes;
exports.getUnicodeForGlyph = getUnicodeForGlyph;

/***/ }),
/* 19 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var coreWorker = __w_pdfjs_require__(8);
var globalScope = sharedUtil.globalScope;
var OK_RESPONSE = 200;
var PARTIAL_CONTENT_RESPONSE = 206;
function NetworkManager(url, args) {
  this.url = url;
  args = args || {};
  this.isHttp = /^https?:/i.test(url);
  this.httpHeaders = this.isHttp && args.httpHeaders || {};
  this.withCredentials = args.withCredentials || false;
  this.getXhr = args.getXhr || function NetworkManager_getXhr() {
    return new XMLHttpRequest();
  };
  this.currXhrId = 0;
  this.pendingRequests = Object.create(null);
  this.loadedRequests = Object.create(null);
}
function getArrayBuffer(xhr) {
  var data = xhr.response;
  if (typeof data !== 'string') {
    return data;
  }
  var length = data.length;
  var array = new Uint8Array(length);
  for (var i = 0; i < length; i++) {
    array[i] = data.charCodeAt(i) & 0xFF;
  }
  return array.buffer;
}
var supportsMozChunked = function supportsMozChunkedClosure() {
  try {
    var x = new XMLHttpRequest();
    x.open('GET', globalScope.location.href);
    x.responseType = 'moz-chunked-arraybuffer';
    return x.responseType === 'moz-chunked-arraybuffer';
  } catch (e) {
    return false;
  }
}();
NetworkManager.prototype = {
  requestRange: function NetworkManager_requestRange(begin, end, listeners) {
    var args = {
      begin: begin,
      end: end
    };
    for (var prop in listeners) {
      args[prop] = listeners[prop];
    }
    return this.request(args);
  },
  requestFull: function NetworkManager_requestFull(listeners) {
    return this.request(listeners);
  },
  request: function NetworkManager_request(args) {
    var xhr = this.getXhr();
    var xhrId = this.currXhrId++;
    var pendingRequest = this.pendingRequests[xhrId] = { xhr: xhr };
    xhr.open('GET', this.url);
    xhr.withCredentials = this.withCredentials;
    for (var property in this.httpHeaders) {
      var value = this.httpHeaders[property];
      if (typeof value === 'undefined') {
        continue;
      }
      xhr.setRequestHeader(property, value);
    }
    if (this.isHttp && 'begin' in args && 'end' in args) {
      var rangeStr = args.begin + '-' + (args.end - 1);
      xhr.setRequestHeader('Range', 'bytes=' + rangeStr);
      pendingRequest.expectedStatus = 206;
    } else {
      pendingRequest.expectedStatus = 200;
    }
    var useMozChunkedLoading = supportsMozChunked && !!args.onProgressiveData;
    if (useMozChunkedLoading) {
      xhr.responseType = 'moz-chunked-arraybuffer';
      pendingRequest.onProgressiveData = args.onProgressiveData;
      pendingRequest.mozChunked = true;
    } else {
      xhr.responseType = 'arraybuffer';
    }
    if (args.onError) {
      xhr.onerror = function (evt) {
        args.onError(xhr.status);
      };
    }
    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
    xhr.onprogress = this.onProgress.bind(this, xhrId);
    pendingRequest.onHeadersReceived = args.onHeadersReceived;
    pendingRequest.onDone = args.onDone;
    pendingRequest.onError = args.onError;
    pendingRequest.onProgress = args.onProgress;
    xhr.send(null);
    return xhrId;
  },
  onProgress: function NetworkManager_onProgress(xhrId, evt) {
    var pendingRequest = this.pendingRequests[xhrId];
    if (!pendingRequest) {
      return;
    }
    if (pendingRequest.mozChunked) {
      var chunk = getArrayBuffer(pendingRequest.xhr);
      pendingRequest.onProgressiveData(chunk);
    }
    var onProgress = pendingRequest.onProgress;
    if (onProgress) {
      onProgress(evt);
    }
  },
  onStateChange: function NetworkManager_onStateChange(xhrId, evt) {
    var pendingRequest = this.pendingRequests[xhrId];
    if (!pendingRequest) {
      return;
    }
    var xhr = pendingRequest.xhr;
    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
      pendingRequest.onHeadersReceived();
      delete pendingRequest.onHeadersReceived;
    }
    if (xhr.readyState !== 4) {
      return;
    }
    if (!(xhrId in this.pendingRequests)) {
      return;
    }
    delete this.pendingRequests[xhrId];
    if (xhr.status === 0 && this.isHttp) {
      if (pendingRequest.onError) {
        pendingRequest.onError(xhr.status);
      }
      return;
    }
    var xhrStatus = xhr.status || OK_RESPONSE;
    var ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
      if (pendingRequest.onError) {
        pendingRequest.onError(xhr.status);
      }
      return;
    }
    this.loadedRequests[xhrId] = true;
    var chunk = getArrayBuffer(xhr);
    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
      var rangeHeader = xhr.getResponseHeader('Content-Range');
      var matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
      var begin = parseInt(matches[1], 10);
      pendingRequest.onDone({
        begin: begin,
        chunk: chunk
      });
    } else if (pendingRequest.onProgressiveData) {
      pendingRequest.onDone(null);
    } else if (chunk) {
      pendingRequest.onDone({
        begin: 0,
        chunk: chunk
      });
    } else if (pendingRequest.onError) {
      pendingRequest.onError(xhr.status);
    }
  },
  hasPendingRequests: function NetworkManager_hasPendingRequests() {
    for (var xhrId in this.pendingRequests) {
      return true;
    }
    return false;
  },
  getRequestXhr: function NetworkManager_getXhr(xhrId) {
    return this.pendingRequests[xhrId].xhr;
  },
  isStreamingRequest: function NetworkManager_isStreamingRequest(xhrId) {
    return !!this.pendingRequests[xhrId].onProgressiveData;
  },
  isPendingRequest: function NetworkManager_isPendingRequest(xhrId) {
    return xhrId in this.pendingRequests;
  },
  isLoadedRequest: function NetworkManager_isLoadedRequest(xhrId) {
    return xhrId in this.loadedRequests;
  },
  abortAllRequests: function NetworkManager_abortAllRequests() {
    for (var xhrId in this.pendingRequests) {
      this.abortRequest(xhrId | 0);
    }
  },
  abortRequest: function NetworkManager_abortRequest(xhrId) {
    var xhr = this.pendingRequests[xhrId].xhr;
    delete this.pendingRequests[xhrId];
    xhr.abort();
  }
};
var assert = sharedUtil.assert;
var createPromiseCapability = sharedUtil.createPromiseCapability;
var isInt = sharedUtil.isInt;
var MissingPDFException = sharedUtil.MissingPDFException;
var UnexpectedResponseException = sharedUtil.UnexpectedResponseException;
function PDFNetworkStream(options) {
  this._options = options;
  var source = options.source;
  this._manager = new NetworkManager(source.url, {
    httpHeaders: source.httpHeaders,
    withCredentials: source.withCredentials
  });
  this._rangeChunkSize = source.rangeChunkSize;
  this._fullRequestReader = null;
  this._rangeRequestReaders = [];
}
PDFNetworkStream.prototype = {
  _onRangeRequestReaderClosed: function PDFNetworkStream_onRangeRequestReaderClosed(reader) {
    var i = this._rangeRequestReaders.indexOf(reader);
    if (i >= 0) {
      this._rangeRequestReaders.splice(i, 1);
    }
  },
  getFullReader: function PDFNetworkStream_getFullReader() {
    assert(!this._fullRequestReader);
    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._options);
    return this._fullRequestReader;
  },
  getRangeReader: function PDFNetworkStream_getRangeReader(begin, end) {
    var reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
    this._rangeRequestReaders.push(reader);
    return reader;
  },
  cancelAllRequests: function PDFNetworkStream_cancelAllRequests(reason) {
    if (this._fullRequestReader) {
      this._fullRequestReader.cancel(reason);
    }
    var readers = this._rangeRequestReaders.slice(0);
    readers.forEach(function (reader) {
      reader.cancel(reason);
    });
  }
};
function PDFNetworkStreamFullRequestReader(manager, options) {
  this._manager = manager;
  var source = options.source;
  var args = {
    onHeadersReceived: this._onHeadersReceived.bind(this),
    onProgressiveData: source.disableStream ? null : this._onProgressiveData.bind(this),
    onDone: this._onDone.bind(this),
    onError: this._onError.bind(this),
    onProgress: this._onProgress.bind(this)
  };
  this._url = source.url;
  this._fullRequestId = manager.requestFull(args);
  this._headersReceivedCapability = createPromiseCapability();
  this._disableRange = options.disableRange || false;
  this._contentLength = source.length;
  this._rangeChunkSize = source.rangeChunkSize;
  if (!this._rangeChunkSize && !this._disableRange) {
    this._disableRange = true;
  }
  this._isStreamingSupported = false;
  this._isRangeSupported = false;
  this._cachedChunks = [];
  this._requests = [];
  this._done = false;
  this._storedError = undefined;
  this.onProgress = null;
}
PDFNetworkStreamFullRequestReader.prototype = {
  _validateRangeRequestCapabilities: function PDFNetworkStreamFullRequestReader_validateRangeRequestCapabilities() {
    if (this._disableRange) {
      return false;
    }
    var networkManager = this._manager;
    if (!networkManager.isHttp) {
      return false;
    }
    var fullRequestXhrId = this._fullRequestId;
    var fullRequestXhr = networkManager.getRequestXhr(fullRequestXhrId);
    if (fullRequestXhr.getResponseHeader('Accept-Ranges') !== 'bytes') {
      return false;
    }
    var contentEncoding = fullRequestXhr.getResponseHeader('Content-Encoding') || 'identity';
    if (contentEncoding !== 'identity') {
      return false;
    }
    var length = fullRequestXhr.getResponseHeader('Content-Length');
    length = parseInt(length, 10);
    if (!isInt(length)) {
      return false;
    }
    this._contentLength = length;
    if (length <= 2 * this._rangeChunkSize) {
      return false;
    }
    return true;
  },
  _onHeadersReceived: function PDFNetworkStreamFullRequestReader_onHeadersReceived() {
    if (this._validateRangeRequestCapabilities()) {
      this._isRangeSupported = true;
    }
    var networkManager = this._manager;
    var fullRequestXhrId = this._fullRequestId;
    if (networkManager.isStreamingRequest(fullRequestXhrId)) {
      this._isStreamingSupported = true;
    } else if (this._isRangeSupported) {
      networkManager.abortRequest(fullRequestXhrId);
    }
    this._headersReceivedCapability.resolve();
  },
  _onProgressiveData: function PDFNetworkStreamFullRequestReader_onProgressiveData(chunk) {
    if (this._requests.length > 0) {
      var requestCapability = this._requests.shift();
      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._cachedChunks.push(chunk);
    }
  },
  _onDone: function PDFNetworkStreamFullRequestReader_onDone(args) {
    if (args) {
      this._onProgressiveData(args.chunk);
    }
    this._done = true;
    if (this._cachedChunks.length > 0) {
      return;
    }
    this._requests.forEach(function (requestCapability) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    });
    this._requests = [];
  },
  _onError: function PDFNetworkStreamFullRequestReader_onError(status) {
    var url = this._url;
    var exception;
    if (status === 404 || status === 0 && /^file:/.test(url)) {
      exception = new MissingPDFException('Missing PDF "' + url + '".');
    } else {
      exception = new UnexpectedResponseException('Unexpected server response (' + status + ') while retrieving PDF "' + url + '".', status);
    }
    this._storedError = exception;
    this._headersReceivedCapability.reject(exception);
    this._requests.forEach(function (requestCapability) {
      requestCapability.reject(exception);
    });
    this._requests = [];
    this._cachedChunks = [];
  },
  _onProgress: function PDFNetworkStreamFullRequestReader_onProgress(data) {
    if (this.onProgress) {
      this.onProgress({
        loaded: data.loaded,
        total: data.lengthComputable ? data.total : this._contentLength
      });
    }
  },
  get isRangeSupported() {
    return this._isRangeSupported;
  },
  get isStreamingSupported() {
    return this._isStreamingSupported;
  },
  get contentLength() {
    return this._contentLength;
  },
  get headersReady() {
    return this._headersReceivedCapability.promise;
  },
  read: function PDFNetworkStreamFullRequestReader_read() {
    if (this._storedError) {
      return Promise.reject(this._storedError);
    }
    if (this._cachedChunks.length > 0) {
      var chunk = this._cachedChunks.shift();
      return Promise.resolve(chunk);
    }
    if (this._done) {
      return Promise.resolve({
        value: undefined,
        done: true
      });
    }
    var requestCapability = createPromiseCapability();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  },
  cancel: function PDFNetworkStreamFullRequestReader_cancel(reason) {
    this._done = true;
    this._headersReceivedCapability.reject(reason);
    this._requests.forEach(function (requestCapability) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    });
    this._requests = [];
    if (this._manager.isPendingRequest(this._fullRequestId)) {
      this._manager.abortRequest(this._fullRequestId);
    }
    this._fullRequestReader = null;
  }
};
function PDFNetworkStreamRangeRequestReader(manager, begin, end) {
  this._manager = manager;
  var args = {
    onDone: this._onDone.bind(this),
    onProgress: this._onProgress.bind(this)
  };
  this._requestId = manager.requestRange(begin, end, args);
  this._requests = [];
  this._queuedChunk = null;
  this._done = false;
  this.onProgress = null;
  this.onClosed = null;
}
PDFNetworkStreamRangeRequestReader.prototype = {
  _close: function PDFNetworkStreamRangeRequestReader_close() {
    if (this.onClosed) {
      this.onClosed(this);
    }
  },
  _onDone: function PDFNetworkStreamRangeRequestReader_onDone(data) {
    var chunk = data.chunk;
    if (this._requests.length > 0) {
      var requestCapability = this._requests.shift();
      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunk = chunk;
    }
    this._done = true;
    this._requests.forEach(function (requestCapability) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    });
    this._requests = [];
    this._close();
  },
  _onProgress: function PDFNetworkStreamRangeRequestReader_onProgress(evt) {
    if (!this.isStreamingSupported && this.onProgress) {
      this.onProgress({ loaded: evt.loaded });
    }
  },
  get isStreamingSupported() {
    return false;
  },
  read: function PDFNetworkStreamRangeRequestReader_read() {
    if (this._queuedChunk !== null) {
      var chunk = this._queuedChunk;
      this._queuedChunk = null;
      return Promise.resolve({
        value: chunk,
        done: false
      });
    }
    if (this._done) {
      return Promise.resolve({
        value: undefined,
        done: true
      });
    }
    var requestCapability = createPromiseCapability();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  },
  cancel: function PDFNetworkStreamRangeRequestReader_cancel(reason) {
    this._done = true;
    this._requests.forEach(function (requestCapability) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    });
    this._requests = [];
    if (this._manager.isPendingRequest(this._requestId)) {
      this._manager.abortRequest(this._requestId);
    }
    this._close();
  }
};
coreWorker.setPDFNetworkStreamClass(PDFNetworkStream);
exports.PDFNetworkStream = PDFNetworkStream;
exports.NetworkManager = NetworkManager;

/***/ }),
/* 20 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var corePrimitives = __w_pdfjs_require__(1);
var coreStream = __w_pdfjs_require__(2);
var coreColorSpace = __w_pdfjs_require__(3);
var coreObj = __w_pdfjs_require__(16);
var coreEvaluator = __w_pdfjs_require__(14);
var AnnotationBorderStyleType = sharedUtil.AnnotationBorderStyleType;
var AnnotationFieldFlag = sharedUtil.AnnotationFieldFlag;
var AnnotationFlag = sharedUtil.AnnotationFlag;
var AnnotationType = sharedUtil.AnnotationType;
var OPS = sharedUtil.OPS;
var Util = sharedUtil.Util;
var isArray = sharedUtil.isArray;
var isInt = sharedUtil.isInt;
var stringToBytes = sharedUtil.stringToBytes;
var stringToPDFString = sharedUtil.stringToPDFString;
var warn = sharedUtil.warn;
var Dict = corePrimitives.Dict;
var isDict = corePrimitives.isDict;
var isName = corePrimitives.isName;
var isRef = corePrimitives.isRef;
var isStream = corePrimitives.isStream;
var Stream = coreStream.Stream;
var ColorSpace = coreColorSpace.ColorSpace;
var Catalog = coreObj.Catalog;
var ObjectLoader = coreObj.ObjectLoader;
var FileSpec = coreObj.FileSpec;
var OperatorList = coreEvaluator.OperatorList;
function AnnotationFactory() {}
AnnotationFactory.prototype = {
  create: function AnnotationFactory_create(xref, ref, pdfManager, idFactory) {
    var dict = xref.fetchIfRef(ref);
    if (!isDict(dict)) {
      return;
    }
    var id = isRef(ref) ? ref.toString() : 'annot_' + idFactory.createObjId();
    var subtype = dict.get('Subtype');
    subtype = isName(subtype) ? subtype.name : null;
    var parameters = {
      xref: xref,
      dict: dict,
      ref: isRef(ref) ? ref : null,
      subtype: subtype,
      id: id,
      pdfManager: pdfManager
    };
    switch (subtype) {
      case 'Link':
        return new LinkAnnotation(parameters);
      case 'Text':
        return new TextAnnotation(parameters);
      case 'Widget':
        var fieldType = Util.getInheritableProperty(dict, 'FT');
        fieldType = isName(fieldType) ? fieldType.name : null;
        switch (fieldType) {
          case 'Tx':
            return new TextWidgetAnnotation(parameters);
          case 'Btn':
            return new ButtonWidgetAnnotation(parameters);
          case 'Ch':
            return new ChoiceWidgetAnnotation(parameters);
        }
        warn('Unimplemented widget field type "' + fieldType + '", ' + 'falling back to base field type.');
        return new WidgetAnnotation(parameters);
      case 'Popup':
        return new PopupAnnotation(parameters);
      case 'Line':
        return new LineAnnotation(parameters);
      case 'Highlight':
        return new HighlightAnnotation(parameters);
      case 'Underline':
        return new UnderlineAnnotation(parameters);
      case 'Squiggly':
        return new SquigglyAnnotation(parameters);
      case 'StrikeOut':
        return new StrikeOutAnnotation(parameters);
      case 'FileAttachment':
        return new FileAttachmentAnnotation(parameters);
      default:
        if (!subtype) {
          warn('Annotation is missing the required /Subtype.');
        } else {
          warn('Unimplemented annotation type "' + subtype + '", ' + 'falling back to base annotation.');
        }
        return new Annotation(parameters);
    }
  }
};
var Annotation = function AnnotationClosure() {
  function getTransformMatrix(rect, bbox, matrix) {
    var bounds = Util.getAxialAlignedBoundingBox(bbox, matrix);
    var minX = bounds[0];
    var minY = bounds[1];
    var maxX = bounds[2];
    var maxY = bounds[3];
    if (minX === maxX || minY === maxY) {
      return [1, 0, 0, 1, rect[0], rect[1]];
    }
    var xRatio = (rect[2] - rect[0]) / (maxX - minX);
    var yRatio = (rect[3] - rect[1]) / (maxY - minY);
    return [xRatio, 0, 0, yRatio, rect[0] - minX * xRatio, rect[1] - minY * yRatio];
  }
  function Annotation(params) {
    var dict = params.dict;
    this.setFlags(dict.get('F'));
    this.setRectangle(dict.getArray('Rect'));
    this.setColor(dict.getArray('C'));
    this.setBorderStyle(dict);
    this.setAppearance(dict);
    this.data = {};
    this.data.id = params.id;
    this.data.subtype = params.subtype;
    this.data.annotationFlags = this.flags;
    this.data.rect = this.rectangle;
    this.data.color = this.color;
    this.data.borderStyle = this.borderStyle;
    this.data.hasAppearance = !!this.appearance;
  }
  Annotation.prototype = {
    _hasFlag: function Annotation_hasFlag(flags, flag) {
      return !!(flags & flag);
    },
    _isViewable: function Annotation_isViewable(flags) {
      return !this._hasFlag(flags, AnnotationFlag.INVISIBLE) && !this._hasFlag(flags, AnnotationFlag.HIDDEN) && !this._hasFlag(flags, AnnotationFlag.NOVIEW);
    },
    _isPrintable: function AnnotationFlag_isPrintable(flags) {
      return this._hasFlag(flags, AnnotationFlag.PRINT) && !this._hasFlag(flags, AnnotationFlag.INVISIBLE) && !this._hasFlag(flags, AnnotationFlag.HIDDEN);
    },
    get viewable() {
      if (this.flags === 0) {
        return true;
      }
      return this._isViewable(this.flags);
    },
    get printable() {
      if (this.flags === 0) {
        return false;
      }
      return this._isPrintable(this.flags);
    },
    setFlags: function Annotation_setFlags(flags) {
      this.flags = isInt(flags) && flags > 0 ? flags : 0;
    },
    hasFlag: function Annotation_hasFlag(flag) {
      return this._hasFlag(this.flags, flag);
    },
    setRectangle: function Annotation_setRectangle(rectangle) {
      if (isArray(rectangle) && rectangle.length === 4) {
        this.rectangle = Util.normalizeRect(rectangle);
      } else {
        this.rectangle = [0, 0, 0, 0];
      }
    },
    setColor: function Annotation_setColor(color) {
      var rgbColor = new Uint8Array(3);
      if (!isArray(color)) {
        this.color = rgbColor;
        return;
      }
      switch (color.length) {
        case 0:
          this.color = null;
          break;
        case 1:
          ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);
          this.color = rgbColor;
          break;
        case 3:
          ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);
          this.color = rgbColor;
          break;
        case 4:
          ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);
          this.color = rgbColor;
          break;
        default:
          this.color = rgbColor;
          break;
      }
    },
    setBorderStyle: function Annotation_setBorderStyle(borderStyle) {
      this.borderStyle = new AnnotationBorderStyle();
      if (!isDict(borderStyle)) {
        return;
      }
      if (borderStyle.has('BS')) {
        var dict = borderStyle.get('BS');
        var dictType = dict.get('Type');
        if (!dictType || isName(dictType, 'Border')) {
          this.borderStyle.setWidth(dict.get('W'));
          this.borderStyle.setStyle(dict.get('S'));
          this.borderStyle.setDashArray(dict.getArray('D'));
        }
      } else if (borderStyle.has('Border')) {
        var array = borderStyle.getArray('Border');
        if (isArray(array) && array.length >= 3) {
          this.borderStyle.setHorizontalCornerRadius(array[0]);
          this.borderStyle.setVerticalCornerRadius(array[1]);
          this.borderStyle.setWidth(array[2]);
          if (array.length === 4) {
            this.borderStyle.setDashArray(array[3]);
          }
        }
      } else {
        this.borderStyle.setWidth(0);
      }
    },
    setAppearance: function Annotation_setAppearance(dict) {
      this.appearance = null;
      var appearanceStates = dict.get('AP');
      if (!isDict(appearanceStates)) {
        return;
      }
      var normalAppearanceState = appearanceStates.get('N');
      if (isStream(normalAppearanceState)) {
        this.appearance = normalAppearanceState;
        return;
      }
      if (!isDict(normalAppearanceState)) {
        return;
      }
      var as = dict.get('AS');
      if (!isName(as) || !normalAppearanceState.has(as.name)) {
        return;
      }
      this.appearance = normalAppearanceState.get(as.name);
    },
    _preparePopup: function Annotation_preparePopup(dict) {
      if (!dict.has('C')) {
        this.data.color = null;
      }
      this.data.hasPopup = dict.has('Popup');
      this.data.title = stringToPDFString(dict.get('T') || '');
      this.data.contents = stringToPDFString(dict.get('Contents') || '');
    },
    loadResources: function Annotation_loadResources(keys) {
      return new Promise(function (resolve, reject) {
        this.appearance.dict.getAsync('Resources').then(function (resources) {
          if (!resources) {
            resolve();
            return;
          }
          var objectLoader = new ObjectLoader(resources.map, keys, resources.xref);
          objectLoader.load().then(function () {
            resolve(resources);
          }, reject);
        }, reject);
      }.bind(this));
    },
    getOperatorList: function Annotation_getOperatorList(evaluator, task, renderForms) {
      if (!this.appearance) {
        return Promise.resolve(new OperatorList());
      }
      var data = this.data;
      var appearanceDict = this.appearance.dict;
      var resourcesPromise = this.loadResources(['ExtGState', 'ColorSpace', 'Pattern', 'Shading', 'XObject', 'Font']);
      var bbox = appearanceDict.getArray('BBox') || [0, 0, 1, 1];
      var matrix = appearanceDict.getArray('Matrix') || [1, 0, 0, 1, 0, 0];
      var transform = getTransformMatrix(data.rect, bbox, matrix);
      var self = this;
      return resourcesPromise.then(function (resources) {
        var opList = new OperatorList();
        opList.addOp(OPS.beginAnnotation, [data.rect, transform, matrix]);
        return evaluator.getOperatorList(self.appearance, task, resources, opList).then(function () {
          opList.addOp(OPS.endAnnotation, []);
          self.appearance.reset();
          return opList;
        });
      });
    }
  };
  return Annotation;
}();
var AnnotationBorderStyle = function AnnotationBorderStyleClosure() {
  function AnnotationBorderStyle() {
    this.width = 1;
    this.style = AnnotationBorderStyleType.SOLID;
    this.dashArray = [3];
    this.horizontalCornerRadius = 0;
    this.verticalCornerRadius = 0;
  }
  AnnotationBorderStyle.prototype = {
    setWidth: function AnnotationBorderStyle_setWidth(width) {
      if (width === (width | 0)) {
        this.width = width;
      }
    },
    setStyle: function AnnotationBorderStyle_setStyle(style) {
      if (!style) {
        return;
      }
      switch (style.name) {
        case 'S':
          this.style = AnnotationBorderStyleType.SOLID;
          break;
        case 'D':
          this.style = AnnotationBorderStyleType.DASHED;
          break;
        case 'B':
          this.style = AnnotationBorderStyleType.BEVELED;
          break;
        case 'I':
          this.style = AnnotationBorderStyleType.INSET;
          break;
        case 'U':
          this.style = AnnotationBorderStyleType.UNDERLINE;
          break;
        default:
          break;
      }
    },
    setDashArray: function AnnotationBorderStyle_setDashArray(dashArray) {
      if (isArray(dashArray) && dashArray.length > 0) {
        var isValid = true;
        var allZeros = true;
        for (var i = 0, len = dashArray.length; i < len; i++) {
          var element = dashArray[i];
          var validNumber = +element >= 0;
          if (!validNumber) {
            isValid = false;
            break;
          } else if (element > 0) {
            allZeros = false;
          }
        }
        if (isValid && !allZeros) {
          this.dashArray = dashArray;
        } else {
          this.width = 0;
        }
      } else if (dashArray) {
        this.width = 0;
      }
    },
    setHorizontalCornerRadius: function AnnotationBorderStyle_setHorizontalCornerRadius(radius) {
      if (radius === (radius | 0)) {
        this.horizontalCornerRadius = radius;
      }
    },
    setVerticalCornerRadius: function AnnotationBorderStyle_setVerticalCornerRadius(radius) {
      if (radius === (radius | 0)) {
        this.verticalCornerRadius = radius;
      }
    }
  };
  return AnnotationBorderStyle;
}();
var WidgetAnnotation = function WidgetAnnotationClosure() {
  function WidgetAnnotation(params) {
    Annotation.call(this, params);
    var dict = params.dict;
    var data = this.data;
    data.annotationType = AnnotationType.WIDGET;
    data.fieldName = this._constructFieldName(dict);
    data.fieldValue = Util.getInheritableProperty(dict, 'V', true);
    data.alternativeText = stringToPDFString(dict.get('TU') || '');
    data.defaultAppearance = Util.getInheritableProperty(dict, 'DA') || '';
    var fieldType = Util.getInheritableProperty(dict, 'FT');
    data.fieldType = isName(fieldType) ? fieldType.name : null;
    this.fieldResources = Util.getInheritableProperty(dict, 'DR') || Dict.empty;
    data.fieldFlags = Util.getInheritableProperty(dict, 'Ff');
    if (!isInt(data.fieldFlags) || data.fieldFlags < 0) {
      data.fieldFlags = 0;
    }
    data.readOnly = this.hasFieldFlag(AnnotationFieldFlag.READONLY);
    if (data.fieldType === 'Sig') {
      this.setFlags(AnnotationFlag.HIDDEN);
    }
  }
  Util.inherit(WidgetAnnotation, Annotation, {
    _constructFieldName: function WidgetAnnotation_constructFieldName(dict) {
      if (!dict.has('T') && !dict.has('Parent')) {
        warn('Unknown field name, falling back to empty field name.');
        return '';
      }
      if (!dict.has('Parent')) {
        return stringToPDFString(dict.get('T'));
      }
      var fieldName = [];
      if (dict.has('T')) {
        fieldName.unshift(stringToPDFString(dict.get('T')));
      }
      var loopDict = dict;
      while (loopDict.has('Parent')) {
        loopDict = loopDict.get('Parent');
        if (!isDict(loopDict)) {
          break;
        }
        if (loopDict.has('T')) {
          fieldName.unshift(stringToPDFString(loopDict.get('T')));
        }
      }
      return fieldName.join('.');
    },
    hasFieldFlag: function WidgetAnnotation_hasFieldFlag(flag) {
      return !!(this.data.fieldFlags & flag);
    }
  });
  return WidgetAnnotation;
}();
var TextWidgetAnnotation = function TextWidgetAnnotationClosure() {
  function TextWidgetAnnotation(params) {
    WidgetAnnotation.call(this, params);
    this.data.fieldValue = stringToPDFString(this.data.fieldValue || '');
    var alignment = Util.getInheritableProperty(params.dict, 'Q');
    if (!isInt(alignment) || alignment < 0 || alignment > 2) {
      alignment = null;
    }
    this.data.textAlignment = alignment;
    var maximumLength = Util.getInheritableProperty(params.dict, 'MaxLen');
    if (!isInt(maximumLength) || maximumLength < 0) {
      maximumLength = null;
    }
    this.data.maxLen = maximumLength;
    this.data.multiLine = this.hasFieldFlag(AnnotationFieldFlag.MULTILINE);
    this.data.comb = this.hasFieldFlag(AnnotationFieldFlag.COMB) && !this.hasFieldFlag(AnnotationFieldFlag.MULTILINE) && !this.hasFieldFlag(AnnotationFieldFlag.PASSWORD) && !this.hasFieldFlag(AnnotationFieldFlag.FILESELECT) && this.data.maxLen !== null;
  }
  Util.inherit(TextWidgetAnnotation, WidgetAnnotation, {
    getOperatorList: function TextWidgetAnnotation_getOperatorList(evaluator, task, renderForms) {
      var operatorList = new OperatorList();
      if (renderForms) {
        return Promise.resolve(operatorList);
      }
      if (this.appearance) {
        return Annotation.prototype.getOperatorList.call(this, evaluator, task, renderForms);
      }
      if (!this.data.defaultAppearance) {
        return Promise.resolve(operatorList);
      }
      var stream = new Stream(stringToBytes(this.data.defaultAppearance));
      return evaluator.getOperatorList(stream, task, this.fieldResources, operatorList).then(function () {
        return operatorList;
      });
    }
  });
  return TextWidgetAnnotation;
}();
var ButtonWidgetAnnotation = function ButtonWidgetAnnotationClosure() {
  function ButtonWidgetAnnotation(params) {
    WidgetAnnotation.call(this, params);
    this.data.checkBox = !this.hasFieldFlag(AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
    if (this.data.checkBox) {
      if (!isName(this.data.fieldValue)) {
        return;
      }
      this.data.fieldValue = this.data.fieldValue.name;
    }
    this.data.radioButton = this.hasFieldFlag(AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
    if (this.data.radioButton) {
      this.data.fieldValue = this.data.buttonValue = null;
      var fieldParent = params.dict.get('Parent');
      if (isDict(fieldParent) && fieldParent.has('V')) {
        var fieldParentValue = fieldParent.get('V');
        if (isName(fieldParentValue)) {
          this.data.fieldValue = fieldParentValue.name;
        }
      }
      var appearanceStates = params.dict.get('AP');
      if (!isDict(appearanceStates)) {
        return;
      }
      var normalAppearanceState = appearanceStates.get('N');
      if (!isDict(normalAppearanceState)) {
        return;
      }
      var keys = normalAppearanceState.getKeys();
      for (var i = 0, ii = keys.length; i < ii; i++) {
        if (keys[i] !== 'Off') {
          this.data.buttonValue = keys[i];
          break;
        }
      }
    }
  }
  Util.inherit(ButtonWidgetAnnotation, WidgetAnnotation, {
    getOperatorList: function ButtonWidgetAnnotation_getOperatorList(evaluator, task, renderForms) {
      var operatorList = new OperatorList();
      if (renderForms) {
        return Promise.resolve(operatorList);
      }
      if (this.appearance) {
        return Annotation.prototype.getOperatorList.call(this, evaluator, task, renderForms);
      }
      return Promise.resolve(operatorList);
    }
  });
  return ButtonWidgetAnnotation;
}();
var ChoiceWidgetAnnotation = function ChoiceWidgetAnnotationClosure() {
  function ChoiceWidgetAnnotation(params) {
    WidgetAnnotation.call(this, params);
    this.data.options = [];
    var options = Util.getInheritableProperty(params.dict, 'Opt');
    if (isArray(options)) {
      var xref = params.xref;
      for (var i = 0, ii = options.length; i < ii; i++) {
        var option = xref.fetchIfRef(options[i]);
        var isOptionArray = isArray(option);
        this.data.options[i] = {
          exportValue: isOptionArray ? xref.fetchIfRef(option[0]) : option,
          displayValue: isOptionArray ? xref.fetchIfRef(option[1]) : option
        };
      }
    }
    if (!isArray(this.data.fieldValue)) {
      this.data.fieldValue = [this.data.fieldValue];
    }
    this.data.combo = this.hasFieldFlag(AnnotationFieldFlag.COMBO);
    this.data.multiSelect = this.hasFieldFlag(AnnotationFieldFlag.MULTISELECT);
  }
  Util.inherit(ChoiceWidgetAnnotation, WidgetAnnotation, {
    getOperatorList: function ChoiceWidgetAnnotation_getOperatorList(evaluator, task, renderForms) {
      var operatorList = new OperatorList();
      if (renderForms) {
        return Promise.resolve(operatorList);
      }
      return Annotation.prototype.getOperatorList.call(this, evaluator, task, renderForms);
    }
  });
  return ChoiceWidgetAnnotation;
}();
var TextAnnotation = function TextAnnotationClosure() {
  var DEFAULT_ICON_SIZE = 22;
  function TextAnnotation(parameters) {
    Annotation.call(this, parameters);
    this.data.annotationType = AnnotationType.TEXT;
    if (this.data.hasAppearance) {
      this.data.name = 'NoIcon';
    } else {
      this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE;
      this.data.rect[2] = this.data.rect[0] + DEFAULT_ICON_SIZE;
      this.data.name = parameters.dict.has('Name') ? parameters.dict.get('Name').name : 'Note';
    }
    this._preparePopup(parameters.dict);
  }
  Util.inherit(TextAnnotation, Annotation, {});
  return TextAnnotation;
}();
var LinkAnnotation = function LinkAnnotationClosure() {
  function LinkAnnotation(params) {
    Annotation.call(this, params);
    var data = this.data;
    data.annotationType = AnnotationType.LINK;
    Catalog.parseDestDictionary({
      destDict: params.dict,
      resultObj: data,
      docBaseUrl: params.pdfManager.docBaseUrl
    });
  }
  Util.inherit(LinkAnnotation, Annotation, {});
  return LinkAnnotation;
}();
var PopupAnnotation = function PopupAnnotationClosure() {
  function PopupAnnotation(parameters) {
    Annotation.call(this, parameters);
    this.data.annotationType = AnnotationType.POPUP;
    var dict = parameters.dict;
    var parentItem = dict.get('Parent');
    if (!parentItem) {
      warn('Popup annotation has a missing or invalid parent annotation.');
      return;
    }
    var parentSubtype = parentItem.get('Subtype');
    this.data.parentType = isName(parentSubtype) ? parentSubtype.name : null;
    this.data.parentId = dict.getRaw('Parent').toString();
    this.data.title = stringToPDFString(parentItem.get('T') || '');
    this.data.contents = stringToPDFString(parentItem.get('Contents') || '');
    if (!parentItem.has('C')) {
      this.data.color = null;
    } else {
      this.setColor(parentItem.getArray('C'));
      this.data.color = this.color;
    }
    if (!this.viewable) {
      var parentFlags = parentItem.get('F');
      if (this._isViewable(parentFlags)) {
        this.setFlags(parentFlags);
      }
    }
  }
  Util.inherit(PopupAnnotation, Annotation, {});
  return PopupAnnotation;
}();
var LineAnnotation = function LineAnnotationClosure() {
  function LineAnnotation(parameters) {
    Annotation.call(this, parameters);
    this.data.annotationType = AnnotationType.LINE;
    var dict = parameters.dict;
    this.data.lineCoordinates = Util.normalizeRect(dict.getArray('L'));
    this._preparePopup(dict);
  }
  Util.inherit(LineAnnotation, Annotation, {});
  return LineAnnotation;
}();
var HighlightAnnotation = function HighlightAnnotationClosure() {
  function HighlightAnnotation(parameters) {
    Annotation.call(this, parameters);
    this.data.annotationType = AnnotationType.HIGHLIGHT;
    this._preparePopup(parameters.dict);
  }
  Util.inherit(HighlightAnnotation, Annotation, {});
  return HighlightAnnotation;
}();
var UnderlineAnnotation = function UnderlineAnnotationClosure() {
  function UnderlineAnnotation(parameters) {
    Annotation.call(this, parameters);
    this.data.annotationType = AnnotationType.UNDERLINE;
    this._preparePopup(parameters.dict);
  }
  Util.inherit(UnderlineAnnotation, Annotation, {});
  return UnderlineAnnotation;
}();
var SquigglyAnnotation = function SquigglyAnnotationClosure() {
  function SquigglyAnnotation(parameters) {
    Annotation.call(this, parameters);
    this.data.annotationType = AnnotationType.SQUIGGLY;
    this._preparePopup(parameters.dict);
  }
  Util.inherit(SquigglyAnnotation, Annotation, {});
  return SquigglyAnnotation;
}();
var StrikeOutAnnotation = function StrikeOutAnnotationClosure() {
  function StrikeOutAnnotation(parameters) {
    Annotation.call(this, parameters);
    this.data.annotationType = AnnotationType.STRIKEOUT;
    this._preparePopup(parameters.dict);
  }
  Util.inherit(StrikeOutAnnotation, Annotation, {});
  return StrikeOutAnnotation;
}();
var FileAttachmentAnnotation = function FileAttachmentAnnotationClosure() {
  function FileAttachmentAnnotation(parameters) {
    Annotation.call(this, parameters);
    var file = new FileSpec(parameters.dict.get('FS'), parameters.xref);
    this.data.annotationType = AnnotationType.FILEATTACHMENT;
    this.data.file = file.serializable;
    this._preparePopup(parameters.dict);
  }
  Util.inherit(FileAttachmentAnnotation, Annotation, {});
  return FileAttachmentAnnotation;
}();
exports.Annotation = Annotation;
exports.AnnotationBorderStyle = AnnotationBorderStyle;
exports.AnnotationFactory = AnnotationFactory;

/***/ }),
/* 21 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var warn = sharedUtil.warn;
var baseTypes = ['BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'S', 'B', 'S', 'WS', 'B', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'B', 'B', 'B', 'S', 'WS', 'ON', 'ON', 'ET', 'ET', 'ET', 'ON', 'ON', 'ON', 'ON', 'ON', 'ES', 'CS', 'ES', 'CS', 'CS', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'CS', 'ON', 'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'ON', 'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'ON', 'ON', 'ON', 'ON', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'B', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'CS', 'ON', 'ET', 'ET', 'ET', 'ET', 'ON', 'ON', 'ON', 'ON', 'L', 'ON', 'ON', 'BN', 'ON', 'ON', 'ET', 'ET', 'EN', 'EN', 'ON', 'L', 'ON', 'ON', 'ON', 'EN', 'L', 'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L'];
var arabicTypes = ['AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'ON', 'ON', 'AL', 'ET', 'ET', 'AL', 'CS', 'AL', 'ON', 'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', '', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'ET', 'AN', 'AN', 'AL', 'AL', 'AL', 'NSM', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'AN', 'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', 'NSM', 'NSM', 'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL'];
function isOdd(i) {
  return (i & 1) !== 0;
}
function isEven(i) {
  return (i & 1) === 0;
}
function findUnequal(arr, start, value) {
  for (var j = start, jj = arr.length; j < jj; ++j) {
    if (arr[j] !== value) {
      return j;
    }
  }
  return j;
}
function setValues(arr, start, end, value) {
  for (var j = start; j < end; ++j) {
    arr[j] = value;
  }
}
function reverseValues(arr, start, end) {
  for (var i = start, j = end - 1; i < j; ++i, --j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }
}
function createBidiText(str, isLTR, vertical) {
  return {
    str: str,
    dir: vertical ? 'ttb' : isLTR ? 'ltr' : 'rtl'
  };
}
var chars = [];
var types = [];
function bidi(str, startLevel, vertical) {
  var isLTR = true;
  var strLength = str.length;
  if (strLength === 0 || vertical) {
    return createBidiText(str, isLTR, vertical);
  }
  chars.length = strLength;
  types.length = strLength;
  var numBidi = 0;
  var i, ii;
  for (i = 0; i < strLength; ++i) {
    chars[i] = str.charAt(i);
    var charCode = str.charCodeAt(i);
    var charType = 'L';
    if (charCode <= 0x00ff) {
      charType = baseTypes[charCode];
    } else if (0x0590 <= charCode && charCode <= 0x05f4) {
      charType = 'R';
    } else if (0x0600 <= charCode && charCode <= 0x06ff) {
      charType = arabicTypes[charCode & 0xff];
      if (!charType) {
        warn('Bidi: invalid Unicode character ' + charCode.toString(16));
      }
    } else if (0x0700 <= charCode && charCode <= 0x08AC) {
      charType = 'AL';
    }
    if (charType === 'R' || charType === 'AL' || charType === 'AN') {
      numBidi++;
    }
    types[i] = charType;
  }
  if (numBidi === 0) {
    isLTR = true;
    return createBidiText(str, isLTR);
  }
  if (startLevel === -1) {
    if (numBidi / strLength < 0.3) {
      isLTR = true;
      startLevel = 0;
    } else {
      isLTR = false;
      startLevel = 1;
    }
  }
  var levels = [];
  for (i = 0; i < strLength; ++i) {
    levels[i] = startLevel;
  }
  var e = isOdd(startLevel) ? 'R' : 'L';
  var sor = e;
  var eor = sor;
  var lastType = sor;
  for (i = 0; i < strLength; ++i) {
    if (types[i] === 'NSM') {
      types[i] = lastType;
    } else {
      lastType = types[i];
    }
  }
  lastType = sor;
  var t;
  for (i = 0; i < strLength; ++i) {
    t = types[i];
    if (t === 'EN') {
      types[i] = lastType === 'AL' ? 'AN' : 'EN';
    } else if (t === 'R' || t === 'L' || t === 'AL') {
      lastType = t;
    }
  }
  for (i = 0; i < strLength; ++i) {
    t = types[i];
    if (t === 'AL') {
      types[i] = 'R';
    }
  }
  for (i = 1; i < strLength - 1; ++i) {
    if (types[i] === 'ES' && types[i - 1] === 'EN' && types[i + 1] === 'EN') {
      types[i] = 'EN';
    }
    if (types[i] === 'CS' && (types[i - 1] === 'EN' || types[i - 1] === 'AN') && types[i + 1] === types[i - 1]) {
      types[i] = types[i - 1];
    }
  }
  for (i = 0; i < strLength; ++i) {
    if (types[i] === 'EN') {
      var j;
      for (j = i - 1; j >= 0; --j) {
        if (types[j] !== 'ET') {
          break;
        }
        types[j] = 'EN';
      }
      for (j = i + 1; j < strLength; ++j) {
        if (types[j] !== 'ET') {
          break;
        }
        types[j] = 'EN';
      }
    }
  }
  for (i = 0; i < strLength; ++i) {
    t = types[i];
    if (t === 'WS' || t === 'ES' || t === 'ET' || t === 'CS') {
      types[i] = 'ON';
    }
  }
  lastType = sor;
  for (i = 0; i < strLength; ++i) {
    t = types[i];
    if (t === 'EN') {
      types[i] = lastType === 'L' ? 'L' : 'EN';
    } else if (t === 'R' || t === 'L') {
      lastType = t;
    }
  }
  for (i = 0; i < strLength; ++i) {
    if (types[i] === 'ON') {
      var end = findUnequal(types, i + 1, 'ON');
      var before = sor;
      if (i > 0) {
        before = types[i - 1];
      }
      var after = eor;
      if (end + 1 < strLength) {
        after = types[end + 1];
      }
      if (before !== 'L') {
        before = 'R';
      }
      if (after !== 'L') {
        after = 'R';
      }
      if (before === after) {
        setValues(types, i, end, before);
      }
      i = end - 1;
    }
  }
  for (i = 0; i < strLength; ++i) {
    if (types[i] === 'ON') {
      types[i] = e;
    }
  }
  for (i = 0; i < strLength; ++i) {
    t = types[i];
    if (isEven(levels[i])) {
      if (t === 'R') {
        levels[i] += 1;
      } else if (t === 'AN' || t === 'EN') {
        levels[i] += 2;
      }
    } else {
      if (t === 'L' || t === 'AN' || t === 'EN') {
        levels[i] += 1;
      }
    }
  }
  var highestLevel = -1;
  var lowestOddLevel = 99;
  var level;
  for (i = 0, ii = levels.length; i < ii; ++i) {
    level = levels[i];
    if (highestLevel < level) {
      highestLevel = level;
    }
    if (lowestOddLevel > level && isOdd(level)) {
      lowestOddLevel = level;
    }
  }
  for (level = highestLevel; level >= lowestOddLevel; --level) {
    var start = -1;
    for (i = 0, ii = levels.length; i < ii; ++i) {
      if (levels[i] < level) {
        if (start >= 0) {
          reverseValues(chars, start, i);
          start = -1;
        }
      } else if (start < 0) {
        start = i;
      }
    }
    if (start >= 0) {
      reverseValues(chars, start, levels.length);
    }
  }
  for (i = 0, ii = chars.length; i < ii; ++i) {
    var ch = chars[i];
    if (ch === '<' || ch === '>') {
      chars[i] = '';
    }
  }
  return createBidiText(chars.join(''), isLTR);
}
exports.bidi = bidi;

/***/ }),
/* 22 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var ISOAdobeCharset = ['.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', 'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE', 'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu', 'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn', 'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright', 'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex', 'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute', 'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute', 'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute', 'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave', 'yacute', 'ydieresis', 'zcaron'];
var ExpertCharset = ['.notdef', 'space', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', 'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', 'onequarter', 'onehalf', 'threequarters', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];
var ExpertSubsetCharset = ['.notdef', 'space', 'dollaroldstyle', 'dollarsuperior', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', 'parenrightinferior', 'hyphensuperior', 'colonmonetary', 'onefitted', 'rupiah', 'centoldstyle', 'figuredash', 'hypheninferior', 'onequarter', 'onehalf', 'threequarters', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior'];
exports.ISOAdobeCharset = ISOAdobeCharset;
exports.ExpertCharset = ExpertCharset;
exports.ExpertSubsetCharset = ExpertSubsetCharset;

/***/ }),
/* 23 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var corePrimitives = __w_pdfjs_require__(1);
var coreStream = __w_pdfjs_require__(2);
var coreParser = __w_pdfjs_require__(5);
var Util = sharedUtil.Util;
var assert = sharedUtil.assert;
var warn = sharedUtil.warn;
var error = sharedUtil.error;
var isInt = sharedUtil.isInt;
var isString = sharedUtil.isString;
var MissingDataException = sharedUtil.MissingDataException;
var CMapCompressionType = sharedUtil.CMapCompressionType;
var isEOF = corePrimitives.isEOF;
var isName = corePrimitives.isName;
var isCmd = corePrimitives.isCmd;
var isStream = corePrimitives.isStream;
var Stream = coreStream.Stream;
var Lexer = coreParser.Lexer;
var BUILT_IN_CMAPS = ['Adobe-GB1-UCS2', 'Adobe-CNS1-UCS2', 'Adobe-Japan1-UCS2', 'Adobe-Korea1-UCS2', '78-EUC-H', '78-EUC-V', '78-H', '78-RKSJ-H', '78-RKSJ-V', '78-V', '78ms-RKSJ-H', '78ms-RKSJ-V', '83pv-RKSJ-H', '90ms-RKSJ-H', '90ms-RKSJ-V', '90msp-RKSJ-H', '90msp-RKSJ-V', '90pv-RKSJ-H', '90pv-RKSJ-V', 'Add-H', 'Add-RKSJ-H', 'Add-RKSJ-V', 'Add-V', 'Adobe-CNS1-0', 'Adobe-CNS1-1', 'Adobe-CNS1-2', 'Adobe-CNS1-3', 'Adobe-CNS1-4', 'Adobe-CNS1-5', 'Adobe-CNS1-6', 'Adobe-GB1-0', 'Adobe-GB1-1', 'Adobe-GB1-2', 'Adobe-GB1-3', 'Adobe-GB1-4', 'Adobe-GB1-5', 'Adobe-Japan1-0', 'Adobe-Japan1-1', 'Adobe-Japan1-2', 'Adobe-Japan1-3', 'Adobe-Japan1-4', 'Adobe-Japan1-5', 'Adobe-Japan1-6', 'Adobe-Korea1-0', 'Adobe-Korea1-1', 'Adobe-Korea1-2', 'B5-H', 'B5-V', 'B5pc-H', 'B5pc-V', 'CNS-EUC-H', 'CNS-EUC-V', 'CNS1-H', 'CNS1-V', 'CNS2-H', 'CNS2-V', 'ETHK-B5-H', 'ETHK-B5-V', 'ETen-B5-H', 'ETen-B5-V', 'ETenms-B5-H', 'ETenms-B5-V', 'EUC-H', 'EUC-V', 'Ext-H', 'Ext-RKSJ-H', 'Ext-RKSJ-V', 'Ext-V', 'GB-EUC-H', 'GB-EUC-V', 'GB-H', 'GB-V', 'GBK-EUC-H', 'GBK-EUC-V', 'GBK2K-H', 'GBK2K-V', 'GBKp-EUC-H', 'GBKp-EUC-V', 'GBT-EUC-H', 'GBT-EUC-V', 'GBT-H', 'GBT-V', 'GBTpc-EUC-H', 'GBTpc-EUC-V', 'GBpc-EUC-H', 'GBpc-EUC-V', 'H', 'HKdla-B5-H', 'HKdla-B5-V', 'HKdlb-B5-H', 'HKdlb-B5-V', 'HKgccs-B5-H', 'HKgccs-B5-V', 'HKm314-B5-H', 'HKm314-B5-V', 'HKm471-B5-H', 'HKm471-B5-V', 'HKscs-B5-H', 'HKscs-B5-V', 'Hankaku', 'Hiragana', 'KSC-EUC-H', 'KSC-EUC-V', 'KSC-H', 'KSC-Johab-H', 'KSC-Johab-V', 'KSC-V', 'KSCms-UHC-H', 'KSCms-UHC-HW-H', 'KSCms-UHC-HW-V', 'KSCms-UHC-V', 'KSCpc-EUC-H', 'KSCpc-EUC-V', 'Katakana', 'NWP-H', 'NWP-V', 'RKSJ-H', 'RKSJ-V', 'Roman', 'UniCNS-UCS2-H', 'UniCNS-UCS2-V', 'UniCNS-UTF16-H', 'UniCNS-UTF16-V', 'UniCNS-UTF32-H', 'UniCNS-UTF32-V', 'UniCNS-UTF8-H', 'UniCNS-UTF8-V', 'UniGB-UCS2-H', 'UniGB-UCS2-V', 'UniGB-UTF16-H', 'UniGB-UTF16-V', 'UniGB-UTF32-H', 'UniGB-UTF32-V', 'UniGB-UTF8-H', 'UniGB-UTF8-V', 'UniJIS-UCS2-H', 'UniJIS-UCS2-HW-H', 'UniJIS-UCS2-HW-V', 'UniJIS-UCS2-V', 'UniJIS-UTF16-H', 'UniJIS-UTF16-V', 'UniJIS-UTF32-H', 'UniJIS-UTF32-V', 'UniJIS-UTF8-H', 'UniJIS-UTF8-V', 'UniJIS2004-UTF16-H', 'UniJIS2004-UTF16-V', 'UniJIS2004-UTF32-H', 'UniJIS2004-UTF32-V', 'UniJIS2004-UTF8-H', 'UniJIS2004-UTF8-V', 'UniJISPro-UCS2-HW-V', 'UniJISPro-UCS2-V', 'UniJISPro-UTF8-V', 'UniJISX0213-UTF32-H', 'UniJISX0213-UTF32-V', 'UniJISX02132004-UTF32-H', 'UniJISX02132004-UTF32-V', 'UniKS-UCS2-H', 'UniKS-UCS2-V', 'UniKS-UTF16-H', 'UniKS-UTF16-V', 'UniKS-UTF32-H', 'UniKS-UTF32-V', 'UniKS-UTF8-H', 'UniKS-UTF8-V', 'V', 'WP-Symbol'];
var CMap = function CMapClosure() {
  function CMap(builtInCMap) {
    this.codespaceRanges = [[], [], [], []];
    this.numCodespaceRanges = 0;
    this._map = [];
    this.name = '';
    this.vertical = false;
    this.useCMap = null;
    this.builtInCMap = builtInCMap;
  }
  CMap.prototype = {
    addCodespaceRange: function addCodespaceRange(n, low, high) {
      this.codespaceRanges[n - 1].push(low, high);
      this.numCodespaceRanges++;
    },
    mapCidRange: function mapCidRange(low, high, dstLow) {
      while (low <= high) {
        this._map[low++] = dstLow++;
      }
    },
    mapBfRange: function mapBfRange(low, high, dstLow) {
      var lastByte = dstLow.length - 1;
      while (low <= high) {
        this._map[low++] = dstLow;
        dstLow = dstLow.substr(0, lastByte) + String.fromCharCode(dstLow.charCodeAt(lastByte) + 1);
      }
    },
    mapBfRangeToArray: function mapBfRangeToArray(low, high, array) {
      var i = 0,
          ii = array.length;
      while (low <= high && i < ii) {
        this._map[low] = array[i++];
        ++low;
      }
    },
    mapOne: function mapOne(src, dst) {
      this._map[src] = dst;
    },
    lookup: function lookup(code) {
      return this._map[code];
    },
    contains: function contains(code) {
      return this._map[code] !== undefined;
    },
    forEach: function forEach(callback) {
      var map = this._map;
      var length = map.length;
      var i;
      if (length <= 0x10000) {
        for (i = 0; i < length; i++) {
          if (map[i] !== undefined) {
            callback(i, map[i]);
          }
        }
      } else {
        for (i in this._map) {
          callback(i, map[i]);
        }
      }
    },
    charCodeOf: function charCodeOf(value) {
      return this._map.indexOf(value);
    },
    getMap: function getMap() {
      return this._map;
    },
    readCharCode: function readCharCode(str, offset, out) {
      var c = 0;
      var codespaceRanges = this.codespaceRanges;
      var codespaceRangesLen = this.codespaceRanges.length;
      for (var n = 0; n < codespaceRangesLen; n++) {
        c = (c << 8 | str.charCodeAt(offset + n)) >>> 0;
        var codespaceRange = codespaceRanges[n];
        for (var k = 0, kk = codespaceRange.length; k < kk;) {
          var low = codespaceRange[k++];
          var high = codespaceRange[k++];
          if (c >= low && c <= high) {
            out.charcode = c;
            out.length = n + 1;
            return;
          }
        }
      }
      out.charcode = 0;
      out.length = 1;
    },
    get length() {
      return this._map.length;
    },
    get isIdentityCMap() {
      if (!(this.name === 'Identity-H' || this.name === 'Identity-V')) {
        return false;
      }
      if (this._map.length !== 0x10000) {
        return false;
      }
      for (var i = 0; i < 0x10000; i++) {
        if (this._map[i] !== i) {
          return false;
        }
      }
      return true;
    }
  };
  return CMap;
}();
var IdentityCMap = function IdentityCMapClosure() {
  function IdentityCMap(vertical, n) {
    CMap.call(this);
    this.vertical = vertical;
    this.addCodespaceRange(n, 0, 0xffff);
  }
  Util.inherit(IdentityCMap, CMap, {});
  IdentityCMap.prototype = {
    addCodespaceRange: CMap.prototype.addCodespaceRange,
    mapCidRange: function mapCidRange(low, high, dstLow) {
      error('should not call mapCidRange');
    },
    mapBfRange: function mapBfRange(low, high, dstLow) {
      error('should not call mapBfRange');
    },
    mapBfRangeToArray: function mapBfRangeToArray(low, high, array) {
      error('should not call mapBfRangeToArray');
    },
    mapOne: function mapOne(src, dst) {
      error('should not call mapCidOne');
    },
    lookup: function lookup(code) {
      return isInt(code) && code <= 0xffff ? code : undefined;
    },
    contains: function contains(code) {
      return isInt(code) && code <= 0xffff;
    },
    forEach: function forEach(callback) {
      for (var i = 0; i <= 0xffff; i++) {
        callback(i, i);
      }
    },
    charCodeOf: function charCodeOf(value) {
      return isInt(value) && value <= 0xffff ? value : -1;
    },
    getMap: function getMap() {
      var map = new Array(0x10000);
      for (var i = 0; i <= 0xffff; i++) {
        map[i] = i;
      }
      return map;
    },
    readCharCode: CMap.prototype.readCharCode,
    get length() {
      return 0x10000;
    },
    get isIdentityCMap() {
      error('should not access .isIdentityCMap');
    }
  };
  return IdentityCMap;
}();
var BinaryCMapReader = function BinaryCMapReaderClosure() {
  function hexToInt(a, size) {
    var n = 0;
    for (var i = 0; i <= size; i++) {
      n = n << 8 | a[i];
    }
    return n >>> 0;
  }
  function hexToStr(a, size) {
    if (size === 1) {
      return String.fromCharCode(a[0], a[1]);
    }
    if (size === 3) {
      return String.fromCharCode(a[0], a[1], a[2], a[3]);
    }
    return String.fromCharCode.apply(null, a.subarray(0, size + 1));
  }
  function addHex(a, b, size) {
    var c = 0;
    for (var i = size; i >= 0; i--) {
      c += a[i] + b[i];
      a[i] = c & 255;
      c >>= 8;
    }
  }
  function incHex(a, size) {
    var c = 1;
    for (var i = size; i >= 0 && c > 0; i--) {
      c += a[i];
      a[i] = c & 255;
      c >>= 8;
    }
  }
  var MAX_NUM_SIZE = 16;
  var MAX_ENCODED_NUM_SIZE = 19;
  function BinaryCMapStream(data) {
    this.buffer = data;
    this.pos = 0;
    this.end = data.length;
    this.tmpBuf = new Uint8Array(MAX_ENCODED_NUM_SIZE);
  }
  BinaryCMapStream.prototype = {
    readByte: function readByte() {
      if (this.pos >= this.end) {
        return -1;
      }
      return this.buffer[this.pos++];
    },
    readNumber: function readNumber() {
      var n = 0;
      var last;
      do {
        var b = this.readByte();
        if (b < 0) {
          error('unexpected EOF in bcmap');
        }
        last = !(b & 0x80);
        n = n << 7 | b & 0x7F;
      } while (!last);
      return n;
    },
    readSigned: function readSigned() {
      var n = this.readNumber();
      return n & 1 ? ~(n >>> 1) : n >>> 1;
    },
    readHex: function readHex(num, size) {
      num.set(this.buffer.subarray(this.pos, this.pos + size + 1));
      this.pos += size + 1;
    },
    readHexNumber: function readHexNumber(num, size) {
      var last;
      var stack = this.tmpBuf,
          sp = 0;
      do {
        var b = this.readByte();
        if (b < 0) {
          error('unexpected EOF in bcmap');
        }
        last = !(b & 0x80);
        stack[sp++] = b & 0x7F;
      } while (!last);
      var i = size,
          buffer = 0,
          bufferSize = 0;
      while (i >= 0) {
        while (bufferSize < 8 && stack.length > 0) {
          buffer = stack[--sp] << bufferSize | buffer;
          bufferSize += 7;
        }
        num[i] = buffer & 255;
        i--;
        buffer >>= 8;
        bufferSize -= 8;
      }
    },
    readHexSigned: function readHexSigned(num, size) {
      this.readHexNumber(num, size);
      var sign = num[size] & 1 ? 255 : 0;
      var c = 0;
      for (var i = 0; i <= size; i++) {
        c = (c & 1) << 8 | num[i];
        num[i] = c >> 1 ^ sign;
      }
    },
    readString: function readString() {
      var len = this.readNumber();
      var s = '';
      for (var i = 0; i < len; i++) {
        s += String.fromCharCode(this.readNumber());
      }
      return s;
    }
  };
  function processBinaryCMap(data, cMap, extend) {
    return new Promise(function (resolve, reject) {
      var stream = new BinaryCMapStream(data);
      var header = stream.readByte();
      cMap.vertical = !!(header & 1);
      var useCMap = null;
      var start = new Uint8Array(MAX_NUM_SIZE);
      var end = new Uint8Array(MAX_NUM_SIZE);
      var char = new Uint8Array(MAX_NUM_SIZE);
      var charCode = new Uint8Array(MAX_NUM_SIZE);
      var tmp = new Uint8Array(MAX_NUM_SIZE);
      var code;
      var b;
      while ((b = stream.readByte()) >= 0) {
        var type = b >> 5;
        if (type === 7) {
          switch (b & 0x1F) {
            case 0:
              stream.readString();
              break;
            case 1:
              useCMap = stream.readString();
              break;
          }
          continue;
        }
        var sequence = !!(b & 0x10);
        var dataSize = b & 15;
        assert(dataSize + 1 <= MAX_NUM_SIZE);
        var ucs2DataSize = 1;
        var subitemsCount = stream.readNumber();
        var i;
        switch (type) {
          case 0:
            stream.readHex(start, dataSize);
            stream.readHexNumber(end, dataSize);
            addHex(end, start, dataSize);
            cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));
            for (i = 1; i < subitemsCount; i++) {
              incHex(end, dataSize);
              stream.readHexNumber(start, dataSize);
              addHex(start, end, dataSize);
              stream.readHexNumber(end, dataSize);
              addHex(end, start, dataSize);
              cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));
            }
            break;
          case 1:
            stream.readHex(start, dataSize);
            stream.readHexNumber(end, dataSize);
            addHex(end, start, dataSize);
            code = stream.readNumber();
            for (i = 1; i < subitemsCount; i++) {
              incHex(end, dataSize);
              stream.readHexNumber(start, dataSize);
              addHex(start, end, dataSize);
              stream.readHexNumber(end, dataSize);
              addHex(end, start, dataSize);
              code = stream.readNumber();
            }
            break;
          case 2:
            stream.readHex(char, dataSize);
            code = stream.readNumber();
            cMap.mapOne(hexToInt(char, dataSize), code);
            for (i = 1; i < subitemsCount; i++) {
              incHex(char, dataSize);
              if (!sequence) {
                stream.readHexNumber(tmp, dataSize);
                addHex(char, tmp, dataSize);
              }
              code = stream.readSigned() + (code + 1);
              cMap.mapOne(hexToInt(char, dataSize), code);
            }
            break;
          case 3:
            stream.readHex(start, dataSize);
            stream.readHexNumber(end, dataSize);
            addHex(end, start, dataSize);
            code = stream.readNumber();
            cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);
            for (i = 1; i < subitemsCount; i++) {
              incHex(end, dataSize);
              if (!sequence) {
                stream.readHexNumber(start, dataSize);
                addHex(start, end, dataSize);
              } else {
                start.set(end);
              }
              stream.readHexNumber(end, dataSize);
              addHex(end, start, dataSize);
              code = stream.readNumber();
              cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);
            }
            break;
          case 4:
            stream.readHex(char, ucs2DataSize);
            stream.readHex(charCode, dataSize);
            cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
            for (i = 1; i < subitemsCount; i++) {
              incHex(char, ucs2DataSize);
              if (!sequence) {
                stream.readHexNumber(tmp, ucs2DataSize);
                addHex(char, tmp, ucs2DataSize);
              }
              incHex(charCode, dataSize);
              stream.readHexSigned(tmp, dataSize);
              addHex(charCode, tmp, dataSize);
              cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
            }
            break;
          case 5:
            stream.readHex(start, ucs2DataSize);
            stream.readHexNumber(end, ucs2DataSize);
            addHex(end, start, ucs2DataSize);
            stream.readHex(charCode, dataSize);
            cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));
            for (i = 1; i < subitemsCount; i++) {
              incHex(end, ucs2DataSize);
              if (!sequence) {
                stream.readHexNumber(start, ucs2DataSize);
                addHex(start, end, ucs2DataSize);
              } else {
                start.set(end);
              }
              stream.readHexNumber(end, ucs2DataSize);
              addHex(end, start, ucs2DataSize);
              stream.readHex(charCode, dataSize);
              cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));
            }
            break;
          default:
            reject(new Error('processBinaryCMap: Unknown type: ' + type));
            return;
        }
      }
      if (useCMap) {
        resolve(extend(useCMap));
        return;
      }
      resolve(cMap);
    });
  }
  function BinaryCMapReader() {}
  BinaryCMapReader.prototype = { process: processBinaryCMap };
  return BinaryCMapReader;
}();
var CMapFactory = function CMapFactoryClosure() {
  function strToInt(str) {
    var a = 0;
    for (var i = 0; i < str.length; i++) {
      a = a << 8 | str.charCodeAt(i);
    }
    return a >>> 0;
  }
  function expectString(obj) {
    if (!isString(obj)) {
      error('Malformed CMap: expected string.');
    }
  }
  function expectInt(obj) {
    if (!isInt(obj)) {
      error('Malformed CMap: expected int.');
    }
  }
  function parseBfChar(cMap, lexer) {
    while (true) {
      var obj = lexer.getObj();
      if (isEOF(obj)) {
        break;
      }
      if (isCmd(obj, 'endbfchar')) {
        return;
      }
      expectString(obj);
      var src = strToInt(obj);
      obj = lexer.getObj();
      expectString(obj);
      var dst = obj;
      cMap.mapOne(src, dst);
    }
  }
  function parseBfRange(cMap, lexer) {
    while (true) {
      var obj = lexer.getObj();
      if (isEOF(obj)) {
        break;
      }
      if (isCmd(obj, 'endbfrange')) {
        return;
      }
      expectString(obj);
      var low = strToInt(obj);
      obj = lexer.getObj();
      expectString(obj);
      var high = strToInt(obj);
      obj = lexer.getObj();
      if (isInt(obj) || isString(obj)) {
        var dstLow = isInt(obj) ? String.fromCharCode(obj) : obj;
        cMap.mapBfRange(low, high, dstLow);
      } else if (isCmd(obj, '[')) {
        obj = lexer.getObj();
        var array = [];
        while (!isCmd(obj, ']') && !isEOF(obj)) {
          array.push(obj);
          obj = lexer.getObj();
        }
        cMap.mapBfRangeToArray(low, high, array);
      } else {
        break;
      }
    }
    error('Invalid bf range.');
  }
  function parseCidChar(cMap, lexer) {
    while (true) {
      var obj = lexer.getObj();
      if (isEOF(obj)) {
        break;
      }
      if (isCmd(obj, 'endcidchar')) {
        return;
      }
      expectString(obj);
      var src = strToInt(obj);
      obj = lexer.getObj();
      expectInt(obj);
      var dst = obj;
      cMap.mapOne(src, dst);
    }
  }
  function parseCidRange(cMap, lexer) {
    while (true) {
      var obj = lexer.getObj();
      if (isEOF(obj)) {
        break;
      }
      if (isCmd(obj, 'endcidrange')) {
        return;
      }
      expectString(obj);
      var low = strToInt(obj);
      obj = lexer.getObj();
      expectString(obj);
      var high = strToInt(obj);
      obj = lexer.getObj();
      expectInt(obj);
      var dstLow = obj;
      cMap.mapCidRange(low, high, dstLow);
    }
  }
  function parseCodespaceRange(cMap, lexer) {
    while (true) {
      var obj = lexer.getObj();
      if (isEOF(obj)) {
        break;
      }
      if (isCmd(obj, 'endcodespacerange')) {
        return;
      }
      if (!isString(obj)) {
        break;
      }
      var low = strToInt(obj);
      obj = lexer.getObj();
      if (!isString(obj)) {
        break;
      }
      var high = strToInt(obj);
      cMap.addCodespaceRange(obj.length, low, high);
    }
    error('Invalid codespace range.');
  }
  function parseWMode(cMap, lexer) {
    var obj = lexer.getObj();
    if (isInt(obj)) {
      cMap.vertical = !!obj;
    }
  }
  function parseCMapName(cMap, lexer) {
    var obj = lexer.getObj();
    if (isName(obj) && isString(obj.name)) {
      cMap.name = obj.name;
    }
  }
  function parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap) {
    var previous;
    var embededUseCMap;
    objLoop: while (true) {
      try {
        var obj = lexer.getObj();
        if (isEOF(obj)) {
          break;
        } else if (isName(obj)) {
          if (obj.name === 'WMode') {
            parseWMode(cMap, lexer);
          } else if (obj.name === 'CMapName') {
            parseCMapName(cMap, lexer);
          }
          previous = obj;
        } else if (isCmd(obj)) {
          switch (obj.cmd) {
            case 'endcmap':
              break objLoop;
            case 'usecmap':
              if (isName(previous)) {
                embededUseCMap = previous.name;
              }
              break;
            case 'begincodespacerange':
              parseCodespaceRange(cMap, lexer);
              break;
            case 'beginbfchar':
              parseBfChar(cMap, lexer);
              break;
            case 'begincidchar':
              parseCidChar(cMap, lexer);
              break;
            case 'beginbfrange':
              parseBfRange(cMap, lexer);
              break;
            case 'begincidrange':
              parseCidRange(cMap, lexer);
              break;
          }
        }
      } catch (ex) {
        if (ex instanceof MissingDataException) {
          throw ex;
        }
        warn('Invalid cMap data: ' + ex);
        continue;
      }
    }
    if (!useCMap && embededUseCMap) {
      useCMap = embededUseCMap;
    }
    if (useCMap) {
      return extendCMap(cMap, fetchBuiltInCMap, useCMap);
    }
    return Promise.resolve(cMap);
  }
  function extendCMap(cMap, fetchBuiltInCMap, useCMap) {
    return createBuiltInCMap(useCMap, fetchBuiltInCMap).then(function (newCMap) {
      cMap.useCMap = newCMap;
      if (cMap.numCodespaceRanges === 0) {
        var useCodespaceRanges = cMap.useCMap.codespaceRanges;
        for (var i = 0; i < useCodespaceRanges.length; i++) {
          cMap.codespaceRanges[i] = useCodespaceRanges[i].slice();
        }
        cMap.numCodespaceRanges = cMap.useCMap.numCodespaceRanges;
      }
      cMap.useCMap.forEach(function (key, value) {
        if (!cMap.contains(key)) {
          cMap.mapOne(key, cMap.useCMap.lookup(key));
        }
      });
      return cMap;
    });
  }
  function createBuiltInCMap(name, fetchBuiltInCMap) {
    if (name === 'Identity-H') {
      return Promise.resolve(new IdentityCMap(false, 2));
    } else if (name === 'Identity-V') {
      return Promise.resolve(new IdentityCMap(true, 2));
    }
    if (BUILT_IN_CMAPS.indexOf(name) === -1) {
      return Promise.reject(new Error('Unknown CMap name: ' + name));
    }
    assert(fetchBuiltInCMap, 'Built-in CMap parameters are not provided.');
    return fetchBuiltInCMap(name).then(function (data) {
      var cMapData = data.cMapData,
          compressionType = data.compressionType;
      var cMap = new CMap(true);
      if (compressionType === CMapCompressionType.BINARY) {
        return new BinaryCMapReader().process(cMapData, cMap, function (useCMap) {
          return extendCMap(cMap, fetchBuiltInCMap, useCMap);
        });
      }
      assert(compressionType === CMapCompressionType.NONE, 'TODO: Only BINARY/NONE CMap compression is currently supported.');
      var lexer = new Lexer(new Stream(cMapData));
      return parseCMap(cMap, lexer, fetchBuiltInCMap, null);
    });
  }
  return {
    create: function create(params) {
      var encoding = params.encoding;
      var fetchBuiltInCMap = params.fetchBuiltInCMap;
      var useCMap = params.useCMap;
      if (isName(encoding)) {
        return createBuiltInCMap(encoding.name, fetchBuiltInCMap);
      } else if (isStream(encoding)) {
        var cMap = new CMap();
        var lexer = new Lexer(encoding);
        return parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap).then(function (parsedCMap) {
          if (parsedCMap.isIdentityCMap) {
            return createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap);
          }
          return parsedCMap;
        });
      }
      return Promise.reject(new Error('Encoding required.'));
    }
  };
}();
exports.CMap = CMap;
exports.CMapFactory = CMapFactory;
exports.IdentityCMap = IdentityCMap;

/***/ }),
/* 24 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var corePrimitives = __w_pdfjs_require__(1);
var coreStream = __w_pdfjs_require__(2);
var coreObj = __w_pdfjs_require__(16);
var coreParser = __w_pdfjs_require__(5);
var coreCrypto = __w_pdfjs_require__(13);
var coreEvaluator = __w_pdfjs_require__(14);
var coreAnnotation = __w_pdfjs_require__(20);
var OPS = sharedUtil.OPS;
var MissingDataException = sharedUtil.MissingDataException;
var Util = sharedUtil.Util;
var assert = sharedUtil.assert;
var error = sharedUtil.error;
var info = sharedUtil.info;
var isArray = sharedUtil.isArray;
var isArrayBuffer = sharedUtil.isArrayBuffer;
var isNum = sharedUtil.isNum;
var isString = sharedUtil.isString;
var shadow = sharedUtil.shadow;
var stringToBytes = sharedUtil.stringToBytes;
var stringToPDFString = sharedUtil.stringToPDFString;
var warn = sharedUtil.warn;
var isSpace = sharedUtil.isSpace;
var Dict = corePrimitives.Dict;
var isDict = corePrimitives.isDict;
var isName = corePrimitives.isName;
var isStream = corePrimitives.isStream;
var NullStream = coreStream.NullStream;
var Stream = coreStream.Stream;
var StreamsSequenceStream = coreStream.StreamsSequenceStream;
var Catalog = coreObj.Catalog;
var ObjectLoader = coreObj.ObjectLoader;
var XRef = coreObj.XRef;
var Linearization = coreParser.Linearization;
var calculateMD5 = coreCrypto.calculateMD5;
var OperatorList = coreEvaluator.OperatorList;
var PartialEvaluator = coreEvaluator.PartialEvaluator;
var AnnotationFactory = coreAnnotation.AnnotationFactory;
var Page = function PageClosure() {
  var DEFAULT_USER_UNIT = 1.0;
  var LETTER_SIZE_MEDIABOX = [0, 0, 612, 792];
  function isAnnotationRenderable(annotation, intent) {
    return intent === 'display' && annotation.viewable || intent === 'print' && annotation.printable;
  }
  function Page(pdfManager, xref, pageIndex, pageDict, ref, fontCache, builtInCMapCache) {
    this.pdfManager = pdfManager;
    this.pageIndex = pageIndex;
    this.pageDict = pageDict;
    this.xref = xref;
    this.ref = ref;
    this.fontCache = fontCache;
    this.builtInCMapCache = builtInCMapCache;
    this.evaluatorOptions = pdfManager.evaluatorOptions;
    this.resourcesPromise = null;
    var uniquePrefix = 'p' + this.pageIndex + '_';
    var idCounters = { obj: 0 };
    this.idFactory = {
      createObjId: function createObjId() {
        return uniquePrefix + ++idCounters.obj;
      }
    };
  }
  Page.prototype = {
    getPageProp: function Page_getPageProp(key) {
      return this.pageDict.get(key);
    },
    getInheritedPageProp: function Page_getInheritedPageProp(key, getArray) {
      var dict = this.pageDict,
          valueArray = null,
          loopCount = 0;
      var MAX_LOOP_COUNT = 100;
      getArray = getArray || false;
      while (dict) {
        var value = getArray ? dict.getArray(key) : dict.get(key);
        if (value !== undefined) {
          if (!valueArray) {
            valueArray = [];
          }
          valueArray.push(value);
        }
        if (++loopCount > MAX_LOOP_COUNT) {
          warn('getInheritedPageProp: maximum loop count exceeded for ' + key);
          return valueArray ? valueArray[0] : undefined;
        }
        dict = dict.get('Parent');
      }
      if (!valueArray) {
        return undefined;
      }
      if (valueArray.length === 1 || !isDict(valueArray[0])) {
        return valueArray[0];
      }
      return Dict.merge(this.xref, valueArray);
    },
    get content() {
      return this.getPageProp('Contents');
    },
    get resources() {
      return shadow(this, 'resources', this.getInheritedPageProp('Resources') || Dict.empty);
    },
    get mediaBox() {
      var mediaBox = this.getInheritedPageProp('MediaBox', true);
      if (!isArray(mediaBox) || mediaBox.length !== 4) {
        return shadow(this, 'mediaBox', LETTER_SIZE_MEDIABOX);
      }
      return shadow(this, 'mediaBox', mediaBox);
    },
    get cropBox() {
      var cropBox = this.getInheritedPageProp('CropBox', true);
      if (!isArray(cropBox) || cropBox.length !== 4) {
        return shadow(this, 'cropBox', this.mediaBox);
      }
      return shadow(this, 'cropBox', cropBox);
    },
    get userUnit() {
      var obj = this.getPageProp('UserUnit');
      if (!isNum(obj) || obj <= 0) {
        obj = DEFAULT_USER_UNIT;
      }
      return shadow(this, 'userUnit', obj);
    },
    get view() {
      var mediaBox = this.mediaBox,
          cropBox = this.cropBox;
      if (mediaBox === cropBox) {
        return shadow(this, 'view', mediaBox);
      }
      var intersection = Util.intersect(cropBox, mediaBox);
      return shadow(this, 'view', intersection || mediaBox);
    },
    get rotate() {
      var rotate = this.getInheritedPageProp('Rotate') || 0;
      if (rotate % 90 !== 0) {
        rotate = 0;
      } else if (rotate >= 360) {
        rotate = rotate % 360;
      } else if (rotate < 0) {
        rotate = (rotate % 360 + 360) % 360;
      }
      return shadow(this, 'rotate', rotate);
    },
    getContentStream: function Page_getContentStream() {
      var content = this.content;
      var stream;
      if (isArray(content)) {
        var xref = this.xref;
        var i,
            n = content.length;
        var streams = [];
        for (i = 0; i < n; ++i) {
          streams.push(xref.fetchIfRef(content[i]));
        }
        stream = new StreamsSequenceStream(streams);
      } else if (isStream(content)) {
        stream = content;
      } else {
        stream = new NullStream();
      }
      return stream;
    },
    loadResources: function Page_loadResources(keys) {
      if (!this.resourcesPromise) {
        this.resourcesPromise = this.pdfManager.ensure(this, 'resources');
      }
      return this.resourcesPromise.then(function resourceSuccess() {
        var objectLoader = new ObjectLoader(this.resources.map, keys, this.xref);
        return objectLoader.load();
      }.bind(this));
    },
    getOperatorList: function Page_getOperatorList(handler, task, intent, renderInteractiveForms) {
      var self = this;
      var pdfManager = this.pdfManager;
      var contentStreamPromise = pdfManager.ensure(this, 'getContentStream', []);
      var resourcesPromise = this.loadResources(['ExtGState', 'ColorSpace', 'Pattern', 'Shading', 'XObject', 'Font']);
      var partialEvaluator = new PartialEvaluator(pdfManager, this.xref, handler, this.pageIndex, this.idFactory, this.fontCache, this.builtInCMapCache, this.evaluatorOptions);
      var dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
      var pageListPromise = dataPromises.then(function (data) {
        var contentStream = data[0];
        var opList = new OperatorList(intent, handler, self.pageIndex);
        handler.send('StartRenderPage', {
          transparency: partialEvaluator.hasBlendModes(self.resources),
          pageIndex: self.pageIndex,
          intent: intent
        });
        return partialEvaluator.getOperatorList(contentStream, task, self.resources, opList).then(function () {
          return opList;
        });
      });
      var annotationsPromise = pdfManager.ensure(this, 'annotations');
      return Promise.all([pageListPromise, annotationsPromise]).then(function (datas) {
        var pageOpList = datas[0];
        var annotations = datas[1];
        if (annotations.length === 0) {
          pageOpList.flush(true);
          return pageOpList;
        }
        var i,
            ii,
            opListPromises = [];
        for (i = 0, ii = annotations.length; i < ii; i++) {
          if (isAnnotationRenderable(annotations[i], intent)) {
            opListPromises.push(annotations[i].getOperatorList(partialEvaluator, task, renderInteractiveForms));
          }
        }
        return Promise.all(opListPromises).then(function (opLists) {
          pageOpList.addOp(OPS.beginAnnotations, []);
          for (i = 0, ii = opLists.length; i < ii; i++) {
            pageOpList.addOpList(opLists[i]);
          }
          pageOpList.addOp(OPS.endAnnotations, []);
          pageOpList.flush(true);
          return pageOpList;
        });
      });
    },
    extractTextContent: function Page_extractTextContent(handler, task, normalizeWhitespace, combineTextItems) {
      var self = this;
      var pdfManager = this.pdfManager;
      var contentStreamPromise = pdfManager.ensure(this, 'getContentStream', []);
      var resourcesPromise = this.loadResources(['ExtGState', 'XObject', 'Font']);
      var dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
      return dataPromises.then(function (data) {
        var contentStream = data[0];
        var partialEvaluator = new PartialEvaluator(pdfManager, self.xref, handler, self.pageIndex, self.idFactory, self.fontCache, self.builtInCMapCache, self.evaluatorOptions);
        return partialEvaluator.getTextContent(contentStream, task, self.resources, null, normalizeWhitespace, combineTextItems);
      });
    },
    getAnnotationsData: function Page_getAnnotationsData(intent) {
      var annotations = this.annotations;
      var annotationsData = [];
      for (var i = 0, n = annotations.length; i < n; ++i) {
        if (!intent || isAnnotationRenderable(annotations[i], intent)) {
          annotationsData.push(annotations[i].data);
        }
      }
      return annotationsData;
    },
    get annotations() {
      var annotations = [];
      var annotationRefs = this.getInheritedPageProp('Annots') || [];
      var annotationFactory = new AnnotationFactory();
      for (var i = 0, n = annotationRefs.length; i < n; ++i) {
        var annotationRef = annotationRefs[i];
        var annotation = annotationFactory.create(this.xref, annotationRef, this.pdfManager, this.idFactory);
        if (annotation) {
          annotations.push(annotation);
        }
      }
      return shadow(this, 'annotations', annotations);
    }
  };
  return Page;
}();
var PDFDocument = function PDFDocumentClosure() {
  var FINGERPRINT_FIRST_BYTES = 1024;
  var EMPTY_FINGERPRINT = '\x00\x00\x00\x00\x00\x00\x00' + '\x00\x00\x00\x00\x00\x00\x00\x00\x00';
  function PDFDocument(pdfManager, arg) {
    var stream;
    if (isStream(arg)) {
      stream = arg;
    } else if (isArrayBuffer(arg)) {
      stream = new Stream(arg);
    } else {
      error('PDFDocument: Unknown argument type');
    }
    assert(stream.length > 0, 'stream must have data');
    this.pdfManager = pdfManager;
    this.stream = stream;
    this.xref = new XRef(stream, pdfManager);
  }
  function find(stream, needle, limit, backwards) {
    var pos = stream.pos;
    var end = stream.end;
    var strBuf = [];
    if (pos + limit > end) {
      limit = end - pos;
    }
    for (var n = 0; n < limit; ++n) {
      strBuf.push(String.fromCharCode(stream.getByte()));
    }
    var str = strBuf.join('');
    stream.pos = pos;
    var index = backwards ? str.lastIndexOf(needle) : str.indexOf(needle);
    if (index === -1) {
      return false;
    }
    stream.pos += index;
    return true;
  }
  var DocumentInfoValidators = {
    get entries() {
      return shadow(this, 'entries', {
        Title: isString,
        Author: isString,
        Subject: isString,
        Keywords: isString,
        Creator: isString,
        Producer: isString,
        CreationDate: isString,
        ModDate: isString,
        Trapped: isName
      });
    }
  };
  PDFDocument.prototype = {
    parse: function PDFDocument_parse(recoveryMode) {
      this.setup(recoveryMode);
      var version = this.catalog.catDict.get('Version');
      if (isName(version)) {
        this.pdfFormatVersion = version.name;
      }
      try {
        this.acroForm = this.catalog.catDict.get('AcroForm');
        if (this.acroForm) {
          this.xfa = this.acroForm.get('XFA');
          var fields = this.acroForm.get('Fields');
          if ((!fields || !isArray(fields) || fields.length === 0) && !this.xfa) {
            this.acroForm = null;
          }
        }
      } catch (ex) {
        if (ex instanceof MissingDataException) {
          throw ex;
        }
        info('Something wrong with AcroForm entry');
        this.acroForm = null;
      }
    },
    get linearization() {
      var linearization = null;
      if (this.stream.length) {
        try {
          linearization = Linearization.create(this.stream);
        } catch (err) {
          if (err instanceof MissingDataException) {
            throw err;
          }
          info(err);
        }
      }
      return shadow(this, 'linearization', linearization);
    },
    get startXRef() {
      var stream = this.stream;
      var startXRef = 0;
      var linearization = this.linearization;
      if (linearization) {
        stream.reset();
        if (find(stream, 'endobj', 1024)) {
          startXRef = stream.pos + 6;
        }
      } else {
        var step = 1024;
        var found = false,
            pos = stream.end;
        while (!found && pos > 0) {
          pos -= step - 'startxref'.length;
          if (pos < 0) {
            pos = 0;
          }
          stream.pos = pos;
          found = find(stream, 'startxref', step, true);
        }
        if (found) {
          stream.skip(9);
          var ch;
          do {
            ch = stream.getByte();
          } while (isSpace(ch));
          var str = '';
          while (ch >= 0x20 && ch <= 0x39) {
            str += String.fromCharCode(ch);
            ch = stream.getByte();
          }
          startXRef = parseInt(str, 10);
          if (isNaN(startXRef)) {
            startXRef = 0;
          }
        }
      }
      return shadow(this, 'startXRef', startXRef);
    },
    get mainXRefEntriesOffset() {
      var mainXRefEntriesOffset = 0;
      var linearization = this.linearization;
      if (linearization) {
        mainXRefEntriesOffset = linearization.mainXRefEntriesOffset;
      }
      return shadow(this, 'mainXRefEntriesOffset', mainXRefEntriesOffset);
    },
    checkHeader: function PDFDocument_checkHeader() {
      var stream = this.stream;
      stream.reset();
      if (find(stream, '%PDF-', 1024)) {
        stream.moveStart();
        var MAX_VERSION_LENGTH = 12;
        var version = '',
            ch;
        while ((ch = stream.getByte()) > 0x20) {
          if (version.length >= MAX_VERSION_LENGTH) {
            break;
          }
          version += String.fromCharCode(ch);
        }
        if (!this.pdfFormatVersion) {
          this.pdfFormatVersion = version.substring(5);
        }
        return;
      }
    },
    parseStartXRef: function PDFDocument_parseStartXRef() {
      var startXRef = this.startXRef;
      this.xref.setStartXRef(startXRef);
    },
    setup: function PDFDocument_setup(recoveryMode) {
      this.xref.parse(recoveryMode);
      var self = this;
      var pageFactory = {
        createPage: function createPage(pageIndex, dict, ref, fontCache, builtInCMapCache) {
          return new Page(self.pdfManager, self.xref, pageIndex, dict, ref, fontCache, builtInCMapCache);
        }
      };
      this.catalog = new Catalog(this.pdfManager, this.xref, pageFactory);
    },
    get numPages() {
      var linearization = this.linearization;
      var num = linearization ? linearization.numPages : this.catalog.numPages;
      return shadow(this, 'numPages', num);
    },
    get documentInfo() {
      var docInfo = {
        PDFFormatVersion: this.pdfFormatVersion,
        IsAcroFormPresent: !!this.acroForm,
        IsXFAPresent: !!this.xfa
      };
      var infoDict;
      try {
        infoDict = this.xref.trailer.get('Info');
      } catch (err) {
        if (err instanceof MissingDataException) {
          throw err;
        }
        info('The document information dictionary is invalid.');
      }
      if (infoDict) {
        var validEntries = DocumentInfoValidators.entries;
        for (var key in validEntries) {
          if (infoDict.has(key)) {
            var value = infoDict.get(key);
            if (validEntries[key](value)) {
              docInfo[key] = typeof value !== 'string' ? value : stringToPDFString(value);
            } else {
              info('Bad value in document info for "' + key + '"');
            }
          }
        }
      }
      return shadow(this, 'documentInfo', docInfo);
    },
    get fingerprint() {
      var xref = this.xref,
          hash,
          fileID = '';
      var idArray = xref.trailer.get('ID');
      if (idArray && isArray(idArray) && idArray[0] && isString(idArray[0]) && idArray[0] !== EMPTY_FINGERPRINT) {
        hash = stringToBytes(idArray[0]);
      } else {
        if (this.stream.ensureRange) {
          this.stream.ensureRange(0, Math.min(FINGERPRINT_FIRST_BYTES, this.stream.end));
        }
        hash = calculateMD5(this.stream.bytes.subarray(0, FINGERPRINT_FIRST_BYTES), 0, FINGERPRINT_FIRST_BYTES);
      }
      for (var i = 0, n = hash.length; i < n; i++) {
        var hex = hash[i].toString(16);
        fileID += hex.length === 1 ? '0' + hex : hex;
      }
      return shadow(this, 'fingerprint', fileID);
    },
    getPage: function PDFDocument_getPage(pageIndex) {
      return this.catalog.getPage(pageIndex);
    },
    cleanup: function PDFDocument_cleanup() {
      return this.catalog.cleanup();
    }
  };
  return PDFDocument;
}();
exports.Page = Page;
exports.PDFDocument = PDFDocument;

/***/ }),
/* 25 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var coreStream = __w_pdfjs_require__(2);
var coreGlyphList = __w_pdfjs_require__(7);
var coreEncodings = __w_pdfjs_require__(4);
var coreCFFParser = __w_pdfjs_require__(11);
var Util = sharedUtil.Util;
var bytesToString = sharedUtil.bytesToString;
var error = sharedUtil.error;
var Stream = coreStream.Stream;
var getGlyphsUnicode = coreGlyphList.getGlyphsUnicode;
var StandardEncoding = coreEncodings.StandardEncoding;
var CFFParser = coreCFFParser.CFFParser;
var FontRendererFactory = function FontRendererFactoryClosure() {
  function getLong(data, offset) {
    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
  }
  function getUshort(data, offset) {
    return data[offset] << 8 | data[offset + 1];
  }
  function parseCmap(data, start, end) {
    var offset = getUshort(data, start + 2) === 1 ? getLong(data, start + 8) : getLong(data, start + 16);
    var format = getUshort(data, start + offset);
    var ranges, p, i;
    if (format === 4) {
      getUshort(data, start + offset + 2);
      var segCount = getUshort(data, start + offset + 6) >> 1;
      p = start + offset + 14;
      ranges = [];
      for (i = 0; i < segCount; i++, p += 2) {
        ranges[i] = { end: getUshort(data, p) };
      }
      p += 2;
      for (i = 0; i < segCount; i++, p += 2) {
        ranges[i].start = getUshort(data, p);
      }
      for (i = 0; i < segCount; i++, p += 2) {
        ranges[i].idDelta = getUshort(data, p);
      }
      for (i = 0; i < segCount; i++, p += 2) {
        var idOffset = getUshort(data, p);
        if (idOffset === 0) {
          continue;
        }
        ranges[i].ids = [];
        for (var j = 0, jj = ranges[i].end - ranges[i].start + 1; j < jj; j++) {
          ranges[i].ids[j] = getUshort(data, p + idOffset);
          idOffset += 2;
        }
      }
      return ranges;
    } else if (format === 12) {
      getLong(data, start + offset + 4);
      var groups = getLong(data, start + offset + 12);
      p = start + offset + 16;
      ranges = [];
      for (i = 0; i < groups; i++) {
        ranges.push({
          start: getLong(data, p),
          end: getLong(data, p + 4),
          idDelta: getLong(data, p + 8) - getLong(data, p)
        });
        p += 12;
      }
      return ranges;
    }
    error('not supported cmap: ' + format);
  }
  function parseCff(data, start, end, seacAnalysisEnabled) {
    var properties = {};
    var parser = new CFFParser(new Stream(data, start, end - start), properties, seacAnalysisEnabled);
    var cff = parser.parse();
    return {
      glyphs: cff.charStrings.objects,
      subrs: cff.topDict.privateDict && cff.topDict.privateDict.subrsIndex && cff.topDict.privateDict.subrsIndex.objects,
      gsubrs: cff.globalSubrIndex && cff.globalSubrIndex.objects
    };
  }
  function parseGlyfTable(glyf, loca, isGlyphLocationsLong) {
    var itemSize, itemDecode;
    if (isGlyphLocationsLong) {
      itemSize = 4;
      itemDecode = function fontItemDecodeLong(data, offset) {
        return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
      };
    } else {
      itemSize = 2;
      itemDecode = function fontItemDecode(data, offset) {
        return data[offset] << 9 | data[offset + 1] << 1;
      };
    }
    var glyphs = [];
    var startOffset = itemDecode(loca, 0);
    for (var j = itemSize; j < loca.length; j += itemSize) {
      var endOffset = itemDecode(loca, j);
      glyphs.push(glyf.subarray(startOffset, endOffset));
      startOffset = endOffset;
    }
    return glyphs;
  }
  function lookupCmap(ranges, unicode) {
    var code = unicode.charCodeAt(0),
        gid = 0;
    var l = 0,
        r = ranges.length - 1;
    while (l < r) {
      var c = l + r + 1 >> 1;
      if (code < ranges[c].start) {
        r = c - 1;
      } else {
        l = c;
      }
    }
    if (ranges[l].start <= code && code <= ranges[l].end) {
      gid = ranges[l].idDelta + (ranges[l].ids ? ranges[l].ids[code - ranges[l].start] : code) & 0xFFFF;
    }
    return {
      charCode: code,
      glyphId: gid
    };
  }
  function compileGlyf(code, cmds, font) {
    function moveTo(x, y) {
      cmds.push({
        cmd: 'moveTo',
        args: [x, y]
      });
    }
    function lineTo(x, y) {
      cmds.push({
        cmd: 'lineTo',
        args: [x, y]
      });
    }
    function quadraticCurveTo(xa, ya, x, y) {
      cmds.push({
        cmd: 'quadraticCurveTo',
        args: [xa, ya, x, y]
      });
    }
    var i = 0;
    var numberOfContours = (code[i] << 24 | code[i + 1] << 16) >> 16;
    var flags;
    var x = 0,
        y = 0;
    i += 10;
    if (numberOfContours < 0) {
      do {
        flags = code[i] << 8 | code[i + 1];
        var glyphIndex = code[i + 2] << 8 | code[i + 3];
        i += 4;
        var arg1, arg2;
        if (flags & 0x01) {
          arg1 = (code[i] << 24 | code[i + 1] << 16) >> 16;
          arg2 = (code[i + 2] << 24 | code[i + 3] << 16) >> 16;
          i += 4;
        } else {
          arg1 = code[i++];
          arg2 = code[i++];
        }
        if (flags & 0x02) {
          x = arg1;
          y = arg2;
        } else {
          x = 0;
          y = 0;
        }
        var scaleX = 1,
            scaleY = 1,
            scale01 = 0,
            scale10 = 0;
        if (flags & 0x08) {
          scaleX = scaleY = (code[i] << 24 | code[i + 1] << 16) / 1073741824;
          i += 2;
        } else if (flags & 0x40) {
          scaleX = (code[i] << 24 | code[i + 1] << 16) / 1073741824;
          scaleY = (code[i + 2] << 24 | code[i + 3] << 16) / 1073741824;
          i += 4;
        } else if (flags & 0x80) {
          scaleX = (code[i] << 24 | code[i + 1] << 16) / 1073741824;
          scale01 = (code[i + 2] << 24 | code[i + 3] << 16) / 1073741824;
          scale10 = (code[i + 4] << 24 | code[i + 5] << 16) / 1073741824;
          scaleY = (code[i + 6] << 24 | code[i + 7] << 16) / 1073741824;
          i += 8;
        }
        var subglyph = font.glyphs[glyphIndex];
        if (subglyph) {
          cmds.push({ cmd: 'save' });
          cmds.push({
            cmd: 'transform',
            args: [scaleX, scale01, scale10, scaleY, x, y]
          });
          compileGlyf(subglyph, cmds, font);
          cmds.push({ cmd: 'restore' });
        }
      } while (flags & 0x20);
    } else {
      var endPtsOfContours = [];
      var j, jj;
      for (j = 0; j < numberOfContours; j++) {
        endPtsOfContours.push(code[i] << 8 | code[i + 1]);
        i += 2;
      }
      var instructionLength = code[i] << 8 | code[i + 1];
      i += 2 + instructionLength;
      var numberOfPoints = endPtsOfContours[endPtsOfContours.length - 1] + 1;
      var points = [];
      while (points.length < numberOfPoints) {
        flags = code[i++];
        var repeat = 1;
        if (flags & 0x08) {
          repeat += code[i++];
        }
        while (repeat-- > 0) {
          points.push({ flags: flags });
        }
      }
      for (j = 0; j < numberOfPoints; j++) {
        switch (points[j].flags & 0x12) {
          case 0x00:
            x += (code[i] << 24 | code[i + 1] << 16) >> 16;
            i += 2;
            break;
          case 0x02:
            x -= code[i++];
            break;
          case 0x12:
            x += code[i++];
            break;
        }
        points[j].x = x;
      }
      for (j = 0; j < numberOfPoints; j++) {
        switch (points[j].flags & 0x24) {
          case 0x00:
            y += (code[i] << 24 | code[i + 1] << 16) >> 16;
            i += 2;
            break;
          case 0x04:
            y -= code[i++];
            break;
          case 0x24:
            y += code[i++];
            break;
        }
        points[j].y = y;
      }
      var startPoint = 0;
      for (i = 0; i < numberOfContours; i++) {
        var endPoint = endPtsOfContours[i];
        var contour = points.slice(startPoint, endPoint + 1);
        if (contour[0].flags & 1) {
          contour.push(contour[0]);
        } else if (contour[contour.length - 1].flags & 1) {
          contour.unshift(contour[contour.length - 1]);
        } else {
          var p = {
            flags: 1,
            x: (contour[0].x + contour[contour.length - 1].x) / 2,
            y: (contour[0].y + contour[contour.length - 1].y) / 2
          };
          contour.unshift(p);
          contour.push(p);
        }
        moveTo(contour[0].x, contour[0].y);
        for (j = 1, jj = contour.length; j < jj; j++) {
          if (contour[j].flags & 1) {
            lineTo(contour[j].x, contour[j].y);
          } else if (contour[j + 1].flags & 1) {
            quadraticCurveTo(contour[j].x, contour[j].y, contour[j + 1].x, contour[j + 1].y);
            j++;
          } else {
            quadraticCurveTo(contour[j].x, contour[j].y, (contour[j].x + contour[j + 1].x) / 2, (contour[j].y + contour[j + 1].y) / 2);
          }
        }
        startPoint = endPoint + 1;
      }
    }
  }
  function compileCharString(code, cmds, font) {
    var stack = [];
    var x = 0,
        y = 0;
    var stems = 0;
    function moveTo(x, y) {
      cmds.push({
        cmd: 'moveTo',
        args: [x, y]
      });
    }
    function lineTo(x, y) {
      cmds.push({
        cmd: 'lineTo',
        args: [x, y]
      });
    }
    function bezierCurveTo(x1, y1, x2, y2, x, y) {
      cmds.push({
        cmd: 'bezierCurveTo',
        args: [x1, y1, x2, y2, x, y]
      });
    }
    function parse(code) {
      var i = 0;
      while (i < code.length) {
        var stackClean = false;
        var v = code[i++];
        var xa, xb, ya, yb, y1, y2, y3, n, subrCode;
        switch (v) {
          case 1:
            stems += stack.length >> 1;
            stackClean = true;
            break;
          case 3:
            stems += stack.length >> 1;
            stackClean = true;
            break;
          case 4:
            y += stack.pop();
            moveTo(x, y);
            stackClean = true;
            break;
          case 5:
            while (stack.length > 0) {
              x += stack.shift();
              y += stack.shift();
              lineTo(x, y);
            }
            break;
          case 6:
            while (stack.length > 0) {
              x += stack.shift();
              lineTo(x, y);
              if (stack.length === 0) {
                break;
              }
              y += stack.shift();
              lineTo(x, y);
            }
            break;
          case 7:
            while (stack.length > 0) {
              y += stack.shift();
              lineTo(x, y);
              if (stack.length === 0) {
                break;
              }
              x += stack.shift();
              lineTo(x, y);
            }
            break;
          case 8:
            while (stack.length > 0) {
              xa = x + stack.shift();
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb + stack.shift();
              bezierCurveTo(xa, ya, xb, yb, x, y);
            }
            break;
          case 10:
            n = stack.pop() + font.subrsBias;
            subrCode = font.subrs[n];
            if (subrCode) {
              parse(subrCode);
            }
            break;
          case 11:
            return;
          case 12:
            v = code[i++];
            switch (v) {
              case 34:
                xa = x + stack.shift();
                xb = xa + stack.shift();
                y1 = y + stack.shift();
                x = xb + stack.shift();
                bezierCurveTo(xa, y, xb, y1, x, y1);
                xa = x + stack.shift();
                xb = xa + stack.shift();
                x = xb + stack.shift();
                bezierCurveTo(xa, y1, xb, y, x, y);
                break;
              case 35:
                xa = x + stack.shift();
                ya = y + stack.shift();
                xb = xa + stack.shift();
                yb = ya + stack.shift();
                x = xb + stack.shift();
                y = yb + stack.shift();
                bezierCurveTo(xa, ya, xb, yb, x, y);
                xa = x + stack.shift();
                ya = y + stack.shift();
                xb = xa + stack.shift();
                yb = ya + stack.shift();
                x = xb + stack.shift();
                y = yb + stack.shift();
                bezierCurveTo(xa, ya, xb, yb, x, y);
                stack.pop();
                break;
              case 36:
                xa = x + stack.shift();
                y1 = y + stack.shift();
                xb = xa + stack.shift();
                y2 = y1 + stack.shift();
                x = xb + stack.shift();
                bezierCurveTo(xa, y1, xb, y2, x, y2);
                xa = x + stack.shift();
                xb = xa + stack.shift();
                y3 = y2 + stack.shift();
                x = xb + stack.shift();
                bezierCurveTo(xa, y2, xb, y3, x, y);
                break;
              case 37:
                var x0 = x,
                    y0 = y;
                xa = x + stack.shift();
                ya = y + stack.shift();
                xb = xa + stack.shift();
                yb = ya + stack.shift();
                x = xb + stack.shift();
                y = yb + stack.shift();
                bezierCurveTo(xa, ya, xb, yb, x, y);
                xa = x + stack.shift();
                ya = y + stack.shift();
                xb = xa + stack.shift();
                yb = ya + stack.shift();
                x = xb;
                y = yb;
                if (Math.abs(x - x0) > Math.abs(y - y0)) {
                  x += stack.shift();
                } else {
                  y += stack.shift();
                }
                bezierCurveTo(xa, ya, xb, yb, x, y);
                break;
              default:
                error('unknown operator: 12 ' + v);
            }
            break;
          case 14:
            if (stack.length >= 4) {
              var achar = stack.pop();
              var bchar = stack.pop();
              y = stack.pop();
              x = stack.pop();
              cmds.push({ cmd: 'save' });
              cmds.push({
                cmd: 'translate',
                args: [x, y]
              });
              var cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[StandardEncoding[achar]]));
              compileCharString(font.glyphs[cmap.glyphId], cmds, font);
              cmds.push({ cmd: 'restore' });
              cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[StandardEncoding[bchar]]));
              compileCharString(font.glyphs[cmap.glyphId], cmds, font);
            }
            return;
          case 18:
            stems += stack.length >> 1;
            stackClean = true;
            break;
          case 19:
            stems += stack.length >> 1;
            i += stems + 7 >> 3;
            stackClean = true;
            break;
          case 20:
            stems += stack.length >> 1;
            i += stems + 7 >> 3;
            stackClean = true;
            break;
          case 21:
            y += stack.pop();
            x += stack.pop();
            moveTo(x, y);
            stackClean = true;
            break;
          case 22:
            x += stack.pop();
            moveTo(x, y);
            stackClean = true;
            break;
          case 23:
            stems += stack.length >> 1;
            stackClean = true;
            break;
          case 24:
            while (stack.length > 2) {
              xa = x + stack.shift();
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb + stack.shift();
              bezierCurveTo(xa, ya, xb, yb, x, y);
            }
            x += stack.shift();
            y += stack.shift();
            lineTo(x, y);
            break;
          case 25:
            while (stack.length > 6) {
              x += stack.shift();
              y += stack.shift();
              lineTo(x, y);
            }
            xa = x + stack.shift();
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb + stack.shift();
            bezierCurveTo(xa, ya, xb, yb, x, y);
            break;
          case 26:
            if (stack.length % 2) {
              x += stack.shift();
            }
            while (stack.length > 0) {
              xa = x;
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb;
              y = yb + stack.shift();
              bezierCurveTo(xa, ya, xb, yb, x, y);
            }
            break;
          case 27:
            if (stack.length % 2) {
              y += stack.shift();
            }
            while (stack.length > 0) {
              xa = x + stack.shift();
              ya = y;
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb;
              bezierCurveTo(xa, ya, xb, yb, x, y);
            }
            break;
          case 28:
            stack.push((code[i] << 24 | code[i + 1] << 16) >> 16);
            i += 2;
            break;
          case 29:
            n = stack.pop() + font.gsubrsBias;
            subrCode = font.gsubrs[n];
            if (subrCode) {
              parse(subrCode);
            }
            break;
          case 30:
            while (stack.length > 0) {
              xa = x;
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb + (stack.length === 1 ? stack.shift() : 0);
              bezierCurveTo(xa, ya, xb, yb, x, y);
              if (stack.length === 0) {
                break;
              }
              xa = x + stack.shift();
              ya = y;
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              y = yb + stack.shift();
              x = xb + (stack.length === 1 ? stack.shift() : 0);
              bezierCurveTo(xa, ya, xb, yb, x, y);
            }
            break;
          case 31:
            while (stack.length > 0) {
              xa = x + stack.shift();
              ya = y;
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              y = yb + stack.shift();
              x = xb + (stack.length === 1 ? stack.shift() : 0);
              bezierCurveTo(xa, ya, xb, yb, x, y);
              if (stack.length === 0) {
                break;
              }
              xa = x;
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb + (stack.length === 1 ? stack.shift() : 0);
              bezierCurveTo(xa, ya, xb, yb, x, y);
            }
            break;
          default:
            if (v < 32) {
              error('unknown operator: ' + v);
            }
            if (v < 247) {
              stack.push(v - 139);
            } else if (v < 251) {
              stack.push((v - 247) * 256 + code[i++] + 108);
            } else if (v < 255) {
              stack.push(-(v - 251) * 256 - code[i++] - 108);
            } else {
              stack.push((code[i] << 24 | code[i + 1] << 16 | code[i + 2] << 8 | code[i + 3]) / 65536);
              i += 4;
            }
            break;
        }
        if (stackClean) {
          stack.length = 0;
        }
      }
    }
    parse(code);
  }
  var noop = '';
  function CompiledFont(fontMatrix) {
    this.compiledGlyphs = Object.create(null);
    this.compiledCharCodeToGlyphId = Object.create(null);
    this.fontMatrix = fontMatrix;
  }
  CompiledFont.prototype = {
    getPathJs: function getPathJs(unicode) {
      var cmap = lookupCmap(this.cmap, unicode);
      var fn = this.compiledGlyphs[cmap.glyphId];
      if (!fn) {
        fn = this.compileGlyph(this.glyphs[cmap.glyphId]);
        this.compiledGlyphs[cmap.glyphId] = fn;
      }
      if (this.compiledCharCodeToGlyphId[cmap.charCode] === undefined) {
        this.compiledCharCodeToGlyphId[cmap.charCode] = cmap.glyphId;
      }
      return fn;
    },
    compileGlyph: function compileGlyph(code) {
      if (!code || code.length === 0 || code[0] === 14) {
        return noop;
      }
      var cmds = [];
      cmds.push({ cmd: 'save' });
      cmds.push({
        cmd: 'transform',
        args: this.fontMatrix.slice()
      });
      cmds.push({
        cmd: 'scale',
        args: ['size', '-size']
      });
      this.compileGlyphImpl(code, cmds);
      cmds.push({ cmd: 'restore' });
      return cmds;
    },
    compileGlyphImpl: function compileGlyphImpl() {
      error('Children classes should implement this.');
    },
    hasBuiltPath: function hasBuiltPath(unicode) {
      var cmap = lookupCmap(this.cmap, unicode);
      return this.compiledGlyphs[cmap.glyphId] !== undefined && this.compiledCharCodeToGlyphId[cmap.charCode] !== undefined;
    }
  };
  function TrueTypeCompiled(glyphs, cmap, fontMatrix) {
    fontMatrix = fontMatrix || [0.000488, 0, 0, 0.000488, 0, 0];
    CompiledFont.call(this, fontMatrix);
    this.glyphs = glyphs;
    this.cmap = cmap;
  }
  Util.inherit(TrueTypeCompiled, CompiledFont, {
    compileGlyphImpl: function compileGlyphImpl(code, cmds) {
      compileGlyf(code, cmds, this);
    }
  });
  function Type2Compiled(cffInfo, cmap, fontMatrix, glyphNameMap) {
    fontMatrix = fontMatrix || [0.001, 0, 0, 0.001, 0, 0];
    CompiledFont.call(this, fontMatrix);
    this.glyphs = cffInfo.glyphs;
    this.gsubrs = cffInfo.gsubrs || [];
    this.subrs = cffInfo.subrs || [];
    this.cmap = cmap;
    this.glyphNameMap = glyphNameMap || getGlyphsUnicode();
    this.gsubrsBias = this.gsubrs.length < 1240 ? 107 : this.gsubrs.length < 33900 ? 1131 : 32768;
    this.subrsBias = this.subrs.length < 1240 ? 107 : this.subrs.length < 33900 ? 1131 : 32768;
  }
  Util.inherit(Type2Compiled, CompiledFont, {
    compileGlyphImpl: function compileGlyphImpl(code, cmds) {
      compileCharString(code, cmds, this);
    }
  });
  return {
    create: function FontRendererFactory_create(font, seacAnalysisEnabled) {
      var data = new Uint8Array(font.data);
      var cmap, glyf, loca, cff, indexToLocFormat, unitsPerEm;
      var numTables = getUshort(data, 4);
      for (var i = 0, p = 12; i < numTables; i++, p += 16) {
        var tag = bytesToString(data.subarray(p, p + 4));
        var offset = getLong(data, p + 8);
        var length = getLong(data, p + 12);
        switch (tag) {
          case 'cmap':
            cmap = parseCmap(data, offset, offset + length);
            break;
          case 'glyf':
            glyf = data.subarray(offset, offset + length);
            break;
          case 'loca':
            loca = data.subarray(offset, offset + length);
            break;
          case 'head':
            unitsPerEm = getUshort(data, offset + 18);
            indexToLocFormat = getUshort(data, offset + 50);
            break;
          case 'CFF ':
            cff = parseCff(data, offset, offset + length, seacAnalysisEnabled);
            break;
        }
      }
      if (glyf) {
        var fontMatrix = !unitsPerEm ? font.fontMatrix : [1 / unitsPerEm, 0, 0, 1 / unitsPerEm, 0, 0];
        return new TrueTypeCompiled(parseGlyfTable(glyf, loca, indexToLocFormat), cmap, fontMatrix);
      }
      return new Type2Compiled(cff, cmap, font.fontMatrix, font.glyphNameMap);
    }
  };
}();
exports.FontRendererFactory = FontRendererFactory;

/***/ }),
/* 26 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var corePrimitives = __w_pdfjs_require__(1);
var coreStream = __w_pdfjs_require__(2);
var coreGlyphList = __w_pdfjs_require__(7);
var coreFontRenderer = __w_pdfjs_require__(25);
var coreEncodings = __w_pdfjs_require__(4);
var coreStandardFonts = __w_pdfjs_require__(17);
var coreUnicode = __w_pdfjs_require__(18);
var coreType1Parser = __w_pdfjs_require__(35);
var coreCFFParser = __w_pdfjs_require__(11);
var FONT_IDENTITY_MATRIX = sharedUtil.FONT_IDENTITY_MATRIX;
var FontType = sharedUtil.FontType;
var assert = sharedUtil.assert;
var bytesToString = sharedUtil.bytesToString;
var error = sharedUtil.error;
var info = sharedUtil.info;
var isArray = sharedUtil.isArray;
var isInt = sharedUtil.isInt;
var isNum = sharedUtil.isNum;
var readUint32 = sharedUtil.readUint32;
var shadow = sharedUtil.shadow;
var string32 = sharedUtil.string32;
var warn = sharedUtil.warn;
var MissingDataException = sharedUtil.MissingDataException;
var isSpace = sharedUtil.isSpace;
var Stream = coreStream.Stream;
var getGlyphsUnicode = coreGlyphList.getGlyphsUnicode;
var getDingbatsGlyphsUnicode = coreGlyphList.getDingbatsGlyphsUnicode;
var FontRendererFactory = coreFontRenderer.FontRendererFactory;
var StandardEncoding = coreEncodings.StandardEncoding;
var MacRomanEncoding = coreEncodings.MacRomanEncoding;
var SymbolSetEncoding = coreEncodings.SymbolSetEncoding;
var ZapfDingbatsEncoding = coreEncodings.ZapfDingbatsEncoding;
var getEncoding = coreEncodings.getEncoding;
var getStdFontMap = coreStandardFonts.getStdFontMap;
var getNonStdFontMap = coreStandardFonts.getNonStdFontMap;
var getGlyphMapForStandardFonts = coreStandardFonts.getGlyphMapForStandardFonts;
var getSupplementalGlyphMapForArialBlack = coreStandardFonts.getSupplementalGlyphMapForArialBlack;
var getUnicodeRangeFor = coreUnicode.getUnicodeRangeFor;
var mapSpecialUnicodeValues = coreUnicode.mapSpecialUnicodeValues;
var getUnicodeForGlyph = coreUnicode.getUnicodeForGlyph;
var Type1Parser = coreType1Parser.Type1Parser;
var CFFStandardStrings = coreCFFParser.CFFStandardStrings;
var CFFParser = coreCFFParser.CFFParser;
var CFFCompiler = coreCFFParser.CFFCompiler;
var CFF = coreCFFParser.CFF;
var CFFHeader = coreCFFParser.CFFHeader;
var CFFTopDict = coreCFFParser.CFFTopDict;
var CFFPrivateDict = coreCFFParser.CFFPrivateDict;
var CFFStrings = coreCFFParser.CFFStrings;
var CFFIndex = coreCFFParser.CFFIndex;
var CFFCharset = coreCFFParser.CFFCharset;
var PRIVATE_USE_OFFSET_START = 0xE000;
var PRIVATE_USE_OFFSET_END = 0xF8FF;
var SKIP_PRIVATE_USE_RANGE_F000_TO_F01F = false;
var PDF_GLYPH_SPACE_UNITS = 1000;
var SEAC_ANALYSIS_ENABLED = false;
var FontFlags = {
  FixedPitch: 1,
  Serif: 2,
  Symbolic: 4,
  Script: 8,
  Nonsymbolic: 32,
  Italic: 64,
  AllCap: 65536,
  SmallCap: 131072,
  ForceBold: 262144
};
var MacStandardGlyphOrdering = ['.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave', 'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis', 'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis', 'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section', 'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal', 'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation', 'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown', 'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright', 'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft', 'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction', 'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase', 'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex', 'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth', 'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior', 'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla', 'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];
function adjustWidths(properties) {
  if (!properties.fontMatrix) {
    return;
  }
  if (properties.fontMatrix[0] === FONT_IDENTITY_MATRIX[0]) {
    return;
  }
  var scale = 0.001 / properties.fontMatrix[0];
  var glyphsWidths = properties.widths;
  for (var glyph in glyphsWidths) {
    glyphsWidths[glyph] *= scale;
  }
  properties.defaultWidth *= scale;
}
function adjustToUnicode(properties, builtInEncoding) {
  if (properties.hasIncludedToUnicodeMap) {
    return;
  }
  if (properties.hasEncoding) {
    return;
  }
  if (builtInEncoding === properties.defaultEncoding) {
    return;
  }
  if (properties.toUnicode instanceof IdentityToUnicodeMap) {
    return;
  }
  var toUnicode = [],
      glyphsUnicodeMap = getGlyphsUnicode();
  for (var charCode in builtInEncoding) {
    var glyphName = builtInEncoding[charCode];
    var unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
    if (unicode !== -1) {
      toUnicode[charCode] = String.fromCharCode(unicode);
    }
  }
  properties.toUnicode.amend(toUnicode);
}
function getFontType(type, subtype) {
  switch (type) {
    case 'Type1':
      return subtype === 'Type1C' ? FontType.TYPE1C : FontType.TYPE1;
    case 'CIDFontType0':
      return subtype === 'CIDFontType0C' ? FontType.CIDFONTTYPE0C : FontType.CIDFONTTYPE0;
    case 'OpenType':
      return FontType.OPENTYPE;
    case 'TrueType':
      return FontType.TRUETYPE;
    case 'CIDFontType2':
      return FontType.CIDFONTTYPE2;
    case 'MMType1':
      return FontType.MMTYPE1;
    case 'Type0':
      return FontType.TYPE0;
    default:
      return FontType.UNKNOWN;
  }
}
function recoverGlyphName(name, glyphsUnicodeMap) {
  if (glyphsUnicodeMap[name] !== undefined) {
    return name;
  }
  var unicode = getUnicodeForGlyph(name, glyphsUnicodeMap);
  if (unicode !== -1) {
    for (var key in glyphsUnicodeMap) {
      if (glyphsUnicodeMap[key] === unicode) {
        return key;
      }
    }
  }
  info('Unable to recover a standard glyph name for: ' + name);
  return name;
}
var Glyph = function GlyphClosure() {
  function Glyph(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) {
    this.fontChar = fontChar;
    this.unicode = unicode;
    this.accent = accent;
    this.width = width;
    this.vmetric = vmetric;
    this.operatorListId = operatorListId;
    this.isSpace = isSpace;
    this.isInFont = isInFont;
  }
  Glyph.prototype.matchesForCache = function (fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) {
    return this.fontChar === fontChar && this.unicode === unicode && this.accent === accent && this.width === width && this.vmetric === vmetric && this.operatorListId === operatorListId && this.isSpace === isSpace && this.isInFont === isInFont;
  };
  return Glyph;
}();
var ToUnicodeMap = function ToUnicodeMapClosure() {
  function ToUnicodeMap(cmap) {
    this._map = cmap;
  }
  ToUnicodeMap.prototype = {
    get length() {
      return this._map.length;
    },
    forEach: function forEach(callback) {
      for (var charCode in this._map) {
        callback(charCode, this._map[charCode].charCodeAt(0));
      }
    },
    has: function has(i) {
      return this._map[i] !== undefined;
    },
    get: function get(i) {
      return this._map[i];
    },
    charCodeOf: function charCodeOf(v) {
      return this._map.indexOf(v);
    },
    amend: function amend(map) {
      for (var charCode in map) {
        this._map[charCode] = map[charCode];
      }
    }
  };
  return ToUnicodeMap;
}();
var IdentityToUnicodeMap = function IdentityToUnicodeMapClosure() {
  function IdentityToUnicodeMap(firstChar, lastChar) {
    this.firstChar = firstChar;
    this.lastChar = lastChar;
  }
  IdentityToUnicodeMap.prototype = {
    get length() {
      return this.lastChar + 1 - this.firstChar;
    },
    forEach: function forEach(callback) {
      for (var i = this.firstChar, ii = this.lastChar; i <= ii; i++) {
        callback(i, i);
      }
    },
    has: function has(i) {
      return this.firstChar <= i && i <= this.lastChar;
    },
    get: function get(i) {
      if (this.firstChar <= i && i <= this.lastChar) {
        return String.fromCharCode(i);
      }
      return undefined;
    },
    charCodeOf: function charCodeOf(v) {
      return isInt(v) && v >= this.firstChar && v <= this.lastChar ? v : -1;
    },
    amend: function amend(map) {
      error('Should not call amend()');
    }
  };
  return IdentityToUnicodeMap;
}();
var OpenTypeFileBuilder = function OpenTypeFileBuilderClosure() {
  function writeInt16(dest, offset, num) {
    dest[offset] = num >> 8 & 0xFF;
    dest[offset + 1] = num & 0xFF;
  }
  function writeInt32(dest, offset, num) {
    dest[offset] = num >> 24 & 0xFF;
    dest[offset + 1] = num >> 16 & 0xFF;
    dest[offset + 2] = num >> 8 & 0xFF;
    dest[offset + 3] = num & 0xFF;
  }
  function writeData(dest, offset, data) {
    var i, ii;
    if (data instanceof Uint8Array) {
      dest.set(data, offset);
    } else if (typeof data === 'string') {
      for (i = 0, ii = data.length; i < ii; i++) {
        dest[offset++] = data.charCodeAt(i) & 0xFF;
      }
    } else {
      for (i = 0, ii = data.length; i < ii; i++) {
        dest[offset++] = data[i] & 0xFF;
      }
    }
  }
  function OpenTypeFileBuilder(sfnt) {
    this.sfnt = sfnt;
    this.tables = Object.create(null);
  }
  OpenTypeFileBuilder.getSearchParams = function OpenTypeFileBuilder_getSearchParams(entriesCount, entrySize) {
    var maxPower2 = 1,
        log2 = 0;
    while ((maxPower2 ^ entriesCount) > maxPower2) {
      maxPower2 <<= 1;
      log2++;
    }
    var searchRange = maxPower2 * entrySize;
    return {
      range: searchRange,
      entry: log2,
      rangeShift: entrySize * entriesCount - searchRange
    };
  };
  var OTF_HEADER_SIZE = 12;
  var OTF_TABLE_ENTRY_SIZE = 16;
  OpenTypeFileBuilder.prototype = {
    toArray: function OpenTypeFileBuilder_toArray() {
      var sfnt = this.sfnt;
      var tables = this.tables;
      var tablesNames = Object.keys(tables);
      tablesNames.sort();
      var numTables = tablesNames.length;
      var i, j, jj, table, tableName;
      var offset = OTF_HEADER_SIZE + numTables * OTF_TABLE_ENTRY_SIZE;
      var tableOffsets = [offset];
      for (i = 0; i < numTables; i++) {
        table = tables[tablesNames[i]];
        var paddedLength = (table.length + 3 & ~3) >>> 0;
        offset += paddedLength;
        tableOffsets.push(offset);
      }
      var file = new Uint8Array(offset);
      for (i = 0; i < numTables; i++) {
        table = tables[tablesNames[i]];
        writeData(file, tableOffsets[i], table);
      }
      if (sfnt === 'true') {
        sfnt = string32(0x00010000);
      }
      file[0] = sfnt.charCodeAt(0) & 0xFF;
      file[1] = sfnt.charCodeAt(1) & 0xFF;
      file[2] = sfnt.charCodeAt(2) & 0xFF;
      file[3] = sfnt.charCodeAt(3) & 0xFF;
      writeInt16(file, 4, numTables);
      var searchParams = OpenTypeFileBuilder.getSearchParams(numTables, 16);
      writeInt16(file, 6, searchParams.range);
      writeInt16(file, 8, searchParams.entry);
      writeInt16(file, 10, searchParams.rangeShift);
      offset = OTF_HEADER_SIZE;
      for (i = 0; i < numTables; i++) {
        tableName = tablesNames[i];
        file[offset] = tableName.charCodeAt(0) & 0xFF;
        file[offset + 1] = tableName.charCodeAt(1) & 0xFF;
        file[offset + 2] = tableName.charCodeAt(2) & 0xFF;
        file[offset + 3] = tableName.charCodeAt(3) & 0xFF;
        var checksum = 0;
        for (j = tableOffsets[i], jj = tableOffsets[i + 1]; j < jj; j += 4) {
          var quad = readUint32(file, j);
          checksum = checksum + quad >>> 0;
        }
        writeInt32(file, offset + 4, checksum);
        writeInt32(file, offset + 8, tableOffsets[i]);
        writeInt32(file, offset + 12, tables[tableName].length);
        offset += OTF_TABLE_ENTRY_SIZE;
      }
      return file;
    },
    addTable: function OpenTypeFileBuilder_addTable(tag, data) {
      if (tag in this.tables) {
        throw new Error('Table ' + tag + ' already exists');
      }
      this.tables[tag] = data;
    }
  };
  return OpenTypeFileBuilder;
}();
var ProblematicCharRanges = new Int32Array([0x0000, 0x0020, 0x007F, 0x00A1, 0x00AD, 0x00AE, 0x0600, 0x0780, 0x08A0, 0x10A0, 0x1780, 0x1800, 0x1C00, 0x1C50, 0x2000, 0x2010, 0x2011, 0x2012, 0x2028, 0x2030, 0x205F, 0x2070, 0x25CC, 0x25CD, 0x3000, 0x3001, 0xAA60, 0xAA80, 0xFFF0, 0x10000]);
var Font = function FontClosure() {
  function Font(name, file, properties) {
    var charCode, glyphName, unicode;
    this.name = name;
    this.loadedName = properties.loadedName;
    this.isType3Font = properties.isType3Font;
    this.sizes = [];
    this.missingFile = false;
    this.glyphCache = Object.create(null);
    this.isSerifFont = !!(properties.flags & FontFlags.Serif);
    this.isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
    this.isMonospace = !!(properties.flags & FontFlags.FixedPitch);
    var type = properties.type;
    var subtype = properties.subtype;
    this.type = type;
    this.fallbackName = this.isMonospace ? 'monospace' : this.isSerifFont ? 'serif' : 'sans-serif';
    this.differences = properties.differences;
    this.widths = properties.widths;
    this.defaultWidth = properties.defaultWidth;
    this.composite = properties.composite;
    this.wideChars = properties.wideChars;
    this.cMap = properties.cMap;
    this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
    this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
    this.fontMatrix = properties.fontMatrix;
    this.bbox = properties.bbox;
    this.toUnicode = properties.toUnicode;
    this.toFontChar = [];
    if (properties.type === 'Type3') {
      for (charCode = 0; charCode < 256; charCode++) {
        this.toFontChar[charCode] = this.differences[charCode] || properties.defaultEncoding[charCode];
      }
      this.fontType = FontType.TYPE3;
      return;
    }
    this.cidEncoding = properties.cidEncoding;
    this.vertical = properties.vertical;
    if (this.vertical) {
      this.vmetrics = properties.vmetrics;
      this.defaultVMetrics = properties.defaultVMetrics;
    }
    var glyphsUnicodeMap;
    if (!file || file.isEmpty) {
      if (file) {
        warn('Font file is empty in "' + name + '" (' + this.loadedName + ')');
      }
      this.missingFile = true;
      var fontName = name.replace(/[,_]/g, '-');
      var stdFontMap = getStdFontMap(),
          nonStdFontMap = getNonStdFontMap();
      var isStandardFont = !!stdFontMap[fontName] || !!(nonStdFontMap[fontName] && stdFontMap[nonStdFontMap[fontName]]);
      fontName = stdFontMap[fontName] || nonStdFontMap[fontName] || fontName;
      this.bold = fontName.search(/bold/gi) !== -1;
      this.italic = fontName.search(/oblique/gi) !== -1 || fontName.search(/italic/gi) !== -1;
      this.black = name.search(/Black/g) !== -1;
      this.remeasure = Object.keys(this.widths).length > 0;
      if (isStandardFont && type === 'CIDFontType2' && properties.cidEncoding.indexOf('Identity-') === 0) {
        var GlyphMapForStandardFonts = getGlyphMapForStandardFonts();
        var map = [];
        for (charCode in GlyphMapForStandardFonts) {
          map[+charCode] = GlyphMapForStandardFonts[charCode];
        }
        if (/Arial-?Black/i.test(name)) {
          var SupplementalGlyphMapForArialBlack = getSupplementalGlyphMapForArialBlack();
          for (charCode in SupplementalGlyphMapForArialBlack) {
            map[+charCode] = SupplementalGlyphMapForArialBlack[charCode];
          }
        }
        var isIdentityUnicode = this.toUnicode instanceof IdentityToUnicodeMap;
        if (!isIdentityUnicode) {
          this.toUnicode.forEach(function (charCode, unicodeCharCode) {
            map[+charCode] = unicodeCharCode;
          });
        }
        this.toFontChar = map;
        this.toUnicode = new ToUnicodeMap(map);
      } else if (/Symbol/i.test(fontName)) {
        this.toFontChar = buildToFontChar(SymbolSetEncoding, getGlyphsUnicode(), properties.differences);
      } else if (/Dingbats/i.test(fontName)) {
        if (/Wingdings/i.test(name)) {
          warn('Non-embedded Wingdings font, falling back to ZapfDingbats.');
        }
        this.toFontChar = buildToFontChar(ZapfDingbatsEncoding, getDingbatsGlyphsUnicode(), properties.differences);
      } else if (isStandardFont) {
        this.toFontChar = buildToFontChar(properties.defaultEncoding, getGlyphsUnicode(), properties.differences);
      } else {
        glyphsUnicodeMap = getGlyphsUnicode();
        this.toUnicode.forEach(function (charCode, unicodeCharCode) {
          if (!this.composite) {
            glyphName = properties.differences[charCode] || properties.defaultEncoding[charCode];
            unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
            if (unicode !== -1) {
              unicodeCharCode = unicode;
            }
          }
          this.toFontChar[charCode] = unicodeCharCode;
        }.bind(this));
      }
      this.loadedName = fontName.split('-')[0];
      this.loading = false;
      this.fontType = getFontType(type, subtype);
      return;
    }
    if (subtype === 'Type1C') {
      if (type !== 'Type1' && type !== 'MMType1') {
        if (isTrueTypeFile(file)) {
          subtype = 'TrueType';
        } else {
          type = 'Type1';
        }
      } else if (isOpenTypeFile(file)) {
        type = subtype = 'OpenType';
      }
    }
    if (subtype === 'CIDFontType0C' && type !== 'CIDFontType0') {
      type = 'CIDFontType0';
    }
    if (subtype === 'OpenType') {
      type = 'OpenType';
    }
    if (type === 'CIDFontType0') {
      if (isType1File(file)) {
        subtype = 'CIDFontType0';
      } else if (isOpenTypeFile(file)) {
        type = subtype = 'OpenType';
      } else {
        subtype = 'CIDFontType0C';
      }
    }
    var data;
    switch (type) {
      case 'MMType1':
        info('MMType1 font (' + name + '), falling back to Type1.');
      case 'Type1':
      case 'CIDFontType0':
        this.mimetype = 'font/opentype';
        var cff = subtype === 'Type1C' || subtype === 'CIDFontType0C' ? new CFFFont(file, properties) : new Type1Font(name, file, properties);
        adjustWidths(properties);
        data = this.convert(name, cff, properties);
        break;
      case 'OpenType':
      case 'TrueType':
      case 'CIDFontType2':
        this.mimetype = 'font/opentype';
        data = this.checkAndRepair(name, file, properties);
        if (this.isOpenType) {
          adjustWidths(properties);
          type = 'OpenType';
        }
        break;
      default:
        error('Font ' + type + ' is not supported');
        break;
    }
    this.data = data;
    this.fontType = getFontType(type, subtype);
    this.fontMatrix = properties.fontMatrix;
    this.widths = properties.widths;
    this.defaultWidth = properties.defaultWidth;
    this.toUnicode = properties.toUnicode;
    this.encoding = properties.baseEncoding;
    this.seacMap = properties.seacMap;
    this.loading = true;
  }
  Font.getFontID = function () {
    var ID = 1;
    return function Font_getFontID() {
      return String(ID++);
    };
  }();
  function int16(b0, b1) {
    return (b0 << 8) + b1;
  }
  function signedInt16(b0, b1) {
    var value = (b0 << 8) + b1;
    return value & 1 << 15 ? value - 0x10000 : value;
  }
  function int32(b0, b1, b2, b3) {
    return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
  }
  function string16(value) {
    return String.fromCharCode(value >> 8 & 0xff, value & 0xff);
  }
  function safeString16(value) {
    value = value > 0x7FFF ? 0x7FFF : value < -0x8000 ? -0x8000 : value;
    return String.fromCharCode(value >> 8 & 0xff, value & 0xff);
  }
  function isTrueTypeFile(file) {
    var header = file.peekBytes(4);
    return readUint32(header, 0) === 0x00010000;
  }
  function isOpenTypeFile(file) {
    var header = file.peekBytes(4);
    return bytesToString(header) === 'OTTO';
  }
  function isType1File(file) {
    var header = file.peekBytes(2);
    if (header[0] === 0x25 && header[1] === 0x21) {
      return true;
    }
    if (header[0] === 0x80 && header[1] === 0x01) {
      return true;
    }
    return false;
  }
  function buildToFontChar(encoding, glyphsUnicodeMap, differences) {
    var toFontChar = [],
        unicode;
    for (var i = 0, ii = encoding.length; i < ii; i++) {
      unicode = getUnicodeForGlyph(encoding[i], glyphsUnicodeMap);
      if (unicode !== -1) {
        toFontChar[i] = unicode;
      }
    }
    for (var charCode in differences) {
      unicode = getUnicodeForGlyph(differences[charCode], glyphsUnicodeMap);
      if (unicode !== -1) {
        toFontChar[+charCode] = unicode;
      }
    }
    return toFontChar;
  }
  function isProblematicUnicodeLocation(code) {
    var i = 0,
        j = ProblematicCharRanges.length - 1;
    while (i < j) {
      var c = i + j + 1 >> 1;
      if (code < ProblematicCharRanges[c]) {
        j = c - 1;
      } else {
        i = c;
      }
    }
    return !(i & 1);
  }
  function adjustMapping(charCodeToGlyphId, properties) {
    var toUnicode = properties.toUnicode;
    var isSymbolic = !!(properties.flags & FontFlags.Symbolic);
    var isIdentityUnicode = properties.toUnicode instanceof IdentityToUnicodeMap;
    var newMap = Object.create(null);
    var toFontChar = [];
    var usedFontCharCodes = [];
    var nextAvailableFontCharCode = PRIVATE_USE_OFFSET_START;
    for (var originalCharCode in charCodeToGlyphId) {
      originalCharCode |= 0;
      var glyphId = charCodeToGlyphId[originalCharCode];
      var fontCharCode = originalCharCode;
      var hasUnicodeValue = false;
      if (!isIdentityUnicode && toUnicode.has(originalCharCode)) {
        hasUnicodeValue = true;
        var unicode = toUnicode.get(fontCharCode);
        if (unicode.length === 1) {
          fontCharCode = unicode.charCodeAt(0);
        }
      }
      if ((usedFontCharCodes[fontCharCode] !== undefined || isProblematicUnicodeLocation(fontCharCode) || isSymbolic && !hasUnicodeValue) && nextAvailableFontCharCode <= PRIVATE_USE_OFFSET_END) {
        do {
          fontCharCode = nextAvailableFontCharCode++;
          if (SKIP_PRIVATE_USE_RANGE_F000_TO_F01F && fontCharCode === 0xF000) {
            fontCharCode = 0xF020;
            nextAvailableFontCharCode = fontCharCode + 1;
          }
        } while (usedFontCharCodes[fontCharCode] !== undefined && nextAvailableFontCharCode <= PRIVATE_USE_OFFSET_END);
      }
      newMap[fontCharCode] = glyphId;
      toFontChar[originalCharCode] = fontCharCode;
      usedFontCharCodes[fontCharCode] = true;
    }
    return {
      toFontChar: toFontChar,
      charCodeToGlyphId: newMap,
      nextAvailableFontCharCode: nextAvailableFontCharCode
    };
  }
  function getRanges(glyphs, numGlyphs) {
    var codes = [];
    for (var charCode in glyphs) {
      if (glyphs[charCode] >= numGlyphs) {
        continue;
      }
      codes.push({
        fontCharCode: charCode | 0,
        glyphId: glyphs[charCode]
      });
    }
    codes.sort(function fontGetRangesSort(a, b) {
      return a.fontCharCode - b.fontCharCode;
    });
    var ranges = [];
    var length = codes.length;
    for (var n = 0; n < length;) {
      var start = codes[n].fontCharCode;
      var codeIndices = [codes[n].glyphId];
      ++n;
      var end = start;
      while (n < length && end + 1 === codes[n].fontCharCode) {
        codeIndices.push(codes[n].glyphId);
        ++end;
        ++n;
        if (end === 0xFFFF) {
          break;
        }
      }
      ranges.push([start, end, codeIndices]);
    }
    return ranges;
  }
  function createCmapTable(glyphs, numGlyphs) {
    var ranges = getRanges(glyphs, numGlyphs);
    var numTables = ranges[ranges.length - 1][1] > 0xFFFF ? 2 : 1;
    var cmap = '\x00\x00' + string16(numTables) + '\x00\x03' + '\x00\x01' + string32(4 + numTables * 8);
    var i, ii, j, jj;
    for (i = ranges.length - 1; i >= 0; --i) {
      if (ranges[i][0] <= 0xFFFF) {
        break;
      }
    }
    var bmpLength = i + 1;
    if (ranges[i][0] < 0xFFFF && ranges[i][1] === 0xFFFF) {
      ranges[i][1] = 0xFFFE;
    }
    var trailingRangesCount = ranges[i][1] < 0xFFFF ? 1 : 0;
    var segCount = bmpLength + trailingRangesCount;
    var searchParams = OpenTypeFileBuilder.getSearchParams(segCount, 2);
    var startCount = '';
    var endCount = '';
    var idDeltas = '';
    var idRangeOffsets = '';
    var glyphsIds = '';
    var bias = 0;
    var range, start, end, codes;
    for (i = 0, ii = bmpLength; i < ii; i++) {
      range = ranges[i];
      start = range[0];
      end = range[1];
      startCount += string16(start);
      endCount += string16(end);
      codes = range[2];
      var contiguous = true;
      for (j = 1, jj = codes.length; j < jj; ++j) {
        if (codes[j] !== codes[j - 1] + 1) {
          contiguous = false;
          break;
        }
      }
      if (!contiguous) {
        var offset = (segCount - i) * 2 + bias * 2;
        bias += end - start + 1;
        idDeltas += string16(0);
        idRangeOffsets += string16(offset);
        for (j = 0, jj = codes.length; j < jj; ++j) {
          glyphsIds += string16(codes[j]);
        }
      } else {
        var startCode = codes[0];
        idDeltas += string16(startCode - start & 0xFFFF);
        idRangeOffsets += string16(0);
      }
    }
    if (trailingRangesCount > 0) {
      endCount += '\xFF\xFF';
      startCount += '\xFF\xFF';
      idDeltas += '\x00\x01';
      idRangeOffsets += '\x00\x00';
    }
    var format314 = '\x00\x00' + string16(2 * segCount) + string16(searchParams.range) + string16(searchParams.entry) + string16(searchParams.rangeShift) + endCount + '\x00\x00' + startCount + idDeltas + idRangeOffsets + glyphsIds;
    var format31012 = '';
    var header31012 = '';
    if (numTables > 1) {
      cmap += '\x00\x03' + '\x00\x0A' + string32(4 + numTables * 8 + 4 + format314.length);
      format31012 = '';
      for (i = 0, ii = ranges.length; i < ii; i++) {
        range = ranges[i];
        start = range[0];
        codes = range[2];
        var code = codes[0];
        for (j = 1, jj = codes.length; j < jj; ++j) {
          if (codes[j] !== codes[j - 1] + 1) {
            end = range[0] + j - 1;
            format31012 += string32(start) + string32(end) + string32(code);
            start = end + 1;
            code = codes[j];
          }
        }
        format31012 += string32(start) + string32(range[1]) + string32(code);
      }
      header31012 = '\x00\x0C' + '\x00\x00' + string32(format31012.length + 16) + '\x00\x00\x00\x00' + string32(format31012.length / 12);
    }
    return cmap + '\x00\x04' + string16(format314.length + 4) + format314 + header31012 + format31012;
  }
  function validateOS2Table(os2) {
    var stream = new Stream(os2.data);
    var version = stream.getUint16();
    stream.getBytes(60);
    var selection = stream.getUint16();
    if (version < 4 && selection & 0x0300) {
      return false;
    }
    var firstChar = stream.getUint16();
    var lastChar = stream.getUint16();
    if (firstChar > lastChar) {
      return false;
    }
    stream.getBytes(6);
    var usWinAscent = stream.getUint16();
    if (usWinAscent === 0) {
      return false;
    }
    os2.data[8] = os2.data[9] = 0;
    return true;
  }
  function createOS2Table(properties, charstrings, override) {
    override = override || {
      unitsPerEm: 0,
      yMax: 0,
      yMin: 0,
      ascent: 0,
      descent: 0
    };
    var ulUnicodeRange1 = 0;
    var ulUnicodeRange2 = 0;
    var ulUnicodeRange3 = 0;
    var ulUnicodeRange4 = 0;
    var firstCharIndex = null;
    var lastCharIndex = 0;
    if (charstrings) {
      for (var code in charstrings) {
        code |= 0;
        if (firstCharIndex > code || !firstCharIndex) {
          firstCharIndex = code;
        }
        if (lastCharIndex < code) {
          lastCharIndex = code;
        }
        var position = getUnicodeRangeFor(code);
        if (position < 32) {
          ulUnicodeRange1 |= 1 << position;
        } else if (position < 64) {
          ulUnicodeRange2 |= 1 << position - 32;
        } else if (position < 96) {
          ulUnicodeRange3 |= 1 << position - 64;
        } else if (position < 123) {
          ulUnicodeRange4 |= 1 << position - 96;
        } else {
          error('Unicode ranges Bits > 123 are reserved for internal usage');
        }
      }
    } else {
      firstCharIndex = 0;
      lastCharIndex = 255;
    }
    var bbox = properties.bbox || [0, 0, 0, 0];
    var unitsPerEm = override.unitsPerEm || 1 / (properties.fontMatrix || FONT_IDENTITY_MATRIX)[0];
    var scale = properties.ascentScaled ? 1.0 : unitsPerEm / PDF_GLYPH_SPACE_UNITS;
    var typoAscent = override.ascent || Math.round(scale * (properties.ascent || bbox[3]));
    var typoDescent = override.descent || Math.round(scale * (properties.descent || bbox[1]));
    if (typoDescent > 0 && properties.descent > 0 && bbox[1] < 0) {
      typoDescent = -typoDescent;
    }
    var winAscent = override.yMax || typoAscent;
    var winDescent = -override.yMin || -typoDescent;
    return '\x00\x03' + '\x02\x24' + '\x01\xF4' + '\x00\x05' + '\x00\x00' + '\x02\x8A' + '\x02\xBB' + '\x00\x00' + '\x00\x8C' + '\x02\x8A' + '\x02\xBB' + '\x00\x00' + '\x01\xDF' + '\x00\x31' + '\x01\x02' + '\x00\x00' + '\x00\x00\x06' + String.fromCharCode(properties.fixedPitch ? 0x09 : 0x00) + '\x00\x00\x00\x00\x00\x00' + string32(ulUnicodeRange1) + string32(ulUnicodeRange2) + string32(ulUnicodeRange3) + string32(ulUnicodeRange4) + '\x2A\x32\x31\x2A' + string16(properties.italicAngle ? 1 : 0) + string16(firstCharIndex || properties.firstChar) + string16(lastCharIndex || properties.lastChar) + string16(typoAscent) + string16(typoDescent) + '\x00\x64' + string16(winAscent) + string16(winDescent) + '\x00\x00\x00\x00' + '\x00\x00\x00\x00' + string16(properties.xHeight) + string16(properties.capHeight) + string16(0) + string16(firstCharIndex || properties.firstChar) + '\x00\x03';
  }
  function createPostTable(properties) {
    var angle = Math.floor(properties.italicAngle * Math.pow(2, 16));
    return '\x00\x03\x00\x00' + string32(angle) + '\x00\x00' + '\x00\x00' + string32(properties.fixedPitch) + '\x00\x00\x00\x00' + '\x00\x00\x00\x00' + '\x00\x00\x00\x00' + '\x00\x00\x00\x00';
  }
  function createNameTable(name, proto) {
    if (!proto) {
      proto = [[], []];
    }
    var strings = [proto[0][0] || 'Original licence', proto[0][1] || name, proto[0][2] || 'Unknown', proto[0][3] || 'uniqueID', proto[0][4] || name, proto[0][5] || 'Version 0.11', proto[0][6] || '', proto[0][7] || 'Unknown', proto[0][8] || 'Unknown', proto[0][9] || 'Unknown'];
    var stringsUnicode = [];
    var i, ii, j, jj, str;
    for (i = 0, ii = strings.length; i < ii; i++) {
      str = proto[1][i] || strings[i];
      var strBufUnicode = [];
      for (j = 0, jj = str.length; j < jj; j++) {
        strBufUnicode.push(string16(str.charCodeAt(j)));
      }
      stringsUnicode.push(strBufUnicode.join(''));
    }
    var names = [strings, stringsUnicode];
    var platforms = ['\x00\x01', '\x00\x03'];
    var encodings = ['\x00\x00', '\x00\x01'];
    var languages = ['\x00\x00', '\x04\x09'];
    var namesRecordCount = strings.length * platforms.length;
    var nameTable = '\x00\x00' + string16(namesRecordCount) + string16(namesRecordCount * 12 + 6);
    var strOffset = 0;
    for (i = 0, ii = platforms.length; i < ii; i++) {
      var strs = names[i];
      for (j = 0, jj = strs.length; j < jj; j++) {
        str = strs[j];
        var nameRecord = platforms[i] + encodings[i] + languages[i] + string16(j) + string16(str.length) + string16(strOffset);
        nameTable += nameRecord;
        strOffset += str.length;
      }
    }
    nameTable += strings.join('') + stringsUnicode.join('');
    return nameTable;
  }
  Font.prototype = {
    name: null,
    font: null,
    mimetype: null,
    encoding: null,
    get renderer() {
      var renderer = FontRendererFactory.create(this, SEAC_ANALYSIS_ENABLED);
      return shadow(this, 'renderer', renderer);
    },
    exportData: function Font_exportData() {
      var data = {};
      for (var i in this) {
        if (this.hasOwnProperty(i)) {
          data[i] = this[i];
        }
      }
      return data;
    },
    checkAndRepair: function Font_checkAndRepair(name, font, properties) {
      function readTableEntry(file) {
        var tag = bytesToString(file.getBytes(4));
        var checksum = file.getInt32() >>> 0;
        var offset = file.getInt32() >>> 0;
        var length = file.getInt32() >>> 0;
        var previousPosition = file.pos;
        file.pos = file.start ? file.start : 0;
        file.skip(offset);
        var data = file.getBytes(length);
        file.pos = previousPosition;
        if (tag === 'head') {
          data[8] = data[9] = data[10] = data[11] = 0;
          data[17] |= 0x20;
        }
        return {
          tag: tag,
          checksum: checksum,
          length: length,
          offset: offset,
          data: data
        };
      }
      function readOpenTypeHeader(ttf) {
        return {
          version: bytesToString(ttf.getBytes(4)),
          numTables: ttf.getUint16(),
          searchRange: ttf.getUint16(),
          entrySelector: ttf.getUint16(),
          rangeShift: ttf.getUint16()
        };
      }
      function readCmapTable(cmap, font, isSymbolicFont, hasEncoding) {
        if (!cmap) {
          warn('No cmap table available.');
          return {
            platformId: -1,
            encodingId: -1,
            mappings: [],
            hasShortCmap: false
          };
        }
        var segment;
        var start = (font.start ? font.start : 0) + cmap.offset;
        font.pos = start;
        font.getUint16();
        var numTables = font.getUint16();
        var potentialTable;
        var canBreak = false;
        for (var i = 0; i < numTables; i++) {
          var platformId = font.getUint16();
          var encodingId = font.getUint16();
          var offset = font.getInt32() >>> 0;
          var useTable = false;
          if (platformId === 0 && encodingId === 0) {
            useTable = true;
          } else if (platformId === 1 && encodingId === 0) {
            useTable = true;
          } else if (platformId === 3 && encodingId === 1 && (hasEncoding || !potentialTable)) {
            useTable = true;
            if (!isSymbolicFont) {
              canBreak = true;
            }
          } else if (isSymbolicFont && platformId === 3 && encodingId === 0) {
            useTable = true;
            canBreak = true;
          }
          if (useTable) {
            potentialTable = {
              platformId: platformId,
              encodingId: encodingId,
              offset: offset
            };
          }
          if (canBreak) {
            break;
          }
        }
        if (potentialTable) {
          font.pos = start + potentialTable.offset;
        }
        if (!potentialTable || font.peekByte() === -1) {
          warn('Could not find a preferred cmap table.');
          return {
            platformId: -1,
            encodingId: -1,
            mappings: [],
            hasShortCmap: false
          };
        }
        var format = font.getUint16();
        font.getUint16();
        font.getUint16();
        var hasShortCmap = false;
        var mappings = [];
        var j, glyphId;
        if (format === 0) {
          for (j = 0; j < 256; j++) {
            var index = font.getByte();
            if (!index) {
              continue;
            }
            mappings.push({
              charCode: j,
              glyphId: index
            });
          }
          hasShortCmap = true;
        } else if (format === 4) {
          var segCount = font.getUint16() >> 1;
          font.getBytes(6);
          var segIndex,
              segments = [];
          for (segIndex = 0; segIndex < segCount; segIndex++) {
            segments.push({ end: font.getUint16() });
          }
          font.getUint16();
          for (segIndex = 0; segIndex < segCount; segIndex++) {
            segments[segIndex].start = font.getUint16();
          }
          for (segIndex = 0; segIndex < segCount; segIndex++) {
            segments[segIndex].delta = font.getUint16();
          }
          var offsetsCount = 0;
          for (segIndex = 0; segIndex < segCount; segIndex++) {
            segment = segments[segIndex];
            var rangeOffset = font.getUint16();
            if (!rangeOffset) {
              segment.offsetIndex = -1;
              continue;
            }
            var offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);
            segment.offsetIndex = offsetIndex;
            offsetsCount = Math.max(offsetsCount, offsetIndex + segment.end - segment.start + 1);
          }
          var offsets = [];
          for (j = 0; j < offsetsCount; j++) {
            offsets.push(font.getUint16());
          }
          for (segIndex = 0; segIndex < segCount; segIndex++) {
            segment = segments[segIndex];
            start = segment.start;
            var end = segment.end;
            var delta = segment.delta;
            offsetIndex = segment.offsetIndex;
            for (j = start; j <= end; j++) {
              if (j === 0xFFFF) {
                continue;
              }
              glyphId = offsetIndex < 0 ? j : offsets[offsetIndex + j - start];
              glyphId = glyphId + delta & 0xFFFF;
              mappings.push({
                charCode: j,
                glyphId: glyphId
              });
            }
          }
        } else if (format === 6) {
          var firstCode = font.getUint16();
          var entryCount = font.getUint16();
          for (j = 0; j < entryCount; j++) {
            glyphId = font.getUint16();
            var charCode = firstCode + j;
            mappings.push({
              charCode: charCode,
              glyphId: glyphId
            });
          }
        } else {
          warn('cmap table has unsupported format: ' + format);
          return {
            platformId: -1,
            encodingId: -1,
            mappings: [],
            hasShortCmap: false
          };
        }
        mappings.sort(function (a, b) {
          return a.charCode - b.charCode;
        });
        for (i = 1; i < mappings.length; i++) {
          if (mappings[i - 1].charCode === mappings[i].charCode) {
            mappings.splice(i, 1);
            i--;
          }
        }
        return {
          platformId: potentialTable.platformId,
          encodingId: potentialTable.encodingId,
          mappings: mappings,
          hasShortCmap: hasShortCmap
        };
      }
      function sanitizeMetrics(font, header, metrics, numGlyphs) {
        if (!header) {
          if (metrics) {
            metrics.data = null;
          }
          return;
        }
        font.pos = (font.start ? font.start : 0) + header.offset;
        font.pos += header.length - 2;
        var numOfMetrics = font.getUint16();
        if (numOfMetrics > numGlyphs) {
          info('The numOfMetrics (' + numOfMetrics + ') should not be ' + 'greater than the numGlyphs (' + numGlyphs + ')');
          numOfMetrics = numGlyphs;
          header.data[34] = (numOfMetrics & 0xff00) >> 8;
          header.data[35] = numOfMetrics & 0x00ff;
        }
        var numOfSidebearings = numGlyphs - numOfMetrics;
        var numMissing = numOfSidebearings - (metrics.length - numOfMetrics * 4 >> 1);
        if (numMissing > 0) {
          var entries = new Uint8Array(metrics.length + numMissing * 2);
          entries.set(metrics.data);
          metrics.data = entries;
        }
      }
      function sanitizeGlyph(source, sourceStart, sourceEnd, dest, destStart, hintsValid) {
        if (sourceEnd - sourceStart <= 12) {
          return 0;
        }
        var glyf = source.subarray(sourceStart, sourceEnd);
        var contoursCount = glyf[0] << 8 | glyf[1];
        if (contoursCount & 0x8000) {
          dest.set(glyf, destStart);
          return glyf.length;
        }
        var i,
            j = 10,
            flagsCount = 0;
        for (i = 0; i < contoursCount; i++) {
          var endPoint = glyf[j] << 8 | glyf[j + 1];
          flagsCount = endPoint + 1;
          j += 2;
        }
        var instructionsStart = j;
        var instructionsLength = glyf[j] << 8 | glyf[j + 1];
        j += 2 + instructionsLength;
        var instructionsEnd = j;
        var coordinatesLength = 0;
        for (i = 0; i < flagsCount; i++) {
          var flag = glyf[j++];
          if (flag & 0xC0) {
            glyf[j - 1] = flag & 0x3F;
          }
          var xyLength = (flag & 2 ? 1 : flag & 16 ? 0 : 2) + (flag & 4 ? 1 : flag & 32 ? 0 : 2);
          coordinatesLength += xyLength;
          if (flag & 8) {
            var repeat = glyf[j++];
            i += repeat;
            coordinatesLength += repeat * xyLength;
          }
        }
        if (coordinatesLength === 0) {
          return 0;
        }
        var glyphDataLength = j + coordinatesLength;
        if (glyphDataLength > glyf.length) {
          return 0;
        }
        if (!hintsValid && instructionsLength > 0) {
          dest.set(glyf.subarray(0, instructionsStart), destStart);
          dest.set([0, 0], destStart + instructionsStart);
          dest.set(glyf.subarray(instructionsEnd, glyphDataLength), destStart + instructionsStart + 2);
          glyphDataLength -= instructionsLength;
          if (glyf.length - glyphDataLength > 3) {
            glyphDataLength = glyphDataLength + 3 & ~3;
          }
          return glyphDataLength;
        }
        if (glyf.length - glyphDataLength > 3) {
          glyphDataLength = glyphDataLength + 3 & ~3;
          dest.set(glyf.subarray(0, glyphDataLength), destStart);
          return glyphDataLength;
        }
        dest.set(glyf, destStart);
        return glyf.length;
      }
      function sanitizeHead(head, numGlyphs, locaLength) {
        var data = head.data;
        var version = int32(data[0], data[1], data[2], data[3]);
        if (version >> 16 !== 1) {
          info('Attempting to fix invalid version in head table: ' + version);
          data[0] = 0;
          data[1] = 1;
          data[2] = 0;
          data[3] = 0;
        }
        var indexToLocFormat = int16(data[50], data[51]);
        if (indexToLocFormat < 0 || indexToLocFormat > 1) {
          info('Attempting to fix invalid indexToLocFormat in head table: ' + indexToLocFormat);
          var numGlyphsPlusOne = numGlyphs + 1;
          if (locaLength === numGlyphsPlusOne << 1) {
            data[50] = 0;
            data[51] = 0;
          } else if (locaLength === numGlyphsPlusOne << 2) {
            data[50] = 0;
            data[51] = 1;
          } else {
            warn('Could not fix indexToLocFormat: ' + indexToLocFormat);
          }
        }
      }
      function sanitizeGlyphLocations(loca, glyf, numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry) {
        var itemSize, itemDecode, itemEncode;
        if (isGlyphLocationsLong) {
          itemSize = 4;
          itemDecode = function fontItemDecodeLong(data, offset) {
            return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
          };
          itemEncode = function fontItemEncodeLong(data, offset, value) {
            data[offset] = value >>> 24 & 0xFF;
            data[offset + 1] = value >> 16 & 0xFF;
            data[offset + 2] = value >> 8 & 0xFF;
            data[offset + 3] = value & 0xFF;
          };
        } else {
          itemSize = 2;
          itemDecode = function fontItemDecode(data, offset) {
            return data[offset] << 9 | data[offset + 1] << 1;
          };
          itemEncode = function fontItemEncode(data, offset, value) {
            data[offset] = value >> 9 & 0xFF;
            data[offset + 1] = value >> 1 & 0xFF;
          };
        }
        var locaData = loca.data;
        var locaDataSize = itemSize * (1 + numGlyphs);
        if (locaData.length !== locaDataSize) {
          locaData = new Uint8Array(locaDataSize);
          locaData.set(loca.data.subarray(0, locaDataSize));
          loca.data = locaData;
        }
        var oldGlyfData = glyf.data;
        var oldGlyfDataLength = oldGlyfData.length;
        var newGlyfData = new Uint8Array(oldGlyfDataLength);
        var startOffset = itemDecode(locaData, 0);
        var writeOffset = 0;
        var missingGlyphData = Object.create(null);
        itemEncode(locaData, 0, writeOffset);
        var i, j;
        for (i = 0, j = itemSize; i < numGlyphs; i++, j += itemSize) {
          var endOffset = itemDecode(locaData, j);
          if (endOffset > oldGlyfDataLength && (oldGlyfDataLength + 3 & ~3) === endOffset) {
            endOffset = oldGlyfDataLength;
          }
          if (endOffset > oldGlyfDataLength) {
            itemEncode(locaData, j, writeOffset);
            startOffset = endOffset;
            continue;
          }
          if (startOffset === endOffset) {
            missingGlyphData[i] = true;
          }
          var newLength = sanitizeGlyph(oldGlyfData, startOffset, endOffset, newGlyfData, writeOffset, hintsValid);
          writeOffset += newLength;
          itemEncode(locaData, j, writeOffset);
          startOffset = endOffset;
        }
        if (writeOffset === 0) {
          var simpleGlyph = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
          for (i = 0, j = itemSize; i < numGlyphs; i++, j += itemSize) {
            itemEncode(locaData, j, simpleGlyph.length);
          }
          glyf.data = simpleGlyph;
          return missingGlyphData;
        }
        if (dupFirstEntry) {
          var firstEntryLength = itemDecode(locaData, itemSize);
          if (newGlyfData.length > firstEntryLength + writeOffset) {
            glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
          } else {
            glyf.data = new Uint8Array(firstEntryLength + writeOffset);
            glyf.data.set(newGlyfData.subarray(0, writeOffset));
          }
          glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
          itemEncode(loca.data, locaData.length - itemSize, writeOffset + firstEntryLength);
        } else {
          glyf.data = newGlyfData.subarray(0, writeOffset);
        }
        return missingGlyphData;
      }
      function readPostScriptTable(post, properties, maxpNumGlyphs) {
        var start = (font.start ? font.start : 0) + post.offset;
        font.pos = start;
        var length = post.length,
            end = start + length;
        var version = font.getInt32();
        font.getBytes(28);
        var glyphNames;
        var valid = true;
        var i;
        switch (version) {
          case 0x00010000:
            glyphNames = MacStandardGlyphOrdering;
            break;
          case 0x00020000:
            var numGlyphs = font.getUint16();
            if (numGlyphs !== maxpNumGlyphs) {
              valid = false;
              break;
            }
            var glyphNameIndexes = [];
            for (i = 0; i < numGlyphs; ++i) {
              var index = font.getUint16();
              if (index >= 32768) {
                valid = false;
                break;
              }
              glyphNameIndexes.push(index);
            }
            if (!valid) {
              break;
            }
            var customNames = [];
            var strBuf = [];
            while (font.pos < end) {
              var stringLength = font.getByte();
              strBuf.length = stringLength;
              for (i = 0; i < stringLength; ++i) {
                strBuf[i] = String.fromCharCode(font.getByte());
              }
              customNames.push(strBuf.join(''));
            }
            glyphNames = [];
            for (i = 0; i < numGlyphs; ++i) {
              var j = glyphNameIndexes[i];
              if (j < 258) {
                glyphNames.push(MacStandardGlyphOrdering[j]);
                continue;
              }
              glyphNames.push(customNames[j - 258]);
            }
            break;
          case 0x00030000:
            break;
          default:
            warn('Unknown/unsupported post table version ' + version);
            valid = false;
            if (properties.defaultEncoding) {
              glyphNames = properties.defaultEncoding;
            }
            break;
        }
        properties.glyphNames = glyphNames;
        return valid;
      }
      function readNameTable(nameTable) {
        var start = (font.start ? font.start : 0) + nameTable.offset;
        font.pos = start;
        var names = [[], []];
        var length = nameTable.length,
            end = start + length;
        var format = font.getUint16();
        var FORMAT_0_HEADER_LENGTH = 6;
        if (format !== 0 || length < FORMAT_0_HEADER_LENGTH) {
          return names;
        }
        var numRecords = font.getUint16();
        var stringsStart = font.getUint16();
        var records = [];
        var NAME_RECORD_LENGTH = 12;
        var i, ii;
        for (i = 0; i < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i++) {
          var r = {
            platform: font.getUint16(),
            encoding: font.getUint16(),
            language: font.getUint16(),
            name: font.getUint16(),
            length: font.getUint16(),
            offset: font.getUint16()
          };
          if (r.platform === 1 && r.encoding === 0 && r.language === 0 || r.platform === 3 && r.encoding === 1 && r.language === 0x409) {
            records.push(r);
          }
        }
        for (i = 0, ii = records.length; i < ii; i++) {
          var record = records[i];
          if (record.length <= 0) {
            continue;
          }
          var pos = start + stringsStart + record.offset;
          if (pos + record.length > end) {
            continue;
          }
          font.pos = pos;
          var nameIndex = record.name;
          if (record.encoding) {
            var str = '';
            for (var j = 0, jj = record.length; j < jj; j += 2) {
              str += String.fromCharCode(font.getUint16());
            }
            names[1][nameIndex] = str;
          } else {
            names[0][nameIndex] = bytesToString(font.getBytes(record.length));
          }
        }
        return names;
      }
      var TTOpsStackDeltas = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
      function sanitizeTTProgram(table, ttContext) {
        var data = table.data;
        var i = 0,
            j,
            n,
            b,
            funcId,
            pc,
            lastEndf = 0,
            lastDeff = 0;
        var stack = [];
        var callstack = [];
        var functionsCalled = [];
        var tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;
        var inFDEF = false,
            ifLevel = 0,
            inELSE = 0;
        for (var ii = data.length; i < ii;) {
          var op = data[i++];
          if (op === 0x40) {
            n = data[i++];
            if (inFDEF || inELSE) {
              i += n;
            } else {
              for (j = 0; j < n; j++) {
                stack.push(data[i++]);
              }
            }
          } else if (op === 0x41) {
            n = data[i++];
            if (inFDEF || inELSE) {
              i += n * 2;
            } else {
              for (j = 0; j < n; j++) {
                b = data[i++];
                stack.push(b << 8 | data[i++]);
              }
            }
          } else if ((op & 0xF8) === 0xB0) {
            n = op - 0xB0 + 1;
            if (inFDEF || inELSE) {
              i += n;
            } else {
              for (j = 0; j < n; j++) {
                stack.push(data[i++]);
              }
            }
          } else if ((op & 0xF8) === 0xB8) {
            n = op - 0xB8 + 1;
            if (inFDEF || inELSE) {
              i += n * 2;
            } else {
              for (j = 0; j < n; j++) {
                b = data[i++];
                stack.push(b << 8 | data[i++]);
              }
            }
          } else if (op === 0x2B && !tooComplexToFollowFunctions) {
            if (!inFDEF && !inELSE) {
              funcId = stack[stack.length - 1];
              ttContext.functionsUsed[funcId] = true;
              if (funcId in ttContext.functionsStackDeltas) {
                stack.length += ttContext.functionsStackDeltas[funcId];
              } else if (funcId in ttContext.functionsDefined && functionsCalled.indexOf(funcId) < 0) {
                callstack.push({
                  data: data,
                  i: i,
                  stackTop: stack.length - 1
                });
                functionsCalled.push(funcId);
                pc = ttContext.functionsDefined[funcId];
                if (!pc) {
                  warn('TT: CALL non-existent function');
                  ttContext.hintsValid = false;
                  return;
                }
                data = pc.data;
                i = pc.i;
              }
            }
          } else if (op === 0x2C && !tooComplexToFollowFunctions) {
            if (inFDEF || inELSE) {
              warn('TT: nested FDEFs not allowed');
              tooComplexToFollowFunctions = true;
            }
            inFDEF = true;
            lastDeff = i;
            funcId = stack.pop();
            ttContext.functionsDefined[funcId] = {
              data: data,
              i: i
            };
          } else if (op === 0x2D) {
            if (inFDEF) {
              inFDEF = false;
              lastEndf = i;
            } else {
              pc = callstack.pop();
              if (!pc) {
                warn('TT: ENDF bad stack');
                ttContext.hintsValid = false;
                return;
              }
              funcId = functionsCalled.pop();
              data = pc.data;
              i = pc.i;
              ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop;
            }
          } else if (op === 0x89) {
            if (inFDEF || inELSE) {
              warn('TT: nested IDEFs not allowed');
              tooComplexToFollowFunctions = true;
            }
            inFDEF = true;
            lastDeff = i;
          } else if (op === 0x58) {
            ++ifLevel;
          } else if (op === 0x1B) {
            inELSE = ifLevel;
          } else if (op === 0x59) {
            if (inELSE === ifLevel) {
              inELSE = 0;
            }
            --ifLevel;
          } else if (op === 0x1C) {
            if (!inFDEF && !inELSE) {
              var offset = stack[stack.length - 1];
              if (offset > 0) {
                i += offset - 1;
              }
            }
          }
          if (!inFDEF && !inELSE) {
            var stackDelta = op <= 0x8E ? TTOpsStackDeltas[op] : op >= 0xC0 && op <= 0xDF ? -1 : op >= 0xE0 ? -2 : 0;
            if (op >= 0x71 && op <= 0x75) {
              n = stack.pop();
              if (!isNaN(n)) {
                stackDelta = -n * 2;
              }
            }
            while (stackDelta < 0 && stack.length > 0) {
              stack.pop();
              stackDelta++;
            }
            while (stackDelta > 0) {
              stack.push(NaN);
              stackDelta--;
            }
          }
        }
        ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
        var content = [data];
        if (i > data.length) {
          content.push(new Uint8Array(i - data.length));
        }
        if (lastDeff > lastEndf) {
          warn('TT: complementing a missing function tail');
          content.push(new Uint8Array([0x22, 0x2D]));
        }
        foldTTTable(table, content);
      }
      function checkInvalidFunctions(ttContext, maxFunctionDefs) {
        if (ttContext.tooComplexToFollowFunctions) {
          return;
        }
        if (ttContext.functionsDefined.length > maxFunctionDefs) {
          warn('TT: more functions defined than expected');
          ttContext.hintsValid = false;
          return;
        }
        for (var j = 0, jj = ttContext.functionsUsed.length; j < jj; j++) {
          if (j > maxFunctionDefs) {
            warn('TT: invalid function id: ' + j);
            ttContext.hintsValid = false;
            return;
          }
          if (ttContext.functionsUsed[j] && !ttContext.functionsDefined[j]) {
            warn('TT: undefined function: ' + j);
            ttContext.hintsValid = false;
            return;
          }
        }
      }
      function foldTTTable(table, content) {
        if (content.length > 1) {
          var newLength = 0;
          var j, jj;
          for (j = 0, jj = content.length; j < jj; j++) {
            newLength += content[j].length;
          }
          newLength = newLength + 3 & ~3;
          var result = new Uint8Array(newLength);
          var pos = 0;
          for (j = 0, jj = content.length; j < jj; j++) {
            result.set(content[j], pos);
            pos += content[j].length;
          }
          table.data = result;
          table.length = newLength;
        }
      }
      function sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs) {
        var ttContext = {
          functionsDefined: [],
          functionsUsed: [],
          functionsStackDeltas: [],
          tooComplexToFollowFunctions: false,
          hintsValid: true
        };
        if (fpgm) {
          sanitizeTTProgram(fpgm, ttContext);
        }
        if (prep) {
          sanitizeTTProgram(prep, ttContext);
        }
        if (fpgm) {
          checkInvalidFunctions(ttContext, maxFunctionDefs);
        }
        if (cvt && cvt.length & 1) {
          var cvtData = new Uint8Array(cvt.length + 1);
          cvtData.set(cvt.data);
          cvt.data = cvtData;
        }
        return ttContext.hintsValid;
      }
      font = new Stream(new Uint8Array(font.getBytes()));
      var VALID_TABLES = ['OS/2', 'cmap', 'head', 'hhea', 'hmtx', 'maxp', 'name', 'post', 'loca', 'glyf', 'fpgm', 'prep', 'cvt ', 'CFF '];
      var header = readOpenTypeHeader(font);
      var numTables = header.numTables;
      var cff, cffFile;
      var tables = Object.create(null);
      tables['OS/2'] = null;
      tables['cmap'] = null;
      tables['head'] = null;
      tables['hhea'] = null;
      tables['hmtx'] = null;
      tables['maxp'] = null;
      tables['name'] = null;
      tables['post'] = null;
      var table;
      for (var i = 0; i < numTables; i++) {
        table = readTableEntry(font);
        if (VALID_TABLES.indexOf(table.tag) < 0) {
          continue;
        }
        if (table.length === 0) {
          continue;
        }
        tables[table.tag] = table;
      }
      var isTrueType = !tables['CFF '];
      if (!isTrueType) {
        if (header.version === 'OTTO' && !properties.composite || !tables['head'] || !tables['hhea'] || !tables['maxp'] || !tables['post']) {
          cffFile = new Stream(tables['CFF '].data);
          cff = new CFFFont(cffFile, properties);
          adjustWidths(properties);
          return this.convert(name, cff, properties);
        }
        delete tables['glyf'];
        delete tables['loca'];
        delete tables['fpgm'];
        delete tables['prep'];
        delete tables['cvt '];
        this.isOpenType = true;
      } else {
        if (!tables['loca']) {
          error('Required "loca" table is not found');
        }
        if (!tables['glyf']) {
          warn('Required "glyf" table is not found -- trying to recover.');
          tables['glyf'] = {
            tag: 'glyf',
            data: new Uint8Array(0)
          };
        }
        this.isOpenType = false;
      }
      if (!tables['maxp']) {
        error('Required "maxp" table is not found');
      }
      font.pos = (font.start || 0) + tables['maxp'].offset;
      var version = font.getInt32();
      var numGlyphs = font.getUint16();
      var maxFunctionDefs = 0;
      if (version >= 0x00010000 && tables['maxp'].length >= 22) {
        font.pos += 8;
        var maxZones = font.getUint16();
        if (maxZones > 2) {
          tables['maxp'].data[14] = 0;
          tables['maxp'].data[15] = 2;
        }
        font.pos += 4;
        maxFunctionDefs = font.getUint16();
      }
      var dupFirstEntry = false;
      if (properties.type === 'CIDFontType2' && properties.toUnicode && properties.toUnicode.get(0) > '\0') {
        dupFirstEntry = true;
        numGlyphs++;
        tables['maxp'].data[4] = numGlyphs >> 8;
        tables['maxp'].data[5] = numGlyphs & 255;
      }
      var hintsValid = sanitizeTTPrograms(tables['fpgm'], tables['prep'], tables['cvt '], maxFunctionDefs);
      if (!hintsValid) {
        delete tables['fpgm'];
        delete tables['prep'];
        delete tables['cvt '];
      }
      sanitizeMetrics(font, tables['hhea'], tables['hmtx'], numGlyphs);
      if (!tables['head']) {
        error('Required "head" table is not found');
      }
      sanitizeHead(tables['head'], numGlyphs, isTrueType ? tables['loca'].length : 0);
      var missingGlyphs = Object.create(null);
      if (isTrueType) {
        var isGlyphLocationsLong = int16(tables['head'].data[50], tables['head'].data[51]);
        missingGlyphs = sanitizeGlyphLocations(tables['loca'], tables['glyf'], numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry);
      }
      if (!tables['hhea']) {
        error('Required "hhea" table is not found');
      }
      if (tables['hhea'].data[10] === 0 && tables['hhea'].data[11] === 0) {
        tables['hhea'].data[10] = 0xFF;
        tables['hhea'].data[11] = 0xFF;
      }
      var metricsOverride = {
        unitsPerEm: int16(tables['head'].data[18], tables['head'].data[19]),
        yMax: int16(tables['head'].data[42], tables['head'].data[43]),
        yMin: signedInt16(tables['head'].data[38], tables['head'].data[39]),
        ascent: int16(tables['hhea'].data[4], tables['hhea'].data[5]),
        descent: signedInt16(tables['hhea'].data[6], tables['hhea'].data[7])
      };
      this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;
      this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;
      if (tables['post']) {
        var valid = readPostScriptTable(tables['post'], properties, numGlyphs);
        if (!valid) {
          tables['post'] = null;
        }
      }
      var charCodeToGlyphId = [],
          charCode;
      var toUnicode = properties.toUnicode,
          widths = properties.widths;
      var skipToUnicode = toUnicode instanceof IdentityToUnicodeMap || toUnicode.length === 0x10000;
      function hasGlyph(glyphId, charCode, widthCode) {
        if (!missingGlyphs[glyphId]) {
          return true;
        }
        if (!skipToUnicode && charCode >= 0 && toUnicode.has(charCode)) {
          return true;
        }
        if (widths && widthCode >= 0 && isNum(widths[widthCode])) {
          return true;
        }
        return false;
      }
      if (properties.composite) {
        var cidToGidMap = properties.cidToGidMap || [];
        var isCidToGidMapEmpty = cidToGidMap.length === 0;
        properties.cMap.forEach(function (charCode, cid) {
          assert(cid <= 0xffff, 'Max size of CID is 65,535');
          var glyphId = -1;
          if (isCidToGidMapEmpty) {
            glyphId = cid;
          } else if (cidToGidMap[cid] !== undefined) {
            glyphId = cidToGidMap[cid];
          }
          if (glyphId >= 0 && glyphId < numGlyphs && hasGlyph(glyphId, charCode, cid)) {
            charCodeToGlyphId[charCode] = glyphId;
          }
        });
        if (dupFirstEntry && (isCidToGidMapEmpty || !charCodeToGlyphId[0])) {
          charCodeToGlyphId[0] = numGlyphs - 1;
        }
      } else {
        var cmapTable = readCmapTable(tables['cmap'], font, this.isSymbolicFont, properties.hasEncoding);
        var cmapPlatformId = cmapTable.platformId;
        var cmapEncodingId = cmapTable.encodingId;
        var cmapMappings = cmapTable.mappings;
        var cmapMappingsLength = cmapMappings.length;
        if (properties.hasEncoding && (cmapPlatformId === 3 && cmapEncodingId === 1 || cmapPlatformId === 1 && cmapEncodingId === 0) || cmapPlatformId === -1 && cmapEncodingId === -1 && !!getEncoding(properties.baseEncodingName)) {
          var baseEncoding = [];
          if (properties.baseEncodingName === 'MacRomanEncoding' || properties.baseEncodingName === 'WinAnsiEncoding') {
            baseEncoding = getEncoding(properties.baseEncodingName);
          }
          var glyphsUnicodeMap = getGlyphsUnicode();
          for (charCode = 0; charCode < 256; charCode++) {
            var glyphName, standardGlyphName;
            if (this.differences && charCode in this.differences) {
              glyphName = this.differences[charCode];
            } else if (charCode in baseEncoding && baseEncoding[charCode] !== '') {
              glyphName = baseEncoding[charCode];
            } else {
              glyphName = StandardEncoding[charCode];
            }
            if (!glyphName) {
              continue;
            }
            standardGlyphName = recoverGlyphName(glyphName, glyphsUnicodeMap);
            var unicodeOrCharCode,
                isUnicode = false;
            if (cmapPlatformId === 3 && cmapEncodingId === 1) {
              unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName];
              isUnicode = true;
            } else if (cmapPlatformId === 1 && cmapEncodingId === 0) {
              unicodeOrCharCode = MacRomanEncoding.indexOf(standardGlyphName);
            }
            var found = false;
            for (i = 0; i < cmapMappingsLength; ++i) {
              if (cmapMappings[i].charCode !== unicodeOrCharCode) {
                continue;
              }
              var code = isUnicode ? charCode : unicodeOrCharCode;
              if (hasGlyph(cmapMappings[i].glyphId, code, -1)) {
                charCodeToGlyphId[charCode] = cmapMappings[i].glyphId;
                found = true;
                break;
              }
            }
            if (!found && properties.glyphNames) {
              var glyphId = properties.glyphNames.indexOf(glyphName);
              if (glyphId === -1 && standardGlyphName !== glyphName) {
                glyphId = properties.glyphNames.indexOf(standardGlyphName);
              }
              if (glyphId > 0 && hasGlyph(glyphId, -1, -1)) {
                charCodeToGlyphId[charCode] = glyphId;
                found = true;
              }
            }
            if (!found) {
              charCodeToGlyphId[charCode] = 0;
            }
          }
        } else if (cmapPlatformId === 0 && cmapEncodingId === 0) {
          for (i = 0; i < cmapMappingsLength; ++i) {
            charCodeToGlyphId[cmapMappings[i].charCode] = cmapMappings[i].glyphId;
          }
        } else {
          for (i = 0; i < cmapMappingsLength; ++i) {
            charCode = cmapMappings[i].charCode & 0xFF;
            charCodeToGlyphId[charCode] = cmapMappings[i].glyphId;
          }
        }
      }
      if (charCodeToGlyphId.length === 0) {
        charCodeToGlyphId[0] = 0;
      }
      var newMapping = adjustMapping(charCodeToGlyphId, properties);
      this.toFontChar = newMapping.toFontChar;
      tables['cmap'] = {
        tag: 'cmap',
        data: createCmapTable(newMapping.charCodeToGlyphId, numGlyphs)
      };
      if (!tables['OS/2'] || !validateOS2Table(tables['OS/2'])) {
        tables['OS/2'] = {
          tag: 'OS/2',
          data: createOS2Table(properties, newMapping.charCodeToGlyphId, metricsOverride)
        };
      }
      if (!tables['post']) {
        tables['post'] = {
          tag: 'post',
          data: createPostTable(properties)
        };
      }
      if (!isTrueType) {
        try {
          cffFile = new Stream(tables['CFF '].data);
          var parser = new CFFParser(cffFile, properties, SEAC_ANALYSIS_ENABLED);
          cff = parser.parse();
          var compiler = new CFFCompiler(cff);
          tables['CFF '].data = compiler.compile();
        } catch (e) {
          warn('Failed to compile font ' + properties.loadedName);
        }
      }
      if (!tables['name']) {
        tables['name'] = {
          tag: 'name',
          data: createNameTable(this.name)
        };
      } else {
        var namePrototype = readNameTable(tables['name']);
        tables['name'].data = createNameTable(name, namePrototype);
      }
      var builder = new OpenTypeFileBuilder(header.version);
      for (var tableTag in tables) {
        builder.addTable(tableTag, tables[tableTag].data);
      }
      return builder.toArray();
    },
    convert: function Font_convert(fontName, font, properties) {
      properties.fixedPitch = false;
      if (properties.builtInEncoding) {
        adjustToUnicode(properties, properties.builtInEncoding);
      }
      var mapping = font.getGlyphMapping(properties);
      var newMapping = adjustMapping(mapping, properties);
      this.toFontChar = newMapping.toFontChar;
      var numGlyphs = font.numGlyphs;
      function getCharCodes(charCodeToGlyphId, glyphId) {
        var charCodes = null;
        for (var charCode in charCodeToGlyphId) {
          if (glyphId === charCodeToGlyphId[charCode]) {
            if (!charCodes) {
              charCodes = [];
            }
            charCodes.push(charCode | 0);
          }
        }
        return charCodes;
      }
      function createCharCode(charCodeToGlyphId, glyphId) {
        for (var charCode in charCodeToGlyphId) {
          if (glyphId === charCodeToGlyphId[charCode]) {
            return charCode | 0;
          }
        }
        newMapping.charCodeToGlyphId[newMapping.nextAvailableFontCharCode] = glyphId;
        return newMapping.nextAvailableFontCharCode++;
      }
      var seacs = font.seacs;
      if (SEAC_ANALYSIS_ENABLED && seacs && seacs.length) {
        var matrix = properties.fontMatrix || FONT_IDENTITY_MATRIX;
        var charset = font.getCharset();
        var seacMap = Object.create(null);
        for (var glyphId in seacs) {
          glyphId |= 0;
          var seac = seacs[glyphId];
          var baseGlyphName = StandardEncoding[seac[2]];
          var accentGlyphName = StandardEncoding[seac[3]];
          var baseGlyphId = charset.indexOf(baseGlyphName);
          var accentGlyphId = charset.indexOf(accentGlyphName);
          if (baseGlyphId < 0 || accentGlyphId < 0) {
            continue;
          }
          var accentOffset = {
            x: seac[0] * matrix[0] + seac[1] * matrix[2] + matrix[4],
            y: seac[0] * matrix[1] + seac[1] * matrix[3] + matrix[5]
          };
          var charCodes = getCharCodes(mapping, glyphId);
          if (!charCodes) {
            continue;
          }
          for (var i = 0, ii = charCodes.length; i < ii; i++) {
            var charCode = charCodes[i];
            var charCodeToGlyphId = newMapping.charCodeToGlyphId;
            var baseFontCharCode = createCharCode(charCodeToGlyphId, baseGlyphId);
            var accentFontCharCode = createCharCode(charCodeToGlyphId, accentGlyphId);
            seacMap[charCode] = {
              baseFontCharCode: baseFontCharCode,
              accentFontCharCode: accentFontCharCode,
              accentOffset: accentOffset
            };
          }
        }
        properties.seacMap = seacMap;
      }
      var unitsPerEm = 1 / (properties.fontMatrix || FONT_IDENTITY_MATRIX)[0];
      var builder = new OpenTypeFileBuilder('\x4F\x54\x54\x4F');
      builder.addTable('CFF ', font.data);
      builder.addTable('OS/2', createOS2Table(properties, newMapping.charCodeToGlyphId));
      builder.addTable('cmap', createCmapTable(newMapping.charCodeToGlyphId, numGlyphs));
      builder.addTable('head', '\x00\x01\x00\x00' + '\x00\x00\x10\x00' + '\x00\x00\x00\x00' + '\x5F\x0F\x3C\xF5' + '\x00\x00' + safeString16(unitsPerEm) + '\x00\x00\x00\x00\x9e\x0b\x7e\x27' + '\x00\x00\x00\x00\x9e\x0b\x7e\x27' + '\x00\x00' + safeString16(properties.descent) + '\x0F\xFF' + safeString16(properties.ascent) + string16(properties.italicAngle ? 2 : 0) + '\x00\x11' + '\x00\x00' + '\x00\x00' + '\x00\x00');
      builder.addTable('hhea', '\x00\x01\x00\x00' + safeString16(properties.ascent) + safeString16(properties.descent) + '\x00\x00' + '\xFF\xFF' + '\x00\x00' + '\x00\x00' + '\x00\x00' + safeString16(properties.capHeight) + safeString16(Math.tan(properties.italicAngle) * properties.xHeight) + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + '\x00\x00' + string16(numGlyphs));
      builder.addTable('hmtx', function fontFieldsHmtx() {
        var charstrings = font.charstrings;
        var cffWidths = font.cff ? font.cff.widths : null;
        var hmtx = '\x00\x00\x00\x00';
        for (var i = 1, ii = numGlyphs; i < ii; i++) {
          var width = 0;
          if (charstrings) {
            var charstring = charstrings[i - 1];
            width = 'width' in charstring ? charstring.width : 0;
          } else if (cffWidths) {
            width = Math.ceil(cffWidths[i] || 0);
          }
          hmtx += string16(width) + string16(0);
        }
        return hmtx;
      }());
      builder.addTable('maxp', '\x00\x00\x50\x00' + string16(numGlyphs));
      builder.addTable('name', createNameTable(fontName));
      builder.addTable('post', createPostTable(properties));
      return builder.toArray();
    },
    get spaceWidth() {
      if ('_shadowWidth' in this) {
        return this._shadowWidth;
      }
      var possibleSpaceReplacements = ['space', 'minus', 'one', 'i', 'I'];
      var width;
      for (var i = 0, ii = possibleSpaceReplacements.length; i < ii; i++) {
        var glyphName = possibleSpaceReplacements[i];
        if (glyphName in this.widths) {
          width = this.widths[glyphName];
          break;
        }
        var glyphsUnicodeMap = getGlyphsUnicode();
        var glyphUnicode = glyphsUnicodeMap[glyphName];
        var charcode = 0;
        if (this.composite) {
          if (this.cMap.contains(glyphUnicode)) {
            charcode = this.cMap.lookup(glyphUnicode);
          }
        }
        if (!charcode && this.toUnicode) {
          charcode = this.toUnicode.charCodeOf(glyphUnicode);
        }
        if (charcode <= 0) {
          charcode = glyphUnicode;
        }
        width = this.widths[charcode];
        if (width) {
          break;
        }
      }
      width = width || this.defaultWidth;
      this._shadowWidth = width;
      return width;
    },
    charToGlyph: function Font_charToGlyph(charcode, isSpace) {
      var fontCharCode, width, operatorListId;
      var widthCode = charcode;
      if (this.cMap && this.cMap.contains(charcode)) {
        widthCode = this.cMap.lookup(charcode);
      }
      width = this.widths[widthCode];
      width = isNum(width) ? width : this.defaultWidth;
      var vmetric = this.vmetrics && this.vmetrics[widthCode];
      var unicode = this.toUnicode.get(charcode) || charcode;
      if (typeof unicode === 'number') {
        unicode = String.fromCharCode(unicode);
      }
      var isInFont = charcode in this.toFontChar;
      fontCharCode = this.toFontChar[charcode] || charcode;
      if (this.missingFile) {
        fontCharCode = mapSpecialUnicodeValues(fontCharCode);
      }
      if (this.isType3Font) {
        operatorListId = fontCharCode;
      }
      var accent = null;
      if (this.seacMap && this.seacMap[charcode]) {
        isInFont = true;
        var seac = this.seacMap[charcode];
        fontCharCode = seac.baseFontCharCode;
        accent = {
          fontChar: String.fromCharCode(seac.accentFontCharCode),
          offset: seac.accentOffset
        };
      }
      var fontChar = String.fromCharCode(fontCharCode);
      var glyph = this.glyphCache[charcode];
      if (!glyph || !glyph.matchesForCache(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont)) {
        glyph = new Glyph(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont);
        this.glyphCache[charcode] = glyph;
      }
      return glyph;
    },
    charsToGlyphs: function Font_charsToGlyphs(chars) {
      var charsCache = this.charsCache;
      var glyphs, glyph, charcode;
      if (charsCache) {
        glyphs = charsCache[chars];
        if (glyphs) {
          return glyphs;
        }
      }
      if (!charsCache) {
        charsCache = this.charsCache = Object.create(null);
      }
      glyphs = [];
      var charsCacheKey = chars;
      var i = 0,
          ii;
      if (this.cMap) {
        var c = Object.create(null);
        while (i < chars.length) {
          this.cMap.readCharCode(chars, i, c);
          charcode = c.charcode;
          var length = c.length;
          i += length;
          var isSpace = length === 1 && chars.charCodeAt(i - 1) === 0x20;
          glyph = this.charToGlyph(charcode, isSpace);
          glyphs.push(glyph);
        }
      } else {
        for (i = 0, ii = chars.length; i < ii; ++i) {
          charcode = chars.charCodeAt(i);
          glyph = this.charToGlyph(charcode, charcode === 0x20);
          glyphs.push(glyph);
        }
      }
      return charsCache[charsCacheKey] = glyphs;
    }
  };
  return Font;
}();
var ErrorFont = function ErrorFontClosure() {
  function ErrorFont(error) {
    this.error = error;
    this.loadedName = 'g_font_error';
    this.loading = false;
  }
  ErrorFont.prototype = {
    charsToGlyphs: function ErrorFont_charsToGlyphs() {
      return [];
    },
    exportData: function ErrorFont_exportData() {
      return { error: this.error };
    }
  };
  return ErrorFont;
}();
function type1FontGlyphMapping(properties, builtInEncoding, glyphNames) {
  var charCodeToGlyphId = Object.create(null);
  var glyphId, charCode, baseEncoding;
  var isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
  if (properties.baseEncodingName) {
    baseEncoding = getEncoding(properties.baseEncodingName);
    for (charCode = 0; charCode < baseEncoding.length; charCode++) {
      glyphId = glyphNames.indexOf(baseEncoding[charCode]);
      if (glyphId >= 0) {
        charCodeToGlyphId[charCode] = glyphId;
      } else {
        charCodeToGlyphId[charCode] = 0;
      }
    }
  } else if (isSymbolicFont) {
    for (charCode in builtInEncoding) {
      charCodeToGlyphId[charCode] = builtInEncoding[charCode];
    }
  } else {
    baseEncoding = StandardEncoding;
    for (charCode = 0; charCode < baseEncoding.length; charCode++) {
      glyphId = glyphNames.indexOf(baseEncoding[charCode]);
      if (glyphId >= 0) {
        charCodeToGlyphId[charCode] = glyphId;
      } else {
        charCodeToGlyphId[charCode] = 0;
      }
    }
  }
  var differences = properties.differences,
      glyphsUnicodeMap;
  if (differences) {
    for (charCode in differences) {
      var glyphName = differences[charCode];
      glyphId = glyphNames.indexOf(glyphName);
      if (glyphId === -1) {
        if (!glyphsUnicodeMap) {
          glyphsUnicodeMap = getGlyphsUnicode();
        }
        var standardGlyphName = recoverGlyphName(glyphName, glyphsUnicodeMap);
        if (standardGlyphName !== glyphName) {
          glyphId = glyphNames.indexOf(standardGlyphName);
        }
      }
      if (glyphId >= 0) {
        charCodeToGlyphId[charCode] = glyphId;
      } else {
        charCodeToGlyphId[charCode] = 0;
      }
    }
  }
  return charCodeToGlyphId;
}
var Type1Font = function Type1FontClosure() {
  function findBlock(streamBytes, signature, startIndex) {
    var streamBytesLength = streamBytes.length;
    var signatureLength = signature.length;
    var scanLength = streamBytesLength - signatureLength;
    var i = startIndex,
        j,
        found = false;
    while (i < scanLength) {
      j = 0;
      while (j < signatureLength && streamBytes[i + j] === signature[j]) {
        j++;
      }
      if (j >= signatureLength) {
        i += j;
        while (i < streamBytesLength && isSpace(streamBytes[i])) {
          i++;
        }
        found = true;
        break;
      }
      i++;
    }
    return {
      found: found,
      length: i
    };
  }
  function getHeaderBlock(stream, suggestedLength) {
    var EEXEC_SIGNATURE = [0x65, 0x65, 0x78, 0x65, 0x63];
    var streamStartPos = stream.pos;
    var headerBytes, headerBytesLength, block;
    try {
      headerBytes = stream.getBytes(suggestedLength);
      headerBytesLength = headerBytes.length;
    } catch (ex) {
      if (ex instanceof MissingDataException) {
        throw ex;
      }
    }
    if (headerBytesLength === suggestedLength) {
      block = findBlock(headerBytes, EEXEC_SIGNATURE, suggestedLength - 2 * EEXEC_SIGNATURE.length);
      if (block.found && block.length === suggestedLength) {
        return {
          stream: new Stream(headerBytes),
          length: suggestedLength
        };
      }
    }
    warn('Invalid "Length1" property in Type1 font -- trying to recover.');
    stream.pos = streamStartPos;
    var SCAN_BLOCK_LENGTH = 2048;
    var actualLength;
    while (true) {
      var scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);
      block = findBlock(scanBytes, EEXEC_SIGNATURE, 0);
      if (block.length === 0) {
        break;
      }
      stream.pos += block.length;
      if (block.found) {
        actualLength = stream.pos - streamStartPos;
        break;
      }
    }
    stream.pos = streamStartPos;
    if (actualLength) {
      return {
        stream: new Stream(stream.getBytes(actualLength)),
        length: actualLength
      };
    }
    warn('Unable to recover "Length1" property in Type1 font -- using as is.');
    return {
      stream: new Stream(stream.getBytes(suggestedLength)),
      length: suggestedLength
    };
  }
  function getEexecBlock(stream, suggestedLength) {
    var eexecBytes = stream.getBytes();
    return {
      stream: new Stream(eexecBytes),
      length: eexecBytes.length
    };
  }
  function Type1Font(name, file, properties) {
    var PFB_HEADER_SIZE = 6;
    var headerBlockLength = properties.length1;
    var eexecBlockLength = properties.length2;
    var pfbHeader = file.peekBytes(PFB_HEADER_SIZE);
    var pfbHeaderPresent = pfbHeader[0] === 0x80 && pfbHeader[1] === 0x01;
    if (pfbHeaderPresent) {
      file.skip(PFB_HEADER_SIZE);
      headerBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
    }
    var headerBlock = getHeaderBlock(file, headerBlockLength);
    headerBlockLength = headerBlock.length;
    var headerBlockParser = new Type1Parser(headerBlock.stream, false, SEAC_ANALYSIS_ENABLED);
    headerBlockParser.extractFontHeader(properties);
    if (pfbHeaderPresent) {
      pfbHeader = file.getBytes(PFB_HEADER_SIZE);
      eexecBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
    }
    var eexecBlock = getEexecBlock(file, eexecBlockLength);
    eexecBlockLength = eexecBlock.length;
    var eexecBlockParser = new Type1Parser(eexecBlock.stream, true, SEAC_ANALYSIS_ENABLED);
    var data = eexecBlockParser.extractFontProgram();
    for (var info in data.properties) {
      properties[info] = data.properties[info];
    }
    var charstrings = data.charstrings;
    var type2Charstrings = this.getType2Charstrings(charstrings);
    var subrs = this.getType2Subrs(data.subrs);
    this.charstrings = charstrings;
    this.data = this.wrap(name, type2Charstrings, this.charstrings, subrs, properties);
    this.seacs = this.getSeacs(data.charstrings);
  }
  Type1Font.prototype = {
    get numGlyphs() {
      return this.charstrings.length + 1;
    },
    getCharset: function Type1Font_getCharset() {
      var charset = ['.notdef'];
      var charstrings = this.charstrings;
      for (var glyphId = 0; glyphId < charstrings.length; glyphId++) {
        charset.push(charstrings[glyphId].glyphName);
      }
      return charset;
    },
    getGlyphMapping: function Type1Font_getGlyphMapping(properties) {
      var charstrings = this.charstrings;
      var glyphNames = ['.notdef'],
          glyphId;
      for (glyphId = 0; glyphId < charstrings.length; glyphId++) {
        glyphNames.push(charstrings[glyphId].glyphName);
      }
      var encoding = properties.builtInEncoding;
      if (encoding) {
        var builtInEncoding = Object.create(null);
        for (var charCode in encoding) {
          glyphId = glyphNames.indexOf(encoding[charCode]);
          if (glyphId >= 0) {
            builtInEncoding[charCode] = glyphId;
          }
        }
      }
      return type1FontGlyphMapping(properties, builtInEncoding, glyphNames);
    },
    getSeacs: function Type1Font_getSeacs(charstrings) {
      var i, ii;
      var seacMap = [];
      for (i = 0, ii = charstrings.length; i < ii; i++) {
        var charstring = charstrings[i];
        if (charstring.seac) {
          seacMap[i + 1] = charstring.seac;
        }
      }
      return seacMap;
    },
    getType2Charstrings: function Type1Font_getType2Charstrings(type1Charstrings) {
      var type2Charstrings = [];
      for (var i = 0, ii = type1Charstrings.length; i < ii; i++) {
        type2Charstrings.push(type1Charstrings[i].charstring);
      }
      return type2Charstrings;
    },
    getType2Subrs: function Type1Font_getType2Subrs(type1Subrs) {
      var bias = 0;
      var count = type1Subrs.length;
      if (count < 1133) {
        bias = 107;
      } else if (count < 33769) {
        bias = 1131;
      } else {
        bias = 32768;
      }
      var type2Subrs = [];
      var i;
      for (i = 0; i < bias; i++) {
        type2Subrs.push([0x0B]);
      }
      for (i = 0; i < count; i++) {
        type2Subrs.push(type1Subrs[i]);
      }
      return type2Subrs;
    },
    wrap: function Type1Font_wrap(name, glyphs, charstrings, subrs, properties) {
      var cff = new CFF();
      cff.header = new CFFHeader(1, 0, 4, 4);
      cff.names = [name];
      var topDict = new CFFTopDict();
      topDict.setByName('version', 391);
      topDict.setByName('Notice', 392);
      topDict.setByName('FullName', 393);
      topDict.setByName('FamilyName', 394);
      topDict.setByName('Weight', 395);
      topDict.setByName('Encoding', null);
      topDict.setByName('FontMatrix', properties.fontMatrix);
      topDict.setByName('FontBBox', properties.bbox);
      topDict.setByName('charset', null);
      topDict.setByName('CharStrings', null);
      topDict.setByName('Private', null);
      cff.topDict = topDict;
      var strings = new CFFStrings();
      strings.add('Version 0.11');
      strings.add('See original notice');
      strings.add(name);
      strings.add(name);
      strings.add('Medium');
      cff.strings = strings;
      cff.globalSubrIndex = new CFFIndex();
      var count = glyphs.length;
      var charsetArray = [0];
      var i, ii;
      for (i = 0; i < count; i++) {
        var index = CFFStandardStrings.indexOf(charstrings[i].glyphName);
        if (index === -1) {
          index = 0;
        }
        charsetArray.push(index >> 8 & 0xff, index & 0xff);
      }
      cff.charset = new CFFCharset(false, 0, [], charsetArray);
      var charStringsIndex = new CFFIndex();
      charStringsIndex.add([0x8B, 0x0E]);
      for (i = 0; i < count; i++) {
        var glyph = glyphs[i];
        if (glyph.length === 0) {
          charStringsIndex.add([0x8B, 0x0E]);
          continue;
        }
        charStringsIndex.add(glyph);
      }
      cff.charStrings = charStringsIndex;
      var privateDict = new CFFPrivateDict();
      privateDict.setByName('Subrs', null);
      var fields = ['BlueValues', 'OtherBlues', 'FamilyBlues', 'FamilyOtherBlues', 'StemSnapH', 'StemSnapV', 'BlueShift', 'BlueFuzz', 'BlueScale', 'LanguageGroup', 'ExpansionFactor', 'ForceBold', 'StdHW', 'StdVW'];
      for (i = 0, ii = fields.length; i < ii; i++) {
        var field = fields[i];
        if (!(field in properties.privateData)) {
          continue;
        }
        var value = properties.privateData[field];
        if (isArray(value)) {
          for (var j = value.length - 1; j > 0; j--) {
            value[j] -= value[j - 1];
          }
        }
        privateDict.setByName(field, value);
      }
      cff.topDict.privateDict = privateDict;
      var subrIndex = new CFFIndex();
      for (i = 0, ii = subrs.length; i < ii; i++) {
        subrIndex.add(subrs[i]);
      }
      privateDict.subrsIndex = subrIndex;
      var compiler = new CFFCompiler(cff);
      return compiler.compile();
    }
  };
  return Type1Font;
}();
var CFFFont = function CFFFontClosure() {
  function CFFFont(file, properties) {
    this.properties = properties;
    var parser = new CFFParser(file, properties, SEAC_ANALYSIS_ENABLED);
    this.cff = parser.parse();
    var compiler = new CFFCompiler(this.cff);
    this.seacs = this.cff.seacs;
    try {
      this.data = compiler.compile();
    } catch (e) {
      warn('Failed to compile font ' + properties.loadedName);
      this.data = file;
    }
  }
  CFFFont.prototype = {
    get numGlyphs() {
      return this.cff.charStrings.count;
    },
    getCharset: function CFFFont_getCharset() {
      return this.cff.charset.charset;
    },
    getGlyphMapping: function CFFFont_getGlyphMapping() {
      var cff = this.cff;
      var properties = this.properties;
      var charsets = cff.charset.charset;
      var charCodeToGlyphId;
      var glyphId;
      if (properties.composite) {
        charCodeToGlyphId = Object.create(null);
        if (cff.isCIDFont) {
          for (glyphId = 0; glyphId < charsets.length; glyphId++) {
            var cid = charsets[glyphId];
            var charCode = properties.cMap.charCodeOf(cid);
            charCodeToGlyphId[charCode] = glyphId;
          }
        } else {
          for (glyphId = 0; glyphId < cff.charStrings.count; glyphId++) {
            charCodeToGlyphId[glyphId] = glyphId;
          }
        }
        return charCodeToGlyphId;
      }
      var encoding = cff.encoding ? cff.encoding.encoding : null;
      charCodeToGlyphId = type1FontGlyphMapping(properties, encoding, charsets);
      return charCodeToGlyphId;
    }
  };
  return CFFFont;
}();
(function checkSeacSupport() {
  if (typeof navigator !== 'undefined' && /Windows/.test(navigator.userAgent)) {
    SEAC_ANALYSIS_ENABLED = true;
  }
})();
(function checkChromeWindows() {
  if (typeof navigator !== 'undefined' && /Windows.*Chrome/.test(navigator.userAgent)) {
    SKIP_PRIVATE_USE_RANGE_F000_TO_F01F = true;
  }
})();
exports.SEAC_ANALYSIS_ENABLED = SEAC_ANALYSIS_ENABLED;
exports.PRIVATE_USE_OFFSET_START = PRIVATE_USE_OFFSET_START;
exports.PRIVATE_USE_OFFSET_END = PRIVATE_USE_OFFSET_END;
exports.ErrorFont = ErrorFont;
exports.Font = Font;
exports.FontFlags = FontFlags;
exports.IdentityToUnicodeMap = IdentityToUnicodeMap;
exports.ProblematicCharRanges = ProblematicCharRanges;
exports.ToUnicodeMap = ToUnicodeMap;
exports.getFontType = getFontType;

/***/ }),
/* 27 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var corePrimitives = __w_pdfjs_require__(1);
var coreColorSpace = __w_pdfjs_require__(3);
var coreStream = __w_pdfjs_require__(2);
var coreJpx = __w_pdfjs_require__(15);
var ImageKind = sharedUtil.ImageKind;
var assert = sharedUtil.assert;
var error = sharedUtil.error;
var info = sharedUtil.info;
var isArray = sharedUtil.isArray;
var warn = sharedUtil.warn;
var Name = corePrimitives.Name;
var isStream = corePrimitives.isStream;
var ColorSpace = coreColorSpace.ColorSpace;
var DecodeStream = coreStream.DecodeStream;
var JpegStream = coreStream.JpegStream;
var JpxImage = coreJpx.JpxImage;
var PDFImage = function PDFImageClosure() {
  function handleImageData(image, nativeDecoder) {
    if (nativeDecoder && nativeDecoder.canDecode(image)) {
      return nativeDecoder.decode(image);
    }
    return Promise.resolve(image);
  }
  function decodeAndClamp(value, addend, coefficient, max) {
    value = addend + value * coefficient;
    return value < 0 ? 0 : value > max ? max : value;
  }
  function resizeImageMask(src, bpc, w1, h1, w2, h2) {
    var length = w2 * h2;
    var dest = bpc <= 8 ? new Uint8Array(length) : bpc <= 16 ? new Uint16Array(length) : new Uint32Array(length);
    var xRatio = w1 / w2;
    var yRatio = h1 / h2;
    var i,
        j,
        py,
        newIndex = 0,
        oldIndex;
    var xScaled = new Uint16Array(w2);
    var w1Scanline = w1;
    for (i = 0; i < w2; i++) {
      xScaled[i] = Math.floor(i * xRatio);
    }
    for (i = 0; i < h2; i++) {
      py = Math.floor(i * yRatio) * w1Scanline;
      for (j = 0; j < w2; j++) {
        oldIndex = py + xScaled[j];
        dest[newIndex++] = src[oldIndex];
      }
    }
    return dest;
  }
  function PDFImage(xref, res, image, inline, smask, mask, isMask) {
    this.image = image;
    var dict = image.dict;
    if (dict.has('Filter')) {
      var filter = dict.get('Filter').name;
      if (filter === 'JPXDecode') {
        var jpxImage = new JpxImage();
        jpxImage.parseImageProperties(image.stream);
        image.stream.reset();
        image.bitsPerComponent = jpxImage.bitsPerComponent;
        image.numComps = jpxImage.componentsCount;
      } else if (filter === 'JBIG2Decode') {
        image.bitsPerComponent = 1;
        image.numComps = 1;
      }
    }
    this.width = dict.get('Width', 'W');
    this.height = dict.get('Height', 'H');
    if (this.width < 1 || this.height < 1) {
      error('Invalid image width: ' + this.width + ' or height: ' + this.height);
    }
    this.interpolate = dict.get('Interpolate', 'I') || false;
    this.imageMask = dict.get('ImageMask', 'IM') || false;
    this.matte = dict.get('Matte') || false;
    var bitsPerComponent = image.bitsPerComponent;
    if (!bitsPerComponent) {
      bitsPerComponent = dict.get('BitsPerComponent', 'BPC');
      if (!bitsPerComponent) {
        if (this.imageMask) {
          bitsPerComponent = 1;
        } else {
          error('Bits per component missing in image: ' + this.imageMask);
        }
      }
    }
    this.bpc = bitsPerComponent;
    if (!this.imageMask) {
      var colorSpace = dict.get('ColorSpace', 'CS');
      if (!colorSpace) {
        info('JPX images (which do not require color spaces)');
        switch (image.numComps) {
          case 1:
            colorSpace = Name.get('DeviceGray');
            break;
          case 3:
            colorSpace = Name.get('DeviceRGB');
            break;
          case 4:
            colorSpace = Name.get('DeviceCMYK');
            break;
          default:
            error('JPX images with ' + this.numComps + ' color components not supported.');
        }
      }
      this.colorSpace = ColorSpace.parse(colorSpace, xref, res);
      this.numComps = this.colorSpace.numComps;
    }
    this.decode = dict.getArray('Decode', 'D');
    this.needsDecode = false;
    if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode) || isMask && !ColorSpace.isDefaultDecode(this.decode, 1))) {
      this.needsDecode = true;
      var max = (1 << bitsPerComponent) - 1;
      this.decodeCoefficients = [];
      this.decodeAddends = [];
      for (var i = 0, j = 0; i < this.decode.length; i += 2, ++j) {
        var dmin = this.decode[i];
        var dmax = this.decode[i + 1];
        this.decodeCoefficients[j] = dmax - dmin;
        this.decodeAddends[j] = max * dmin;
      }
    }
    if (smask) {
      this.smask = new PDFImage(xref, res, smask, false);
    } else if (mask) {
      if (isStream(mask)) {
        var maskDict = mask.dict,
            imageMask = maskDict.get('ImageMask', 'IM');
        if (!imageMask) {
          warn('Ignoring /Mask in image without /ImageMask.');
        } else {
          this.mask = new PDFImage(xref, res, mask, false, null, null, true);
        }
      } else {
        this.mask = mask;
      }
    }
  }
  PDFImage.buildImage = function PDFImage_buildImage(handler, xref, res, image, inline, nativeDecoder) {
    var imagePromise = handleImageData(image, nativeDecoder);
    var smaskPromise;
    var maskPromise;
    var smask = image.dict.get('SMask');
    var mask = image.dict.get('Mask');
    if (smask) {
      smaskPromise = handleImageData(smask, nativeDecoder);
      maskPromise = Promise.resolve(null);
    } else {
      smaskPromise = Promise.resolve(null);
      if (mask) {
        if (isStream(mask)) {
          maskPromise = handleImageData(mask, nativeDecoder);
        } else if (isArray(mask)) {
          maskPromise = Promise.resolve(mask);
        } else {
          warn('Unsupported mask format.');
          maskPromise = Promise.resolve(null);
        }
      } else {
        maskPromise = Promise.resolve(null);
      }
    }
    return Promise.all([imagePromise, smaskPromise, maskPromise]).then(function (results) {
      var imageData = results[0];
      var smaskData = results[1];
      var maskData = results[2];
      return new PDFImage(xref, res, imageData, inline, smaskData, maskData);
    });
  };
  PDFImage.createMask = function PDFImage_createMask(imgArray, width, height, imageIsFromDecodeStream, inverseDecode) {
    var computedLength = (width + 7 >> 3) * height;
    var actualLength = imgArray.byteLength;
    var haveFullData = computedLength === actualLength;
    var data, i;
    if (imageIsFromDecodeStream && (!inverseDecode || haveFullData)) {
      data = imgArray;
    } else if (!inverseDecode) {
      data = new Uint8Array(actualLength);
      data.set(imgArray);
    } else {
      data = new Uint8Array(computedLength);
      data.set(imgArray);
      for (i = actualLength; i < computedLength; i++) {
        data[i] = 0xff;
      }
    }
    if (inverseDecode) {
      for (i = 0; i < actualLength; i++) {
        data[i] = ~data[i];
      }
    }
    return {
      data: data,
      width: width,
      height: height
    };
  };
  PDFImage.prototype = {
    get drawWidth() {
      return Math.max(this.width, this.smask && this.smask.width || 0, this.mask && this.mask.width || 0);
    },
    get drawHeight() {
      return Math.max(this.height, this.smask && this.smask.height || 0, this.mask && this.mask.height || 0);
    },
    decodeBuffer: function PDFImage_decodeBuffer(buffer) {
      var bpc = this.bpc;
      var numComps = this.numComps;
      var decodeAddends = this.decodeAddends;
      var decodeCoefficients = this.decodeCoefficients;
      var max = (1 << bpc) - 1;
      var i, ii;
      if (bpc === 1) {
        for (i = 0, ii = buffer.length; i < ii; i++) {
          buffer[i] = +!buffer[i];
        }
        return;
      }
      var index = 0;
      for (i = 0, ii = this.width * this.height; i < ii; i++) {
        for (var j = 0; j < numComps; j++) {
          buffer[index] = decodeAndClamp(buffer[index], decodeAddends[j], decodeCoefficients[j], max);
          index++;
        }
      }
    },
    getComponents: function PDFImage_getComponents(buffer) {
      var bpc = this.bpc;
      if (bpc === 8) {
        return buffer;
      }
      var width = this.width;
      var height = this.height;
      var numComps = this.numComps;
      var length = width * height * numComps;
      var bufferPos = 0;
      var output = bpc <= 8 ? new Uint8Array(length) : bpc <= 16 ? new Uint16Array(length) : new Uint32Array(length);
      var rowComps = width * numComps;
      var max = (1 << bpc) - 1;
      var i = 0,
          ii,
          buf;
      if (bpc === 1) {
        var mask, loop1End, loop2End;
        for (var j = 0; j < height; j++) {
          loop1End = i + (rowComps & ~7);
          loop2End = i + rowComps;
          while (i < loop1End) {
            buf = buffer[bufferPos++];
            output[i] = buf >> 7 & 1;
            output[i + 1] = buf >> 6 & 1;
            output[i + 2] = buf >> 5 & 1;
            output[i + 3] = buf >> 4 & 1;
            output[i + 4] = buf >> 3 & 1;
            output[i + 5] = buf >> 2 & 1;
            output[i + 6] = buf >> 1 & 1;
            output[i + 7] = buf & 1;
            i += 8;
          }
          if (i < loop2End) {
            buf = buffer[bufferPos++];
            mask = 128;
            while (i < loop2End) {
              output[i++] = +!!(buf & mask);
              mask >>= 1;
            }
          }
        }
      } else {
        var bits = 0;
        buf = 0;
        for (i = 0, ii = length; i < ii; ++i) {
          if (i % rowComps === 0) {
            buf = 0;
            bits = 0;
          }
          while (bits < bpc) {
            buf = buf << 8 | buffer[bufferPos++];
            bits += 8;
          }
          var remainingBits = bits - bpc;
          var value = buf >> remainingBits;
          output[i] = value < 0 ? 0 : value > max ? max : value;
          buf = buf & (1 << remainingBits) - 1;
          bits = remainingBits;
        }
      }
      return output;
    },
    fillOpacity: function PDFImage_fillOpacity(rgbaBuf, width, height, actualHeight, image) {
      var smask = this.smask;
      var mask = this.mask;
      var alphaBuf, sw, sh, i, ii, j;
      if (smask) {
        sw = smask.width;
        sh = smask.height;
        alphaBuf = new Uint8Array(sw * sh);
        smask.fillGrayBuffer(alphaBuf);
        if (sw !== width || sh !== height) {
          alphaBuf = resizeImageMask(alphaBuf, smask.bpc, sw, sh, width, height);
        }
      } else if (mask) {
        if (mask instanceof PDFImage) {
          sw = mask.width;
          sh = mask.height;
          alphaBuf = new Uint8Array(sw * sh);
          mask.numComps = 1;
          mask.fillGrayBuffer(alphaBuf);
          for (i = 0, ii = sw * sh; i < ii; ++i) {
            alphaBuf[i] = 255 - alphaBuf[i];
          }
          if (sw !== width || sh !== height) {
            alphaBuf = resizeImageMask(alphaBuf, mask.bpc, sw, sh, width, height);
          }
        } else if (isArray(mask)) {
          alphaBuf = new Uint8Array(width * height);
          var numComps = this.numComps;
          for (i = 0, ii = width * height; i < ii; ++i) {
            var opacity = 0;
            var imageOffset = i * numComps;
            for (j = 0; j < numComps; ++j) {
              var color = image[imageOffset + j];
              var maskOffset = j * 2;
              if (color < mask[maskOffset] || color > mask[maskOffset + 1]) {
                opacity = 255;
                break;
              }
            }
            alphaBuf[i] = opacity;
          }
        } else {
          error('Unknown mask format.');
        }
      }
      if (alphaBuf) {
        for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
          rgbaBuf[j] = alphaBuf[i];
        }
      } else {
        for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
          rgbaBuf[j] = 255;
        }
      }
    },
    undoPreblend: function PDFImage_undoPreblend(buffer, width, height) {
      var matte = this.smask && this.smask.matte;
      if (!matte) {
        return;
      }
      var matteRgb = this.colorSpace.getRgb(matte, 0);
      var matteR = matteRgb[0];
      var matteG = matteRgb[1];
      var matteB = matteRgb[2];
      var length = width * height * 4;
      var r, g, b;
      for (var i = 0; i < length; i += 4) {
        var alpha = buffer[i + 3];
        if (alpha === 0) {
          buffer[i] = 255;
          buffer[i + 1] = 255;
          buffer[i + 2] = 255;
          continue;
        }
        var k = 255 / alpha;
        r = (buffer[i] - matteR) * k + matteR;
        g = (buffer[i + 1] - matteG) * k + matteG;
        b = (buffer[i + 2] - matteB) * k + matteB;
        buffer[i] = r <= 0 ? 0 : r >= 255 ? 255 : r | 0;
        buffer[i + 1] = g <= 0 ? 0 : g >= 255 ? 255 : g | 0;
        buffer[i + 2] = b <= 0 ? 0 : b >= 255 ? 255 : b | 0;
      }
    },
    createImageData: function PDFImage_createImageData(forceRGBA) {
      var drawWidth = this.drawWidth;
      var drawHeight = this.drawHeight;
      var imgData = {
        width: drawWidth,
        height: drawHeight
      };
      var numComps = this.numComps;
      var originalWidth = this.width;
      var originalHeight = this.height;
      var bpc = this.bpc;
      var rowBytes = originalWidth * numComps * bpc + 7 >> 3;
      var imgArray;
      if (!forceRGBA) {
        var kind;
        if (this.colorSpace.name === 'DeviceGray' && bpc === 1) {
          kind = ImageKind.GRAYSCALE_1BPP;
        } else if (this.colorSpace.name === 'DeviceRGB' && bpc === 8 && !this.needsDecode) {
          kind = ImageKind.RGB_24BPP;
        }
        if (kind && !this.smask && !this.mask && drawWidth === originalWidth && drawHeight === originalHeight) {
          imgData.kind = kind;
          imgArray = this.getImageBytes(originalHeight * rowBytes);
          if (this.image instanceof DecodeStream) {
            imgData.data = imgArray;
          } else {
            var newArray = new Uint8Array(imgArray.length);
            newArray.set(imgArray);
            imgData.data = newArray;
          }
          if (this.needsDecode) {
            assert(kind === ImageKind.GRAYSCALE_1BPP);
            var buffer = imgData.data;
            for (var i = 0, ii = buffer.length; i < ii; i++) {
              buffer[i] ^= 0xff;
            }
          }
          return imgData;
        }
        if (this.image instanceof JpegStream && !this.smask && !this.mask && (this.colorSpace.name === 'DeviceGray' || this.colorSpace.name === 'DeviceRGB' || this.colorSpace.name === 'DeviceCMYK')) {
          imgData.kind = ImageKind.RGB_24BPP;
          imgData.data = this.getImageBytes(originalHeight * rowBytes, drawWidth, drawHeight, true);
          return imgData;
        }
      }
      imgArray = this.getImageBytes(originalHeight * rowBytes);
      var actualHeight = 0 | imgArray.length / rowBytes * drawHeight / originalHeight;
      var comps = this.getComponents(imgArray);
      var alpha01, maybeUndoPreblend;
      if (!forceRGBA && !this.smask && !this.mask) {
        imgData.kind = ImageKind.RGB_24BPP;
        imgData.data = new Uint8Array(drawWidth * drawHeight * 3);
        alpha01 = 0;
        maybeUndoPreblend = false;
      } else {
        imgData.kind = ImageKind.RGBA_32BPP;
        imgData.data = new Uint8Array(drawWidth * drawHeight * 4);
        alpha01 = 1;
        maybeUndoPreblend = true;
        this.fillOpacity(imgData.data, drawWidth, drawHeight, actualHeight, comps);
      }
      if (this.needsDecode) {
        this.decodeBuffer(comps);
      }
      this.colorSpace.fillRgb(imgData.data, originalWidth, originalHeight, drawWidth, drawHeight, actualHeight, bpc, comps, alpha01);
      if (maybeUndoPreblend) {
        this.undoPreblend(imgData.data, drawWidth, actualHeight);
      }
      return imgData;
    },
    fillGrayBuffer: function PDFImage_fillGrayBuffer(buffer) {
      var numComps = this.numComps;
      if (numComps !== 1) {
        error('Reading gray scale from a color image: ' + numComps);
      }
      var width = this.width;
      var height = this.height;
      var bpc = this.bpc;
      var rowBytes = width * numComps * bpc + 7 >> 3;
      var imgArray = this.getImageBytes(height * rowBytes);
      var comps = this.getComponents(imgArray);
      var i, length;
      if (bpc === 1) {
        length = width * height;
        if (this.needsDecode) {
          for (i = 0; i < length; ++i) {
            buffer[i] = comps[i] - 1 & 255;
          }
        } else {
          for (i = 0; i < length; ++i) {
            buffer[i] = -comps[i] & 255;
          }
        }
        return;
      }
      if (this.needsDecode) {
        this.decodeBuffer(comps);
      }
      length = width * height;
      var scale = 255 / ((1 << bpc) - 1);
      for (i = 0; i < length; ++i) {
        buffer[i] = scale * comps[i] | 0;
      }
    },
    getImageBytes: function PDFImage_getImageBytes(length, drawWidth, drawHeight, forceRGB) {
      this.image.reset();
      this.image.drawWidth = drawWidth || this.width;
      this.image.drawHeight = drawHeight || this.height;
      this.image.forceRGB = !!forceRGB;
      return this.image.getBytes(length);
    }
  };
  return PDFImage;
}();
exports.PDFImage = PDFImage;

/***/ }),
/* 28 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var coreArithmeticDecoder = __w_pdfjs_require__(10);
var error = sharedUtil.error;
var log2 = sharedUtil.log2;
var readInt8 = sharedUtil.readInt8;
var readUint16 = sharedUtil.readUint16;
var readUint32 = sharedUtil.readUint32;
var shadow = sharedUtil.shadow;
var ArithmeticDecoder = coreArithmeticDecoder.ArithmeticDecoder;
var Jbig2Image = function Jbig2ImageClosure() {
  function ContextCache() {}
  ContextCache.prototype = {
    getContexts: function getContexts(id) {
      if (id in this) {
        return this[id];
      }
      return this[id] = new Int8Array(1 << 16);
    }
  };
  function DecodingContext(data, start, end) {
    this.data = data;
    this.start = start;
    this.end = end;
  }
  DecodingContext.prototype = {
    get decoder() {
      var decoder = new ArithmeticDecoder(this.data, this.start, this.end);
      return shadow(this, 'decoder', decoder);
    },
    get contextCache() {
      var cache = new ContextCache();
      return shadow(this, 'contextCache', cache);
    }
  };
  function decodeInteger(contextCache, procedure, decoder) {
    var contexts = contextCache.getContexts(procedure);
    var prev = 1;
    function readBits(length) {
      var v = 0;
      for (var i = 0; i < length; i++) {
        var bit = decoder.readBit(contexts, prev);
        prev = prev < 256 ? prev << 1 | bit : (prev << 1 | bit) & 511 | 256;
        v = v << 1 | bit;
      }
      return v >>> 0;
    }
    var sign = readBits(1);
    var value = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);
    return sign === 0 ? value : value > 0 ? -value : null;
  }
  function decodeIAID(contextCache, decoder, codeLength) {
    var contexts = contextCache.getContexts('IAID');
    var prev = 1;
    for (var i = 0; i < codeLength; i++) {
      var bit = decoder.readBit(contexts, prev);
      prev = prev << 1 | bit;
    }
    if (codeLength < 31) {
      return prev & (1 << codeLength) - 1;
    }
    return prev & 0x7FFFFFFF;
  }
  var SegmentTypes = ['SymbolDictionary', null, null, null, 'IntermediateTextRegion', null, 'ImmediateTextRegion', 'ImmediateLosslessTextRegion', null, null, null, null, null, null, null, null, 'patternDictionary', null, null, null, 'IntermediateHalftoneRegion', null, 'ImmediateHalftoneRegion', 'ImmediateLosslessHalftoneRegion', null, null, null, null, null, null, null, null, null, null, null, null, 'IntermediateGenericRegion', null, 'ImmediateGenericRegion', 'ImmediateLosslessGenericRegion', 'IntermediateGenericRefinementRegion', null, 'ImmediateGenericRefinementRegion', 'ImmediateLosslessGenericRefinementRegion', null, null, null, null, 'PageInformation', 'EndOfPage', 'EndOfStripe', 'EndOfFile', 'Profiles', 'Tables', null, null, null, null, null, null, null, null, 'Extension'];
  var CodingTemplates = [[{
    x: -1,
    y: -2
  }, {
    x: 0,
    y: -2
  }, {
    x: 1,
    y: -2
  }, {
    x: -2,
    y: -1
  }, {
    x: -1,
    y: -1
  }, {
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: 2,
    y: -1
  }, {
    x: -4,
    y: 0
  }, {
    x: -3,
    y: 0
  }, {
    x: -2,
    y: 0
  }, {
    x: -1,
    y: 0
  }], [{
    x: -1,
    y: -2
  }, {
    x: 0,
    y: -2
  }, {
    x: 1,
    y: -2
  }, {
    x: 2,
    y: -2
  }, {
    x: -2,
    y: -1
  }, {
    x: -1,
    y: -1
  }, {
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: 2,
    y: -1
  }, {
    x: -3,
    y: 0
  }, {
    x: -2,
    y: 0
  }, {
    x: -1,
    y: 0
  }], [{
    x: -1,
    y: -2
  }, {
    x: 0,
    y: -2
  }, {
    x: 1,
    y: -2
  }, {
    x: -2,
    y: -1
  }, {
    x: -1,
    y: -1
  }, {
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: -2,
    y: 0
  }, {
    x: -1,
    y: 0
  }], [{
    x: -3,
    y: -1
  }, {
    x: -2,
    y: -1
  }, {
    x: -1,
    y: -1
  }, {
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: -4,
    y: 0
  }, {
    x: -3,
    y: 0
  }, {
    x: -2,
    y: 0
  }, {
    x: -1,
    y: 0
  }]];
  var RefinementTemplates = [{
    coding: [{
      x: 0,
      y: -1
    }, {
      x: 1,
      y: -1
    }, {
      x: -1,
      y: 0
    }],
    reference: [{
      x: 0,
      y: -1
    }, {
      x: 1,
      y: -1
    }, {
      x: -1,
      y: 0
    }, {
      x: 0,
      y: 0
    }, {
      x: 1,
      y: 0
    }, {
      x: -1,
      y: 1
    }, {
      x: 0,
      y: 1
    }, {
      x: 1,
      y: 1
    }]
  }, {
    coding: [{
      x: -1,
      y: -1
    }, {
      x: 0,
      y: -1
    }, {
      x: 1,
      y: -1
    }, {
      x: -1,
      y: 0
    }],
    reference: [{
      x: 0,
      y: -1
    }, {
      x: -1,
      y: 0
    }, {
      x: 0,
      y: 0
    }, {
      x: 1,
      y: 0
    }, {
      x: 0,
      y: 1
    }, {
      x: 1,
      y: 1
    }]
  }];
  var ReusedContexts = [0x9B25, 0x0795, 0x00E5, 0x0195];
  var RefinementReusedContexts = [0x0020, 0x0008];
  function decodeBitmapTemplate0(width, height, decodingContext) {
    var decoder = decodingContext.decoder;
    var contexts = decodingContext.contextCache.getContexts('GB');
    var contextLabel,
        i,
        j,
        pixel,
        row,
        row1,
        row2,
        bitmap = [];
    var OLD_PIXEL_MASK = 0x7BF7;
    for (i = 0; i < height; i++) {
      row = bitmap[i] = new Uint8Array(width);
      row1 = i < 1 ? row : bitmap[i - 1];
      row2 = i < 2 ? row : bitmap[i - 2];
      contextLabel = row2[0] << 13 | row2[1] << 12 | row2[2] << 11 | row1[0] << 7 | row1[1] << 6 | row1[2] << 5 | row1[3] << 4;
      for (j = 0; j < width; j++) {
        row[j] = pixel = decoder.readBit(contexts, contextLabel);
        contextLabel = (contextLabel & OLD_PIXEL_MASK) << 1 | (j + 3 < width ? row2[j + 3] << 11 : 0) | (j + 4 < width ? row1[j + 4] << 4 : 0) | pixel;
      }
    }
    return bitmap;
  }
  function decodeBitmap(mmr, width, height, templateIndex, prediction, skip, at, decodingContext) {
    if (mmr) {
      error('JBIG2 error: MMR encoding is not supported');
    }
    if (templateIndex === 0 && !skip && !prediction && at.length === 4 && at[0].x === 3 && at[0].y === -1 && at[1].x === -3 && at[1].y === -1 && at[2].x === 2 && at[2].y === -2 && at[3].x === -2 && at[3].y === -2) {
      return decodeBitmapTemplate0(width, height, decodingContext);
    }
    var useskip = !!skip;
    var template = CodingTemplates[templateIndex].concat(at);
    template.sort(function (a, b) {
      return a.y - b.y || a.x - b.x;
    });
    var templateLength = template.length;
    var templateX = new Int8Array(templateLength);
    var templateY = new Int8Array(templateLength);
    var changingTemplateEntries = [];
    var reuseMask = 0,
        minX = 0,
        maxX = 0,
        minY = 0;
    var c, k;
    for (k = 0; k < templateLength; k++) {
      templateX[k] = template[k].x;
      templateY[k] = template[k].y;
      minX = Math.min(minX, template[k].x);
      maxX = Math.max(maxX, template[k].x);
      minY = Math.min(minY, template[k].y);
      if (k < templateLength - 1 && template[k].y === template[k + 1].y && template[k].x === template[k + 1].x - 1) {
        reuseMask |= 1 << templateLength - 1 - k;
      } else {
        changingTemplateEntries.push(k);
      }
    }
    var changingEntriesLength = changingTemplateEntries.length;
    var changingTemplateX = new Int8Array(changingEntriesLength);
    var changingTemplateY = new Int8Array(changingEntriesLength);
    var changingTemplateBit = new Uint16Array(changingEntriesLength);
    for (c = 0; c < changingEntriesLength; c++) {
      k = changingTemplateEntries[c];
      changingTemplateX[c] = template[k].x;
      changingTemplateY[c] = template[k].y;
      changingTemplateBit[c] = 1 << templateLength - 1 - k;
    }
    var sbb_left = -minX;
    var sbb_top = -minY;
    var sbb_right = width - maxX;
    var pseudoPixelContext = ReusedContexts[templateIndex];
    var row = new Uint8Array(width);
    var bitmap = [];
    var decoder = decodingContext.decoder;
    var contexts = decodingContext.contextCache.getContexts('GB');
    var ltp = 0,
        j,
        i0,
        j0,
        contextLabel = 0,
        bit,
        shift;
    for (var i = 0; i < height; i++) {
      if (prediction) {
        var sltp = decoder.readBit(contexts, pseudoPixelContext);
        ltp ^= sltp;
        if (ltp) {
          bitmap.push(row);
          continue;
        }
      }
      row = new Uint8Array(row);
      bitmap.push(row);
      for (j = 0; j < width; j++) {
        if (useskip && skip[i][j]) {
          row[j] = 0;
          continue;
        }
        if (j >= sbb_left && j < sbb_right && i >= sbb_top) {
          contextLabel = contextLabel << 1 & reuseMask;
          for (k = 0; k < changingEntriesLength; k++) {
            i0 = i + changingTemplateY[k];
            j0 = j + changingTemplateX[k];
            bit = bitmap[i0][j0];
            if (bit) {
              bit = changingTemplateBit[k];
              contextLabel |= bit;
            }
          }
        } else {
          contextLabel = 0;
          shift = templateLength - 1;
          for (k = 0; k < templateLength; k++, shift--) {
            j0 = j + templateX[k];
            if (j0 >= 0 && j0 < width) {
              i0 = i + templateY[k];
              if (i0 >= 0) {
                bit = bitmap[i0][j0];
                if (bit) {
                  contextLabel |= bit << shift;
                }
              }
            }
          }
        }
        var pixel = decoder.readBit(contexts, contextLabel);
        row[j] = pixel;
      }
    }
    return bitmap;
  }
  function decodeRefinement(width, height, templateIndex, referenceBitmap, offsetX, offsetY, prediction, at, decodingContext) {
    var codingTemplate = RefinementTemplates[templateIndex].coding;
    if (templateIndex === 0) {
      codingTemplate = codingTemplate.concat([at[0]]);
    }
    var codingTemplateLength = codingTemplate.length;
    var codingTemplateX = new Int32Array(codingTemplateLength);
    var codingTemplateY = new Int32Array(codingTemplateLength);
    var k;
    for (k = 0; k < codingTemplateLength; k++) {
      codingTemplateX[k] = codingTemplate[k].x;
      codingTemplateY[k] = codingTemplate[k].y;
    }
    var referenceTemplate = RefinementTemplates[templateIndex].reference;
    if (templateIndex === 0) {
      referenceTemplate = referenceTemplate.concat([at[1]]);
    }
    var referenceTemplateLength = referenceTemplate.length;
    var referenceTemplateX = new Int32Array(referenceTemplateLength);
    var referenceTemplateY = new Int32Array(referenceTemplateLength);
    for (k = 0; k < referenceTemplateLength; k++) {
      referenceTemplateX[k] = referenceTemplate[k].x;
      referenceTemplateY[k] = referenceTemplate[k].y;
    }
    var referenceWidth = referenceBitmap[0].length;
    var referenceHeight = referenceBitmap.length;
    var pseudoPixelContext = RefinementReusedContexts[templateIndex];
    var bitmap = [];
    var decoder = decodingContext.decoder;
    var contexts = decodingContext.contextCache.getContexts('GR');
    var ltp = 0;
    for (var i = 0; i < height; i++) {
      if (prediction) {
        var sltp = decoder.readBit(contexts, pseudoPixelContext);
        ltp ^= sltp;
        if (ltp) {
          error('JBIG2 error: prediction is not supported');
        }
      }
      var row = new Uint8Array(width);
      bitmap.push(row);
      for (var j = 0; j < width; j++) {
        var i0, j0;
        var contextLabel = 0;
        for (k = 0; k < codingTemplateLength; k++) {
          i0 = i + codingTemplateY[k];
          j0 = j + codingTemplateX[k];
          if (i0 < 0 || j0 < 0 || j0 >= width) {
            contextLabel <<= 1;
          } else {
            contextLabel = contextLabel << 1 | bitmap[i0][j0];
          }
        }
        for (k = 0; k < referenceTemplateLength; k++) {
          i0 = i + referenceTemplateY[k] + offsetY;
          j0 = j + referenceTemplateX[k] + offsetX;
          if (i0 < 0 || i0 >= referenceHeight || j0 < 0 || j0 >= referenceWidth) {
            contextLabel <<= 1;
          } else {
            contextLabel = contextLabel << 1 | referenceBitmap[i0][j0];
          }
        }
        var pixel = decoder.readBit(contexts, contextLabel);
        row[j] = pixel;
      }
    }
    return bitmap;
  }
  function decodeSymbolDictionary(huffman, refinement, symbols, numberOfNewSymbols, numberOfExportedSymbols, huffmanTables, templateIndex, at, refinementTemplateIndex, refinementAt, decodingContext) {
    if (huffman) {
      error('JBIG2 error: huffman is not supported');
    }
    var newSymbols = [];
    var currentHeight = 0;
    var symbolCodeLength = log2(symbols.length + numberOfNewSymbols);
    var decoder = decodingContext.decoder;
    var contextCache = decodingContext.contextCache;
    while (newSymbols.length < numberOfNewSymbols) {
      var deltaHeight = decodeInteger(contextCache, 'IADH', decoder);
      currentHeight += deltaHeight;
      var currentWidth = 0;
      while (true) {
        var deltaWidth = decodeInteger(contextCache, 'IADW', decoder);
        if (deltaWidth === null) {
          break;
        }
        currentWidth += deltaWidth;
        var bitmap;
        if (refinement) {
          var numberOfInstances = decodeInteger(contextCache, 'IAAI', decoder);
          if (numberOfInstances > 1) {
            bitmap = decodeTextRegion(huffman, refinement, currentWidth, currentHeight, 0, numberOfInstances, 1, symbols.concat(newSymbols), symbolCodeLength, 0, 0, 1, 0, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext);
          } else {
            var symbolId = decodeIAID(contextCache, decoder, symbolCodeLength);
            var rdx = decodeInteger(contextCache, 'IARDX', decoder);
            var rdy = decodeInteger(contextCache, 'IARDY', decoder);
            var symbol = symbolId < symbols.length ? symbols[symbolId] : newSymbols[symbolId - symbols.length];
            bitmap = decodeRefinement(currentWidth, currentHeight, refinementTemplateIndex, symbol, rdx, rdy, false, refinementAt, decodingContext);
          }
        } else {
          bitmap = decodeBitmap(false, currentWidth, currentHeight, templateIndex, false, null, at, decodingContext);
        }
        newSymbols.push(bitmap);
      }
    }
    var exportedSymbols = [];
    var flags = [],
        currentFlag = false;
    var totalSymbolsLength = symbols.length + numberOfNewSymbols;
    while (flags.length < totalSymbolsLength) {
      var runLength = decodeInteger(contextCache, 'IAEX', decoder);
      while (runLength--) {
        flags.push(currentFlag);
      }
      currentFlag = !currentFlag;
    }
    for (var i = 0, ii = symbols.length; i < ii; i++) {
      if (flags[i]) {
        exportedSymbols.push(symbols[i]);
      }
    }
    for (var j = 0; j < numberOfNewSymbols; i++, j++) {
      if (flags[i]) {
        exportedSymbols.push(newSymbols[j]);
      }
    }
    return exportedSymbols;
  }
  function decodeTextRegion(huffman, refinement, width, height, defaultPixelValue, numberOfSymbolInstances, stripSize, inputSymbols, symbolCodeLength, transposed, dsOffset, referenceCorner, combinationOperator, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext) {
    if (huffman) {
      error('JBIG2 error: huffman is not supported');
    }
    var bitmap = [];
    var i, row;
    for (i = 0; i < height; i++) {
      row = new Uint8Array(width);
      if (defaultPixelValue) {
        for (var j = 0; j < width; j++) {
          row[j] = defaultPixelValue;
        }
      }
      bitmap.push(row);
    }
    var decoder = decodingContext.decoder;
    var contextCache = decodingContext.contextCache;
    var stripT = -decodeInteger(contextCache, 'IADT', decoder);
    var firstS = 0;
    i = 0;
    while (i < numberOfSymbolInstances) {
      var deltaT = decodeInteger(contextCache, 'IADT', decoder);
      stripT += deltaT;
      var deltaFirstS = decodeInteger(contextCache, 'IAFS', decoder);
      firstS += deltaFirstS;
      var currentS = firstS;
      do {
        var currentT = stripSize === 1 ? 0 : decodeInteger(contextCache, 'IAIT', decoder);
        var t = stripSize * stripT + currentT;
        var symbolId = decodeIAID(contextCache, decoder, symbolCodeLength);
        var applyRefinement = refinement && decodeInteger(contextCache, 'IARI', decoder);
        var symbolBitmap = inputSymbols[symbolId];
        var symbolWidth = symbolBitmap[0].length;
        var symbolHeight = symbolBitmap.length;
        if (applyRefinement) {
          var rdw = decodeInteger(contextCache, 'IARDW', decoder);
          var rdh = decodeInteger(contextCache, 'IARDH', decoder);
          var rdx = decodeInteger(contextCache, 'IARDX', decoder);
          var rdy = decodeInteger(contextCache, 'IARDY', decoder);
          symbolWidth += rdw;
          symbolHeight += rdh;
          symbolBitmap = decodeRefinement(symbolWidth, symbolHeight, refinementTemplateIndex, symbolBitmap, (rdw >> 1) + rdx, (rdh >> 1) + rdy, false, refinementAt, decodingContext);
        }
        var offsetT = t - (referenceCorner & 1 ? 0 : symbolHeight);
        var offsetS = currentS - (referenceCorner & 2 ? symbolWidth : 0);
        var s2, t2, symbolRow;
        if (transposed) {
          for (s2 = 0; s2 < symbolHeight; s2++) {
            row = bitmap[offsetS + s2];
            if (!row) {
              continue;
            }
            symbolRow = symbolBitmap[s2];
            var maxWidth = Math.min(width - offsetT, symbolWidth);
            switch (combinationOperator) {
              case 0:
                for (t2 = 0; t2 < maxWidth; t2++) {
                  row[offsetT + t2] |= symbolRow[t2];
                }
                break;
              case 2:
                for (t2 = 0; t2 < maxWidth; t2++) {
                  row[offsetT + t2] ^= symbolRow[t2];
                }
                break;
              default:
                error('JBIG2 error: operator ' + combinationOperator + ' is not supported');
            }
          }
          currentS += symbolHeight - 1;
        } else {
          for (t2 = 0; t2 < symbolHeight; t2++) {
            row = bitmap[offsetT + t2];
            if (!row) {
              continue;
            }
            symbolRow = symbolBitmap[t2];
            switch (combinationOperator) {
              case 0:
                for (s2 = 0; s2 < symbolWidth; s2++) {
                  row[offsetS + s2] |= symbolRow[s2];
                }
                break;
              case 2:
                for (s2 = 0; s2 < symbolWidth; s2++) {
                  row[offsetS + s2] ^= symbolRow[s2];
                }
                break;
              default:
                error('JBIG2 error: operator ' + combinationOperator + ' is not supported');
            }
          }
          currentS += symbolWidth - 1;
        }
        i++;
        var deltaS = decodeInteger(contextCache, 'IADS', decoder);
        if (deltaS === null) {
          break;
        }
        currentS += deltaS + dsOffset;
      } while (true);
    }
    return bitmap;
  }
  function readSegmentHeader(data, start) {
    var segmentHeader = {};
    segmentHeader.number = readUint32(data, start);
    var flags = data[start + 4];
    var segmentType = flags & 0x3F;
    if (!SegmentTypes[segmentType]) {
      error('JBIG2 error: invalid segment type: ' + segmentType);
    }
    segmentHeader.type = segmentType;
    segmentHeader.typeName = SegmentTypes[segmentType];
    segmentHeader.deferredNonRetain = !!(flags & 0x80);
    var pageAssociationFieldSize = !!(flags & 0x40);
    var referredFlags = data[start + 5];
    var referredToCount = referredFlags >> 5 & 7;
    var retainBits = [referredFlags & 31];
    var position = start + 6;
    if (referredFlags === 7) {
      referredToCount = readUint32(data, position - 1) & 0x1FFFFFFF;
      position += 3;
      var bytes = referredToCount + 7 >> 3;
      retainBits[0] = data[position++];
      while (--bytes > 0) {
        retainBits.push(data[position++]);
      }
    } else if (referredFlags === 5 || referredFlags === 6) {
      error('JBIG2 error: invalid referred-to flags');
    }
    segmentHeader.retainBits = retainBits;
    var referredToSegmentNumberSize = segmentHeader.number <= 256 ? 1 : segmentHeader.number <= 65536 ? 2 : 4;
    var referredTo = [];
    var i, ii;
    for (i = 0; i < referredToCount; i++) {
      var number = referredToSegmentNumberSize === 1 ? data[position] : referredToSegmentNumberSize === 2 ? readUint16(data, position) : readUint32(data, position);
      referredTo.push(number);
      position += referredToSegmentNumberSize;
    }
    segmentHeader.referredTo = referredTo;
    if (!pageAssociationFieldSize) {
      segmentHeader.pageAssociation = data[position++];
    } else {
      segmentHeader.pageAssociation = readUint32(data, position);
      position += 4;
    }
    segmentHeader.length = readUint32(data, position);
    position += 4;
    if (segmentHeader.length === 0xFFFFFFFF) {
      if (segmentType === 38) {
        var genericRegionInfo = readRegionSegmentInformation(data, position);
        var genericRegionSegmentFlags = data[position + RegionSegmentInformationFieldLength];
        var genericRegionMmr = !!(genericRegionSegmentFlags & 1);
        var searchPatternLength = 6;
        var searchPattern = new Uint8Array(searchPatternLength);
        if (!genericRegionMmr) {
          searchPattern[0] = 0xFF;
          searchPattern[1] = 0xAC;
        }
        searchPattern[2] = genericRegionInfo.height >>> 24 & 0xFF;
        searchPattern[3] = genericRegionInfo.height >> 16 & 0xFF;
        searchPattern[4] = genericRegionInfo.height >> 8 & 0xFF;
        searchPattern[5] = genericRegionInfo.height & 0xFF;
        for (i = position, ii = data.length; i < ii; i++) {
          var j = 0;
          while (j < searchPatternLength && searchPattern[j] === data[i + j]) {
            j++;
          }
          if (j === searchPatternLength) {
            segmentHeader.length = i + searchPatternLength;
            break;
          }
        }
        if (segmentHeader.length === 0xFFFFFFFF) {
          error('JBIG2 error: segment end was not found');
        }
      } else {
        error('JBIG2 error: invalid unknown segment length');
      }
    }
    segmentHeader.headerEnd = position;
    return segmentHeader;
  }
  function readSegments(header, data, start, end) {
    var segments = [];
    var position = start;
    while (position < end) {
      var segmentHeader = readSegmentHeader(data, position);
      position = segmentHeader.headerEnd;
      var segment = {
        header: segmentHeader,
        data: data
      };
      if (!header.randomAccess) {
        segment.start = position;
        position += segmentHeader.length;
        segment.end = position;
      }
      segments.push(segment);
      if (segmentHeader.type === 51) {
        break;
      }
    }
    if (header.randomAccess) {
      for (var i = 0, ii = segments.length; i < ii; i++) {
        segments[i].start = position;
        position += segments[i].header.length;
        segments[i].end = position;
      }
    }
    return segments;
  }
  function readRegionSegmentInformation(data, start) {
    return {
      width: readUint32(data, start),
      height: readUint32(data, start + 4),
      x: readUint32(data, start + 8),
      y: readUint32(data, start + 12),
      combinationOperator: data[start + 16] & 7
    };
  }
  var RegionSegmentInformationFieldLength = 17;
  function processSegment(segment, visitor) {
    var header = segment.header;
    var data = segment.data,
        position = segment.start,
        end = segment.end;
    var args, at, i, atLength;
    switch (header.type) {
      case 0:
        var dictionary = {};
        var dictionaryFlags = readUint16(data, position);
        dictionary.huffman = !!(dictionaryFlags & 1);
        dictionary.refinement = !!(dictionaryFlags & 2);
        dictionary.huffmanDHSelector = dictionaryFlags >> 2 & 3;
        dictionary.huffmanDWSelector = dictionaryFlags >> 4 & 3;
        dictionary.bitmapSizeSelector = dictionaryFlags >> 6 & 1;
        dictionary.aggregationInstancesSelector = dictionaryFlags >> 7 & 1;
        dictionary.bitmapCodingContextUsed = !!(dictionaryFlags & 256);
        dictionary.bitmapCodingContextRetained = !!(dictionaryFlags & 512);
        dictionary.template = dictionaryFlags >> 10 & 3;
        dictionary.refinementTemplate = dictionaryFlags >> 12 & 1;
        position += 2;
        if (!dictionary.huffman) {
          atLength = dictionary.template === 0 ? 4 : 1;
          at = [];
          for (i = 0; i < atLength; i++) {
            at.push({
              x: readInt8(data, position),
              y: readInt8(data, position + 1)
            });
            position += 2;
          }
          dictionary.at = at;
        }
        if (dictionary.refinement && !dictionary.refinementTemplate) {
          at = [];
          for (i = 0; i < 2; i++) {
            at.push({
              x: readInt8(data, position),
              y: readInt8(data, position + 1)
            });
            position += 2;
          }
          dictionary.refinementAt = at;
        }
        dictionary.numberOfExportedSymbols = readUint32(data, position);
        position += 4;
        dictionary.numberOfNewSymbols = readUint32(data, position);
        position += 4;
        args = [dictionary, header.number, header.referredTo, data, position, end];
        break;
      case 6:
      case 7:
        var textRegion = {};
        textRegion.info = readRegionSegmentInformation(data, position);
        position += RegionSegmentInformationFieldLength;
        var textRegionSegmentFlags = readUint16(data, position);
        position += 2;
        textRegion.huffman = !!(textRegionSegmentFlags & 1);
        textRegion.refinement = !!(textRegionSegmentFlags & 2);
        textRegion.stripSize = 1 << (textRegionSegmentFlags >> 2 & 3);
        textRegion.referenceCorner = textRegionSegmentFlags >> 4 & 3;
        textRegion.transposed = !!(textRegionSegmentFlags & 64);
        textRegion.combinationOperator = textRegionSegmentFlags >> 7 & 3;
        textRegion.defaultPixelValue = textRegionSegmentFlags >> 9 & 1;
        textRegion.dsOffset = textRegionSegmentFlags << 17 >> 27;
        textRegion.refinementTemplate = textRegionSegmentFlags >> 15 & 1;
        if (textRegion.huffman) {
          var textRegionHuffmanFlags = readUint16(data, position);
          position += 2;
          textRegion.huffmanFS = textRegionHuffmanFlags & 3;
          textRegion.huffmanDS = textRegionHuffmanFlags >> 2 & 3;
          textRegion.huffmanDT = textRegionHuffmanFlags >> 4 & 3;
          textRegion.huffmanRefinementDW = textRegionHuffmanFlags >> 6 & 3;
          textRegion.huffmanRefinementDH = textRegionHuffmanFlags >> 8 & 3;
          textRegion.huffmanRefinementDX = textRegionHuffmanFlags >> 10 & 3;
          textRegion.huffmanRefinementDY = textRegionHuffmanFlags >> 12 & 3;
          textRegion.huffmanRefinementSizeSelector = !!(textRegionHuffmanFlags & 14);
        }
        if (textRegion.refinement && !textRegion.refinementTemplate) {
          at = [];
          for (i = 0; i < 2; i++) {
            at.push({
              x: readInt8(data, position),
              y: readInt8(data, position + 1)
            });
            position += 2;
          }
          textRegion.refinementAt = at;
        }
        textRegion.numberOfSymbolInstances = readUint32(data, position);
        position += 4;
        if (textRegion.huffman) {
          error('JBIG2 error: huffman is not supported');
        }
        args = [textRegion, header.referredTo, data, position, end];
        break;
      case 38:
      case 39:
        var genericRegion = {};
        genericRegion.info = readRegionSegmentInformation(data, position);
        position += RegionSegmentInformationFieldLength;
        var genericRegionSegmentFlags = data[position++];
        genericRegion.mmr = !!(genericRegionSegmentFlags & 1);
        genericRegion.template = genericRegionSegmentFlags >> 1 & 3;
        genericRegion.prediction = !!(genericRegionSegmentFlags & 8);
        if (!genericRegion.mmr) {
          atLength = genericRegion.template === 0 ? 4 : 1;
          at = [];
          for (i = 0; i < atLength; i++) {
            at.push({
              x: readInt8(data, position),
              y: readInt8(data, position + 1)
            });
            position += 2;
          }
          genericRegion.at = at;
        }
        args = [genericRegion, data, position, end];
        break;
      case 48:
        var pageInfo = {
          width: readUint32(data, position),
          height: readUint32(data, position + 4),
          resolutionX: readUint32(data, position + 8),
          resolutionY: readUint32(data, position + 12)
        };
        if (pageInfo.height === 0xFFFFFFFF) {
          delete pageInfo.height;
        }
        var pageSegmentFlags = data[position + 16];
        readUint16(data, position + 17);
        pageInfo.lossless = !!(pageSegmentFlags & 1);
        pageInfo.refinement = !!(pageSegmentFlags & 2);
        pageInfo.defaultPixelValue = pageSegmentFlags >> 2 & 1;
        pageInfo.combinationOperator = pageSegmentFlags >> 3 & 3;
        pageInfo.requiresBuffer = !!(pageSegmentFlags & 32);
        pageInfo.combinationOperatorOverride = !!(pageSegmentFlags & 64);
        args = [pageInfo];
        break;
      case 49:
        break;
      case 50:
        break;
      case 51:
        break;
      case 62:
        break;
      default:
        error('JBIG2 error: segment type ' + header.typeName + '(' + header.type + ') is not implemented');
    }
    var callbackName = 'on' + header.typeName;
    if (callbackName in visitor) {
      visitor[callbackName].apply(visitor, args);
    }
  }
  function processSegments(segments, visitor) {
    for (var i = 0, ii = segments.length; i < ii; i++) {
      processSegment(segments[i], visitor);
    }
  }
  function parseJbig2(data, start, end) {
    var position = start;
    if (data[position] !== 0x97 || data[position + 1] !== 0x4A || data[position + 2] !== 0x42 || data[position + 3] !== 0x32 || data[position + 4] !== 0x0D || data[position + 5] !== 0x0A || data[position + 6] !== 0x1A || data[position + 7] !== 0x0A) {
      error('JBIG2 error: invalid header');
    }
    var header = {};
    position += 8;
    var flags = data[position++];
    header.randomAccess = !(flags & 1);
    if (!(flags & 2)) {
      header.numberOfPages = readUint32(data, position);
      position += 4;
    }
    readSegments(header, data, position, end);
    error('Not implemented');
  }
  function parseJbig2Chunks(chunks) {
    var visitor = new SimpleSegmentVisitor();
    for (var i = 0, ii = chunks.length; i < ii; i++) {
      var chunk = chunks[i];
      var segments = readSegments({}, chunk.data, chunk.start, chunk.end);
      processSegments(segments, visitor);
    }
    return visitor.buffer;
  }
  function SimpleSegmentVisitor() {}
  SimpleSegmentVisitor.prototype = {
    onPageInformation: function SimpleSegmentVisitor_onPageInformation(info) {
      this.currentPageInfo = info;
      var rowSize = info.width + 7 >> 3;
      var buffer = new Uint8Array(rowSize * info.height);
      if (info.defaultPixelValue) {
        for (var i = 0, ii = buffer.length; i < ii; i++) {
          buffer[i] = 0xFF;
        }
      }
      this.buffer = buffer;
    },
    drawBitmap: function SimpleSegmentVisitor_drawBitmap(regionInfo, bitmap) {
      var pageInfo = this.currentPageInfo;
      var width = regionInfo.width,
          height = regionInfo.height;
      var rowSize = pageInfo.width + 7 >> 3;
      var combinationOperator = pageInfo.combinationOperatorOverride ? regionInfo.combinationOperator : pageInfo.combinationOperator;
      var buffer = this.buffer;
      var mask0 = 128 >> (regionInfo.x & 7);
      var offset0 = regionInfo.y * rowSize + (regionInfo.x >> 3);
      var i, j, mask, offset;
      switch (combinationOperator) {
        case 0:
          for (i = 0; i < height; i++) {
            mask = mask0;
            offset = offset0;
            for (j = 0; j < width; j++) {
              if (bitmap[i][j]) {
                buffer[offset] |= mask;
              }
              mask >>= 1;
              if (!mask) {
                mask = 128;
                offset++;
              }
            }
            offset0 += rowSize;
          }
          break;
        case 2:
          for (i = 0; i < height; i++) {
            mask = mask0;
            offset = offset0;
            for (j = 0; j < width; j++) {
              if (bitmap[i][j]) {
                buffer[offset] ^= mask;
              }
              mask >>= 1;
              if (!mask) {
                mask = 128;
                offset++;
              }
            }
            offset0 += rowSize;
          }
          break;
        default:
          error('JBIG2 error: operator ' + combinationOperator + ' is not supported');
      }
    },
    onImmediateGenericRegion: function SimpleSegmentVisitor_onImmediateGenericRegion(region, data, start, end) {
      var regionInfo = region.info;
      var decodingContext = new DecodingContext(data, start, end);
      var bitmap = decodeBitmap(region.mmr, regionInfo.width, regionInfo.height, region.template, region.prediction, null, region.at, decodingContext);
      this.drawBitmap(regionInfo, bitmap);
    },
    onImmediateLosslessGenericRegion: function SimpleSegmentVisitor_onImmediateLosslessGenericRegion() {
      this.onImmediateGenericRegion.apply(this, arguments);
    },
    onSymbolDictionary: function SimpleSegmentVisitor_onSymbolDictionary(dictionary, currentSegment, referredSegments, data, start, end) {
      var huffmanTables;
      if (dictionary.huffman) {
        error('JBIG2 error: huffman is not supported');
      }
      var symbols = this.symbols;
      if (!symbols) {
        this.symbols = symbols = {};
      }
      var inputSymbols = [];
      for (var i = 0, ii = referredSegments.length; i < ii; i++) {
        inputSymbols = inputSymbols.concat(symbols[referredSegments[i]]);
      }
      var decodingContext = new DecodingContext(data, start, end);
      symbols[currentSegment] = decodeSymbolDictionary(dictionary.huffman, dictionary.refinement, inputSymbols, dictionary.numberOfNewSymbols, dictionary.numberOfExportedSymbols, huffmanTables, dictionary.template, dictionary.at, dictionary.refinementTemplate, dictionary.refinementAt, decodingContext);
    },
    onImmediateTextRegion: function SimpleSegmentVisitor_onImmediateTextRegion(region, referredSegments, data, start, end) {
      var regionInfo = region.info;
      var huffmanTables;
      var symbols = this.symbols;
      var inputSymbols = [];
      for (var i = 0, ii = referredSegments.length; i < ii; i++) {
        inputSymbols = inputSymbols.concat(symbols[referredSegments[i]]);
      }
      var symbolCodeLength = log2(inputSymbols.length);
      var decodingContext = new DecodingContext(data, start, end);
      var bitmap = decodeTextRegion(region.huffman, region.refinement, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.numberOfSymbolInstances, region.stripSize, inputSymbols, symbolCodeLength, region.transposed, region.dsOffset, region.referenceCorner, region.combinationOperator, huffmanTables, region.refinementTemplate, region.refinementAt, decodingContext);
      this.drawBitmap(regionInfo, bitmap);
    },
    onImmediateLosslessTextRegion: function SimpleSegmentVisitor_onImmediateLosslessTextRegion() {
      this.onImmediateTextRegion.apply(this, arguments);
    }
  };
  function Jbig2Image() {}
  Jbig2Image.prototype = {
    parseChunks: function Jbig2Image_parseChunks(chunks) {
      return parseJbig2Chunks(chunks);
    }
  };
  return Jbig2Image;
}();
exports.Jbig2Image = Jbig2Image;

/***/ }),
/* 29 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var sharedUtil = __w_pdfjs_require__(0);
var warn = sharedUtil.warn;
var error = sharedUtil.error;
var JpegImage = function JpegImageClosure() {
  var dctZigZag = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
  var dctCos1 = 4017;
  var dctSin1 = 799;
  var dctCos3 = 3406;
  var dctSin3 = 2276;
  var dctCos6 = 1567;
  var dctSin6 = 3784;
  var dctSqrt2 = 5793;
  var dctSqrt1d2 = 2896;
  function JpegImage() {
    this.decodeTransform = null;
    this.colorTransform = -1;
  }
  function buildHuffmanTable(codeLengths, values) {
    var k = 0,
        code = [],
        i,
        j,
        length = 16;
    while (length > 0 && !codeLengths[length - 1]) {
      length--;
    }
    code.push({
      children: [],
      index: 0
    });
    var p = code[0],
        q;
    for (i = 0; i < length; i++) {
      for (j = 0; j < codeLengths[i]; j++) {
        p = code.pop();
        p.children[p.index] = values[k];
        while (p.index > 0) {
          p = code.pop();
        }
        p.index++;
        code.push(p);
        while (code.length <= i) {
          code.push(q = {
            children: [],
            index: 0
          });
          p.children[p.index] = q.children;
          p = q;
        }
        k++;
      }
      if (i + 1 < length) {
        code.push(q = {
          children: [],
          index: 0
        });
        p.children[p.index] = q.children;
        p = q;
      }
    }
    return code[0].children;
  }
  function getBlockBufferOffset(component, row, col) {
    return 64 * ((component.blocksPerLine + 1) * row + col);
  }
  function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {
    var mcusPerLine = frame.mcusPerLine;
    var progressive = frame.progressive;
    var startOffset = offset,
        bitsData = 0,
        bitsCount = 0;
    function readBit() {
      if (bitsCount > 0) {
        bitsCount--;
        return bitsData >> bitsCount & 1;
      }
      bitsData = data[offset++];
      if (bitsData === 0xFF) {
        var nextByte = data[offset++];
        if (nextByte) {
          error('JPEG error: unexpected marker ' + (bitsData << 8 | nextByte).toString(16));
        }
      }
      bitsCount = 7;
      return bitsData >>> 7;
    }
    function decodeHuffman(tree) {
      var node = tree;
      while (true) {
        node = node[readBit()];
        if (typeof node === 'number') {
          return node;
        }
        if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
          error('JPEG error: invalid huffman sequence');
        }
      }
    }
    function receive(length) {
      var n = 0;
      while (length > 0) {
        n = n << 1 | readBit();
        length--;
      }
      return n;
    }
    function receiveAndExtend(length) {
      if (length === 1) {
        return readBit() === 1 ? 1 : -1;
      }
      var n = receive(length);
      if (n >= 1 << length - 1) {
        return n;
      }
      return n + (-1 << length) + 1;
    }
    function decodeBaseline(component, offset) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : receiveAndExtend(t);
      component.blockData[offset] = component.pred += diff;
      var k = 1;
      while (k < 64) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15,
            r = rs >> 4;
        if (s === 0) {
          if (r < 15) {
            break;
          }
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        component.blockData[offset + z] = receiveAndExtend(s);
        k++;
      }
    }
    function decodeDCFirst(component, offset) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
      component.blockData[offset] = component.pred += diff;
    }
    function decodeDCSuccessive(component, offset) {
      component.blockData[offset] |= readBit() << successive;
    }
    var eobrun = 0;
    function decodeACFirst(component, offset) {
      if (eobrun > 0) {
        eobrun--;
        return;
      }
      var k = spectralStart,
          e = spectralEnd;
      while (k <= e) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15,
            r = rs >> 4;
        if (s === 0) {
          if (r < 15) {
            eobrun = receive(r) + (1 << r) - 1;
            break;
          }
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        component.blockData[offset + z] = receiveAndExtend(s) * (1 << successive);
        k++;
      }
    }
    var successiveACState = 0,
        successiveACNextValue;
    function decodeACSuccessive(component, offset) {
      var k = spectralStart;
      var e = spectralEnd;
      var r = 0;
      var s;
      var rs;
      while (k <= e) {
        var z = dctZigZag[k];
        switch (successiveACState) {
          case 0:
            rs = decodeHuffman(component.huffmanTableAC);
            s = rs & 15;
            r = rs >> 4;
            if (s === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r);
                successiveACState = 4;
              } else {
                r = 16;
                successiveACState = 1;
              }
            } else {
              if (s !== 1) {
                error('JPEG error: invalid ACn encoding');
              }
              successiveACNextValue = receiveAndExtend(s);
              successiveACState = r ? 2 : 3;
            }
            continue;
          case 1:
          case 2:
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += readBit() << successive;
            } else {
              r--;
              if (r === 0) {
                successiveACState = successiveACState === 2 ? 3 : 0;
              }
            }
            break;
          case 3:
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += readBit() << successive;
            } else {
              component.blockData[offset + z] = successiveACNextValue << successive;
              successiveACState = 0;
            }
            break;
          case 4:
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += readBit() << successive;
            }
            break;
        }
        k++;
      }
      if (successiveACState === 4) {
        eobrun--;
        if (eobrun === 0) {
          successiveACState = 0;
        }
      }
    }
    function decodeMcu(component, decode, mcu, row, col) {
      var mcuRow = mcu / mcusPerLine | 0;
      var mcuCol = mcu % mcusPerLine;
      var blockRow = mcuRow * component.v + row;
      var blockCol = mcuCol * component.h + col;
      var offset = getBlockBufferOffset(component, blockRow, blockCol);
      decode(component, offset);
    }
    function decodeBlock(component, decode, mcu) {
      var blockRow = mcu / component.blocksPerLine | 0;
      var blockCol = mcu % component.blocksPerLine;
      var offset = getBlockBufferOffset(component, blockRow, blockCol);
      decode(component, offset);
    }
    var componentsLength = components.length;
    var component, i, j, k, n;
    var decodeFn;
    if (progressive) {
      if (spectralStart === 0) {
        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
      } else {
        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
      }
    } else {
      decodeFn = decodeBaseline;
    }
    var mcu = 0,
        fileMarker;
    var mcuExpected;
    if (componentsLength === 1) {
      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
    } else {
      mcuExpected = mcusPerLine * frame.mcusPerColumn;
    }
    var h, v;
    while (mcu < mcuExpected) {
      var mcuToRead = resetInterval ? Math.min(mcuExpected - mcu, resetInterval) : mcuExpected;
      for (i = 0; i < componentsLength; i++) {
        components[i].pred = 0;
      }
      eobrun = 0;
      if (componentsLength === 1) {
        component = components[0];
        for (n = 0; n < mcuToRead; n++) {
          decodeBlock(component, decodeFn, mcu);
          mcu++;
        }
      } else {
        for (n = 0; n < mcuToRead; n++) {
          for (i = 0; i < componentsLength; i++) {
            component = components[i];
            h = component.h;
            v = component.v;
            for (j = 0; j < v; j++) {
              for (k = 0; k < h; k++) {
                decodeMcu(component, decodeFn, mcu, j, k);
              }
            }
          }
          mcu++;
        }
      }
      bitsCount = 0;
      fileMarker = findNextFileMarker(data, offset);
      if (fileMarker && fileMarker.invalid) {
        warn('decodeScan - unexpected MCU data, next marker is: ' + fileMarker.invalid);
        offset = fileMarker.offset;
      }
      var marker = fileMarker && fileMarker.marker;
      if (!marker || marker <= 0xFF00) {
        error('JPEG error: marker was not found');
      }
      if (marker >= 0xFFD0 && marker <= 0xFFD7) {
        offset += 2;
      } else {
        break;
      }
    }
    fileMarker = findNextFileMarker(data, offset);
    if (fileMarker && fileMarker.invalid) {
      warn('decodeScan - unexpected Scan data, next marker is: ' + fileMarker.invalid);
      offset = fileMarker.offset;
    }
    return offset - startOffset;
  }
  function quantizeAndInverse(component, blockBufferOffset, p) {
    var qt = component.quantizationTable,
        blockData = component.blockData;
    var v0, v1, v2, v3, v4, v5, v6, v7;
    var p0, p1, p2, p3, p4, p5, p6, p7;
    var t;
    if (!qt) {
      error('JPEG error: missing required Quantization Table.');
    }
    for (var row = 0; row < 64; row += 8) {
      p0 = blockData[blockBufferOffset + row];
      p1 = blockData[blockBufferOffset + row + 1];
      p2 = blockData[blockBufferOffset + row + 2];
      p3 = blockData[blockBufferOffset + row + 3];
      p4 = blockData[blockBufferOffset + row + 4];
      p5 = blockData[blockBufferOffset + row + 5];
      p6 = blockData[blockBufferOffset + row + 6];
      p7 = blockData[blockBufferOffset + row + 7];
      p0 *= qt[row];
      if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
        t = dctSqrt2 * p0 + 512 >> 10;
        p[row] = t;
        p[row + 1] = t;
        p[row + 2] = t;
        p[row + 3] = t;
        p[row + 4] = t;
        p[row + 5] = t;
        p[row + 6] = t;
        p[row + 7] = t;
        continue;
      }
      p1 *= qt[row + 1];
      p2 *= qt[row + 2];
      p3 *= qt[row + 3];
      p4 *= qt[row + 4];
      p5 *= qt[row + 5];
      p6 *= qt[row + 6];
      p7 *= qt[row + 7];
      v0 = dctSqrt2 * p0 + 128 >> 8;
      v1 = dctSqrt2 * p4 + 128 >> 8;
      v2 = p2;
      v3 = p6;
      v4 = dctSqrt1d2 * (p1 - p7) + 128 >> 8;
      v7 = dctSqrt1d2 * (p1 + p7) + 128 >> 8;
      v5 = p3 << 4;
      v6 = p5 << 4;
      v0 = v0 + v1 + 1 >> 1;
      v1 = v0 - v1;
      t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
      v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
      v3 = t;
      v4 = v4 + v6 + 1 >> 1;
      v6 = v4 - v6;
      v7 = v7 + v5 + 1 >> 1;
      v5 = v7 - v5;
      v0 = v0 + v3 + 1 >> 1;
      v3 = v0 - v3;
      v1 = v1 + v2 + 1 >> 1;
      v2 = v1 - v2;
      t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
      v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
      v7 = t;
      t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
      v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
      v6 = t;
      p[row] = v0 + v7;
      p[row + 7] = v0 - v7;
      p[row + 1] = v1 + v6;
      p[row + 6] = v1 - v6;
      p[row + 2] = v2 + v5;
      p[row + 5] = v2 - v5;
      p[row + 3] = v3 + v4;
      p[row + 4] = v3 - v4;
    }
    for (var col = 0; col < 8; ++col) {
      p0 = p[col];
      p1 = p[col + 8];
      p2 = p[col + 16];
      p3 = p[col + 24];
      p4 = p[col + 32];
      p5 = p[col + 40];
      p6 = p[col + 48];
      p7 = p[col + 56];
      if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
        t = dctSqrt2 * p0 + 8192 >> 14;
        t = t < -2040 ? 0 : t >= 2024 ? 255 : t + 2056 >> 4;
        blockData[blockBufferOffset + col] = t;
        blockData[blockBufferOffset + col + 8] = t;
        blockData[blockBufferOffset + col + 16] = t;
        blockData[blockBufferOffset + col + 24] = t;
        blockData[blockBufferOffset + col + 32] = t;
        blockData[blockBufferOffset + col + 40] = t;
        blockData[blockBufferOffset + col + 48] = t;
        blockData[blockBufferOffset + col + 56] = t;
        continue;
      }
      v0 = dctSqrt2 * p0 + 2048 >> 12;
      v1 = dctSqrt2 * p4 + 2048 >> 12;
      v2 = p2;
      v3 = p6;
      v4 = dctSqrt1d2 * (p1 - p7) + 2048 >> 12;
      v7 = dctSqrt1d2 * (p1 + p7) + 2048 >> 12;
      v5 = p3;
      v6 = p5;
      v0 = (v0 + v1 + 1 >> 1) + 4112;
      v1 = v0 - v1;
      t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
      v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
      v3 = t;
      v4 = v4 + v6 + 1 >> 1;
      v6 = v4 - v6;
      v7 = v7 + v5 + 1 >> 1;
      v5 = v7 - v5;
      v0 = v0 + v3 + 1 >> 1;
      v3 = v0 - v3;
      v1 = v1 + v2 + 1 >> 1;
      v2 = v1 - v2;
      t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
      v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
      v7 = t;
      t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
      v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
      v6 = t;
      p0 = v0 + v7;
      p7 = v0 - v7;
      p1 = v1 + v6;
      p6 = v1 - v6;
      p2 = v2 + v5;
      p5 = v2 - v5;
      p3 = v3 + v4;
      p4 = v3 - v4;
      p0 = p0 < 16 ? 0 : p0 >= 4080 ? 255 : p0 >> 4;
      p1 = p1 < 16 ? 0 : p1 >= 4080 ? 255 : p1 >> 4;
      p2 = p2 < 16 ? 0 : p2 >= 4080 ? 255 : p2 >> 4;
      p3 = p3 < 16 ? 0 : p3 >= 4080 ? 255 : p3 >> 4;
      p4 = p4 < 16 ? 0 : p4 >= 4080 ? 255 : p4 >> 4;
      p5 = p5 < 16 ? 0 : p5 >= 4080 ? 255 : p5 >> 4;
      p6 = p6 < 16 ? 0 : p6 >= 4080 ? 255 : p6 >> 4;
      p7 = p7 < 16 ? 0 : p7 >= 4080 ? 255 : p7 >> 4;
      blockData[blockBufferOffset + col] = p0;
      blockData[blockBufferOffset + col + 8] = p1;
      blockData[blockBufferOffset + col + 16] = p2;
      blockData[blockBufferOffset + col + 24] = p3;
      blockData[blockBufferOffset + col + 32] = p4;
      blockData[blockBufferOffset + col + 40] = p5;
      blockData[blockBufferOffset + col + 48] = p6;
      blockData[blockBufferOffset + col + 56] = p7;
    }
  }
  function buildComponentData(frame, component) {
    var blocksPerLine = component.blocksPerLine;
    var blocksPerColumn = component.blocksPerColumn;
    var computationBuffer = new Int16Array(64);
    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
        var offset = getBlockBufferOffset(component, blockRow, blockCol);
        quantizeAndInverse(component, offset, computationBuffer);
      }
    }
    return component.blockData;
  }
  function clamp0to255(a) {
    return a <= 0 ? 0 : a >= 255 ? 255 : a;
  }
  function findNextFileMarker(data, currentPos, startPos) {
    function peekUint16(pos) {
      return data[pos] << 8 | data[pos + 1];
    }
    var maxPos = data.length - 1;
    var newPos = startPos < currentPos ? startPos : currentPos;
    if (currentPos >= maxPos) {
      return null;
    }
    var currentMarker = peekUint16(currentPos);
    if (currentMarker >= 0xFFC0 && currentMarker <= 0xFFFE) {
      return {
        invalid: null,
        marker: currentMarker,
        offset: currentPos
      };
    }
    var newMarker = peekUint16(newPos);
    while (!(newMarker >= 0xFFC0 && newMarker <= 0xFFFE)) {
      if (++newPos >= maxPos) {
        return null;
      }
      newMarker = peekUint16(newPos);
    }
    return {
      invalid: currentMarker.toString(16),
      marker: newMarker,
      offset: newPos
    };
  }
  JpegImage.prototype = {
    parse: function parse(data) {
      function readUint16() {
        var value = data[offset] << 8 | data[offset + 1];
        offset += 2;
        return value;
      }
      function readDataBlock() {
        var length = readUint16();
        var endOffset = offset + length - 2;
        var fileMarker = findNextFileMarker(data, endOffset, offset);
        if (fileMarker && fileMarker.invalid) {
          warn('readDataBlock - incorrect length, next marker is: ' + fileMarker.invalid);
          endOffset = fileMarker.offset;
        }
        var array = data.subarray(offset, endOffset);
        offset += array.length;
        return array;
      }
      function prepareComponents(frame) {
        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);
        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);
        for (var i = 0; i < frame.components.length; i++) {
          component = frame.components[i];
          var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);
          var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV);
          var blocksPerLineForMcu = mcusPerLine * component.h;
          var blocksPerColumnForMcu = mcusPerColumn * component.v;
          var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
          component.blockData = new Int16Array(blocksBufferSize);
          component.blocksPerLine = blocksPerLine;
          component.blocksPerColumn = blocksPerColumn;
        }
        frame.mcusPerLine = mcusPerLine;
        frame.mcusPerColumn = mcusPerColumn;
      }
      var offset = 0;
      var jfif = null;
      var adobe = null;
      var frame, resetInterval;
      var quantizationTables = [];
      var huffmanTablesAC = [],
          huffmanTablesDC = [];
      var fileMarker = readUint16();
      if (fileMarker !== 0xFFD8) {
        error('JPEG error: SOI not found');
      }
      fileMarker = readUint16();
      while (fileMarker !== 0xFFD9) {
        var i, j, l;
        switch (fileMarker) {
          case 0xFFE0:
          case 0xFFE1:
          case 0xFFE2:
          case 0xFFE3:
          case 0xFFE4:
          case 0xFFE5:
          case 0xFFE6:
          case 0xFFE7:
          case 0xFFE8:
          case 0xFFE9:
          case 0xFFEA:
          case 0xFFEB:
          case 0xFFEC:
          case 0xFFED:
          case 0xFFEE:
          case 0xFFEF:
          case 0xFFFE:
            var appData = readDataBlock();
            if (fileMarker === 0xFFE0) {
              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 && appData[3] === 0x46 && appData[4] === 0) {
                jfif = {
                  version: {
                    major: appData[5],
                    minor: appData[6]
                  },
                  densityUnits: appData[7],
                  xDensity: appData[8] << 8 | appData[9],
                  yDensity: appData[10] << 8 | appData[11],
                  thumbWidth: appData[12],
                  thumbHeight: appData[13],
                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                };
              }
            }
            if (fileMarker === 0xFFEE) {
              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F && appData[3] === 0x62 && appData[4] === 0x65) {
                adobe = {
                  version: appData[5] << 8 | appData[6],
                  flags0: appData[7] << 8 | appData[8],
                  flags1: appData[9] << 8 | appData[10],
                  transformCode: appData[11]
                };
              }
            }
            break;
          case 0xFFDB:
            var quantizationTablesLength = readUint16();
            var quantizationTablesEnd = quantizationTablesLength + offset - 2;
            var z;
            while (offset < quantizationTablesEnd) {
              var quantizationTableSpec = data[offset++];
              var tableData = new Uint16Array(64);
              if (quantizationTableSpec >> 4 === 0) {
                for (j = 0; j < 64; j++) {
                  z = dctZigZag[j];
                  tableData[z] = data[offset++];
                }
              } else if (quantizationTableSpec >> 4 === 1) {
                for (j = 0; j < 64; j++) {
                  z = dctZigZag[j];
                  tableData[z] = readUint16();
                }
              } else {
                error('JPEG error: DQT - invalid table spec');
              }
              quantizationTables[quantizationTableSpec & 15] = tableData;
            }
            break;
          case 0xFFC0:
          case 0xFFC1:
          case 0xFFC2:
            if (frame) {
              error('JPEG error: Only single frame JPEGs supported');
            }
            readUint16();
            frame = {};
            frame.extended = fileMarker === 0xFFC1;
            frame.progressive = fileMarker === 0xFFC2;
            frame.precision = data[offset++];
            frame.scanLines = readUint16();
            frame.samplesPerLine = readUint16();
            frame.components = [];
            frame.componentIds = {};
            var componentsCount = data[offset++],
                componentId;
            var maxH = 0,
                maxV = 0;
            for (i = 0; i < componentsCount; i++) {
              componentId = data[offset];
              var h = data[offset + 1] >> 4;
              var v = data[offset + 1] & 15;
              if (maxH < h) {
                maxH = h;
              }
              if (maxV < v) {
                maxV = v;
              }
              var qId = data[offset + 2];
              l = frame.components.push({
                h: h,
                v: v,
                quantizationId: qId,
                quantizationTable: null
              });
              frame.componentIds[componentId] = l - 1;
              offset += 3;
            }
            frame.maxH = maxH;
            frame.maxV = maxV;
            prepareComponents(frame);
            break;
          case 0xFFC4:
            var huffmanLength = readUint16();
            for (i = 2; i < huffmanLength;) {
              var huffmanTableSpec = data[offset++];
              var codeLengths = new Uint8Array(16);
              var codeLengthSum = 0;
              for (j = 0; j < 16; j++, offset++) {
                codeLengthSum += codeLengths[j] = data[offset];
              }
              var huffmanValues = new Uint8Array(codeLengthSum);
              for (j = 0; j < codeLengthSum; j++, offset++) {
                huffmanValues[j] = data[offset];
              }
              i += 17 + codeLengthSum;
              (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
            }
            break;
          case 0xFFDD:
            readUint16();
            resetInterval = readUint16();
            break;
          case 0xFFDA:
            readUint16();
            var selectorsCount = data[offset++];
            var components = [],
                component;
            for (i = 0; i < selectorsCount; i++) {
              var componentIndex = frame.componentIds[data[offset++]];
              component = frame.components[componentIndex];
              var tableSpec = data[offset++];
              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
              components.push(component);
            }
            var spectralStart = data[offset++];
            var spectralEnd = data[offset++];
            var successiveApproximation = data[offset++];
            var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15);
            offset += processed;
            break;
          case 0xFFFF:
            if (data[offset] !== 0xFF) {
              offset--;
            }
            break;
          default:
            if (data[offset - 3] === 0xFF && data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
              offset -= 3;
              break;
            }
            error('JPEG error: unknown marker ' + fileMarker.toString(16));
        }
        fileMarker = readUint16();
      }
      this.width = frame.samplesPerLine;
      this.height = frame.scanLines;
      this.jfif = jfif;
      this.adobe = adobe;
      this.components = [];
      for (i = 0; i < frame.components.length; i++) {
        component = frame.components[i];
        var quantizationTable = quantizationTables[component.quantizationId];
        if (quantizationTable) {
          component.quantizationTable = quantizationTable;
        }
        this.components.push({
          output: buildComponentData(frame, component),
          scaleX: component.h / frame.maxH,
          scaleY: component.v / frame.maxV,
          blocksPerLine: component.blocksPerLine,
          blocksPerColumn: component.blocksPerColumn
        });
      }
      this.numComponents = this.components.length;
    },
    _getLinearizedBlockData: function getLinearizedBlockData(width, height) {
      var scaleX = this.width / width,
          scaleY = this.height / height;
      var component, componentScaleX, componentScaleY, blocksPerScanline;
      var x, y, i, j, k;
      var index;
      var offset = 0;
      var output;
      var numComponents = this.components.length;
      var dataLength = width * height * numComponents;
      var data = new Uint8Array(dataLength);
      var xScaleBlockOffset = new Uint32Array(width);
      var mask3LSB = 0xfffffff8;
      for (i = 0; i < numComponents; i++) {
        component = this.components[i];
        componentScaleX = component.scaleX * scaleX;
        componentScaleY = component.scaleY * scaleY;
        offset = i;
        output = component.output;
        blocksPerScanline = component.blocksPerLine + 1 << 3;
        for (x = 0; x < width; x++) {
          j = 0 | x * componentScaleX;
          xScaleBlockOffset[x] = (j & mask3LSB) << 3 | j & 7;
        }
        for (y = 0; y < height; y++) {
          j = 0 | y * componentScaleY;
          index = blocksPerScanline * (j & mask3LSB) | (j & 7) << 3;
          for (x = 0; x < width; x++) {
            data[offset] = output[index + xScaleBlockOffset[x]];
            offset += numComponents;
          }
        }
      }
      var transform = this.decodeTransform;
      if (transform) {
        for (i = 0; i < dataLength;) {
          for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {
            data[i] = (data[i] * transform[k] >> 8) + transform[k + 1];
          }
        }
      }
      return data;
    },
    _isColorConversionNeeded: function isColorConversionNeeded() {
      if (this.adobe && this.adobe.transformCode) {
        return true;
      } else if (this.numComponents === 3) {
        if (!this.adobe && this.colorTransform === 0) {
          return false;
        }
        return true;
      }
      if (!this.adobe && this.colorTransform === 1) {
        return true;
      }
      return false;
    },
    _convertYccToRgb: function convertYccToRgb(data) {
      var Y, Cb, Cr;
      for (var i = 0, length = data.length; i < length; i += 3) {
        Y = data[i];
        Cb = data[i + 1];
        Cr = data[i + 2];
        data[i] = clamp0to255(Y - 179.456 + 1.402 * Cr);
        data[i + 1] = clamp0to255(Y + 135.459 - 0.344 * Cb - 0.714 * Cr);
        data[i + 2] = clamp0to255(Y - 226.816 + 1.772 * Cb);
      }
      return data;
    },
    _convertYcckToRgb: function convertYcckToRgb(data) {
      var Y, Cb, Cr, k;
      var offset = 0;
      for (var i = 0, length = data.length; i < length; i += 4) {
        Y = data[i];
        Cb = data[i + 1];
        Cr = data[i + 2];
        k = data[i + 3];
        var r = -122.67195406894 + Cb * (-6.60635669420364e-5 * Cb + 0.000437130475926232 * Cr - 5.4080610064599e-5 * Y + 0.00048449797120281 * k - 0.154362151871126) + Cr * (-0.000957964378445773 * Cr + 0.000817076911346625 * Y - 0.00477271405408747 * k + 1.53380253221734) + Y * (0.000961250184130688 * Y - 0.00266257332283933 * k + 0.48357088451265) + k * (-0.000336197177618394 * k + 0.484791561490776);
        var g = 107.268039397724 + Cb * (2.19927104525741e-5 * Cb - 0.000640992018297945 * Cr + 0.000659397001245577 * Y + 0.000426105652938837 * k - 0.176491792462875) + Cr * (-0.000778269941513683 * Cr + 0.00130872261408275 * Y + 0.000770482631801132 * k - 0.151051492775562) + Y * (0.00126935368114843 * Y - 0.00265090189010898 * k + 0.25802910206845) + k * (-0.000318913117588328 * k - 0.213742400323665);
        var b = -20.810012546947 + Cb * (-0.000570115196973677 * Cb - 2.63409051004589e-5 * Cr + 0.0020741088115012 * Y - 0.00288260236853442 * k + 0.814272968359295) + Cr * (-1.53496057440975e-5 * Cr - 0.000132689043961446 * Y + 0.000560833691242812 * k - 0.195152027534049) + Y * (0.00174418132927582 * Y - 0.00255243321439347 * k + 0.116935020465145) + k * (-0.000343531996510555 * k + 0.24165260232407);
        data[offset++] = clamp0to255(r);
        data[offset++] = clamp0to255(g);
        data[offset++] = clamp0to255(b);
      }
      return data;
    },
    _convertYcckToCmyk: function convertYcckToCmyk(data) {
      var Y, Cb, Cr;
      for (var i = 0, length = data.length; i < length; i += 4) {
        Y = data[i];
        Cb = data[i + 1];
        Cr = data[i + 2];
        data[i] = clamp0to255(434.456 - Y - 1.402 * Cr);
        data[i + 1] = clamp0to255(119.541 - Y + 0.344 * Cb + 0.714 * Cr);
        data[i + 2] = clamp0to255(481.816 - Y - 1.772 * Cb);
      }
      return data;
    },
    _convertCmykToRgb: function convertCmykToRgb(data) {
      var c, m, y, k;
      var offset = 0;
      var min = -255 * 255 * 255;
      var scale = 1 / 255 / 255;
      for (var i = 0, length = data.length; i < length; i += 4) {
        c = data[i];
        m = data[i + 1];
        y = data[i + 2];
        k = data[i + 3];
        var r = c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k - 72734.4411664936) + m * (1.7149763477362134 * m - 5.6096736904047315 * y - 17.873870861415444 * k - 1401.7366389350734) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 4465.541406466231) - k * (21.86122147463605 * k + 48317.86113160301);
        var g = c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k - 20220.756542821975) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 48691.05921601825) + y * (4.444339102852739 * y + 9.8632861493405 * k - 6341.191035517494) - k * (20.737325471181034 * k + 47890.15695978492);
        var b = c * (0.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - 0.23883238689178934 * k - 3616.812083916688) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 28620.90484698408) + y * (0.03296041114873217 * y + 115.60384449646641 * k - 49363.43385999684) - k * (22.33816807309886 * k + 45932.16563550634);
        data[offset++] = r >= 0 ? 255 : r <= min ? 0 : 255 + r * scale | 0;
        data[offset++] = g >= 0 ? 255 : g <= min ? 0 : 255 + g * scale | 0;
        data[offset++] = b >= 0 ? 255 : b <= min ? 0 : 255 + b * scale | 0;
      }
      return data;
    },
    getData: function getData(width, height, forceRGBoutput) {
      if (this.numComponents > 4) {
        error('JPEG error: Unsupported color mode');
      }
      var data = this._getLinearizedBlockData(width, height);
      if (this.numComponents === 1 && forceRGBoutput) {
        var dataLength = data.length;
        var rgbData = new Uint8Array(dataLength * 3);
        var offset = 0;
        for (var i = 0; i < dataLength; i++) {
          var grayColor = data[i];
          rgbData[offset++] = grayColor;
          rgbData[offset++] = grayColor;
          rgbData[offset++] = grayColor;
        }
        return rgbData;
      } else if (this.numComponents === 3 && this._isColorConversionNeeded()) {
        return this._convertYccToRgb(data);
      } else if (this.numComponents === 4) {
        if (this._isColorConversionNeeded()) {
          if (forceRGBoutput) {
            return this._convertYcckToRgb(data);
          }
          return this._convertYcckToCmyk(data);
        } else if (forceRGBoutput) {
          return this._convertCmykToRgb(data);
        }
      }
      return data;
    }
  };
  return JpegImage;
}();
exports.JpegImage = JpegImage;

/***/ }),
/* 30 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var getLookupTableFactory = sharedUtil.getLookupTableFactory;
var getMetrics = getLookupTableFactory(function (t) {
  t['Courier'] = 600;
  t['Courier-Bold'] = 600;
  t['Courier-BoldOblique'] = 600;
  t['Courier-Oblique'] = 600;
  t['Helvetica'] = getLookupTableFactory(function (t) {
    t['space'] = 278;
    t['exclam'] = 278;
    t['quotedbl'] = 355;
    t['numbersign'] = 556;
    t['dollar'] = 556;
    t['percent'] = 889;
    t['ampersand'] = 667;
    t['quoteright'] = 222;
    t['parenleft'] = 333;
    t['parenright'] = 333;
    t['asterisk'] = 389;
    t['plus'] = 584;
    t['comma'] = 278;
    t['hyphen'] = 333;
    t['period'] = 278;
    t['slash'] = 278;
    t['zero'] = 556;
    t['one'] = 556;
    t['two'] = 556;
    t['three'] = 556;
    t['four'] = 556;
    t['five'] = 556;
    t['six'] = 556;
    t['seven'] = 556;
    t['eight'] = 556;
    t['nine'] = 556;
    t['colon'] = 278;
    t['semicolon'] = 278;
    t['less'] = 584;
    t['equal'] = 584;
    t['greater'] = 584;
    t['question'] = 556;
    t['at'] = 1015;
    t['A'] = 667;
    t['B'] = 667;
    t['C'] = 722;
    t['D'] = 722;
    t['E'] = 667;
    t['F'] = 611;
    t['G'] = 778;
    t['H'] = 722;
    t['I'] = 278;
    t['J'] = 500;
    t['K'] = 667;
    t['L'] = 556;
    t['M'] = 833;
    t['N'] = 722;
    t['O'] = 778;
    t['P'] = 667;
    t['Q'] = 778;
    t['R'] = 722;
    t['S'] = 667;
    t['T'] = 611;
    t['U'] = 722;
    t['V'] = 667;
    t['W'] = 944;
    t['X'] = 667;
    t['Y'] = 667;
    t['Z'] = 611;
    t['bracketleft'] = 278;
    t['backslash'] = 278;
    t['bracketright'] = 278;
    t['asciicircum'] = 469;
    t['underscore'] = 556;
    t['quoteleft'] = 222;
    t['a'] = 556;
    t['b'] = 556;
    t['c'] = 500;
    t['d'] = 556;
    t['e'] = 556;
    t['f'] = 278;
    t['g'] = 556;
    t['h'] = 556;
    t['i'] = 222;
    t['j'] = 222;
    t['k'] = 500;
    t['l'] = 222;
    t['m'] = 833;
    t['n'] = 556;
    t['o'] = 556;
    t['p'] = 556;
    t['q'] = 556;
    t['r'] = 333;
    t['s'] = 500;
    t['t'] = 278;
    t['u'] = 556;
    t['v'] = 500;
    t['w'] = 722;
    t['x'] = 500;
    t['y'] = 500;
    t['z'] = 500;
    t['braceleft'] = 334;
    t['bar'] = 260;
    t['braceright'] = 334;
    t['asciitilde'] = 584;
    t['exclamdown'] = 333;
    t['cent'] = 556;
    t['sterling'] = 556;
    t['fraction'] = 167;
    t['yen'] = 556;
    t['florin'] = 556;
    t['section'] = 556;
    t['currency'] = 556;
    t['quotesingle'] = 191;
    t['quotedblleft'] = 333;
    t['guillemotleft'] = 556;
    t['guilsinglleft'] = 333;
    t['guilsinglright'] = 333;
    t['fi'] = 500;
    t['fl'] = 500;
    t['endash'] = 556;
    t['dagger'] = 556;
    t['daggerdbl'] = 556;
    t['periodcentered'] = 278;
    t['paragraph'] = 537;
    t['bullet'] = 350;
    t['quotesinglbase'] = 222;
    t['quotedblbase'] = 333;
    t['quotedblright'] = 333;
    t['guillemotright'] = 556;
    t['ellipsis'] = 1000;
    t['perthousand'] = 1000;
    t['questiondown'] = 611;
    t['grave'] = 333;
    t['acute'] = 333;
    t['circumflex'] = 333;
    t['tilde'] = 333;
    t['macron'] = 333;
    t['breve'] = 333;
    t['dotaccent'] = 333;
    t['dieresis'] = 333;
    t['ring'] = 333;
    t['cedilla'] = 333;
    t['hungarumlaut'] = 333;
    t['ogonek'] = 333;
    t['caron'] = 333;
    t['emdash'] = 1000;
    t['AE'] = 1000;
    t['ordfeminine'] = 370;
    t['Lslash'] = 556;
    t['Oslash'] = 778;
    t['OE'] = 1000;
    t['ordmasculine'] = 365;
    t['ae'] = 889;
    t['dotlessi'] = 278;
    t['lslash'] = 222;
    t['oslash'] = 611;
    t['oe'] = 944;
    t['germandbls'] = 611;
    t['Idieresis'] = 278;
    t['eacute'] = 556;
    t['abreve'] = 556;
    t['uhungarumlaut'] = 556;
    t['ecaron'] = 556;
    t['Ydieresis'] = 667;
    t['divide'] = 584;
    t['Yacute'] = 667;
    t['Acircumflex'] = 667;
    t['aacute'] = 556;
    t['Ucircumflex'] = 722;
    t['yacute'] = 500;
    t['scommaaccent'] = 500;
    t['ecircumflex'] = 556;
    t['Uring'] = 722;
    t['Udieresis'] = 722;
    t['aogonek'] = 556;
    t['Uacute'] = 722;
    t['uogonek'] = 556;
    t['Edieresis'] = 667;
    t['Dcroat'] = 722;
    t['commaaccent'] = 250;
    t['copyright'] = 737;
    t['Emacron'] = 667;
    t['ccaron'] = 500;
    t['aring'] = 556;
    t['Ncommaaccent'] = 722;
    t['lacute'] = 222;
    t['agrave'] = 556;
    t['Tcommaaccent'] = 611;
    t['Cacute'] = 722;
    t['atilde'] = 556;
    t['Edotaccent'] = 667;
    t['scaron'] = 500;
    t['scedilla'] = 500;
    t['iacute'] = 278;
    t['lozenge'] = 471;
    t['Rcaron'] = 722;
    t['Gcommaaccent'] = 778;
    t['ucircumflex'] = 556;
    t['acircumflex'] = 556;
    t['Amacron'] = 667;
    t['rcaron'] = 333;
    t['ccedilla'] = 500;
    t['Zdotaccent'] = 611;
    t['Thorn'] = 667;
    t['Omacron'] = 778;
    t['Racute'] = 722;
    t['Sacute'] = 667;
    t['dcaron'] = 643;
    t['Umacron'] = 722;
    t['uring'] = 556;
    t['threesuperior'] = 333;
    t['Ograve'] = 778;
    t['Agrave'] = 667;
    t['Abreve'] = 667;
    t['multiply'] = 584;
    t['uacute'] = 556;
    t['Tcaron'] = 611;
    t['partialdiff'] = 476;
    t['ydieresis'] = 500;
    t['Nacute'] = 722;
    t['icircumflex'] = 278;
    t['Ecircumflex'] = 667;
    t['adieresis'] = 556;
    t['edieresis'] = 556;
    t['cacute'] = 500;
    t['nacute'] = 556;
    t['umacron'] = 556;
    t['Ncaron'] = 722;
    t['Iacute'] = 278;
    t['plusminus'] = 584;
    t['brokenbar'] = 260;
    t['registered'] = 737;
    t['Gbreve'] = 778;
    t['Idotaccent'] = 278;
    t['summation'] = 600;
    t['Egrave'] = 667;
    t['racute'] = 333;
    t['omacron'] = 556;
    t['Zacute'] = 611;
    t['Zcaron'] = 611;
    t['greaterequal'] = 549;
    t['Eth'] = 722;
    t['Ccedilla'] = 722;
    t['lcommaaccent'] = 222;
    t['tcaron'] = 317;
    t['eogonek'] = 556;
    t['Uogonek'] = 722;
    t['Aacute'] = 667;
    t['Adieresis'] = 667;
    t['egrave'] = 556;
    t['zacute'] = 500;
    t['iogonek'] = 222;
    t['Oacute'] = 778;
    t['oacute'] = 556;
    t['amacron'] = 556;
    t['sacute'] = 500;
    t['idieresis'] = 278;
    t['Ocircumflex'] = 778;
    t['Ugrave'] = 722;
    t['Delta'] = 612;
    t['thorn'] = 556;
    t['twosuperior'] = 333;
    t['Odieresis'] = 778;
    t['mu'] = 556;
    t['igrave'] = 278;
    t['ohungarumlaut'] = 556;
    t['Eogonek'] = 667;
    t['dcroat'] = 556;
    t['threequarters'] = 834;
    t['Scedilla'] = 667;
    t['lcaron'] = 299;
    t['Kcommaaccent'] = 667;
    t['Lacute'] = 556;
    t['trademark'] = 1000;
    t['edotaccent'] = 556;
    t['Igrave'] = 278;
    t['Imacron'] = 278;
    t['Lcaron'] = 556;
    t['onehalf'] = 834;
    t['lessequal'] = 549;
    t['ocircumflex'] = 556;
    t['ntilde'] = 556;
    t['Uhungarumlaut'] = 722;
    t['Eacute'] = 667;
    t['emacron'] = 556;
    t['gbreve'] = 556;
    t['onequarter'] = 834;
    t['Scaron'] = 667;
    t['Scommaaccent'] = 667;
    t['Ohungarumlaut'] = 778;
    t['degree'] = 400;
    t['ograve'] = 556;
    t['Ccaron'] = 722;
    t['ugrave'] = 556;
    t['radical'] = 453;
    t['Dcaron'] = 722;
    t['rcommaaccent'] = 333;
    t['Ntilde'] = 722;
    t['otilde'] = 556;
    t['Rcommaaccent'] = 722;
    t['Lcommaaccent'] = 556;
    t['Atilde'] = 667;
    t['Aogonek'] = 667;
    t['Aring'] = 667;
    t['Otilde'] = 778;
    t['zdotaccent'] = 500;
    t['Ecaron'] = 667;
    t['Iogonek'] = 278;
    t['kcommaaccent'] = 500;
    t['minus'] = 584;
    t['Icircumflex'] = 278;
    t['ncaron'] = 556;
    t['tcommaaccent'] = 278;
    t['logicalnot'] = 584;
    t['odieresis'] = 556;
    t['udieresis'] = 556;
    t['notequal'] = 549;
    t['gcommaaccent'] = 556;
    t['eth'] = 556;
    t['zcaron'] = 500;
    t['ncommaaccent'] = 556;
    t['onesuperior'] = 333;
    t['imacron'] = 278;
    t['Euro'] = 556;
  });
  t['Helvetica-Bold'] = getLookupTableFactory(function (t) {
    t['space'] = 278;
    t['exclam'] = 333;
    t['quotedbl'] = 474;
    t['numbersign'] = 556;
    t['dollar'] = 556;
    t['percent'] = 889;
    t['ampersand'] = 722;
    t['quoteright'] = 278;
    t['parenleft'] = 333;
    t['parenright'] = 333;
    t['asterisk'] = 389;
    t['plus'] = 584;
    t['comma'] = 278;
    t['hyphen'] = 333;
    t['period'] = 278;
    t['slash'] = 278;
    t['zero'] = 556;
    t['one'] = 556;
    t['two'] = 556;
    t['three'] = 556;
    t['four'] = 556;
    t['five'] = 556;
    t['six'] = 556;
    t['seven'] = 556;
    t['eight'] = 556;
    t['nine'] = 556;
    t['colon'] = 333;
    t['semicolon'] = 333;
    t['less'] = 584;
    t['equal'] = 584;
    t['greater'] = 584;
    t['question'] = 611;
    t['at'] = 975;
    t['A'] = 722;
    t['B'] = 722;
    t['C'] = 722;
    t['D'] = 722;
    t['E'] = 667;
    t['F'] = 611;
    t['G'] = 778;
    t['H'] = 722;
    t['I'] = 278;
    t['J'] = 556;
    t['K'] = 722;
    t['L'] = 611;
    t['M'] = 833;
    t['N'] = 722;
    t['O'] = 778;
    t['P'] = 667;
    t['Q'] = 778;
    t['R'] = 722;
    t['S'] = 667;
    t['T'] = 611;
    t['U'] = 722;
    t['V'] = 667;
    t['W'] = 944;
    t['X'] = 667;
    t['Y'] = 667;
    t['Z'] = 611;
    t['bracketleft'] = 333;
    t['backslash'] = 278;
    t['bracketright'] = 333;
    t['asciicircum'] = 584;
    t['underscore'] = 556;
    t['quoteleft'] = 278;
    t['a'] = 556;
    t['b'] = 611;
    t['c'] = 556;
    t['d'] = 611;
    t['e'] = 556;
    t['f'] = 333;
    t['g'] = 611;
    t['h'] = 611;
    t['i'] = 278;
    t['j'] = 278;
    t['k'] = 556;
    t['l'] = 278;
    t['m'] = 889;
    t['n'] = 611;
    t['o'] = 611;
    t['p'] = 611;
    t['q'] = 611;
    t['r'] = 389;
    t['s'] = 556;
    t['t'] = 333;
    t['u'] = 611;
    t['v'] = 556;
    t['w'] = 778;
    t['x'] = 556;
    t['y'] = 556;
    t['z'] = 500;
    t['braceleft'] = 389;
    t['bar'] = 280;
    t['braceright'] = 389;
    t['asciitilde'] = 584;
    t['exclamdown'] = 333;
    t['cent'] = 556;
    t['sterling'] = 556;
    t['fraction'] = 167;
    t['yen'] = 556;
    t['florin'] = 556;
    t['section'] = 556;
    t['currency'] = 556;
    t['quotesingle'] = 238;
    t['quotedblleft'] = 500;
    t['guillemotleft'] = 556;
    t['guilsinglleft'] = 333;
    t['guilsinglright'] = 333;
    t['fi'] = 611;
    t['fl'] = 611;
    t['endash'] = 556;
    t['dagger'] = 556;
    t['daggerdbl'] = 556;
    t['periodcentered'] = 278;
    t['paragraph'] = 556;
    t['bullet'] = 350;
    t['quotesinglbase'] = 278;
    t['quotedblbase'] = 500;
    t['quotedblright'] = 500;
    t['guillemotright'] = 556;
    t['ellipsis'] = 1000;
    t['perthousand'] = 1000;
    t['questiondown'] = 611;
    t['grave'] = 333;
    t['acute'] = 333;
    t['circumflex'] = 333;
    t['tilde'] = 333;
    t['macron'] = 333;
    t['breve'] = 333;
    t['dotaccent'] = 333;
    t['dieresis'] = 333;
    t['ring'] = 333;
    t['cedilla'] = 333;
    t['hungarumlaut'] = 333;
    t['ogonek'] = 333;
    t['caron'] = 333;
    t['emdash'] = 1000;
    t['AE'] = 1000;
    t['ordfeminine'] = 370;
    t['Lslash'] = 611;
    t['Oslash'] = 778;
    t['OE'] = 1000;
    t['ordmasculine'] = 365;
    t['ae'] = 889;
    t['dotlessi'] = 278;
    t['lslash'] = 278;
    t['oslash'] = 611;
    t['oe'] = 944;
    t['germandbls'] = 611;
    t['Idieresis'] = 278;
    t['eacute'] = 556;
    t['abreve'] = 556;
    t['uhungarumlaut'] = 611;
    t['ecaron'] = 556;
    t['Ydieresis'] = 667;
    t['divide'] = 584;
    t['Yacute'] = 667;
    t['Acircumflex'] = 722;
    t['aacute'] = 556;
    t['Ucircumflex'] = 722;
    t['yacute'] = 556;
    t['scommaaccent'] = 556;
    t['ecircumflex'] = 556;
    t['Uring'] = 722;
    t['Udieresis'] = 722;
    t['aogonek'] = 556;
    t['Uacute'] = 722;
    t['uogonek'] = 611;
    t['Edieresis'] = 667;
    t['Dcroat'] = 722;
    t['commaaccent'] = 250;
    t['copyright'] = 737;
    t['Emacron'] = 667;
    t['ccaron'] = 556;
    t['aring'] = 556;
    t['Ncommaaccent'] = 722;
    t['lacute'] = 278;
    t['agrave'] = 556;
    t['Tcommaaccent'] = 611;
    t['Cacute'] = 722;
    t['atilde'] = 556;
    t['Edotaccent'] = 667;
    t['scaron'] = 556;
    t['scedilla'] = 556;
    t['iacute'] = 278;
    t['lozenge'] = 494;
    t['Rcaron'] = 722;
    t['Gcommaaccent'] = 778;
    t['ucircumflex'] = 611;
    t['acircumflex'] = 556;
    t['Amacron'] = 722;
    t['rcaron'] = 389;
    t['ccedilla'] = 556;
    t['Zdotaccent'] = 611;
    t['Thorn'] = 667;
    t['Omacron'] = 778;
    t['Racute'] = 722;
    t['Sacute'] = 667;
    t['dcaron'] = 743;
    t['Umacron'] = 722;
    t['uring'] = 611;
    t['threesuperior'] = 333;
    t['Ograve'] = 778;
    t['Agrave'] = 722;
    t['Abreve'] = 722;
    t['multiply'] = 584;
    t['uacute'] = 611;
    t['Tcaron'] = 611;
    t['partialdiff'] = 494;
    t['ydieresis'] = 556;
    t['Nacute'] = 722;
    t['icircumflex'] = 278;
    t['Ecircumflex'] = 667;
    t['adieresis'] = 556;
    t['edieresis'] = 556;
    t['cacute'] = 556;
    t['nacute'] = 611;
    t['umacron'] = 611;
    t['Ncaron'] = 722;
    t['Iacute'] = 278;
    t['plusminus'] = 584;
    t['brokenbar'] = 280;
    t['registered'] = 737;
    t['Gbreve'] = 778;
    t['Idotaccent'] = 278;
    t['summation'] = 600;
    t['Egrave'] = 667;
    t['racute'] = 389;
    t['omacron'] = 611;
    t['Zacute'] = 611;
    t['Zcaron'] = 611;
    t['greaterequal'] = 549;
    t['Eth'] = 722;
    t['Ccedilla'] = 722;
    t['lcommaaccent'] = 278;
    t['tcaron'] = 389;
    t['eogonek'] = 556;
    t['Uogonek'] = 722;
    t['Aacute'] = 722;
    t['Adieresis'] = 722;
    t['egrave'] = 556;
    t['zacute'] = 500;
    t['iogonek'] = 278;
    t['Oacute'] = 778;
    t['oacute'] = 611;
    t['amacron'] = 556;
    t['sacute'] = 556;
    t['idieresis'] = 278;
    t['Ocircumflex'] = 778;
    t['Ugrave'] = 722;
    t['Delta'] = 612;
    t['thorn'] = 611;
    t['twosuperior'] = 333;
    t['Odieresis'] = 778;
    t['mu'] = 611;
    t['igrave'] = 278;
    t['ohungarumlaut'] = 611;
    t['Eogonek'] = 667;
    t['dcroat'] = 611;
    t['threequarters'] = 834;
    t['Scedilla'] = 667;
    t['lcaron'] = 400;
    t['Kcommaaccent'] = 722;
    t['Lacute'] = 611;
    t['trademark'] = 1000;
    t['edotaccent'] = 556;
    t['Igrave'] = 278;
    t['Imacron'] = 278;
    t['Lcaron'] = 611;
    t['onehalf'] = 834;
    t['lessequal'] = 549;
    t['ocircumflex'] = 611;
    t['ntilde'] = 611;
    t['Uhungarumlaut'] = 722;
    t['Eacute'] = 667;
    t['emacron'] = 556;
    t['gbreve'] = 611;
    t['onequarter'] = 834;
    t['Scaron'] = 667;
    t['Scommaaccent'] = 667;
    t['Ohungarumlaut'] = 778;
    t['degree'] = 400;
    t['ograve'] = 611;
    t['Ccaron'] = 722;
    t['ugrave'] = 611;
    t['radical'] = 549;
    t['Dcaron'] = 722;
    t['rcommaaccent'] = 389;
    t['Ntilde'] = 722;
    t['otilde'] = 611;
    t['Rcommaaccent'] = 722;
    t['Lcommaaccent'] = 611;
    t['Atilde'] = 722;
    t['Aogonek'] = 722;
    t['Aring'] = 722;
    t['Otilde'] = 778;
    t['zdotaccent'] = 500;
    t['Ecaron'] = 667;
    t['Iogonek'] = 278;
    t['kcommaaccent'] = 556;
    t['minus'] = 584;
    t['Icircumflex'] = 278;
    t['ncaron'] = 611;
    t['tcommaaccent'] = 333;
    t['logicalnot'] = 584;
    t['odieresis'] = 611;
    t['udieresis'] = 611;
    t['notequal'] = 549;
    t['gcommaaccent'] = 611;
    t['eth'] = 611;
    t['zcaron'] = 500;
    t['ncommaaccent'] = 611;
    t['onesuperior'] = 333;
    t['imacron'] = 278;
    t['Euro'] = 556;
  });
  t['Helvetica-BoldOblique'] = getLookupTableFactory(function (t) {
    t['space'] = 278;
    t['exclam'] = 333;
    t['quotedbl'] = 474;
    t['numbersign'] = 556;
    t['dollar'] = 556;
    t['percent'] = 889;
    t['ampersand'] = 722;
    t['quoteright'] = 278;
    t['parenleft'] = 333;
    t['parenright'] = 333;
    t['asterisk'] = 389;
    t['plus'] = 584;
    t['comma'] = 278;
    t['hyphen'] = 333;
    t['period'] = 278;
    t['slash'] = 278;
    t['zero'] = 556;
    t['one'] = 556;
    t['two'] = 556;
    t['three'] = 556;
    t['four'] = 556;
    t['five'] = 556;
    t['six'] = 556;
    t['seven'] = 556;
    t['eight'] = 556;
    t['nine'] = 556;
    t['colon'] = 333;
    t['semicolon'] = 333;
    t['less'] = 584;
    t['equal'] = 584;
    t['greater'] = 584;
    t['question'] = 611;
    t['at'] = 975;
    t['A'] = 722;
    t['B'] = 722;
    t['C'] = 722;
    t['D'] = 722;
    t['E'] = 667;
    t['F'] = 611;
    t['G'] = 778;
    t['H'] = 722;
    t['I'] = 278;
    t['J'] = 556;
    t['K'] = 722;
    t['L'] = 611;
    t['M'] = 833;
    t['N'] = 722;
    t['O'] = 778;
    t['P'] = 667;
    t['Q'] = 778;
    t['R'] = 722;
    t['S'] = 667;
    t['T'] = 611;
    t['U'] = 722;
    t['V'] = 667;
    t['W'] = 944;
    t['X'] = 667;
    t['Y'] = 667;
    t['Z'] = 611;
    t['bracketleft'] = 333;
    t['backslash'] = 278;
    t['bracketright'] = 333;
    t['asciicircum'] = 584;
    t['underscore'] = 556;
    t['quoteleft'] = 278;
    t['a'] = 556;
    t['b'] = 611;
    t['c'] = 556;
    t['d'] = 611;
    t['e'] = 556;
    t['f'] = 333;
    t['g'] = 611;
    t['h'] = 611;
    t['i'] = 278;
    t['j'] = 278;
    t['k'] = 556;
    t['l'] = 278;
    t['m'] = 889;
    t['n'] = 611;
    t['o'] = 611;
    t['p'] = 611;
    t['q'] = 611;
    t['r'] = 389;
    t['s'] = 556;
    t['t'] = 333;
    t['u'] = 611;
    t['v'] = 556;
    t['w'] = 778;
    t['x'] = 556;
    t['y'] = 556;
    t['z'] = 500;
    t['braceleft'] = 389;
    t['bar'] = 280;
    t['braceright'] = 389;
    t['asciitilde'] = 584;
    t['exclamdown'] = 333;
    t['cent'] = 556;
    t['sterling'] = 556;
    t['fraction'] = 167;
    t['yen'] = 556;
    t['florin'] = 556;
    t['section'] = 556;
    t['currency'] = 556;
    t['quotesingle'] = 238;
    t['quotedblleft'] = 500;
    t['guillemotleft'] = 556;
    t['guilsinglleft'] = 333;
    t['guilsinglright'] = 333;
    t['fi'] = 611;
    t['fl'] = 611;
    t['endash'] = 556;
    t['dagger'] = 556;
    t['daggerdbl'] = 556;
    t['periodcentered'] = 278;
    t['paragraph'] = 556;
    t['bullet'] = 350;
    t['quotesinglbase'] = 278;
    t['quotedblbase'] = 500;
    t['quotedblright'] = 500;
    t['guillemotright'] = 556;
    t['ellipsis'] = 1000;
    t['perthousand'] = 1000;
    t['questiondown'] = 611;
    t['grave'] = 333;
    t['acute'] = 333;
    t['circumflex'] = 333;
    t['tilde'] = 333;
    t['macron'] = 333;
    t['breve'] = 333;
    t['dotaccent'] = 333;
    t['dieresis'] = 333;
    t['ring'] = 333;
    t['cedilla'] = 333;
    t['hungarumlaut'] = 333;
    t['ogonek'] = 333;
    t['caron'] = 333;
    t['emdash'] = 1000;
    t['AE'] = 1000;
    t['ordfeminine'] = 370;
    t['Lslash'] = 611;
    t['Oslash'] = 778;
    t['OE'] = 1000;
    t['ordmasculine'] = 365;
    t['ae'] = 889;
    t['dotlessi'] = 278;
    t['lslash'] = 278;
    t['oslash'] = 611;
    t['oe'] = 944;
    t['germandbls'] = 611;
    t['Idieresis'] = 278;
    t['eacute'] = 556;
    t['abreve'] = 556;
    t['uhungarumlaut'] = 611;
    t['ecaron'] = 556;
    t['Ydieresis'] = 667;
    t['divide'] = 584;
    t['Yacute'] = 667;
    t['Acircumflex'] = 722;
    t['aacute'] = 556;
    t['Ucircumflex'] = 722;
    t['yacute'] = 556;
    t['scommaaccent'] = 556;
    t['ecircumflex'] = 556;
    t['Uring'] = 722;
    t['Udieresis'] = 722;
    t['aogonek'] = 556;
    t['Uacute'] = 722;
    t['uogonek'] = 611;
    t['Edieresis'] = 667;
    t['Dcroat'] = 722;
    t['commaaccent'] = 250;
    t['copyright'] = 737;
    t['Emacron'] = 667;
    t['ccaron'] = 556;
    t['aring'] = 556;
    t['Ncommaaccent'] = 722;
    t['lacute'] = 278;
    t['agrave'] = 556;
    t['Tcommaaccent'] = 611;
    t['Cacute'] = 722;
    t['atilde'] = 556;
    t['Edotaccent'] = 667;
    t['scaron'] = 556;
    t['scedilla'] = 556;
    t['iacute'] = 278;
    t['lozenge'] = 494;
    t['Rcaron'] = 722;
    t['Gcommaaccent'] = 778;
    t['ucircumflex'] = 611;
    t['acircumflex'] = 556;
    t['Amacron'] = 722;
    t['rcaron'] = 389;
    t['ccedilla'] = 556;
    t['Zdotaccent'] = 611;
    t['Thorn'] = 667;
    t['Omacron'] = 778;
    t['Racute'] = 722;
    t['Sacute'] = 667;
    t['dcaron'] = 743;
    t['Umacron'] = 722;
    t['uring'] = 611;
    t['threesuperior'] = 333;
    t['Ograve'] = 778;
    t['Agrave'] = 722;
    t['Abreve'] = 722;
    t['multiply'] = 584;
    t['uacute'] = 611;
    t['Tcaron'] = 611;
    t['partialdiff'] = 494;
    t['ydieresis'] = 556;
    t['Nacute'] = 722;
    t['icircumflex'] = 278;
    t['Ecircumflex'] = 667;
    t['adieresis'] = 556;
    t['edieresis'] = 556;
    t['cacute'] = 556;
    t['nacute'] = 611;
    t['umacron'] = 611;
    t['Ncaron'] = 722;
    t['Iacute'] = 278;
    t['plusminus'] = 584;
    t['brokenbar'] = 280;
    t['registered'] = 737;
    t['Gbreve'] = 778;
    t['Idotaccent'] = 278;
    t['summation'] = 600;
    t['Egrave'] = 667;
    t['racute'] = 389;
    t['omacron'] = 611;
    t['Zacute'] = 611;
    t['Zcaron'] = 611;
    t['greaterequal'] = 549;
    t['Eth'] = 722;
    t['Ccedilla'] = 722;
    t['lcommaaccent'] = 278;
    t['tcaron'] = 389;
    t['eogonek'] = 556;
    t['Uogonek'] = 722;
    t['Aacute'] = 722;
    t['Adieresis'] = 722;
    t['egrave'] = 556;
    t['zacute'] = 500;
    t['iogonek'] = 278;
    t['Oacute'] = 778;
    t['oacute'] = 611;
    t['amacron'] = 556;
    t['sacute'] = 556;
    t['idieresis'] = 278;
    t['Ocircumflex'] = 778;
    t['Ugrave'] = 722;
    t['Delta'] = 612;
    t['thorn'] = 611;
    t['twosuperior'] = 333;
    t['Odieresis'] = 778;
    t['mu'] = 611;
    t['igrave'] = 278;
    t['ohungarumlaut'] = 611;
    t['Eogonek'] = 667;
    t['dcroat'] = 611;
    t['threequarters'] = 834;
    t['Scedilla'] = 667;
    t['lcaron'] = 400;
    t['Kcommaaccent'] = 722;
    t['Lacute'] = 611;
    t['trademark'] = 1000;
    t['edotaccent'] = 556;
    t['Igrave'] = 278;
    t['Imacron'] = 278;
    t['Lcaron'] = 611;
    t['onehalf'] = 834;
    t['lessequal'] = 549;
    t['ocircumflex'] = 611;
    t['ntilde'] = 611;
    t['Uhungarumlaut'] = 722;
    t['Eacute'] = 667;
    t['emacron'] = 556;
    t['gbreve'] = 611;
    t['onequarter'] = 834;
    t['Scaron'] = 667;
    t['Scommaaccent'] = 667;
    t['Ohungarumlaut'] = 778;
    t['degree'] = 400;
    t['ograve'] = 611;
    t['Ccaron'] = 722;
    t['ugrave'] = 611;
    t['radical'] = 549;
    t['Dcaron'] = 722;
    t['rcommaaccent'] = 389;
    t['Ntilde'] = 722;
    t['otilde'] = 611;
    t['Rcommaaccent'] = 722;
    t['Lcommaaccent'] = 611;
    t['Atilde'] = 722;
    t['Aogonek'] = 722;
    t['Aring'] = 722;
    t['Otilde'] = 778;
    t['zdotaccent'] = 500;
    t['Ecaron'] = 667;
    t['Iogonek'] = 278;
    t['kcommaaccent'] = 556;
    t['minus'] = 584;
    t['Icircumflex'] = 278;
    t['ncaron'] = 611;
    t['tcommaaccent'] = 333;
    t['logicalnot'] = 584;
    t['odieresis'] = 611;
    t['udieresis'] = 611;
    t['notequal'] = 549;
    t['gcommaaccent'] = 611;
    t['eth'] = 611;
    t['zcaron'] = 500;
    t['ncommaaccent'] = 611;
    t['onesuperior'] = 333;
    t['imacron'] = 278;
    t['Euro'] = 556;
  });
  t['Helvetica-Oblique'] = getLookupTableFactory(function (t) {
    t['space'] = 278;
    t['exclam'] = 278;
    t['quotedbl'] = 355;
    t['numbersign'] = 556;
    t['dollar'] = 556;
    t['percent'] = 889;
    t['ampersand'] = 667;
    t['quoteright'] = 222;
    t['parenleft'] = 333;
    t['parenright'] = 333;
    t['asterisk'] = 389;
    t['plus'] = 584;
    t['comma'] = 278;
    t['hyphen'] = 333;
    t['period'] = 278;
    t['slash'] = 278;
    t['zero'] = 556;
    t['one'] = 556;
    t['two'] = 556;
    t['three'] = 556;
    t['four'] = 556;
    t['five'] = 556;
    t['six'] = 556;
    t['seven'] = 556;
    t['eight'] = 556;
    t['nine'] = 556;
    t['colon'] = 278;
    t['semicolon'] = 278;
    t['less'] = 584;
    t['equal'] = 584;
    t['greater'] = 584;
    t['question'] = 556;
    t['at'] = 1015;
    t['A'] = 667;
    t['B'] = 667;
    t['C'] = 722;
    t['D'] = 722;
    t['E'] = 667;
    t['F'] = 611;
    t['G'] = 778;
    t['H'] = 722;
    t['I'] = 278;
    t['J'] = 500;
    t['K'] = 667;
    t['L'] = 556;
    t['M'] = 833;
    t['N'] = 722;
    t['O'] = 778;
    t['P'] = 667;
    t['Q'] = 778;
    t['R'] = 722;
    t['S'] = 667;
    t['T'] = 611;
    t['U'] = 722;
    t['V'] = 667;
    t['W'] = 944;
    t['X'] = 667;
    t['Y'] = 667;
    t['Z'] = 611;
    t['bracketleft'] = 278;
    t['backslash'] = 278;
    t['bracketright'] = 278;
    t['asciicircum'] = 469;
    t['underscore'] = 556;
    t['quoteleft'] = 222;
    t['a'] = 556;
    t['b'] = 556;
    t['c'] = 500;
    t['d'] = 556;
    t['e'] = 556;
    t['f'] = 278;
    t['g'] = 556;
    t['h'] = 556;
    t['i'] = 222;
    t['j'] = 222;
    t['k'] = 500;
    t['l'] = 222;
    t['m'] = 833;
    t['n'] = 556;
    t['o'] = 556;
    t['p'] = 556;
    t['q'] = 556;
    t['r'] = 333;
    t['s'] = 500;
    t['t'] = 278;
    t['u'] = 556;
    t['v'] = 500;
    t['w'] = 722;
    t['x'] = 500;
    t['y'] = 500;
    t['z'] = 500;
    t['braceleft'] = 334;
    t['bar'] = 260;
    t['braceright'] = 334;
    t['asciitilde'] = 584;
    t['exclamdown'] = 333;
    t['cent'] = 556;
    t['sterling'] = 556;
    t['fraction'] = 167;
    t['yen'] = 556;
    t['florin'] = 556;
    t['section'] = 556;
    t['currency'] = 556;
    t['quotesingle'] = 191;
    t['quotedblleft'] = 333;
    t['guillemotleft'] = 556;
    t['guilsinglleft'] = 333;
    t['guilsinglright'] = 333;
    t['fi'] = 500;
    t['fl'] = 500;
    t['endash'] = 556;
    t['dagger'] = 556;
    t['daggerdbl'] = 556;
    t['periodcentered'] = 278;
    t['paragraph'] = 537;
    t['bullet'] = 350;
    t['quotesinglbase'] = 222;
    t['quotedblbase'] = 333;
    t['quotedblright'] = 333;
    t['guillemotright'] = 556;
    t['ellipsis'] = 1000;
    t['perthousand'] = 1000;
    t['questiondown'] = 611;
    t['grave'] = 333;
    t['acute'] = 333;
    t['circumflex'] = 333;
    t['tilde'] = 333;
    t['macron'] = 333;
    t['breve'] = 333;
    t['dotaccent'] = 333;
    t['dieresis'] = 333;
    t['ring'] = 333;
    t['cedilla'] = 333;
    t['hungarumlaut'] = 333;
    t['ogonek'] = 333;
    t['caron'] = 333;
    t['emdash'] = 1000;
    t['AE'] = 1000;
    t['ordfeminine'] = 370;
    t['Lslash'] = 556;
    t['Oslash'] = 778;
    t['OE'] = 1000;
    t['ordmasculine'] = 365;
    t['ae'] = 889;
    t['dotlessi'] = 278;
    t['lslash'] = 222;
    t['oslash'] = 611;
    t['oe'] = 944;
    t['germandbls'] = 611;
    t['Idieresis'] = 278;
    t['eacute'] = 556;
    t['abreve'] = 556;
    t['uhungarumlaut'] = 556;
    t['ecaron'] = 556;
    t['Ydieresis'] = 667;
    t['divide'] = 584;
    t['Yacute'] = 667;
    t['Acircumflex'] = 667;
    t['aacute'] = 556;
    t['Ucircumflex'] = 722;
    t['yacute'] = 500;
    t['scommaaccent'] = 500;
    t['ecircumflex'] = 556;
    t['Uring'] = 722;
    t['Udieresis'] = 722;
    t['aogonek'] = 556;
    t['Uacute'] = 722;
    t['uogonek'] = 556;
    t['Edieresis'] = 667;
    t['Dcroat'] = 722;
    t['commaaccent'] = 250;
    t['copyright'] = 737;
    t['Emacron'] = 667;
    t['ccaron'] = 500;
    t['aring'] = 556;
    t['Ncommaaccent'] = 722;
    t['lacute'] = 222;
    t['agrave'] = 556;
    t['Tcommaaccent'] = 611;
    t['Cacute'] = 722;
    t['atilde'] = 556;
    t['Edotaccent'] = 667;
    t['scaron'] = 500;
    t['scedilla'] = 500;
    t['iacute'] = 278;
    t['lozenge'] = 471;
    t['Rcaron'] = 722;
    t['Gcommaaccent'] = 778;
    t['ucircumflex'] = 556;
    t['acircumflex'] = 556;
    t['Amacron'] = 667;
    t['rcaron'] = 333;
    t['ccedilla'] = 500;
    t['Zdotaccent'] = 611;
    t['Thorn'] = 667;
    t['Omacron'] = 778;
    t['Racute'] = 722;
    t['Sacute'] = 667;
    t['dcaron'] = 643;
    t['Umacron'] = 722;
    t['uring'] = 556;
    t['threesuperior'] = 333;
    t['Ograve'] = 778;
    t['Agrave'] = 667;
    t['Abreve'] = 667;
    t['multiply'] = 584;
    t['uacute'] = 556;
    t['Tcaron'] = 611;
    t['partialdiff'] = 476;
    t['ydieresis'] = 500;
    t['Nacute'] = 722;
    t['icircumflex'] = 278;
    t['Ecircumflex'] = 667;
    t['adieresis'] = 556;
    t['edieresis'] = 556;
    t['cacute'] = 500;
    t['nacute'] = 556;
    t['umacron'] = 556;
    t['Ncaron'] = 722;
    t['Iacute'] = 278;
    t['plusminus'] = 584;
    t['brokenbar'] = 260;
    t['registered'] = 737;
    t['Gbreve'] = 778;
    t['Idotaccent'] = 278;
    t['summation'] = 600;
    t['Egrave'] = 667;
    t['racute'] = 333;
    t['omacron'] = 556;
    t['Zacute'] = 611;
    t['Zcaron'] = 611;
    t['greaterequal'] = 549;
    t['Eth'] = 722;
    t['Ccedilla'] = 722;
    t['lcommaaccent'] = 222;
    t['tcaron'] = 317;
    t['eogonek'] = 556;
    t['Uogonek'] = 722;
    t['Aacute'] = 667;
    t['Adieresis'] = 667;
    t['egrave'] = 556;
    t['zacute'] = 500;
    t['iogonek'] = 222;
    t['Oacute'] = 778;
    t['oacute'] = 556;
    t['amacron'] = 556;
    t['sacute'] = 500;
    t['idieresis'] = 278;
    t['Ocircumflex'] = 778;
    t['Ugrave'] = 722;
    t['Delta'] = 612;
    t['thorn'] = 556;
    t['twosuperior'] = 333;
    t['Odieresis'] = 778;
    t['mu'] = 556;
    t['igrave'] = 278;
    t['ohungarumlaut'] = 556;
    t['Eogonek'] = 667;
    t['dcroat'] = 556;
    t['threequarters'] = 834;
    t['Scedilla'] = 667;
    t['lcaron'] = 299;
    t['Kcommaaccent'] = 667;
    t['Lacute'] = 556;
    t['trademark'] = 1000;
    t['edotaccent'] = 556;
    t['Igrave'] = 278;
    t['Imacron'] = 278;
    t['Lcaron'] = 556;
    t['onehalf'] = 834;
    t['lessequal'] = 549;
    t['ocircumflex'] = 556;
    t['ntilde'] = 556;
    t['Uhungarumlaut'] = 722;
    t['Eacute'] = 667;
    t['emacron'] = 556;
    t['gbreve'] = 556;
    t['onequarter'] = 834;
    t['Scaron'] = 667;
    t['Scommaaccent'] = 667;
    t['Ohungarumlaut'] = 778;
    t['degree'] = 400;
    t['ograve'] = 556;
    t['Ccaron'] = 722;
    t['ugrave'] = 556;
    t['radical'] = 453;
    t['Dcaron'] = 722;
    t['rcommaaccent'] = 333;
    t['Ntilde'] = 722;
    t['otilde'] = 556;
    t['Rcommaaccent'] = 722;
    t['Lcommaaccent'] = 556;
    t['Atilde'] = 667;
    t['Aogonek'] = 667;
    t['Aring'] = 667;
    t['Otilde'] = 778;
    t['zdotaccent'] = 500;
    t['Ecaron'] = 667;
    t['Iogonek'] = 278;
    t['kcommaaccent'] = 500;
    t['minus'] = 584;
    t['Icircumflex'] = 278;
    t['ncaron'] = 556;
    t['tcommaaccent'] = 278;
    t['logicalnot'] = 584;
    t['odieresis'] = 556;
    t['udieresis'] = 556;
    t['notequal'] = 549;
    t['gcommaaccent'] = 556;
    t['eth'] = 556;
    t['zcaron'] = 500;
    t['ncommaaccent'] = 556;
    t['onesuperior'] = 333;
    t['imacron'] = 278;
    t['Euro'] = 556;
  });
  t['Symbol'] = getLookupTableFactory(function (t) {
    t['space'] = 250;
    t['exclam'] = 333;
    t['universal'] = 713;
    t['numbersign'] = 500;
    t['existential'] = 549;
    t['percent'] = 833;
    t['ampersand'] = 778;
    t['suchthat'] = 439;
    t['parenleft'] = 333;
    t['parenright'] = 333;
    t['asteriskmath'] = 500;
    t['plus'] = 549;
    t['comma'] = 250;
    t['minus'] = 549;
    t['period'] = 250;
    t['slash'] = 278;
    t['zero'] = 500;
    t['one'] = 500;
    t['two'] = 500;
    t['three'] = 500;
    t['four'] = 500;
    t['five'] = 500;
    t['six'] = 500;
    t['seven'] = 500;
    t['eight'] = 500;
    t['nine'] = 500;
    t['colon'] = 278;
    t['semicolon'] = 278;
    t['less'] = 549;
    t['equal'] = 549;
    t['greater'] = 549;
    t['question'] = 444;
    t['congruent'] = 549;
    t['Alpha'] = 722;
    t['Beta'] = 667;
    t['Chi'] = 722;
    t['Delta'] = 612;
    t['Epsilon'] = 611;
    t['Phi'] = 763;
    t['Gamma'] = 603;
    t['Eta'] = 722;
    t['Iota'] = 333;
    t['theta1'] = 631;
    t['Kappa'] = 722;
    t['Lambda'] = 686;
    t['Mu'] = 889;
    t['Nu'] = 722;
    t['Omicron'] = 722;
    t['Pi'] = 768;
    t['Theta'] = 741;
    t['Rho'] = 556;
    t['Sigma'] = 592;
    t['Tau'] = 611;
    t['Upsilon'] = 690;
    t['sigma1'] = 439;
    t['Omega'] = 768;
    t['Xi'] = 645;
    t['Psi'] = 795;
    t['Zeta'] = 611;
    t['bracketleft'] = 333;
    t['therefore'] = 863;
    t['bracketright'] = 333;
    t['perpendicular'] = 658;
    t['underscore'] = 500;
    t['radicalex'] = 500;
    t['alpha'] = 631;
    t['beta'] = 549;
    t['chi'] = 549;
    t['delta'] = 494;
    t['epsilon'] = 439;
    t['phi'] = 521;
    t['gamma'] = 411;
    t['eta'] = 603;
    t['iota'] = 329;
    t['phi1'] = 603;
    t['kappa'] = 549;
    t['lambda'] = 549;
    t['mu'] = 576;
    t['nu'] = 521;
    t['omicron'] = 549;
    t['pi'] = 549;
    t['theta'] = 521;
    t['rho'] = 549;
    t['sigma'] = 603;
    t['tau'] = 439;
    t['upsilon'] = 576;
    t['omega1'] = 713;
    t['omega'] = 686;
    t['xi'] = 493;
    t['psi'] = 686;
    t['zeta'] = 494;
    t['braceleft'] = 480;
    t['bar'] = 200;
    t['braceright'] = 480;
    t['similar'] = 549;
    t['Euro'] = 750;
    t['Upsilon1'] = 620;
    t['minute'] = 247;
    t['lessequal'] = 549;
    t['fraction'] = 167;
    t['infinity'] = 713;
    t['florin'] = 500;
    t['club'] = 753;
    t['diamond'] = 753;
    t['heart'] = 753;
    t['spade'] = 753;
    t['arrowboth'] = 1042;
    t['arrowleft'] = 987;
    t['arrowup'] = 603;
    t['arrowright'] = 987;
    t['arrowdown'] = 603;
    t['degree'] = 400;
    t['plusminus'] = 549;
    t['second'] = 411;
    t['greaterequal'] = 549;
    t['multiply'] = 549;
    t['proportional'] = 713;
    t['partialdiff'] = 494;
    t['bullet'] = 460;
    t['divide'] = 549;
    t['notequal'] = 549;
    t['equivalence'] = 549;
    t['approxequal'] = 549;
    t['ellipsis'] = 1000;
    t['arrowvertex'] = 603;
    t['arrowhorizex'] = 1000;
    t['carriagereturn'] = 658;
    t['aleph'] = 823;
    t['Ifraktur'] = 686;
    t['Rfraktur'] = 795;
    t['weierstrass'] = 987;
    t['circlemultiply'] = 768;
    t['circleplus'] = 768;
    t['emptyset'] = 823;
    t['intersection'] = 768;
    t['union'] = 768;
    t['propersuperset'] = 713;
    t['reflexsuperset'] = 713;
    t['notsubset'] = 713;
    t['propersubset'] = 713;
    t['reflexsubset'] = 713;
    t['element'] = 713;
    t['notelement'] = 713;
    t['angle'] = 768;
    t['gradient'] = 713;
    t['registerserif'] = 790;
    t['copyrightserif'] = 790;
    t['trademarkserif'] = 890;
    t['product'] = 823;
    t['radical'] = 549;
    t['dotmath'] = 250;
    t['logicalnot'] = 713;
    t['logicaland'] = 603;
    t['logicalor'] = 603;
    t['arrowdblboth'] = 1042;
    t['arrowdblleft'] = 987;
    t['arrowdblup'] = 603;
    t['arrowdblright'] = 987;
    t['arrowdbldown'] = 603;
    t['lozenge'] = 494;
    t['angleleft'] = 329;
    t['registersans'] = 790;
    t['copyrightsans'] = 790;
    t['trademarksans'] = 786;
    t['summation'] = 713;
    t['parenlefttp'] = 384;
    t['parenleftex'] = 384;
    t['parenleftbt'] = 384;
    t['bracketlefttp'] = 384;
    t['bracketleftex'] = 384;
    t['bracketleftbt'] = 384;
    t['bracelefttp'] = 494;
    t['braceleftmid'] = 494;
    t['braceleftbt'] = 494;
    t['braceex'] = 494;
    t['angleright'] = 329;
    t['integral'] = 274;
    t['integraltp'] = 686;
    t['integralex'] = 686;
    t['integralbt'] = 686;
    t['parenrighttp'] = 384;
    t['parenrightex'] = 384;
    t['parenrightbt'] = 384;
    t['bracketrighttp'] = 384;
    t['bracketrightex'] = 384;
    t['bracketrightbt'] = 384;
    t['bracerighttp'] = 494;
    t['bracerightmid'] = 494;
    t['bracerightbt'] = 494;
    t['apple'] = 790;
  });
  t['Times-Roman'] = getLookupTableFactory(function (t) {
    t['space'] = 250;
    t['exclam'] = 333;
    t['quotedbl'] = 408;
    t['numbersign'] = 500;
    t['dollar'] = 500;
    t['percent'] = 833;
    t['ampersand'] = 778;
    t['quoteright'] = 333;
    t['parenleft'] = 333;
    t['parenright'] = 333;
    t['asterisk'] = 500;
    t['plus'] = 564;
    t['comma'] = 250;
    t['hyphen'] = 333;
    t['period'] = 250;
    t['slash'] = 278;
    t['zero'] = 500;
    t['one'] = 500;
    t['two'] = 500;
    t['three'] = 500;
    t['four'] = 500;
    t['five'] = 500;
    t['six'] = 500;
    t['seven'] = 500;
    t['eight'] = 500;
    t['nine'] = 500;
    t['colon'] = 278;
    t['semicolon'] = 278;
    t['less'] = 564;
    t['equal'] = 564;
    t['greater'] = 564;
    t['question'] = 444;
    t['at'] = 921;
    t['A'] = 722;
    t['B'] = 667;
    t['C'] = 667;
    t['D'] = 722;
    t['E'] = 611;
    t['F'] = 556;
    t['G'] = 722;
    t['H'] = 722;
    t['I'] = 333;
    t['J'] = 389;
    t['K'] = 722;
    t['L'] = 611;
    t['M'] = 889;
    t['N'] = 722;
    t['O'] = 722;
    t['P'] = 556;
    t['Q'] = 722;
    t['R'] = 667;
    t['S'] = 556;
    t['T'] = 611;
    t['U'] = 722;
    t['V'] = 722;
    t['W'] = 944;
    t['X'] = 722;
    t['Y'] = 722;
    t['Z'] = 611;
    t['bracketleft'] = 333;
    t['backslash'] = 278;
    t['bracketright'] = 333;
    t['asciicircum'] = 469;
    t['underscore'] = 500;
    t['quoteleft'] = 333;
    t['a'] = 444;
    t['b'] = 500;
    t['c'] = 444;
    t['d'] = 500;
    t['e'] = 444;
    t['f'] = 333;
    t['g'] = 500;
    t['h'] = 500;
    t['i'] = 278;
    t['j'] = 278;
    t['k'] = 500;
    t['l'] = 278;
    t['m'] = 778;
    t['n'] = 500;
    t['o'] = 500;
    t['p'] = 500;
    t['q'] = 500;
    t['r'] = 333;
    t['s'] = 389;
    t['t'] = 278;
    t['u'] = 500;
    t['v'] = 500;
    t['w'] = 722;
    t['x'] = 500;
    t['y'] = 500;
    t['z'] = 444;
    t['braceleft'] = 480;
    t['bar'] = 200;
    t['braceright'] = 480;
    t['asciitilde'] = 541;
    t['exclamdown'] = 333;
    t['cent'] = 500;
    t['sterling'] = 500;
    t['fraction'] = 167;
    t['yen'] = 500;
    t['florin'] = 500;
    t['section'] = 500;
    t['currency'] = 500;
    t['quotesingle'] = 180;
    t['quotedblleft'] = 444;
    t['guillemotleft'] = 500;
    t['guilsinglleft'] = 333;
    t['guilsinglright'] = 333;
    t['fi'] = 556;
    t['fl'] = 556;
    t['endash'] = 500;
    t['dagger'] = 500;
    t['daggerdbl'] = 500;
    t['periodcentered'] = 250;
    t['paragraph'] = 453;
    t['bullet'] = 350;
    t['quotesinglbase'] = 333;
    t['quotedblbase'] = 444;
    t['quotedblright'] = 444;
    t['guillemotright'] = 500;
    t['ellipsis'] = 1000;
    t['perthousand'] = 1000;
    t['questiondown'] = 444;
    t['grave'] = 333;
    t['acute'] = 333;
    t['circumflex'] = 333;
    t['tilde'] = 333;
    t['macron'] = 333;
    t['breve'] = 333;
    t['dotaccent'] = 333;
    t['dieresis'] = 333;
    t['ring'] = 333;
    t['cedilla'] = 333;
    t['hungarumlaut'] = 333;
    t['ogonek'] = 333;
    t['caron'] = 333;
    t['emdash'] = 1000;
    t['AE'] = 889;
    t['ordfeminine'] = 276;
    t['Lslash'] = 611;
    t['Oslash'] = 722;
    t['OE'] = 889;
    t['ordmasculine'] = 310;
    t['ae'] = 667;
    t['dotlessi'] = 278;
    t['lslash'] = 278;
    t['oslash'] = 500;
    t['oe'] = 722;
    t['germandbls'] = 500;
    t['Idieresis'] = 333;
    t['eacute'] = 444;
    t['abreve'] = 444;
    t['uhungarumlaut'] = 500;
    t['ecaron'] = 444;
    t['Ydieresis'] = 722;
    t['divide'] = 564;
    t['Yacute'] = 722;
    t['Acircumflex'] = 722;
    t['aacute'] = 444;
    t['Ucircumflex'] = 722;
    t['yacute'] = 500;
    t['scommaaccent'] = 389;
    t['ecircumflex'] = 444;
    t['Uring'] = 722;
    t['Udieresis'] = 722;
    t['aogonek'] = 444;
    t['Uacute'] = 722;
    t['uogonek'] = 500;
    t['Edieresis'] = 611;
    t['Dcroat'] = 722;
    t['commaaccent'] = 250;
    t['copyright'] = 760;
    t['Emacron'] = 611;
    t['ccaron'] = 444;
    t['aring'] = 444;
    t['Ncommaaccent'] = 722;
    t['lacute'] = 278;
    t['agrave'] = 444;
    t['Tcommaaccent'] = 611;
    t['Cacute'] = 667;
    t['atilde'] = 444;
    t['Edotaccent'] = 611;
    t['scaron'] = 389;
    t['scedilla'] = 389;
    t['iacute'] = 278;
    t['lozenge'] = 471;
    t['Rcaron'] = 667;
    t['Gcommaaccent'] = 722;
    t['ucircumflex'] = 500;
    t['acircumflex'] = 444;
    t['Amacron'] = 722;
    t['rcaron'] = 333;
    t['ccedilla'] = 444;
    t['Zdotaccent'] = 611;
    t['Thorn'] = 556;
    t['Omacron'] = 722;
    t['Racute'] = 667;
    t['Sacute'] = 556;
    t['dcaron'] = 588;
    t['Umacron'] = 722;
    t['uring'] = 500;
    t['threesuperior'] = 300;
    t['Ograve'] = 722;
    t['Agrave'] = 722;
    t['Abreve'] = 722;
    t['multiply'] = 564;
    t['uacute'] = 500;
    t['Tcaron'] = 611;
    t['partialdiff'] = 476;
    t['ydieresis'] = 500;
    t['Nacute'] = 722;
    t['icircumflex'] = 278;
    t['Ecircumflex'] = 611;
    t['adieresis'] = 444;
    t['edieresis'] = 444;
    t['cacute'] = 444;
    t['nacute'] = 500;
    t['umacron'] = 500;
    t['Ncaron'] = 722;
    t['Iacute'] = 333;
    t['plusminus'] = 564;
    t['brokenbar'] = 200;
    t['registered'] = 760;
    t['Gbreve'] = 722;
    t['Idotaccent'] = 333;
    t['summation'] = 600;
    t['Egrave'] = 611;
    t['racute'] = 333;
    t['omacron'] = 500;
    t['Zacute'] = 611;
    t['Zcaron'] = 611;
    t['greaterequal'] = 549;
    t['Eth'] = 722;
    t['Ccedilla'] = 667;
    t['lcommaaccent'] = 278;
    t['tcaron'] = 326;
    t['eogonek'] = 444;
    t['Uogonek'] = 722;
    t['Aacute'] = 722;
    t['Adieresis'] = 722;
    t['egrave'] = 444;
    t['zacute'] = 444;
    t['iogonek'] = 278;
    t['Oacute'] = 722;
    t['oacute'] = 500;
    t['amacron'] = 444;
    t['sacute'] = 389;
    t['idieresis'] = 278;
    t['Ocircumflex'] = 722;
    t['Ugrave'] = 722;
    t['Delta'] = 612;
    t['thorn'] = 500;
    t['twosuperior'] = 300;
    t['Odieresis'] = 722;
    t['mu'] = 500;
    t['igrave'] = 278;
    t['ohungarumlaut'] = 500;
    t['Eogonek'] = 611;
    t['dcroat'] = 500;
    t['threequarters'] = 750;
    t['Scedilla'] = 556;
    t['lcaron'] = 344;
    t['Kcommaaccent'] = 722;
    t['Lacute'] = 611;
    t['trademark'] = 980;
    t['edotaccent'] = 444;
    t['Igrave'] = 333;
    t['Imacron'] = 333;
    t['Lcaron'] = 611;
    t['onehalf'] = 750;
    t['lessequal'] = 549;
    t['ocircumflex'] = 500;
    t['ntilde'] = 500;
    t['Uhungarumlaut'] = 722;
    t['Eacute'] = 611;
    t['emacron'] = 444;
    t['gbreve'] = 500;
    t['onequarter'] = 750;
    t['Scaron'] = 556;
    t['Scommaaccent'] = 556;
    t['Ohungarumlaut'] = 722;
    t['degree'] = 400;
    t['ograve'] = 500;
    t['Ccaron'] = 667;
    t['ugrave'] = 500;
    t['radical'] = 453;
    t['Dcaron'] = 722;
    t['rcommaaccent'] = 333;
    t['Ntilde'] = 722;
    t['otilde'] = 500;
    t['Rcommaaccent'] = 667;
    t['Lcommaaccent'] = 611;
    t['Atilde'] = 722;
    t['Aogonek'] = 722;
    t['Aring'] = 722;
    t['Otilde'] = 722;
    t['zdotaccent'] = 444;
    t['Ecaron'] = 611;
    t['Iogonek'] = 333;
    t['kcommaaccent'] = 500;
    t['minus'] = 564;
    t['Icircumflex'] = 333;
    t['ncaron'] = 500;
    t['tcommaaccent'] = 278;
    t['logicalnot'] = 564;
    t['odieresis'] = 500;
    t['udieresis'] = 500;
    t['notequal'] = 549;
    t['gcommaaccent'] = 500;
    t['eth'] = 500;
    t['zcaron'] = 444;
    t['ncommaaccent'] = 500;
    t['onesuperior'] = 300;
    t['imacron'] = 278;
    t['Euro'] = 500;
  });
  t['Times-Bold'] = getLookupTableFactory(function (t) {
    t['space'] = 250;
    t['exclam'] = 333;
    t['quotedbl'] = 555;
    t['numbersign'] = 500;
    t['dollar'] = 500;
    t['percent'] = 1000;
    t['ampersand'] = 833;
    t['quoteright'] = 333;
    t['parenleft'] = 333;
    t['parenright'] = 333;
    t['asterisk'] = 500;
    t['plus'] = 570;
    t['comma'] = 250;
    t['hyphen'] = 333;
    t['period'] = 250;
    t['slash'] = 278;
    t['zero'] = 500;
    t['one'] = 500;
    t['two'] = 500;
    t['three'] = 500;
    t['four'] = 500;
    t['five'] = 500;
    t['six'] = 500;
    t['seven'] = 500;
    t['eight'] = 500;
    t['nine'] = 500;
    t['colon'] = 333;
    t['semicolon'] = 333;
    t['less'] = 570;
    t['equal'] = 570;
    t['greater'] = 570;
    t['question'] = 500;
    t['at'] = 930;
    t['A'] = 722;
    t['B'] = 667;
    t['C'] = 722;
    t['D'] = 722;
    t['E'] = 667;
    t['F'] = 611;
    t['G'] = 778;
    t['H'] = 778;
    t['I'] = 389;
    t['J'] = 500;
    t['K'] = 778;
    t['L'] = 667;
    t['M'] = 944;
    t['N'] = 722;
    t['O'] = 778;
    t['P'] = 611;
    t['Q'] = 778;
    t['R'] = 722;
    t['S'] = 556;
    t['T'] = 667;
    t['U'] = 722;
    t['V'] = 722;
    t['W'] = 1000;
    t['X'] = 722;
    t['Y'] = 722;
    t['Z'] = 667;
    t['bracketleft'] = 333;
    t['backslash'] = 278;
    t['bracketright'] = 333;
    t['asciicircum'] = 581;
    t['underscore'] = 500;
    t['quoteleft'] = 333;
    t['a'] = 500;
    t['b'] = 556;
    t['c'] = 444;
    t['d'] = 556;
    t['e'] = 444;
    t['f'] = 333;
    t['g'] = 500;
    t['h'] = 556;
    t['i'] = 278;
    t['j'] = 333;
    t['k'] = 556;
    t['l'] = 278;
    t['m'] = 833;
    t['n'] = 556;
    t['o'] = 500;
    t['p'] = 556;
    t['q'] = 556;
    t['r'] = 444;
    t['s'] = 389;
    t['t'] = 333;
    t['u'] = 556;
    t['v'] = 500;
    t['w'] = 722;
    t['x'] = 500;
    t['y'] = 500;
    t['z'] = 444;
    t['braceleft'] = 394;
    t['bar'] = 220;
    t['braceright'] = 394;
    t['asciitilde'] = 520;
    t['exclamdown'] = 333;
    t['cent'] = 500;
    t['sterling'] = 500;
    t['fraction'] = 167;
    t['yen'] = 500;
    t['florin'] = 500;
    t['section'] = 500;
    t['currency'] = 500;
    t['quotesingle'] = 278;
    t['quotedblleft'] = 500;
    t['guillemotleft'] = 500;
    t['guilsinglleft'] = 333;
    t['guilsinglright'] = 333;
    t['fi'] = 556;
    t['fl'] = 556;
    t['endash'] = 500;
    t['dagger'] = 500;
    t['daggerdbl'] = 500;
    t['periodcentered'] = 250;
    t['paragraph'] = 540;
    t['bullet'] = 350;
    t['quotesinglbase'] = 333;
    t['quotedblbase'] = 500;
    t['quotedblright'] = 500;
    t['guillemotright'] = 500;
    t['ellipsis'] = 1000;
    t['perthousand'] = 1000;
    t['questiondown'] = 500;
    t['grave'] = 333;
    t['acute'] = 333;
    t['circumflex'] = 333;
    t['tilde'] = 333;
    t['macron'] = 333;
    t['breve'] = 333;
    t['dotaccent'] = 333;
    t['dieresis'] = 333;
    t['ring'] = 333;
    t['cedilla'] = 333;
    t['hungarumlaut'] = 333;
    t['ogonek'] = 333;
    t['caron'] = 333;
    t['emdash'] = 1000;
    t['AE'] = 1000;
    t['ordfeminine'] = 300;
    t['Lslash'] = 667;
    t['Oslash'] = 778;
    t['OE'] = 1000;
    t['ordmasculine'] = 330;
    t['ae'] = 722;
    t['dotlessi'] = 278;
    t['lslash'] = 278;
    t['oslash'] = 500;
    t['oe'] = 722;
    t['germandbls'] = 556;
    t['Idieresis'] = 389;
    t['eacute'] = 444;
    t['abreve'] = 500;
    t['uhungarumlaut'] = 556;
    t['ecaron'] = 444;
    t['Ydieresis'] = 722;
    t['divide'] = 570;
    t['Yacute'] = 722;
    t['Acircumflex'] = 722;
    t['aacute'] = 500;
    t['Ucircumflex'] = 722;
    t['yacute'] = 500;
    t['scommaaccent'] = 389;
    t['ecircumflex'] = 444;
    t['Uring'] = 722;
    t['Udieresis'] = 722;
    t['aogonek'] = 500;
    t['Uacute'] = 722;
    t['uogonek'] = 556;
    t['Edieresis'] = 667;
    t['Dcroat'] = 722;
    t['commaaccent'] = 250;
    t['copyright'] = 747;
    t['Emacron'] = 667;
    t['ccaron'] = 444;
    t['aring'] = 500;
    t['Ncommaaccent'] = 722;
    t['lacute'] = 278;
    t['agrave'] = 500;
    t['Tcommaaccent'] = 667;
    t['Cacute'] = 722;
    t['atilde'] = 500;
    t['Edotaccent'] = 667;
    t['scaron'] = 389;
    t['scedilla'] = 389;
    t['iacute'] = 278;
    t['lozenge'] = 494;
    t['Rcaron'] = 722;
    t['Gcommaaccent'] = 778;
    t['ucircumflex'] = 556;
    t['acircumflex'] = 500;
    t['Amacron'] = 722;
    t['rcaron'] = 444;
    t['ccedilla'] = 444;
    t['Zdotaccent'] = 667;
    t['Thorn'] = 611;
    t['Omacron'] = 778;
    t['Racute'] = 722;
    t['Sacute'] = 556;
    t['dcaron'] = 672;
    t['Umacron'] = 722;
    t['uring'] = 556;
    t['threesuperior'] = 300;
    t['Ograve'] = 778;
    t['Agrave'] = 722;
    t['Abreve'] = 722;
    t['multiply'] = 570;
    t['uacute'] = 556;
    t['Tcaron'] = 667;
    t['partialdiff'] = 494;
    t['ydieresis'] = 500;
    t['Nacute'] = 722;
    t['icircumflex'] = 278;
    t['Ecircumflex'] = 667;
    t['adieresis'] = 500;
    t['edieresis'] = 444;
    t['cacute'] = 444;
    t['nacute'] = 556;
    t['umacron'] = 556;
    t['Ncaron'] = 722;
    t['Iacute'] = 389;
    t['plusminus'] = 570;
    t['brokenbar'] = 220;
    t['registered'] = 747;
    t['Gbreve'] = 778;
    t['Idotaccent'] = 389;
    t['summation'] = 600;
    t['Egrave'] = 667;
    t['racute'] = 444;
    t['omacron'] = 500;
    t['Zacute'] = 667;
    t['Zcaron'] = 667;
    t['greaterequal'] = 549;
    t['Eth'] = 722;
    t['Ccedilla'] = 722;
    t['lcommaaccent'] = 278;
    t['tcaron'] = 416;
    t['eogonek'] = 444;
    t['Uogonek'] = 722;
    t['Aacute'] = 722;
    t['Adieresis'] = 722;
    t['egrave'] = 444;
    t['zacute'] = 444;
    t['iogonek'] = 278;
    t['Oacute'] = 778;
    t['oacute'] = 500;
    t['amacron'] = 500;
    t['sacute'] = 389;
    t['idieresis'] = 278;
    t['Ocircumflex'] = 778;
    t['Ugrave'] = 722;
    t['Delta'] = 612;
    t['thorn'] = 556;
    t['twosuperior'] = 300;
    t['Odieresis'] = 778;
    t['mu'] = 556;
    t['igrave'] = 278;
    t['ohungarumlaut'] = 500;
    t['Eogonek'] = 667;
    t['dcroat'] = 556;
    t['threequarters'] = 750;
    t['Scedilla'] = 556;
    t['lcaron'] = 394;
    t['Kcommaaccent'] = 778;
    t['Lacute'] = 667;
    t['trademark'] = 1000;
    t['edotaccent'] = 444;
    t['Igrave'] = 389;
    t['Imacron'] = 389;
    t['Lcaron'] = 667;
    t['onehalf'] = 750;
    t['lessequal'] = 549;
    t['ocircumflex'] = 500;
    t['ntilde'] = 556;
    t['Uhungarumlaut'] = 722;
    t['Eacute'] = 667;
    t['emacron'] = 444;
    t['gbreve'] = 500;
    t['onequarter'] = 750;
    t['Scaron'] = 556;
    t['Scommaaccent'] = 556;
    t['Ohungarumlaut'] = 778;
    t['degree'] = 400;
    t['ograve'] = 500;
    t['Ccaron'] = 722;
    t['ugrave'] = 556;
    t['radical'] = 549;
    t['Dcaron'] = 722;
    t['rcommaaccent'] = 444;
    t['Ntilde'] = 722;
    t['otilde'] = 500;
    t['Rcommaaccent'] = 722;
    t['Lcommaaccent'] = 667;
    t['Atilde'] = 722;
    t['Aogonek'] = 722;
    t['Aring'] = 722;
    t['Otilde'] = 778;
    t['zdotaccent'] = 444;
    t['Ecaron'] = 667;
    t['Iogonek'] = 389;
    t['kcommaaccent'] = 556;
    t['minus'] = 570;
    t['Icircumflex'] = 389;
    t['ncaron'] = 556;
    t['tcommaaccent'] = 333;
    t['logicalnot'] = 570;
    t['odieresis'] = 500;
    t['udieresis'] = 556;
    t['notequal'] = 549;
    t['gcommaaccent'] = 500;
    t['eth'] = 500;
    t['zcaron'] = 444;
    t['ncommaaccent'] = 556;
    t['onesuperior'] = 300;
    t['imacron'] = 278;
    t['Euro'] = 500;
  });
  t['Times-BoldItalic'] = getLookupTableFactory(function (t) {
    t['space'] = 250;
    t['exclam'] = 389;
    t['quotedbl'] = 555;
    t['numbersign'] = 500;
    t['dollar'] = 500;
    t['percent'] = 833;
    t['ampersand'] = 778;
    t['quoteright'] = 333;
    t['parenleft'] = 333;
    t['parenright'] = 333;
    t['asterisk'] = 500;
    t['plus'] = 570;
    t['comma'] = 250;
    t['hyphen'] = 333;
    t['period'] = 250;
    t['slash'] = 278;
    t['zero'] = 500;
    t['one'] = 500;
    t['two'] = 500;
    t['three'] = 500;
    t['four'] = 500;
    t['five'] = 500;
    t['six'] = 500;
    t['seven'] = 500;
    t['eight'] = 500;
    t['nine'] = 500;
    t['colon'] = 333;
    t['semicolon'] = 333;
    t['less'] = 570;
    t['equal'] = 570;
    t['greater'] = 570;
    t['question'] = 500;
    t['at'] = 832;
    t['A'] = 667;
    t['B'] = 667;
    t['C'] = 667;
    t['D'] = 722;
    t['E'] = 667;
    t['F'] = 667;
    t['G'] = 722;
    t['H'] = 778;
    t['I'] = 389;
    t['J'] = 500;
    t['K'] = 667;
    t['L'] = 611;
    t['M'] = 889;
    t['N'] = 722;
    t['O'] = 722;
    t['P'] = 611;
    t['Q'] = 722;
    t['R'] = 667;
    t['S'] = 556;
    t['T'] = 611;
    t['U'] = 722;
    t['V'] = 667;
    t['W'] = 889;
    t['X'] = 667;
    t['Y'] = 611;
    t['Z'] = 611;
    t['bracketleft'] = 333;
    t['backslash'] = 278;
    t['bracketright'] = 333;
    t['asciicircum'] = 570;
    t['underscore'] = 500;
    t['quoteleft'] = 333;
    t['a'] = 500;
    t['b'] = 500;
    t['c'] = 444;
    t['d'] = 500;
    t['e'] = 444;
    t['f'] = 333;
    t['g'] = 500;
    t['h'] = 556;
    t['i'] = 278;
    t['j'] = 278;
    t['k'] = 500;
    t['l'] = 278;
    t['m'] = 778;
    t['n'] = 556;
    t['o'] = 500;
    t['p'] = 500;
    t['q'] = 500;
    t['r'] = 389;
    t['s'] = 389;
    t['t'] = 278;
    t['u'] = 556;
    t['v'] = 444;
    t['w'] = 667;
    t['x'] = 500;
    t['y'] = 444;
    t['z'] = 389;
    t['braceleft'] = 348;
    t['bar'] = 220;
    t['braceright'] = 348;
    t['asciitilde'] = 570;
    t['exclamdown'] = 389;
    t['cent'] = 500;
    t['sterling'] = 500;
    t['fraction'] = 167;
    t['yen'] = 500;
    t['florin'] = 500;
    t['section'] = 500;
    t['currency'] = 500;
    t['quotesingle'] = 278;
    t['quotedblleft'] = 500;
    t['guillemotleft'] = 500;
    t['guilsinglleft'] = 333;
    t['guilsinglright'] = 333;
    t['fi'] = 556;
    t['fl'] = 556;
    t['endash'] = 500;
    t['dagger'] = 500;
    t['daggerdbl'] = 500;
    t['periodcentered'] = 250;
    t['paragraph'] = 500;
    t['bullet'] = 350;
    t['quotesinglbase'] = 333;
    t['quotedblbase'] = 500;
    t['quotedblright'] = 500;
    t['guillemotright'] = 500;
    t['ellipsis'] = 1000;
    t['perthousand'] = 1000;
    t['questiondown'] = 500;
    t['grave'] = 333;
    t['acute'] = 333;
    t['circumflex'] = 333;
    t['tilde'] = 333;
    t['macron'] = 333;
    t['breve'] = 333;
    t['dotaccent'] = 333;
    t['dieresis'] = 333;
    t['ring'] = 333;
    t['cedilla'] = 333;
    t['hungarumlaut'] = 333;
    t['ogonek'] = 333;
    t['caron'] = 333;
    t['emdash'] = 1000;
    t['AE'] = 944;
    t['ordfeminine'] = 266;
    t['Lslash'] = 611;
    t['Oslash'] = 722;
    t['OE'] = 944;
    t['ordmasculine'] = 300;
    t['ae'] = 722;
    t['dotlessi'] = 278;
    t['lslash'] = 278;
    t['oslash'] = 500;
    t['oe'] = 722;
    t['germandbls'] = 500;
    t['Idieresis'] = 389;
    t['eacute'] = 444;
    t['abreve'] = 500;
    t['uhungarumlaut'] = 556;
    t['ecaron'] = 444;
    t['Ydieresis'] = 611;
    t['divide'] = 570;
    t['Yacute'] = 611;
    t['Acircumflex'] = 667;
    t['aacute'] = 500;
    t['Ucircumflex'] = 722;
    t['yacute'] = 444;
    t['scommaaccent'] = 389;
    t['ecircumflex'] = 444;
    t['Uring'] = 722;
    t['Udieresis'] = 722;
    t['aogonek'] = 500;
    t['Uacute'] = 722;
    t['uogonek'] = 556;
    t['Edieresis'] = 667;
    t['Dcroat'] = 722;
    t['commaaccent'] = 250;
    t['copyright'] = 747;
    t['Emacron'] = 667;
    t['ccaron'] = 444;
    t['aring'] = 500;
    t['Ncommaaccent'] = 722;
    t['lacute'] = 278;
    t['agrave'] = 500;
    t['Tcommaaccent'] = 611;
    t['Cacute'] = 667;
    t['atilde'] = 500;
    t['Edotaccent'] = 667;
    t['scaron'] = 389;
    t['scedilla'] = 389;
    t['iacute'] = 278;
    t['lozenge'] = 494;
    t['Rcaron'] = 667;
    t['Gcommaaccent'] = 722;
    t['ucircumflex'] = 556;
    t['acircumflex'] = 500;
    t['Amacron'] = 667;
    t['rcaron'] = 389;
    t['ccedilla'] = 444;
    t['Zdotaccent'] = 611;
    t['Thorn'] = 611;
    t['Omacron'] = 722;
    t['Racute'] = 667;
    t['Sacute'] = 556;
    t['dcaron'] = 608;
    t['Umacron'] = 722;
    t['uring'] = 556;
    t['threesuperior'] = 300;
    t['Ograve'] = 722;
    t['Agrave'] = 667;
    t['Abreve'] = 667;
    t['multiply'] = 570;
    t['uacute'] = 556;
    t['Tcaron'] = 611;
    t['partialdiff'] = 494;
    t['ydieresis'] = 444;
    t['Nacute'] = 722;
    t['icircumflex'] = 278;
    t['Ecircumflex'] = 667;
    t['adieresis'] = 500;
    t['edieresis'] = 444;
    t['cacute'] = 444;
    t['nacute'] = 556;
    t['umacron'] = 556;
    t['Ncaron'] = 722;
    t['Iacute'] = 389;
    t['plusminus'] = 570;
    t['brokenbar'] = 220;
    t['registered'] = 747;
    t['Gbreve'] = 722;
    t['Idotaccent'] = 389;
    t['summation'] = 600;
    t['Egrave'] = 667;
    t['racute'] = 389;
    t['omacron'] = 500;
    t['Zacute'] = 611;
    t['Zcaron'] = 611;
    t['greaterequal'] = 549;
    t['Eth'] = 722;
    t['Ccedilla'] = 667;
    t['lcommaaccent'] = 278;
    t['tcaron'] = 366;
    t['eogonek'] = 444;
    t['Uogonek'] = 722;
    t['Aacute'] = 667;
    t['Adieresis'] = 667;
    t['egrave'] = 444;
    t['zacute'] = 389;
    t['iogonek'] = 278;
    t['Oacute'] = 722;
    t['oacute'] = 500;
    t['amacron'] = 500;
    t['sacute'] = 389;
    t['idieresis'] = 278;
    t['Ocircumflex'] = 722;
    t['Ugrave'] = 722;
    t['Delta'] = 612;
    t['thorn'] = 500;
    t['twosuperior'] = 300;
    t['Odieresis'] = 722;
    t['mu'] = 576;
    t['igrave'] = 278;
    t['ohungarumlaut'] = 500;
    t['Eogonek'] = 667;
    t['dcroat'] = 500;
    t['threequarters'] = 750;
    t['Scedilla'] = 556;
    t['lcaron'] = 382;
    t['Kcommaaccent'] = 667;
    t['Lacute'] = 611;
    t['trademark'] = 1000;
    t['edotaccent'] = 444;
    t['Igrave'] = 389;
    t['Imacron'] = 389;
    t['Lcaron'] = 611;
    t['onehalf'] = 750;
    t['lessequal'] = 549;
    t['ocircumflex'] = 500;
    t['ntilde'] = 556;
    t['Uhungarumlaut'] = 722;
    t['Eacute'] = 667;
    t['emacron'] = 444;
    t['gbreve'] = 500;
    t['onequarter'] = 750;
    t['Scaron'] = 556;
    t['Scommaaccent'] = 556;
    t['Ohungarumlaut'] = 722;
    t['degree'] = 400;
    t['ograve'] = 500;
    t['Ccaron'] = 667;
    t['ugrave'] = 556;
    t['radical'] = 549;
    t['Dcaron'] = 722;
    t['rcommaaccent'] = 389;
    t['Ntilde'] = 722;
    t['otilde'] = 500;
    t['Rcommaaccent'] = 667;
    t['Lcommaaccent'] = 611;
    t['Atilde'] = 667;
    t['Aogonek'] = 667;
    t['Aring'] = 667;
    t['Otilde'] = 722;
    t['zdotaccent'] = 389;
    t['Ecaron'] = 667;
    t['Iogonek'] = 389;
    t['kcommaaccent'] = 500;
    t['minus'] = 606;
    t['Icircumflex'] = 389;
    t['ncaron'] = 556;
    t['tcommaaccent'] = 278;
    t['logicalnot'] = 606;
    t['odieresis'] = 500;
    t['udieresis'] = 556;
    t['notequal'] = 549;
    t['gcommaaccent'] = 500;
    t['eth'] = 500;
    t['zcaron'] = 389;
    t['ncommaaccent'] = 556;
    t['onesuperior'] = 300;
    t['imacron'] = 278;
    t['Euro'] = 500;
  });
  t['Times-Italic'] = getLookupTableFactory(function (t) {
    t['space'] = 250;
    t['exclam'] = 333;
    t['quotedbl'] = 420;
    t['numbersign'] = 500;
    t['dollar'] = 500;
    t['percent'] = 833;
    t['ampersand'] = 778;
    t['quoteright'] = 333;
    t['parenleft'] = 333;
    t['parenright'] = 333;
    t['asterisk'] = 500;
    t['plus'] = 675;
    t['comma'] = 250;
    t['hyphen'] = 333;
    t['period'] = 250;
    t['slash'] = 278;
    t['zero'] = 500;
    t['one'] = 500;
    t['two'] = 500;
    t['three'] = 500;
    t['four'] = 500;
    t['five'] = 500;
    t['six'] = 500;
    t['seven'] = 500;
    t['eight'] = 500;
    t['nine'] = 500;
    t['colon'] = 333;
    t['semicolon'] = 333;
    t['less'] = 675;
    t['equal'] = 675;
    t['greater'] = 675;
    t['question'] = 500;
    t['at'] = 920;
    t['A'] = 611;
    t['B'] = 611;
    t['C'] = 667;
    t['D'] = 722;
    t['E'] = 611;
    t['F'] = 611;
    t['G'] = 722;
    t['H'] = 722;
    t['I'] = 333;
    t['J'] = 444;
    t['K'] = 667;
    t['L'] = 556;
    t['M'] = 833;
    t['N'] = 667;
    t['O'] = 722;
    t['P'] = 611;
    t['Q'] = 722;
    t['R'] = 611;
    t['S'] = 500;
    t['T'] = 556;
    t['U'] = 722;
    t['V'] = 611;
    t['W'] = 833;
    t['X'] = 611;
    t['Y'] = 556;
    t['Z'] = 556;
    t['bracketleft'] = 389;
    t['backslash'] = 278;
    t['bracketright'] = 389;
    t['asciicircum'] = 422;
    t['underscore'] = 500;
    t['quoteleft'] = 333;
    t['a'] = 500;
    t['b'] = 500;
    t['c'] = 444;
    t['d'] = 500;
    t['e'] = 444;
    t['f'] = 278;
    t['g'] = 500;
    t['h'] = 500;
    t['i'] = 278;
    t['j'] = 278;
    t['k'] = 444;
    t['l'] = 278;
    t['m'] = 722;
    t['n'] = 500;
    t['o'] = 500;
    t['p'] = 500;
    t['q'] = 500;
    t['r'] = 389;
    t['s'] = 389;
    t['t'] = 278;
    t['u'] = 500;
    t['v'] = 444;
    t['w'] = 667;
    t['x'] = 444;
    t['y'] = 444;
    t['z'] = 389;
    t['braceleft'] = 400;
    t['bar'] = 275;
    t['braceright'] = 400;
    t['asciitilde'] = 541;
    t['exclamdown'] = 389;
    t['cent'] = 500;
    t['sterling'] = 500;
    t['fraction'] = 167;
    t['yen'] = 500;
    t['florin'] = 500;
    t['section'] = 500;
    t['currency'] = 500;
    t['quotesingle'] = 214;
    t['quotedblleft'] = 556;
    t['guillemotleft'] = 500;
    t['guilsinglleft'] = 333;
    t['guilsinglright'] = 333;
    t['fi'] = 500;
    t['fl'] = 500;
    t['endash'] = 500;
    t['dagger'] = 500;
    t['daggerdbl'] = 500;
    t['periodcentered'] = 250;
    t['paragraph'] = 523;
    t['bullet'] = 350;
    t['quotesinglbase'] = 333;
    t['quotedblbase'] = 556;
    t['quotedblright'] = 556;
    t['guillemotright'] = 500;
    t['ellipsis'] = 889;
    t['perthousand'] = 1000;
    t['questiondown'] = 500;
    t['grave'] = 333;
    t['acute'] = 333;
    t['circumflex'] = 333;
    t['tilde'] = 333;
    t['macron'] = 333;
    t['breve'] = 333;
    t['dotaccent'] = 333;
    t['dieresis'] = 333;
    t['ring'] = 333;
    t['cedilla'] = 333;
    t['hungarumlaut'] = 333;
    t['ogonek'] = 333;
    t['caron'] = 333;
    t['emdash'] = 889;
    t['AE'] = 889;
    t['ordfeminine'] = 276;
    t['Lslash'] = 556;
    t['Oslash'] = 722;
    t['OE'] = 944;
    t['ordmasculine'] = 310;
    t['ae'] = 667;
    t['dotlessi'] = 278;
    t['lslash'] = 278;
    t['oslash'] = 500;
    t['oe'] = 667;
    t['germandbls'] = 500;
    t['Idieresis'] = 333;
    t['eacute'] = 444;
    t['abreve'] = 500;
    t['uhungarumlaut'] = 500;
    t['ecaron'] = 444;
    t['Ydieresis'] = 556;
    t['divide'] = 675;
    t['Yacute'] = 556;
    t['Acircumflex'] = 611;
    t['aacute'] = 500;
    t['Ucircumflex'] = 722;
    t['yacute'] = 444;
    t['scommaaccent'] = 389;
    t['ecircumflex'] = 444;
    t['Uring'] = 722;
    t['Udieresis'] = 722;
    t['aogonek'] = 500;
    t['Uacute'] = 722;
    t['uogonek'] = 500;
    t['Edieresis'] = 611;
    t['Dcroat'] = 722;
    t['commaaccent'] = 250;
    t['copyright'] = 760;
    t['Emacron'] = 611;
    t['ccaron'] = 444;
    t['aring'] = 500;
    t['Ncommaaccent'] = 667;
    t['lacute'] = 278;
    t['agrave'] = 500;
    t['Tcommaaccent'] = 556;
    t['Cacute'] = 667;
    t['atilde'] = 500;
    t['Edotaccent'] = 611;
    t['scaron'] = 389;
    t['scedilla'] = 389;
    t['iacute'] = 278;
    t['lozenge'] = 471;
    t['Rcaron'] = 611;
    t['Gcommaaccent'] = 722;
    t['ucircumflex'] = 500;
    t['acircumflex'] = 500;
    t['Amacron'] = 611;
    t['rcaron'] = 389;
    t['ccedilla'] = 444;
    t['Zdotaccent'] = 556;
    t['Thorn'] = 611;
    t['Omacron'] = 722;
    t['Racute'] = 611;
    t['Sacute'] = 500;
    t['dcaron'] = 544;
    t['Umacron'] = 722;
    t['uring'] = 500;
    t['threesuperior'] = 300;
    t['Ograve'] = 722;
    t['Agrave'] = 611;
    t['Abreve'] = 611;
    t['multiply'] = 675;
    t['uacute'] = 500;
    t['Tcaron'] = 556;
    t['partialdiff'] = 476;
    t['ydieresis'] = 444;
    t['Nacute'] = 667;
    t['icircumflex'] = 278;
    t['Ecircumflex'] = 611;
    t['adieresis'] = 500;
    t['edieresis'] = 444;
    t['cacute'] = 444;
    t['nacute'] = 500;
    t['umacron'] = 500;
    t['Ncaron'] = 667;
    t['Iacute'] = 333;
    t['plusminus'] = 675;
    t['brokenbar'] = 275;
    t['registered'] = 760;
    t['Gbreve'] = 722;
    t['Idotaccent'] = 333;
    t['summation'] = 600;
    t['Egrave'] = 611;
    t['racute'] = 389;
    t['omacron'] = 500;
    t['Zacute'] = 556;
    t['Zcaron'] = 556;
    t['greaterequal'] = 549;
    t['Eth'] = 722;
    t['Ccedilla'] = 667;
    t['lcommaaccent'] = 278;
    t['tcaron'] = 300;
    t['eogonek'] = 444;
    t['Uogonek'] = 722;
    t['Aacute'] = 611;
    t['Adieresis'] = 611;
    t['egrave'] = 444;
    t['zacute'] = 389;
    t['iogonek'] = 278;
    t['Oacute'] = 722;
    t['oacute'] = 500;
    t['amacron'] = 500;
    t['sacute'] = 389;
    t['idieresis'] = 278;
    t['Ocircumflex'] = 722;
    t['Ugrave'] = 722;
    t['Delta'] = 612;
    t['thorn'] = 500;
    t['twosuperior'] = 300;
    t['Odieresis'] = 722;
    t['mu'] = 500;
    t['igrave'] = 278;
    t['ohungarumlaut'] = 500;
    t['Eogonek'] = 611;
    t['dcroat'] = 500;
    t['threequarters'] = 750;
    t['Scedilla'] = 500;
    t['lcaron'] = 300;
    t['Kcommaaccent'] = 667;
    t['Lacute'] = 556;
    t['trademark'] = 980;
    t['edotaccent'] = 444;
    t['Igrave'] = 333;
    t['Imacron'] = 333;
    t['Lcaron'] = 611;
    t['onehalf'] = 750;
    t['lessequal'] = 549;
    t['ocircumflex'] = 500;
    t['ntilde'] = 500;
    t['Uhungarumlaut'] = 722;
    t['Eacute'] = 611;
    t['emacron'] = 444;
    t['gbreve'] = 500;
    t['onequarter'] = 750;
    t['Scaron'] = 500;
    t['Scommaaccent'] = 500;
    t['Ohungarumlaut'] = 722;
    t['degree'] = 400;
    t['ograve'] = 500;
    t['Ccaron'] = 667;
    t['ugrave'] = 500;
    t['radical'] = 453;
    t['Dcaron'] = 722;
    t['rcommaaccent'] = 389;
    t['Ntilde'] = 667;
    t['otilde'] = 500;
    t['Rcommaaccent'] = 611;
    t['Lcommaaccent'] = 556;
    t['Atilde'] = 611;
    t['Aogonek'] = 611;
    t['Aring'] = 611;
    t['Otilde'] = 722;
    t['zdotaccent'] = 389;
    t['Ecaron'] = 611;
    t['Iogonek'] = 333;
    t['kcommaaccent'] = 444;
    t['minus'] = 675;
    t['Icircumflex'] = 333;
    t['ncaron'] = 500;
    t['tcommaaccent'] = 278;
    t['logicalnot'] = 675;
    t['odieresis'] = 500;
    t['udieresis'] = 500;
    t['notequal'] = 549;
    t['gcommaaccent'] = 500;
    t['eth'] = 500;
    t['zcaron'] = 389;
    t['ncommaaccent'] = 500;
    t['onesuperior'] = 300;
    t['imacron'] = 278;
    t['Euro'] = 500;
  });
  t['ZapfDingbats'] = getLookupTableFactory(function (t) {
    t['space'] = 278;
    t['a1'] = 974;
    t['a2'] = 961;
    t['a202'] = 974;
    t['a3'] = 980;
    t['a4'] = 719;
    t['a5'] = 789;
    t['a119'] = 790;
    t['a118'] = 791;
    t['a117'] = 690;
    t['a11'] = 960;
    t['a12'] = 939;
    t['a13'] = 549;
    t['a14'] = 855;
    t['a15'] = 911;
    t['a16'] = 933;
    t['a105'] = 911;
    t['a17'] = 945;
    t['a18'] = 974;
    t['a19'] = 755;
    t['a20'] = 846;
    t['a21'] = 762;
    t['a22'] = 761;
    t['a23'] = 571;
    t['a24'] = 677;
    t['a25'] = 763;
    t['a26'] = 760;
    t['a27'] = 759;
    t['a28'] = 754;
    t['a6'] = 494;
    t['a7'] = 552;
    t['a8'] = 537;
    t['a9'] = 577;
    t['a10'] = 692;
    t['a29'] = 786;
    t['a30'] = 788;
    t['a31'] = 788;
    t['a32'] = 790;
    t['a33'] = 793;
    t['a34'] = 794;
    t['a35'] = 816;
    t['a36'] = 823;
    t['a37'] = 789;
    t['a38'] = 841;
    t['a39'] = 823;
    t['a40'] = 833;
    t['a41'] = 816;
    t['a42'] = 831;
    t['a43'] = 923;
    t['a44'] = 744;
    t['a45'] = 723;
    t['a46'] = 749;
    t['a47'] = 790;
    t['a48'] = 792;
    t['a49'] = 695;
    t['a50'] = 776;
    t['a51'] = 768;
    t['a52'] = 792;
    t['a53'] = 759;
    t['a54'] = 707;
    t['a55'] = 708;
    t['a56'] = 682;
    t['a57'] = 701;
    t['a58'] = 826;
    t['a59'] = 815;
    t['a60'] = 789;
    t['a61'] = 789;
    t['a62'] = 707;
    t['a63'] = 687;
    t['a64'] = 696;
    t['a65'] = 689;
    t['a66'] = 786;
    t['a67'] = 787;
    t['a68'] = 713;
    t['a69'] = 791;
    t['a70'] = 785;
    t['a71'] = 791;
    t['a72'] = 873;
    t['a73'] = 761;
    t['a74'] = 762;
    t['a203'] = 762;
    t['a75'] = 759;
    t['a204'] = 759;
    t['a76'] = 892;
    t['a77'] = 892;
    t['a78'] = 788;
    t['a79'] = 784;
    t['a81'] = 438;
    t['a82'] = 138;
    t['a83'] = 277;
    t['a84'] = 415;
    t['a97'] = 392;
    t['a98'] = 392;
    t['a99'] = 668;
    t['a100'] = 668;
    t['a89'] = 390;
    t['a90'] = 390;
    t['a93'] = 317;
    t['a94'] = 317;
    t['a91'] = 276;
    t['a92'] = 276;
    t['a205'] = 509;
    t['a85'] = 509;
    t['a206'] = 410;
    t['a86'] = 410;
    t['a87'] = 234;
    t['a88'] = 234;
    t['a95'] = 334;
    t['a96'] = 334;
    t['a101'] = 732;
    t['a102'] = 544;
    t['a103'] = 544;
    t['a104'] = 910;
    t['a106'] = 667;
    t['a107'] = 760;
    t['a108'] = 760;
    t['a112'] = 776;
    t['a111'] = 595;
    t['a110'] = 694;
    t['a109'] = 626;
    t['a120'] = 788;
    t['a121'] = 788;
    t['a122'] = 788;
    t['a123'] = 788;
    t['a124'] = 788;
    t['a125'] = 788;
    t['a126'] = 788;
    t['a127'] = 788;
    t['a128'] = 788;
    t['a129'] = 788;
    t['a130'] = 788;
    t['a131'] = 788;
    t['a132'] = 788;
    t['a133'] = 788;
    t['a134'] = 788;
    t['a135'] = 788;
    t['a136'] = 788;
    t['a137'] = 788;
    t['a138'] = 788;
    t['a139'] = 788;
    t['a140'] = 788;
    t['a141'] = 788;
    t['a142'] = 788;
    t['a143'] = 788;
    t['a144'] = 788;
    t['a145'] = 788;
    t['a146'] = 788;
    t['a147'] = 788;
    t['a148'] = 788;
    t['a149'] = 788;
    t['a150'] = 788;
    t['a151'] = 788;
    t['a152'] = 788;
    t['a153'] = 788;
    t['a154'] = 788;
    t['a155'] = 788;
    t['a156'] = 788;
    t['a157'] = 788;
    t['a158'] = 788;
    t['a159'] = 788;
    t['a160'] = 894;
    t['a161'] = 838;
    t['a163'] = 1016;
    t['a164'] = 458;
    t['a196'] = 748;
    t['a165'] = 924;
    t['a192'] = 748;
    t['a166'] = 918;
    t['a167'] = 927;
    t['a168'] = 928;
    t['a169'] = 928;
    t['a170'] = 834;
    t['a171'] = 873;
    t['a172'] = 828;
    t['a173'] = 924;
    t['a162'] = 924;
    t['a174'] = 917;
    t['a175'] = 930;
    t['a176'] = 931;
    t['a177'] = 463;
    t['a178'] = 883;
    t['a179'] = 836;
    t['a193'] = 836;
    t['a180'] = 867;
    t['a199'] = 867;
    t['a181'] = 696;
    t['a200'] = 696;
    t['a182'] = 874;
    t['a201'] = 874;
    t['a183'] = 760;
    t['a184'] = 946;
    t['a197'] = 771;
    t['a185'] = 865;
    t['a194'] = 771;
    t['a198'] = 888;
    t['a186'] = 967;
    t['a195'] = 888;
    t['a187'] = 831;
    t['a188'] = 873;
    t['a189'] = 927;
    t['a190'] = 970;
    t['a191'] = 918;
  });
});
exports.getMetrics = getMetrics;

/***/ }),
/* 31 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var sharedUtil = __w_pdfjs_require__(0);
var MurmurHash3_64 = function MurmurHash3_64Closure(seed) {
  var MASK_HIGH = 0xffff0000;
  var MASK_LOW = 0xffff;
  function MurmurHash3_64(seed) {
    var SEED = 0xc3d2e1f0;
    this.h1 = seed ? seed & 0xffffffff : SEED;
    this.h2 = seed ? seed & 0xffffffff : SEED;
  }
  MurmurHash3_64.prototype = {
    update: function MurmurHash3_64_update(input) {
      var i;
      if (typeof input === 'string') {
        var data = new Uint8Array(input.length * 2);
        var length = 0;
        for (i = 0; i < input.length; i++) {
          var code = input.charCodeAt(i);
          if (code <= 0xff) {
            data[length++] = code;
          } else {
            data[length++] = code >>> 8;
            data[length++] = code & 0xff;
          }
        }
      } else if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' && 'byteLength' in input) {
        data = input;
        length = data.byteLength;
      } else {
        throw new Error('Wrong data format in MurmurHash3_64_update. ' + 'Input must be a string or array.');
      }
      var blockCounts = length >> 2;
      var tailLength = length - blockCounts * 4;
      var dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
      var k1 = 0;
      var k2 = 0;
      var h1 = this.h1;
      var h2 = this.h2;
      var C1 = 0xcc9e2d51;
      var C2 = 0x1b873593;
      var C1_LOW = C1 & MASK_LOW;
      var C2_LOW = C2 & MASK_LOW;
      for (i = 0; i < blockCounts; i++) {
        if (i & 1) {
          k1 = dataUint32[i];
          k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
          h1 ^= k1;
          h1 = h1 << 13 | h1 >>> 19;
          h1 = h1 * 5 + 0xe6546b64;
        } else {
          k2 = dataUint32[i];
          k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
          k2 = k2 << 15 | k2 >>> 17;
          k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
          h2 ^= k2;
          h2 = h2 << 13 | h2 >>> 19;
          h2 = h2 * 5 + 0xe6546b64;
        }
      }
      k1 = 0;
      switch (tailLength) {
        case 3:
          k1 ^= data[blockCounts * 4 + 2] << 16;
        case 2:
          k1 ^= data[blockCounts * 4 + 1] << 8;
        case 1:
          k1 ^= data[blockCounts * 4];
          k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
          if (blockCounts & 1) {
            h1 ^= k1;
          } else {
            h2 ^= k1;
          }
      }
      this.h1 = h1;
      this.h2 = h2;
      return this;
    },
    hexdigest: function MurmurHash3_64_hexdigest() {
      var h1 = this.h1;
      var h2 = this.h2;
      h1 ^= h2 >>> 1;
      h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;
      h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;
      h1 ^= h2 >>> 1;
      h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;
      h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;
      h1 ^= h2 >>> 1;
      for (var i = 0, arr = [h1, h2], str = ''; i < arr.length; i++) {
        var hex = (arr[i] >>> 0).toString(16);
        while (hex.length < 8) {
          hex = '0' + hex;
        }
        str += hex;
      }
      return str;
    }
  };
  return MurmurHash3_64;
}();
exports.MurmurHash3_64 = MurmurHash3_64;

/***/ }),
/* 32 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var corePrimitives = __w_pdfjs_require__(1);
var coreFunction = __w_pdfjs_require__(6);
var coreColorSpace = __w_pdfjs_require__(3);
var UNSUPPORTED_FEATURES = sharedUtil.UNSUPPORTED_FEATURES;
var MissingDataException = sharedUtil.MissingDataException;
var Util = sharedUtil.Util;
var assert = sharedUtil.assert;
var error = sharedUtil.error;
var info = sharedUtil.info;
var warn = sharedUtil.warn;
var isStream = corePrimitives.isStream;
var PDFFunction = coreFunction.PDFFunction;
var ColorSpace = coreColorSpace.ColorSpace;
var ShadingType = {
  FUNCTION_BASED: 1,
  AXIAL: 2,
  RADIAL: 3,
  FREE_FORM_MESH: 4,
  LATTICE_FORM_MESH: 5,
  COONS_PATCH_MESH: 6,
  TENSOR_PATCH_MESH: 7
};
var Pattern = function PatternClosure() {
  function Pattern() {
    error('should not call Pattern constructor');
  }
  Pattern.prototype = {
    getPattern: function Pattern_getPattern(ctx) {
      error('Should not call Pattern.getStyle: ' + ctx);
    }
  };
  Pattern.parseShading = function Pattern_parseShading(shading, matrix, xref, res, handler) {
    var dict = isStream(shading) ? shading.dict : shading;
    var type = dict.get('ShadingType');
    try {
      switch (type) {
        case ShadingType.AXIAL:
        case ShadingType.RADIAL:
          return new Shadings.RadialAxial(dict, matrix, xref, res);
        case ShadingType.FREE_FORM_MESH:
        case ShadingType.LATTICE_FORM_MESH:
        case ShadingType.COONS_PATCH_MESH:
        case ShadingType.TENSOR_PATCH_MESH:
          return new Shadings.Mesh(shading, matrix, xref, res);
        default:
          throw new Error('Unsupported ShadingType: ' + type);
      }
    } catch (ex) {
      if (ex instanceof MissingDataException) {
        throw ex;
      }
      handler.send('UnsupportedFeature', { featureId: UNSUPPORTED_FEATURES.shadingPattern });
      warn(ex);
      return new Shadings.Dummy();
    }
  };
  return Pattern;
}();
var Shadings = {};
Shadings.SMALL_NUMBER = 1e-6;
Shadings.RadialAxial = function RadialAxialClosure() {
  function RadialAxial(dict, matrix, xref, res) {
    this.matrix = matrix;
    this.coordsArr = dict.getArray('Coords');
    this.shadingType = dict.get('ShadingType');
    this.type = 'Pattern';
    var cs = dict.get('ColorSpace', 'CS');
    cs = ColorSpace.parse(cs, xref, res);
    this.cs = cs;
    var t0 = 0.0,
        t1 = 1.0;
    if (dict.has('Domain')) {
      var domainArr = dict.getArray('Domain');
      t0 = domainArr[0];
      t1 = domainArr[1];
    }
    var extendStart = false,
        extendEnd = false;
    if (dict.has('Extend')) {
      var extendArr = dict.getArray('Extend');
      extendStart = extendArr[0];
      extendEnd = extendArr[1];
    }
    if (this.shadingType === ShadingType.RADIAL && (!extendStart || !extendEnd)) {
      var x1 = this.coordsArr[0];
      var y1 = this.coordsArr[1];
      var r1 = this.coordsArr[2];
      var x2 = this.coordsArr[3];
      var y2 = this.coordsArr[4];
      var r2 = this.coordsArr[5];
      var distance = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
      if (r1 <= r2 + distance && r2 <= r1 + distance) {
        warn('Unsupported radial gradient.');
      }
    }
    this.extendStart = extendStart;
    this.extendEnd = extendEnd;
    var fnObj = dict.get('Function');
    var fn = PDFFunction.parseArray(xref, fnObj);
    var diff = t1 - t0;
    var step = diff / 10;
    var colorStops = this.colorStops = [];
    if (t0 >= t1 || step <= 0) {
      info('Bad shading domain.');
      return;
    }
    var color = new Float32Array(cs.numComps),
        ratio = new Float32Array(1);
    var rgbColor;
    for (var i = t0; i <= t1; i += step) {
      ratio[0] = i;
      fn(ratio, 0, color, 0);
      rgbColor = cs.getRgb(color, 0);
      var cssColor = Util.makeCssRgb(rgbColor[0], rgbColor[1], rgbColor[2]);
      colorStops.push([(i - t0) / diff, cssColor]);
    }
    var background = 'transparent';
    if (dict.has('Background')) {
      rgbColor = cs.getRgb(dict.get('Background'), 0);
      background = Util.makeCssRgb(rgbColor[0], rgbColor[1], rgbColor[2]);
    }
    if (!extendStart) {
      colorStops.unshift([0, background]);
      colorStops[1][0] += Shadings.SMALL_NUMBER;
    }
    if (!extendEnd) {
      colorStops[colorStops.length - 1][0] -= Shadings.SMALL_NUMBER;
      colorStops.push([1, background]);
    }
    this.colorStops = colorStops;
  }
  RadialAxial.prototype = {
    getIR: function RadialAxial_getIR() {
      var coordsArr = this.coordsArr;
      var shadingType = this.shadingType;
      var type, p0, p1, r0, r1;
      if (shadingType === ShadingType.AXIAL) {
        p0 = [coordsArr[0], coordsArr[1]];
        p1 = [coordsArr[2], coordsArr[3]];
        r0 = null;
        r1 = null;
        type = 'axial';
      } else if (shadingType === ShadingType.RADIAL) {
        p0 = [coordsArr[0], coordsArr[1]];
        p1 = [coordsArr[3], coordsArr[4]];
        r0 = coordsArr[2];
        r1 = coordsArr[5];
        type = 'radial';
      } else {
        error('getPattern type unknown: ' + shadingType);
      }
      var matrix = this.matrix;
      if (matrix) {
        p0 = Util.applyTransform(p0, matrix);
        p1 = Util.applyTransform(p1, matrix);
        if (shadingType === ShadingType.RADIAL) {
          var scale = Util.singularValueDecompose2dScale(matrix);
          r0 *= scale[0];
          r1 *= scale[1];
        }
      }
      return ['RadialAxial', type, this.colorStops, p0, p1, r0, r1];
    }
  };
  return RadialAxial;
}();
Shadings.Mesh = function MeshClosure() {
  function MeshStreamReader(stream, context) {
    this.stream = stream;
    this.context = context;
    this.buffer = 0;
    this.bufferLength = 0;
    var numComps = context.numComps;
    this.tmpCompsBuf = new Float32Array(numComps);
    var csNumComps = context.colorSpace.numComps;
    this.tmpCsCompsBuf = context.colorFn ? new Float32Array(csNumComps) : this.tmpCompsBuf;
  }
  MeshStreamReader.prototype = {
    get hasData() {
      if (this.stream.end) {
        return this.stream.pos < this.stream.end;
      }
      if (this.bufferLength > 0) {
        return true;
      }
      var nextByte = this.stream.getByte();
      if (nextByte < 0) {
        return false;
      }
      this.buffer = nextByte;
      this.bufferLength = 8;
      return true;
    },
    readBits: function MeshStreamReader_readBits(n) {
      var buffer = this.buffer;
      var bufferLength = this.bufferLength;
      if (n === 32) {
        if (bufferLength === 0) {
          return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
        }
        buffer = buffer << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
        var nextByte = this.stream.getByte();
        this.buffer = nextByte & (1 << bufferLength) - 1;
        return (buffer << 8 - bufferLength | (nextByte & 0xFF) >> bufferLength) >>> 0;
      }
      if (n === 8 && bufferLength === 0) {
        return this.stream.getByte();
      }
      while (bufferLength < n) {
        buffer = buffer << 8 | this.stream.getByte();
        bufferLength += 8;
      }
      bufferLength -= n;
      this.bufferLength = bufferLength;
      this.buffer = buffer & (1 << bufferLength) - 1;
      return buffer >> bufferLength;
    },
    align: function MeshStreamReader_align() {
      this.buffer = 0;
      this.bufferLength = 0;
    },
    readFlag: function MeshStreamReader_readFlag() {
      return this.readBits(this.context.bitsPerFlag);
    },
    readCoordinate: function MeshStreamReader_readCoordinate() {
      var bitsPerCoordinate = this.context.bitsPerCoordinate;
      var xi = this.readBits(bitsPerCoordinate);
      var yi = this.readBits(bitsPerCoordinate);
      var decode = this.context.decode;
      var scale = bitsPerCoordinate < 32 ? 1 / ((1 << bitsPerCoordinate) - 1) : 2.3283064365386963e-10;
      return [xi * scale * (decode[1] - decode[0]) + decode[0], yi * scale * (decode[3] - decode[2]) + decode[2]];
    },
    readComponents: function MeshStreamReader_readComponents() {
      var numComps = this.context.numComps;
      var bitsPerComponent = this.context.bitsPerComponent;
      var scale = bitsPerComponent < 32 ? 1 / ((1 << bitsPerComponent) - 1) : 2.3283064365386963e-10;
      var decode = this.context.decode;
      var components = this.tmpCompsBuf;
      for (var i = 0, j = 4; i < numComps; i++, j += 2) {
        var ci = this.readBits(bitsPerComponent);
        components[i] = ci * scale * (decode[j + 1] - decode[j]) + decode[j];
      }
      var color = this.tmpCsCompsBuf;
      if (this.context.colorFn) {
        this.context.colorFn(components, 0, color, 0);
      }
      return this.context.colorSpace.getRgb(color, 0);
    }
  };
  function decodeType4Shading(mesh, reader) {
    var coords = mesh.coords;
    var colors = mesh.colors;
    var operators = [];
    var ps = [];
    var verticesLeft = 0;
    while (reader.hasData) {
      var f = reader.readFlag();
      var coord = reader.readCoordinate();
      var color = reader.readComponents();
      if (verticesLeft === 0) {
        assert(0 <= f && f <= 2, 'Unknown type4 flag');
        switch (f) {
          case 0:
            verticesLeft = 3;
            break;
          case 1:
            ps.push(ps[ps.length - 2], ps[ps.length - 1]);
            verticesLeft = 1;
            break;
          case 2:
            ps.push(ps[ps.length - 3], ps[ps.length - 1]);
            verticesLeft = 1;
            break;
        }
        operators.push(f);
      }
      ps.push(coords.length);
      coords.push(coord);
      colors.push(color);
      verticesLeft--;
      reader.align();
    }
    mesh.figures.push({
      type: 'triangles',
      coords: new Int32Array(ps),
      colors: new Int32Array(ps)
    });
  }
  function decodeType5Shading(mesh, reader, verticesPerRow) {
    var coords = mesh.coords;
    var colors = mesh.colors;
    var ps = [];
    while (reader.hasData) {
      var coord = reader.readCoordinate();
      var color = reader.readComponents();
      ps.push(coords.length);
      coords.push(coord);
      colors.push(color);
    }
    mesh.figures.push({
      type: 'lattice',
      coords: new Int32Array(ps),
      colors: new Int32Array(ps),
      verticesPerRow: verticesPerRow
    });
  }
  var MIN_SPLIT_PATCH_CHUNKS_AMOUNT = 3;
  var MAX_SPLIT_PATCH_CHUNKS_AMOUNT = 20;
  var TRIANGLE_DENSITY = 20;
  var getB = function getBClosure() {
    function buildB(count) {
      var lut = [];
      for (var i = 0; i <= count; i++) {
        var t = i / count,
            t_ = 1 - t;
        lut.push(new Float32Array([t_ * t_ * t_, 3 * t * t_ * t_, 3 * t * t * t_, t * t * t]));
      }
      return lut;
    }
    var cache = [];
    return function getB(count) {
      if (!cache[count]) {
        cache[count] = buildB(count);
      }
      return cache[count];
    };
  }();
  function buildFigureFromPatch(mesh, index) {
    var figure = mesh.figures[index];
    assert(figure.type === 'patch', 'Unexpected patch mesh figure');
    var coords = mesh.coords,
        colors = mesh.colors;
    var pi = figure.coords;
    var ci = figure.colors;
    var figureMinX = Math.min(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
    var figureMinY = Math.min(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
    var figureMaxX = Math.max(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
    var figureMaxY = Math.max(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
    var splitXBy = Math.ceil((figureMaxX - figureMinX) * TRIANGLE_DENSITY / (mesh.bounds[2] - mesh.bounds[0]));
    splitXBy = Math.max(MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitXBy));
    var splitYBy = Math.ceil((figureMaxY - figureMinY) * TRIANGLE_DENSITY / (mesh.bounds[3] - mesh.bounds[1]));
    splitYBy = Math.max(MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitYBy));
    var verticesPerRow = splitXBy + 1;
    var figureCoords = new Int32Array((splitYBy + 1) * verticesPerRow);
    var figureColors = new Int32Array((splitYBy + 1) * verticesPerRow);
    var k = 0;
    var cl = new Uint8Array(3),
        cr = new Uint8Array(3);
    var c0 = colors[ci[0]],
        c1 = colors[ci[1]],
        c2 = colors[ci[2]],
        c3 = colors[ci[3]];
    var bRow = getB(splitYBy),
        bCol = getB(splitXBy);
    for (var row = 0; row <= splitYBy; row++) {
      cl[0] = (c0[0] * (splitYBy - row) + c2[0] * row) / splitYBy | 0;
      cl[1] = (c0[1] * (splitYBy - row) + c2[1] * row) / splitYBy | 0;
      cl[2] = (c0[2] * (splitYBy - row) + c2[2] * row) / splitYBy | 0;
      cr[0] = (c1[0] * (splitYBy - row) + c3[0] * row) / splitYBy | 0;
      cr[1] = (c1[1] * (splitYBy - row) + c3[1] * row) / splitYBy | 0;
      cr[2] = (c1[2] * (splitYBy - row) + c3[2] * row) / splitYBy | 0;
      for (var col = 0; col <= splitXBy; col++, k++) {
        if ((row === 0 || row === splitYBy) && (col === 0 || col === splitXBy)) {
          continue;
        }
        var x = 0,
            y = 0;
        var q = 0;
        for (var i = 0; i <= 3; i++) {
          for (var j = 0; j <= 3; j++, q++) {
            var m = bRow[row][i] * bCol[col][j];
            x += coords[pi[q]][0] * m;
            y += coords[pi[q]][1] * m;
          }
        }
        figureCoords[k] = coords.length;
        coords.push([x, y]);
        figureColors[k] = colors.length;
        var newColor = new Uint8Array(3);
        newColor[0] = (cl[0] * (splitXBy - col) + cr[0] * col) / splitXBy | 0;
        newColor[1] = (cl[1] * (splitXBy - col) + cr[1] * col) / splitXBy | 0;
        newColor[2] = (cl[2] * (splitXBy - col) + cr[2] * col) / splitXBy | 0;
        colors.push(newColor);
      }
    }
    figureCoords[0] = pi[0];
    figureColors[0] = ci[0];
    figureCoords[splitXBy] = pi[3];
    figureColors[splitXBy] = ci[1];
    figureCoords[verticesPerRow * splitYBy] = pi[12];
    figureColors[verticesPerRow * splitYBy] = ci[2];
    figureCoords[verticesPerRow * splitYBy + splitXBy] = pi[15];
    figureColors[verticesPerRow * splitYBy + splitXBy] = ci[3];
    mesh.figures[index] = {
      type: 'lattice',
      coords: figureCoords,
      colors: figureColors,
      verticesPerRow: verticesPerRow
    };
  }
  function decodeType6Shading(mesh, reader) {
    var coords = mesh.coords;
    var colors = mesh.colors;
    var ps = new Int32Array(16);
    var cs = new Int32Array(4);
    while (reader.hasData) {
      var f = reader.readFlag();
      assert(0 <= f && f <= 3, 'Unknown type6 flag');
      var i, ii;
      var pi = coords.length;
      for (i = 0, ii = f !== 0 ? 8 : 12; i < ii; i++) {
        coords.push(reader.readCoordinate());
      }
      var ci = colors.length;
      for (i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {
        colors.push(reader.readComponents());
      }
      var tmp1, tmp2, tmp3, tmp4;
      switch (f) {
        case 0:
          ps[12] = pi + 3;
          ps[13] = pi + 4;
          ps[14] = pi + 5;
          ps[15] = pi + 6;
          ps[8] = pi + 2;
          ps[11] = pi + 7;
          ps[4] = pi + 1;
          ps[7] = pi + 8;
          ps[0] = pi;
          ps[1] = pi + 11;
          ps[2] = pi + 10;
          ps[3] = pi + 9;
          cs[2] = ci + 1;
          cs[3] = ci + 2;
          cs[0] = ci;
          cs[1] = ci + 3;
          break;
        case 1:
          tmp1 = ps[12];
          tmp2 = ps[13];
          tmp3 = ps[14];
          tmp4 = ps[15];
          ps[12] = tmp4;
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = tmp3;
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[2];
          tmp2 = cs[3];
          cs[2] = tmp2;
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;
        case 2:
          tmp1 = ps[15];
          tmp2 = ps[11];
          ps[12] = ps[3];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[7];
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[3];
          cs[2] = cs[1];
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;
        case 3:
          ps[12] = ps[0];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[1];
          ps[11] = pi + 3;
          ps[4] = ps[2];
          ps[7] = pi + 4;
          ps[0] = ps[3];
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          cs[2] = cs[0];
          cs[3] = ci;
          cs[0] = cs[1];
          cs[1] = ci + 1;
          break;
      }
      ps[5] = coords.length;
      coords.push([(-4 * coords[ps[0]][0] - coords[ps[15]][0] + 6 * (coords[ps[4]][0] + coords[ps[1]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[13]][0] + coords[ps[7]][0])) / 9, (-4 * coords[ps[0]][1] - coords[ps[15]][1] + 6 * (coords[ps[4]][1] + coords[ps[1]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[13]][1] + coords[ps[7]][1])) / 9]);
      ps[6] = coords.length;
      coords.push([(-4 * coords[ps[3]][0] - coords[ps[12]][0] + 6 * (coords[ps[2]][0] + coords[ps[7]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[4]][0] + coords[ps[14]][0])) / 9, (-4 * coords[ps[3]][1] - coords[ps[12]][1] + 6 * (coords[ps[2]][1] + coords[ps[7]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[4]][1] + coords[ps[14]][1])) / 9]);
      ps[9] = coords.length;
      coords.push([(-4 * coords[ps[12]][0] - coords[ps[3]][0] + 6 * (coords[ps[8]][0] + coords[ps[13]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[11]][0] + coords[ps[1]][0])) / 9, (-4 * coords[ps[12]][1] - coords[ps[3]][1] + 6 * (coords[ps[8]][1] + coords[ps[13]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[11]][1] + coords[ps[1]][1])) / 9]);
      ps[10] = coords.length;
      coords.push([(-4 * coords[ps[15]][0] - coords[ps[0]][0] + 6 * (coords[ps[11]][0] + coords[ps[14]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[2]][0] + coords[ps[8]][0])) / 9, (-4 * coords[ps[15]][1] - coords[ps[0]][1] + 6 * (coords[ps[11]][1] + coords[ps[14]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[2]][1] + coords[ps[8]][1])) / 9]);
      mesh.figures.push({
        type: 'patch',
        coords: new Int32Array(ps),
        colors: new Int32Array(cs)
      });
    }
  }
  function decodeType7Shading(mesh, reader) {
    var coords = mesh.coords;
    var colors = mesh.colors;
    var ps = new Int32Array(16);
    var cs = new Int32Array(4);
    while (reader.hasData) {
      var f = reader.readFlag();
      assert(0 <= f && f <= 3, 'Unknown type7 flag');
      var i, ii;
      var pi = coords.length;
      for (i = 0, ii = f !== 0 ? 12 : 16; i < ii; i++) {
        coords.push(reader.readCoordinate());
      }
      var ci = colors.length;
      for (i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {
        colors.push(reader.readComponents());
      }
      var tmp1, tmp2, tmp3, tmp4;
      switch (f) {
        case 0:
          ps[12] = pi + 3;
          ps[13] = pi + 4;
          ps[14] = pi + 5;
          ps[15] = pi + 6;
          ps[8] = pi + 2;
          ps[9] = pi + 13;
          ps[10] = pi + 14;
          ps[11] = pi + 7;
          ps[4] = pi + 1;
          ps[5] = pi + 12;
          ps[6] = pi + 15;
          ps[7] = pi + 8;
          ps[0] = pi;
          ps[1] = pi + 11;
          ps[2] = pi + 10;
          ps[3] = pi + 9;
          cs[2] = ci + 1;
          cs[3] = ci + 2;
          cs[0] = ci;
          cs[1] = ci + 3;
          break;
        case 1:
          tmp1 = ps[12];
          tmp2 = ps[13];
          tmp3 = ps[14];
          tmp4 = ps[15];
          ps[12] = tmp4;
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = tmp3;
          ps[9] = pi + 9;
          ps[10] = pi + 10;
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[5] = pi + 8;
          ps[6] = pi + 11;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[2];
          tmp2 = cs[3];
          cs[2] = tmp2;
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;
        case 2:
          tmp1 = ps[15];
          tmp2 = ps[11];
          ps[12] = ps[3];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[7];
          ps[9] = pi + 9;
          ps[10] = pi + 10;
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[5] = pi + 8;
          ps[6] = pi + 11;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[3];
          cs[2] = cs[1];
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;
        case 3:
          ps[12] = ps[0];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[1];
          ps[9] = pi + 9;
          ps[10] = pi + 10;
          ps[11] = pi + 3;
          ps[4] = ps[2];
          ps[5] = pi + 8;
          ps[6] = pi + 11;
          ps[7] = pi + 4;
          ps[0] = ps[3];
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          cs[2] = cs[0];
          cs[3] = ci;
          cs[0] = cs[1];
          cs[1] = ci + 1;
          break;
      }
      mesh.figures.push({
        type: 'patch',
        coords: new Int32Array(ps),
        colors: new Int32Array(cs)
      });
    }
  }
  function updateBounds(mesh) {
    var minX = mesh.coords[0][0],
        minY = mesh.coords[0][1],
        maxX = minX,
        maxY = minY;
    for (var i = 1, ii = mesh.coords.length; i < ii; i++) {
      var x = mesh.coords[i][0],
          y = mesh.coords[i][1];
      minX = minX > x ? x : minX;
      minY = minY > y ? y : minY;
      maxX = maxX < x ? x : maxX;
      maxY = maxY < y ? y : maxY;
    }
    mesh.bounds = [minX, minY, maxX, maxY];
  }
  function packData(mesh) {
    var i, ii, j, jj;
    var coords = mesh.coords;
    var coordsPacked = new Float32Array(coords.length * 2);
    for (i = 0, j = 0, ii = coords.length; i < ii; i++) {
      var xy = coords[i];
      coordsPacked[j++] = xy[0];
      coordsPacked[j++] = xy[1];
    }
    mesh.coords = coordsPacked;
    var colors = mesh.colors;
    var colorsPacked = new Uint8Array(colors.length * 3);
    for (i = 0, j = 0, ii = colors.length; i < ii; i++) {
      var c = colors[i];
      colorsPacked[j++] = c[0];
      colorsPacked[j++] = c[1];
      colorsPacked[j++] = c[2];
    }
    mesh.colors = colorsPacked;
    var figures = mesh.figures;
    for (i = 0, ii = figures.length; i < ii; i++) {
      var figure = figures[i],
          ps = figure.coords,
          cs = figure.colors;
      for (j = 0, jj = ps.length; j < jj; j++) {
        ps[j] *= 2;
        cs[j] *= 3;
      }
    }
  }
  function Mesh(stream, matrix, xref, res) {
    assert(isStream(stream), 'Mesh data is not a stream');
    var dict = stream.dict;
    this.matrix = matrix;
    this.shadingType = dict.get('ShadingType');
    this.type = 'Pattern';
    this.bbox = dict.getArray('BBox');
    var cs = dict.get('ColorSpace', 'CS');
    cs = ColorSpace.parse(cs, xref, res);
    this.cs = cs;
    this.background = dict.has('Background') ? cs.getRgb(dict.get('Background'), 0) : null;
    var fnObj = dict.get('Function');
    var fn = fnObj ? PDFFunction.parseArray(xref, fnObj) : null;
    this.coords = [];
    this.colors = [];
    this.figures = [];
    var decodeContext = {
      bitsPerCoordinate: dict.get('BitsPerCoordinate'),
      bitsPerComponent: dict.get('BitsPerComponent'),
      bitsPerFlag: dict.get('BitsPerFlag'),
      decode: dict.getArray('Decode'),
      colorFn: fn,
      colorSpace: cs,
      numComps: fn ? 1 : cs.numComps
    };
    var reader = new MeshStreamReader(stream, decodeContext);
    var patchMesh = false;
    switch (this.shadingType) {
      case ShadingType.FREE_FORM_MESH:
        decodeType4Shading(this, reader);
        break;
      case ShadingType.LATTICE_FORM_MESH:
        var verticesPerRow = dict.get('VerticesPerRow') | 0;
        assert(verticesPerRow >= 2, 'Invalid VerticesPerRow');
        decodeType5Shading(this, reader, verticesPerRow);
        break;
      case ShadingType.COONS_PATCH_MESH:
        decodeType6Shading(this, reader);
        patchMesh = true;
        break;
      case ShadingType.TENSOR_PATCH_MESH:
        decodeType7Shading(this, reader);
        patchMesh = true;
        break;
      default:
        error('Unsupported mesh type.');
        break;
    }
    if (patchMesh) {
      updateBounds(this);
      for (var i = 0, ii = this.figures.length; i < ii; i++) {
        buildFigureFromPatch(this, i);
      }
    }
    updateBounds(this);
    packData(this);
  }
  Mesh.prototype = {
    getIR: function Mesh_getIR() {
      return ['Mesh', this.shadingType, this.coords, this.colors, this.figures, this.bounds, this.matrix, this.bbox, this.background];
    }
  };
  return Mesh;
}();
Shadings.Dummy = function DummyClosure() {
  function Dummy() {
    this.type = 'Pattern';
  }
  Dummy.prototype = {
    getIR: function Dummy_getIR() {
      return ['Dummy'];
    }
  };
  return Dummy;
}();
function getTilingPatternIR(operatorList, dict, args) {
  var matrix = dict.getArray('Matrix');
  var bbox = dict.getArray('BBox');
  var xstep = dict.get('XStep');
  var ystep = dict.get('YStep');
  var paintType = dict.get('PaintType');
  var tilingType = dict.get('TilingType');
  return ['TilingPattern', args, operatorList, matrix, bbox, xstep, ystep, paintType, tilingType];
}
exports.Pattern = Pattern;
exports.getTilingPatternIR = getTilingPatternIR;

/***/ }),
/* 33 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var coreStream = __w_pdfjs_require__(2);
var coreChunkedStream = __w_pdfjs_require__(12);
var coreDocument = __w_pdfjs_require__(24);
var warn = sharedUtil.warn;
var createValidAbsoluteUrl = sharedUtil.createValidAbsoluteUrl;
var shadow = sharedUtil.shadow;
var NotImplementedException = sharedUtil.NotImplementedException;
var MissingDataException = sharedUtil.MissingDataException;
var createPromiseCapability = sharedUtil.createPromiseCapability;
var Util = sharedUtil.Util;
var Stream = coreStream.Stream;
var ChunkedStreamManager = coreChunkedStream.ChunkedStreamManager;
var PDFDocument = coreDocument.PDFDocument;
var BasePdfManager = function BasePdfManagerClosure() {
  function BasePdfManager() {
    throw new Error('Cannot initialize BaseManagerManager');
  }
  BasePdfManager.prototype = {
    get docId() {
      return this._docId;
    },
    get password() {
      return this._password;
    },
    get docBaseUrl() {
      var docBaseUrl = null;
      if (this._docBaseUrl) {
        var absoluteUrl = createValidAbsoluteUrl(this._docBaseUrl);
        if (absoluteUrl) {
          docBaseUrl = absoluteUrl.href;
        } else {
          warn('Invalid absolute docBaseUrl: "' + this._docBaseUrl + '".');
        }
      }
      return shadow(this, 'docBaseUrl', docBaseUrl);
    },
    onLoadedStream: function BasePdfManager_onLoadedStream() {
      throw new NotImplementedException();
    },
    ensureDoc: function BasePdfManager_ensureDoc(prop, args) {
      return this.ensure(this.pdfDocument, prop, args);
    },
    ensureXRef: function BasePdfManager_ensureXRef(prop, args) {
      return this.ensure(this.pdfDocument.xref, prop, args);
    },
    ensureCatalog: function BasePdfManager_ensureCatalog(prop, args) {
      return this.ensure(this.pdfDocument.catalog, prop, args);
    },
    getPage: function BasePdfManager_getPage(pageIndex) {
      return this.pdfDocument.getPage(pageIndex);
    },
    cleanup: function BasePdfManager_cleanup() {
      return this.pdfDocument.cleanup();
    },
    ensure: function BasePdfManager_ensure(obj, prop, args) {
      return new NotImplementedException();
    },
    requestRange: function BasePdfManager_requestRange(begin, end) {
      return new NotImplementedException();
    },
    requestLoadedStream: function BasePdfManager_requestLoadedStream() {
      return new NotImplementedException();
    },
    sendProgressiveData: function BasePdfManager_sendProgressiveData(chunk) {
      return new NotImplementedException();
    },
    updatePassword: function BasePdfManager_updatePassword(password) {
      this._password = password;
    },
    terminate: function BasePdfManager_terminate() {
      return new NotImplementedException();
    }
  };
  return BasePdfManager;
}();
var LocalPdfManager = function LocalPdfManagerClosure() {
  function LocalPdfManager(docId, data, password, evaluatorOptions, docBaseUrl) {
    this._docId = docId;
    this._password = password;
    this._docBaseUrl = docBaseUrl;
    this.evaluatorOptions = evaluatorOptions;
    var stream = new Stream(data);
    this.pdfDocument = new PDFDocument(this, stream);
    this._loadedStreamCapability = createPromiseCapability();
    this._loadedStreamCapability.resolve(stream);
  }
  Util.inherit(LocalPdfManager, BasePdfManager, {
    ensure: function LocalPdfManager_ensure(obj, prop, args) {
      return new Promise(function (resolve, reject) {
        try {
          var value = obj[prop];
          var result;
          if (typeof value === 'function') {
            result = value.apply(obj, args);
          } else {
            result = value;
          }
          resolve(result);
        } catch (e) {
          reject(e);
        }
      });
    },
    requestRange: function LocalPdfManager_requestRange(begin, end) {
      return Promise.resolve();
    },
    requestLoadedStream: function LocalPdfManager_requestLoadedStream() {},
    onLoadedStream: function LocalPdfManager_onLoadedStream() {
      return this._loadedStreamCapability.promise;
    },
    terminate: function LocalPdfManager_terminate() {}
  });
  return LocalPdfManager;
}();
var NetworkPdfManager = function NetworkPdfManagerClosure() {
  function NetworkPdfManager(docId, pdfNetworkStream, args, evaluatorOptions, docBaseUrl) {
    this._docId = docId;
    this._password = args.password;
    this._docBaseUrl = docBaseUrl;
    this.msgHandler = args.msgHandler;
    this.evaluatorOptions = evaluatorOptions;
    var params = {
      msgHandler: args.msgHandler,
      url: args.url,
      length: args.length,
      disableAutoFetch: args.disableAutoFetch,
      rangeChunkSize: args.rangeChunkSize
    };
    this.streamManager = new ChunkedStreamManager(pdfNetworkStream, params);
    this.pdfDocument = new PDFDocument(this, this.streamManager.getStream());
  }
  Util.inherit(NetworkPdfManager, BasePdfManager, {
    ensure: function NetworkPdfManager_ensure(obj, prop, args) {
      var pdfManager = this;
      return new Promise(function (resolve, reject) {
        function ensureHelper() {
          try {
            var result;
            var value = obj[prop];
            if (typeof value === 'function') {
              result = value.apply(obj, args);
            } else {
              result = value;
            }
            resolve(result);
          } catch (e) {
            if (!(e instanceof MissingDataException)) {
              reject(e);
              return;
            }
            pdfManager.streamManager.requestRange(e.begin, e.end).then(ensureHelper, reject);
          }
        }
        ensureHelper();
      });
    },
    requestRange: function NetworkPdfManager_requestRange(begin, end) {
      return this.streamManager.requestRange(begin, end);
    },
    requestLoadedStream: function NetworkPdfManager_requestLoadedStream() {
      this.streamManager.requestAllChunks();
    },
    sendProgressiveData: function NetworkPdfManager_sendProgressiveData(chunk) {
      this.streamManager.onReceiveData({ chunk: chunk });
    },
    onLoadedStream: function NetworkPdfManager_onLoadedStream() {
      return this.streamManager.onLoadedStream();
    },
    terminate: function NetworkPdfManager_terminate() {
      this.streamManager.abort();
    }
  });
  return NetworkPdfManager;
}();
exports.LocalPdfManager = LocalPdfManager;
exports.NetworkPdfManager = NetworkPdfManager;

/***/ }),
/* 34 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var corePrimitives = __w_pdfjs_require__(1);
var error = sharedUtil.error;
var isSpace = sharedUtil.isSpace;
var EOF = corePrimitives.EOF;
var PostScriptParser = function PostScriptParserClosure() {
  function PostScriptParser(lexer) {
    this.lexer = lexer;
    this.operators = [];
    this.token = null;
    this.prev = null;
  }
  PostScriptParser.prototype = {
    nextToken: function PostScriptParser_nextToken() {
      this.prev = this.token;
      this.token = this.lexer.getToken();
    },
    accept: function PostScriptParser_accept(type) {
      if (this.token.type === type) {
        this.nextToken();
        return true;
      }
      return false;
    },
    expect: function PostScriptParser_expect(type) {
      if (this.accept(type)) {
        return true;
      }
      error('Unexpected symbol: found ' + this.token.type + ' expected ' + type + '.');
    },
    parse: function PostScriptParser_parse() {
      this.nextToken();
      this.expect(PostScriptTokenTypes.LBRACE);
      this.parseBlock();
      this.expect(PostScriptTokenTypes.RBRACE);
      return this.operators;
    },
    parseBlock: function PostScriptParser_parseBlock() {
      while (true) {
        if (this.accept(PostScriptTokenTypes.NUMBER)) {
          this.operators.push(this.prev.value);
        } else if (this.accept(PostScriptTokenTypes.OPERATOR)) {
          this.operators.push(this.prev.value);
        } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
          this.parseCondition();
        } else {
          return;
        }
      }
    },
    parseCondition: function PostScriptParser_parseCondition() {
      var conditionLocation = this.operators.length;
      this.operators.push(null, null);
      this.parseBlock();
      this.expect(PostScriptTokenTypes.RBRACE);
      if (this.accept(PostScriptTokenTypes.IF)) {
        this.operators[conditionLocation] = this.operators.length;
        this.operators[conditionLocation + 1] = 'jz';
      } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
        var jumpLocation = this.operators.length;
        this.operators.push(null, null);
        var endOfTrue = this.operators.length;
        this.parseBlock();
        this.expect(PostScriptTokenTypes.RBRACE);
        this.expect(PostScriptTokenTypes.IFELSE);
        this.operators[jumpLocation] = this.operators.length;
        this.operators[jumpLocation + 1] = 'j';
        this.operators[conditionLocation] = endOfTrue;
        this.operators[conditionLocation + 1] = 'jz';
      } else {
        error('PS Function: error parsing conditional.');
      }
    }
  };
  return PostScriptParser;
}();
var PostScriptTokenTypes = {
  LBRACE: 0,
  RBRACE: 1,
  NUMBER: 2,
  OPERATOR: 3,
  IF: 4,
  IFELSE: 5
};
var PostScriptToken = function PostScriptTokenClosure() {
  function PostScriptToken(type, value) {
    this.type = type;
    this.value = value;
  }
  var opCache = Object.create(null);
  PostScriptToken.getOperator = function PostScriptToken_getOperator(op) {
    var opValue = opCache[op];
    if (opValue) {
      return opValue;
    }
    return opCache[op] = new PostScriptToken(PostScriptTokenTypes.OPERATOR, op);
  };
  PostScriptToken.LBRACE = new PostScriptToken(PostScriptTokenTypes.LBRACE, '{');
  PostScriptToken.RBRACE = new PostScriptToken(PostScriptTokenTypes.RBRACE, '}');
  PostScriptToken.IF = new PostScriptToken(PostScriptTokenTypes.IF, 'IF');
  PostScriptToken.IFELSE = new PostScriptToken(PostScriptTokenTypes.IFELSE, 'IFELSE');
  return PostScriptToken;
}();
var PostScriptLexer = function PostScriptLexerClosure() {
  function PostScriptLexer(stream) {
    this.stream = stream;
    this.nextChar();
    this.strBuf = [];
  }
  PostScriptLexer.prototype = {
    nextChar: function PostScriptLexer_nextChar() {
      return this.currentChar = this.stream.getByte();
    },
    getToken: function PostScriptLexer_getToken() {
      var comment = false;
      var ch = this.currentChar;
      while (true) {
        if (ch < 0) {
          return EOF;
        }
        if (comment) {
          if (ch === 0x0A || ch === 0x0D) {
            comment = false;
          }
        } else if (ch === 0x25) {
          comment = true;
        } else if (!isSpace(ch)) {
          break;
        }
        ch = this.nextChar();
      }
      switch (ch | 0) {
        case 0x30:
        case 0x31:
        case 0x32:
        case 0x33:
        case 0x34:
        case 0x35:
        case 0x36:
        case 0x37:
        case 0x38:
        case 0x39:
        case 0x2B:
        case 0x2D:
        case 0x2E:
          return new PostScriptToken(PostScriptTokenTypes.NUMBER, this.getNumber());
        case 0x7B:
          this.nextChar();
          return PostScriptToken.LBRACE;
        case 0x7D:
          this.nextChar();
          return PostScriptToken.RBRACE;
      }
      var strBuf = this.strBuf;
      strBuf.length = 0;
      strBuf[0] = String.fromCharCode(ch);
      while ((ch = this.nextChar()) >= 0 && (ch >= 0x41 && ch <= 0x5A || ch >= 0x61 && ch <= 0x7A)) {
        strBuf.push(String.fromCharCode(ch));
      }
      var str = strBuf.join('');
      switch (str.toLowerCase()) {
        case 'if':
          return PostScriptToken.IF;
        case 'ifelse':
          return PostScriptToken.IFELSE;
        default:
          return PostScriptToken.getOperator(str);
      }
    },
    getNumber: function PostScriptLexer_getNumber() {
      var ch = this.currentChar;
      var strBuf = this.strBuf;
      strBuf.length = 0;
      strBuf[0] = String.fromCharCode(ch);
      while ((ch = this.nextChar()) >= 0) {
        if (ch >= 0x30 && ch <= 0x39 || ch === 0x2D || ch === 0x2E) {
          strBuf.push(String.fromCharCode(ch));
        } else {
          break;
        }
      }
      var value = parseFloat(strBuf.join(''));
      if (isNaN(value)) {
        error('Invalid floating point number: ' + value);
      }
      return value;
    }
  };
  return PostScriptLexer;
}();
exports.PostScriptLexer = PostScriptLexer;
exports.PostScriptParser = PostScriptParser;

/***/ }),
/* 35 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var sharedUtil = __w_pdfjs_require__(0);
var coreStream = __w_pdfjs_require__(2);
var coreEncodings = __w_pdfjs_require__(4);
var warn = sharedUtil.warn;
var isSpace = sharedUtil.isSpace;
var Stream = coreStream.Stream;
var getEncoding = coreEncodings.getEncoding;
var HINTING_ENABLED = false;
var Type1CharString = function Type1CharStringClosure() {
  var COMMAND_MAP = {
    'hstem': [1],
    'vstem': [3],
    'vmoveto': [4],
    'rlineto': [5],
    'hlineto': [6],
    'vlineto': [7],
    'rrcurveto': [8],
    'callsubr': [10],
    'flex': [12, 35],
    'drop': [12, 18],
    'endchar': [14],
    'rmoveto': [21],
    'hmoveto': [22],
    'vhcurveto': [30],
    'hvcurveto': [31]
  };
  function Type1CharString() {
    this.width = 0;
    this.lsb = 0;
    this.flexing = false;
    this.output = [];
    this.stack = [];
  }
  Type1CharString.prototype = {
    convert: function Type1CharString_convert(encoded, subrs, seacAnalysisEnabled) {
      var count = encoded.length;
      var error = false;
      var wx, sbx, subrNumber;
      for (var i = 0; i < count; i++) {
        var value = encoded[i];
        if (value < 32) {
          if (value === 12) {
            value = (value << 8) + encoded[++i];
          }
          switch (value) {
            case 1:
              if (!HINTING_ENABLED) {
                this.stack = [];
                break;
              }
              error = this.executeCommand(2, COMMAND_MAP.hstem);
              break;
            case 3:
              if (!HINTING_ENABLED) {
                this.stack = [];
                break;
              }
              error = this.executeCommand(2, COMMAND_MAP.vstem);
              break;
            case 4:
              if (this.flexing) {
                if (this.stack.length < 1) {
                  error = true;
                  break;
                }
                var dy = this.stack.pop();
                this.stack.push(0, dy);
                break;
              }
              error = this.executeCommand(1, COMMAND_MAP.vmoveto);
              break;
            case 5:
              error = this.executeCommand(2, COMMAND_MAP.rlineto);
              break;
            case 6:
              error = this.executeCommand(1, COMMAND_MAP.hlineto);
              break;
            case 7:
              error = this.executeCommand(1, COMMAND_MAP.vlineto);
              break;
            case 8:
              error = this.executeCommand(6, COMMAND_MAP.rrcurveto);
              break;
            case 9:
              this.stack = [];
              break;
            case 10:
              if (this.stack.length < 1) {
                error = true;
                break;
              }
              subrNumber = this.stack.pop();
              error = this.convert(subrs[subrNumber], subrs, seacAnalysisEnabled);
              break;
            case 11:
              return error;
            case 13:
              if (this.stack.length < 2) {
                error = true;
                break;
              }
              wx = this.stack.pop();
              sbx = this.stack.pop();
              this.lsb = sbx;
              this.width = wx;
              this.stack.push(wx, sbx);
              error = this.executeCommand(2, COMMAND_MAP.hmoveto);
              break;
            case 14:
              this.output.push(COMMAND_MAP.endchar[0]);
              break;
            case 21:
              if (this.flexing) {
                break;
              }
              error = this.executeCommand(2, COMMAND_MAP.rmoveto);
              break;
            case 22:
              if (this.flexing) {
                this.stack.push(0);
                break;
              }
              error = this.executeCommand(1, COMMAND_MAP.hmoveto);
              break;
            case 30:
              error = this.executeCommand(4, COMMAND_MAP.vhcurveto);
              break;
            case 31:
              error = this.executeCommand(4, COMMAND_MAP.hvcurveto);
              break;
            case (12 << 8) + 0:
              this.stack = [];
              break;
            case (12 << 8) + 1:
              if (!HINTING_ENABLED) {
                this.stack = [];
                break;
              }
              error = this.executeCommand(2, COMMAND_MAP.vstem);
              break;
            case (12 << 8) + 2:
              if (!HINTING_ENABLED) {
                this.stack = [];
                break;
              }
              error = this.executeCommand(2, COMMAND_MAP.hstem);
              break;
            case (12 << 8) + 6:
              if (seacAnalysisEnabled) {
                this.seac = this.stack.splice(-4, 4);
                error = this.executeCommand(0, COMMAND_MAP.endchar);
              } else {
                error = this.executeCommand(4, COMMAND_MAP.endchar);
              }
              break;
            case (12 << 8) + 7:
              if (this.stack.length < 4) {
                error = true;
                break;
              }
              this.stack.pop();
              wx = this.stack.pop();
              var sby = this.stack.pop();
              sbx = this.stack.pop();
              this.lsb = sbx;
              this.width = wx;
              this.stack.push(wx, sbx, sby);
              error = this.executeCommand(3, COMMAND_MAP.rmoveto);
              break;
            case (12 << 8) + 12:
              if (this.stack.length < 2) {
                error = true;
                break;
              }
              var num2 = this.stack.pop();
              var num1 = this.stack.pop();
              this.stack.push(num1 / num2);
              break;
            case (12 << 8) + 16:
              if (this.stack.length < 2) {
                error = true;
                break;
              }
              subrNumber = this.stack.pop();
              var numArgs = this.stack.pop();
              if (subrNumber === 0 && numArgs === 3) {
                var flexArgs = this.stack.splice(this.stack.length - 17, 17);
                this.stack.push(flexArgs[2] + flexArgs[0], flexArgs[3] + flexArgs[1], flexArgs[4], flexArgs[5], flexArgs[6], flexArgs[7], flexArgs[8], flexArgs[9], flexArgs[10], flexArgs[11], flexArgs[12], flexArgs[13], flexArgs[14]);
                error = this.executeCommand(13, COMMAND_MAP.flex, true);
                this.flexing = false;
                this.stack.push(flexArgs[15], flexArgs[16]);
              } else if (subrNumber === 1 && numArgs === 0) {
                this.flexing = true;
              }
              break;
            case (12 << 8) + 17:
              break;
            case (12 << 8) + 33:
              this.stack = [];
              break;
            default:
              warn('Unknown type 1 charstring command of "' + value + '"');
              break;
          }
          if (error) {
            break;
          }
          continue;
        } else if (value <= 246) {
          value = value - 139;
        } else if (value <= 250) {
          value = (value - 247) * 256 + encoded[++i] + 108;
        } else if (value <= 254) {
          value = -((value - 251) * 256) - encoded[++i] - 108;
        } else {
          value = (encoded[++i] & 0xff) << 24 | (encoded[++i] & 0xff) << 16 | (encoded[++i] & 0xff) << 8 | (encoded[++i] & 0xff) << 0;
        }
        this.stack.push(value);
      }
      return error;
    },
    executeCommand: function executeCommand(howManyArgs, command, keepStack) {
      var stackLength = this.stack.length;
      if (howManyArgs > stackLength) {
        return true;
      }
      var start = stackLength - howManyArgs;
      for (var i = start; i < stackLength; i++) {
        var value = this.stack[i];
        if (value === (value | 0)) {
          this.output.push(28, value >> 8 & 0xff, value & 0xff);
        } else {
          value = 65536 * value | 0;
          this.output.push(255, value >> 24 & 0xFF, value >> 16 & 0xFF, value >> 8 & 0xFF, value & 0xFF);
        }
      }
      this.output.push.apply(this.output, command);
      if (keepStack) {
        this.stack.splice(start, howManyArgs);
      } else {
        this.stack.length = 0;
      }
      return false;
    }
  };
  return Type1CharString;
}();
var Type1Parser = function Type1ParserClosure() {
  var EEXEC_ENCRYPT_KEY = 55665;
  var CHAR_STRS_ENCRYPT_KEY = 4330;
  function isHexDigit(code) {
    return code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102;
  }
  function decrypt(data, key, discardNumber) {
    if (discardNumber >= data.length) {
      return new Uint8Array(0);
    }
    var r = key | 0,
        c1 = 52845,
        c2 = 22719,
        i,
        j;
    for (i = 0; i < discardNumber; i++) {
      r = (data[i] + r) * c1 + c2 & (1 << 16) - 1;
    }
    var count = data.length - discardNumber;
    var decrypted = new Uint8Array(count);
    for (i = discardNumber, j = 0; j < count; i++, j++) {
      var value = data[i];
      decrypted[j] = value ^ r >> 8;
      r = (value + r) * c1 + c2 & (1 << 16) - 1;
    }
    return decrypted;
  }
  function decryptAscii(data, key, discardNumber) {
    var r = key | 0,
        c1 = 52845,
        c2 = 22719;
    var count = data.length,
        maybeLength = count >>> 1;
    var decrypted = new Uint8Array(maybeLength);
    var i, j;
    for (i = 0, j = 0; i < count; i++) {
      var digit1 = data[i];
      if (!isHexDigit(digit1)) {
        continue;
      }
      i++;
      var digit2;
      while (i < count && !isHexDigit(digit2 = data[i])) {
        i++;
      }
      if (i < count) {
        var value = parseInt(String.fromCharCode(digit1, digit2), 16);
        decrypted[j++] = value ^ r >> 8;
        r = (value + r) * c1 + c2 & (1 << 16) - 1;
      }
    }
    return Array.prototype.slice.call(decrypted, discardNumber, j);
  }
  function isSpecial(c) {
    return c === 0x2F || c === 0x5B || c === 0x5D || c === 0x7B || c === 0x7D || c === 0x28 || c === 0x29;
  }
  function Type1Parser(stream, encrypted, seacAnalysisEnabled) {
    if (encrypted) {
      var data = stream.getBytes();
      var isBinary = !(isHexDigit(data[0]) && isHexDigit(data[1]) && isHexDigit(data[2]) && isHexDigit(data[3]));
      stream = new Stream(isBinary ? decrypt(data, EEXEC_ENCRYPT_KEY, 4) : decryptAscii(data, EEXEC_ENCRYPT_KEY, 4));
    }
    this.seacAnalysisEnabled = !!seacAnalysisEnabled;
    this.stream = stream;
    this.nextChar();
  }
  Type1Parser.prototype = {
    readNumberArray: function Type1Parser_readNumberArray() {
      this.getToken();
      var array = [];
      while (true) {
        var token = this.getToken();
        if (token === null || token === ']' || token === '}') {
          break;
        }
        array.push(parseFloat(token || 0));
      }
      return array;
    },
    readNumber: function Type1Parser_readNumber() {
      var token = this.getToken();
      return parseFloat(token || 0);
    },
    readInt: function Type1Parser_readInt() {
      var token = this.getToken();
      return parseInt(token || 0, 10) | 0;
    },
    readBoolean: function Type1Parser_readBoolean() {
      var token = this.getToken();
      return token === 'true' ? 1 : 0;
    },
    nextChar: function Type1_nextChar() {
      return this.currentChar = this.stream.getByte();
    },
    getToken: function Type1Parser_getToken() {
      var comment = false;
      var ch = this.currentChar;
      while (true) {
        if (ch === -1) {
          return null;
        }
        if (comment) {
          if (ch === 0x0A || ch === 0x0D) {
            comment = false;
          }
        } else if (ch === 0x25) {
          comment = true;
        } else if (!isSpace(ch)) {
          break;
        }
        ch = this.nextChar();
      }
      if (isSpecial(ch)) {
        this.nextChar();
        return String.fromCharCode(ch);
      }
      var token = '';
      do {
        token += String.fromCharCode(ch);
        ch = this.nextChar();
      } while (ch >= 0 && !isSpace(ch) && !isSpecial(ch));
      return token;
    },
    extractFontProgram: function Type1Parser_extractFontProgram() {
      var stream = this.stream;
      var subrs = [],
          charstrings = [];
      var privateData = Object.create(null);
      privateData['lenIV'] = 4;
      var program = {
        subrs: [],
        charstrings: [],
        properties: { 'privateData': privateData }
      };
      var token, length, data, lenIV, encoded;
      while ((token = this.getToken()) !== null) {
        if (token !== '/') {
          continue;
        }
        token = this.getToken();
        switch (token) {
          case 'CharStrings':
            this.getToken();
            this.getToken();
            this.getToken();
            this.getToken();
            while (true) {
              token = this.getToken();
              if (token === null || token === 'end') {
                break;
              }
              if (token !== '/') {
                continue;
              }
              var glyph = this.getToken();
              length = this.readInt();
              this.getToken();
              data = stream.makeSubStream(stream.pos, length);
              lenIV = program.properties.privateData['lenIV'];
              encoded = decrypt(data.getBytes(), CHAR_STRS_ENCRYPT_KEY, lenIV);
              stream.skip(length);
              this.nextChar();
              token = this.getToken();
              if (token === 'noaccess') {
                this.getToken();
              }
              charstrings.push({
                glyph: glyph,
                encoded: encoded
              });
            }
            break;
          case 'Subrs':
            this.readInt();
            this.getToken();
            while ((token = this.getToken()) === 'dup') {
              var index = this.readInt();
              length = this.readInt();
              this.getToken();
              data = stream.makeSubStream(stream.pos, length);
              lenIV = program.properties.privateData['lenIV'];
              encoded = decrypt(data.getBytes(), CHAR_STRS_ENCRYPT_KEY, lenIV);
              stream.skip(length);
              this.nextChar();
              token = this.getToken();
              if (token === 'noaccess') {
                this.getToken();
              }
              subrs[index] = encoded;
            }
            break;
          case 'BlueValues':
          case 'OtherBlues':
          case 'FamilyBlues':
          case 'FamilyOtherBlues':
            var blueArray = this.readNumberArray();
            if (blueArray.length > 0 && blueArray.length % 2 === 0 && HINTING_ENABLED) {
              program.properties.privateData[token] = blueArray;
            }
            break;
          case 'StemSnapH':
          case 'StemSnapV':
            program.properties.privateData[token] = this.readNumberArray();
            break;
          case 'StdHW':
          case 'StdVW':
            program.properties.privateData[token] = this.readNumberArray()[0];
            break;
          case 'BlueShift':
          case 'lenIV':
          case 'BlueFuzz':
          case 'BlueScale':
          case 'LanguageGroup':
          case 'ExpansionFactor':
            program.properties.privateData[token] = this.readNumber();
            break;
          case 'ForceBold':
            program.properties.privateData[token] = this.readBoolean();
            break;
        }
      }
      for (var i = 0; i < charstrings.length; i++) {
        glyph = charstrings[i].glyph;
        encoded = charstrings[i].encoded;
        var charString = new Type1CharString();
        var error = charString.convert(encoded, subrs, this.seacAnalysisEnabled);
        var output = charString.output;
        if (error) {
          output = [14];
        }
        program.charstrings.push({
          glyphName: glyph,
          charstring: output,
          width: charString.width,
          lsb: charString.lsb,
          seac: charString.seac
        });
      }
      return program;
    },
    extractFontHeader: function Type1Parser_extractFontHeader(properties) {
      var token;
      while ((token = this.getToken()) !== null) {
        if (token !== '/') {
          continue;
        }
        token = this.getToken();
        switch (token) {
          case 'FontMatrix':
            var matrix = this.readNumberArray();
            properties.fontMatrix = matrix;
            break;
          case 'Encoding':
            var encodingArg = this.getToken();
            var encoding;
            if (!/^\d+$/.test(encodingArg)) {
              encoding = getEncoding(encodingArg);
            } else {
              encoding = [];
              var size = parseInt(encodingArg, 10) | 0;
              this.getToken();
              for (var j = 0; j < size; j++) {
                token = this.getToken();
                while (token !== 'dup' && token !== 'def') {
                  token = this.getToken();
                  if (token === null) {
                    return;
                  }
                }
                if (token === 'def') {
                  break;
                }
                var index = this.readInt();
                this.getToken();
                var glyph = this.getToken();
                encoding[index] = glyph;
                this.getToken();
              }
            }
            properties.builtInEncoding = encoding;
            break;
          case 'FontBBox':
            var fontBBox = this.readNumberArray();
            properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
            properties.descent = Math.min(fontBBox[1], fontBBox[3]);
            properties.ascentScaled = true;
            break;
        }
      }
    }
  };
  return Type1Parser;
}();
exports.Type1Parser = Type1Parser;

/***/ }),
/* 36 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var pdfjsVersion = '1.8.233';
var pdfjsBuild = '19321937';
var pdfjsCoreWorker = __w_pdfjs_require__(8);
{
  __w_pdfjs_require__(19);
}
exports.WorkerMessageHandler = pdfjsCoreWorker.WorkerMessageHandler;

/***/ }),
/* 37 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (typeof PDFJS === 'undefined' || !PDFJS.compatibilityChecked) {
  var globalScope = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : undefined;
  var userAgent = typeof navigator !== 'undefined' && navigator.userAgent || '';
  var isAndroid = /Android/.test(userAgent);
  var isAndroidPre3 = /Android\s[0-2][^\d]/.test(userAgent);
  var isAndroidPre5 = /Android\s[0-4][^\d]/.test(userAgent);
  var isChrome = userAgent.indexOf('Chrom') >= 0;
  var isChromeWithRangeBug = /Chrome\/(39|40)\./.test(userAgent);
  var isIOSChrome = userAgent.indexOf('CriOS') >= 0;
  var isIE = userAgent.indexOf('Trident') >= 0;
  var isIOS = /\b(iPad|iPhone|iPod)(?=;)/.test(userAgent);
  var isOpera = userAgent.indexOf('Opera') >= 0;
  var isSafari = /Safari\//.test(userAgent) && !/(Chrome\/|Android\s)/.test(userAgent);
  var hasDOM = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && (typeof document === 'undefined' ? 'undefined' : _typeof(document)) === 'object';
  if (typeof PDFJS === 'undefined') {
    globalScope.PDFJS = {};
  }
  PDFJS.compatibilityChecked = true;
  (function checkTypedArrayCompatibility() {
    if (typeof Uint8Array !== 'undefined') {
      if (typeof Uint8Array.prototype.subarray === 'undefined') {
        Uint8Array.prototype.subarray = function subarray(start, end) {
          return new Uint8Array(this.slice(start, end));
        };
        Float32Array.prototype.subarray = function subarray(start, end) {
          return new Float32Array(this.slice(start, end));
        };
      }
      if (typeof Float64Array === 'undefined') {
        globalScope.Float64Array = Float32Array;
      }
      return;
    }
    function subarray(start, end) {
      return new TypedArray(this.slice(start, end));
    }
    function setArrayOffset(array, offset) {
      if (arguments.length < 2) {
        offset = 0;
      }
      for (var i = 0, n = array.length; i < n; ++i, ++offset) {
        this[offset] = array[i] & 0xFF;
      }
    }
    function Uint32ArrayView(buffer, length) {
      this.buffer = buffer;
      this.byteLength = buffer.length;
      this.length = length;
      ensureUint32ArrayViewProps(this.length);
    }
    Uint32ArrayView.prototype = Object.create(null);
    var uint32ArrayViewSetters = 0;
    function createUint32ArrayProp(index) {
      return {
        get: function get() {
          var buffer = this.buffer,
              offset = index << 2;
          return (buffer[offset] | buffer[offset + 1] << 8 | buffer[offset + 2] << 16 | buffer[offset + 3] << 24) >>> 0;
        },
        set: function set(value) {
          var buffer = this.buffer,
              offset = index << 2;
          buffer[offset] = value & 255;
          buffer[offset + 1] = value >> 8 & 255;
          buffer[offset + 2] = value >> 16 & 255;
          buffer[offset + 3] = value >>> 24 & 255;
        }
      };
    }
    function ensureUint32ArrayViewProps(length) {
      while (uint32ArrayViewSetters < length) {
        Object.defineProperty(Uint32ArrayView.prototype, uint32ArrayViewSetters, createUint32ArrayProp(uint32ArrayViewSetters));
        uint32ArrayViewSetters++;
      }
    }
    function TypedArray(arg1) {
      var result, i, n;
      if (typeof arg1 === 'number') {
        result = [];
        for (i = 0; i < arg1; ++i) {
          result[i] = 0;
        }
      } else if ('slice' in arg1) {
        result = arg1.slice(0);
      } else {
        result = [];
        for (i = 0, n = arg1.length; i < n; ++i) {
          result[i] = arg1[i];
        }
      }
      result.subarray = subarray;
      result.buffer = result;
      result.byteLength = result.length;
      result.set = setArrayOffset;
      if ((typeof arg1 === 'undefined' ? 'undefined' : _typeof(arg1)) === 'object' && arg1.buffer) {
        result.buffer = arg1.buffer;
      }
      return result;
    }
    globalScope.Uint8Array = TypedArray;
    globalScope.Int8Array = TypedArray;
    globalScope.Int32Array = TypedArray;
    globalScope.Uint16Array = TypedArray;
    globalScope.Float32Array = TypedArray;
    globalScope.Float64Array = TypedArray;
    globalScope.Uint32Array = function () {
      if (arguments.length === 3) {
        if (arguments[1] !== 0) {
          throw new Error('offset !== 0 is not supported');
        }
        return new Uint32ArrayView(arguments[0], arguments[2]);
      }
      return TypedArray.apply(this, arguments);
    };
  })();
  (function canvasPixelArrayBuffer() {
    if (!hasDOM || !window.CanvasPixelArray) {
      return;
    }
    var cpaProto = window.CanvasPixelArray.prototype;
    if ('buffer' in cpaProto) {
      return;
    }
    Object.defineProperty(cpaProto, 'buffer', {
      get: function get() {
        return this;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(cpaProto, 'byteLength', {
      get: function get() {
        return this.length;
      },
      enumerable: false,
      configurable: true
    });
  })();
  (function normalizeURLObject() {
    if (!globalScope.URL) {
      globalScope.URL = globalScope.webkitURL;
    }
  })();
  (function checkObjectDefinePropertyCompatibility() {
    if (typeof Object.defineProperty !== 'undefined') {
      var definePropertyPossible = true;
      try {
        if (hasDOM) {
          Object.defineProperty(new Image(), 'id', { value: 'test' });
        }
        var Test = function Test() {};
        Test.prototype = {
          get id() {}
        };
        Object.defineProperty(new Test(), 'id', {
          value: '',
          configurable: true,
          enumerable: true,
          writable: false
        });
      } catch (e) {
        definePropertyPossible = false;
      }
      if (definePropertyPossible) {
        return;
      }
    }
    Object.defineProperty = function objectDefineProperty(obj, name, def) {
      delete obj[name];
      if ('get' in def) {
        obj.__defineGetter__(name, def['get']);
      }
      if ('set' in def) {
        obj.__defineSetter__(name, def['set']);
      }
      if ('value' in def) {
        obj.__defineSetter__(name, function objectDefinePropertySetter(value) {
          this.__defineGetter__(name, function objectDefinePropertyGetter() {
            return value;
          });
          return value;
        });
        obj[name] = def.value;
      }
    };
  })();
  (function checkXMLHttpRequestResponseCompatibility() {
    if (typeof XMLHttpRequest === 'undefined') {
      return;
    }
    var xhrPrototype = XMLHttpRequest.prototype;
    var xhr = new XMLHttpRequest();
    if (!('overrideMimeType' in xhr)) {
      Object.defineProperty(xhrPrototype, 'overrideMimeType', {
        value: function xmlHttpRequestOverrideMimeType(mimeType) {}
      });
    }
    if ('responseType' in xhr) {
      return;
    }
    Object.defineProperty(xhrPrototype, 'responseType', {
      get: function xmlHttpRequestGetResponseType() {
        return this._responseType || 'text';
      },
      set: function xmlHttpRequestSetResponseType(value) {
        if (value === 'text' || value === 'arraybuffer') {
          this._responseType = value;
          if (value === 'arraybuffer' && typeof this.overrideMimeType === 'function') {
            this.overrideMimeType('text/plain; charset=x-user-defined');
          }
        }
      }
    });
    if (typeof VBArray !== 'undefined') {
      Object.defineProperty(xhrPrototype, 'response', {
        get: function xmlHttpRequestResponseGet() {
          if (this.responseType === 'arraybuffer') {
            return new Uint8Array(new VBArray(this.responseBody).toArray());
          }
          return this.responseText;
        }
      });
      return;
    }
    Object.defineProperty(xhrPrototype, 'response', {
      get: function xmlHttpRequestResponseGet() {
        if (this.responseType !== 'arraybuffer') {
          return this.responseText;
        }
        var text = this.responseText;
        var i,
            n = text.length;
        var result = new Uint8Array(n);
        for (i = 0; i < n; ++i) {
          result[i] = text.charCodeAt(i) & 0xFF;
        }
        return result.buffer;
      }
    });
  })();
  (function checkWindowBtoaCompatibility() {
    if ('btoa' in globalScope) {
      return;
    }
    var digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    globalScope.btoa = function (chars) {
      var buffer = '';
      var i, n;
      for (i = 0, n = chars.length; i < n; i += 3) {
        var b1 = chars.charCodeAt(i) & 0xFF;
        var b2 = chars.charCodeAt(i + 1) & 0xFF;
        var b3 = chars.charCodeAt(i + 2) & 0xFF;
        var d1 = b1 >> 2,
            d2 = (b1 & 3) << 4 | b2 >> 4;
        var d3 = i + 1 < n ? (b2 & 0xF) << 2 | b3 >> 6 : 64;
        var d4 = i + 2 < n ? b3 & 0x3F : 64;
        buffer += digits.charAt(d1) + digits.charAt(d2) + digits.charAt(d3) + digits.charAt(d4);
      }
      return buffer;
    };
  })();
  (function checkWindowAtobCompatibility() {
    if ('atob' in globalScope) {
      return;
    }
    var digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    globalScope.atob = function (input) {
      input = input.replace(/=+$/, '');
      if (input.length % 4 === 1) {
        throw new Error('bad atob input');
      }
      for (var bc = 0, bs, buffer, idx = 0, output = ''; buffer = input.charAt(idx++); ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
        buffer = digits.indexOf(buffer);
      }
      return output;
    };
  })();
  (function checkFunctionPrototypeBindCompatibility() {
    if (typeof Function.prototype.bind !== 'undefined') {
      return;
    }
    Function.prototype.bind = function functionPrototypeBind(obj) {
      var fn = this,
          headArgs = Array.prototype.slice.call(arguments, 1);
      var bound = function functionPrototypeBindBound() {
        var args = headArgs.concat(Array.prototype.slice.call(arguments));
        return fn.apply(obj, args);
      };
      return bound;
    };
  })();
  (function checkDatasetProperty() {
    if (!hasDOM) {
      return;
    }
    var div = document.createElement('div');
    if ('dataset' in div) {
      return;
    }
    Object.defineProperty(HTMLElement.prototype, 'dataset', {
      get: function get() {
        if (this._dataset) {
          return this._dataset;
        }
        var dataset = {};
        for (var j = 0, jj = this.attributes.length; j < jj; j++) {
          var attribute = this.attributes[j];
          if (attribute.name.substring(0, 5) !== 'data-') {
            continue;
          }
          var key = attribute.name.substring(5).replace(/\-([a-z])/g, function (all, ch) {
            return ch.toUpperCase();
          });
          dataset[key] = attribute.value;
        }
        Object.defineProperty(this, '_dataset', {
          value: dataset,
          writable: false,
          enumerable: false
        });
        return dataset;
      },
      enumerable: true
    });
  })();
  (function checkClassListProperty() {
    function changeList(element, itemName, add, remove) {
      var s = element.className || '';
      var list = s.split(/\s+/g);
      if (list[0] === '') {
        list.shift();
      }
      var index = list.indexOf(itemName);
      if (index < 0 && add) {
        list.push(itemName);
      }
      if (index >= 0 && remove) {
        list.splice(index, 1);
      }
      element.className = list.join(' ');
      return index >= 0;
    }
    if (!hasDOM) {
      return;
    }
    var div = document.createElement('div');
    if ('classList' in div) {
      return;
    }
    var classListPrototype = {
      add: function add(name) {
        changeList(this.element, name, true, false);
      },
      contains: function contains(name) {
        return changeList(this.element, name, false, false);
      },
      remove: function remove(name) {
        changeList(this.element, name, false, true);
      },
      toggle: function toggle(name) {
        changeList(this.element, name, true, true);
      }
    };
    Object.defineProperty(HTMLElement.prototype, 'classList', {
      get: function get() {
        if (this._classList) {
          return this._classList;
        }
        var classList = Object.create(classListPrototype, {
          element: {
            value: this,
            writable: false,
            enumerable: true
          }
        });
        Object.defineProperty(this, '_classList', {
          value: classList,
          writable: false,
          enumerable: false
        });
        return classList;
      },
      enumerable: true
    });
  })();
  (function checkWorkerConsoleCompatibility() {
    if (typeof importScripts === 'undefined' || 'console' in globalScope) {
      return;
    }
    var consoleTimer = {};
    var workerConsole = {
      log: function log() {
        var args = Array.prototype.slice.call(arguments);
        globalScope.postMessage({
          targetName: 'main',
          action: 'console_log',
          data: args
        });
      },
      error: function error() {
        var args = Array.prototype.slice.call(arguments);
        globalScope.postMessage({
          targetName: 'main',
          action: 'console_error',
          data: args
        });
      },
      time: function time(name) {
        consoleTimer[name] = Date.now();
      },
      timeEnd: function timeEnd(name) {
        var time = consoleTimer[name];
        if (!time) {
          throw new Error('Unknown timer name ' + name);
        }
        this.log('Timer:', name, Date.now() - time);
      }
    };
    globalScope.console = workerConsole;
  })();
  (function checkConsoleCompatibility() {
    if (!hasDOM) {
      return;
    }
    if (!('console' in window)) {
      window.console = {
        log: function log() {},
        error: function error() {},
        warn: function warn() {}
      };
      return;
    }
    if (!('bind' in console.log)) {
      console.log = function (fn) {
        return function (msg) {
          return fn(msg);
        };
      }(console.log);
      console.error = function (fn) {
        return function (msg) {
          return fn(msg);
        };
      }(console.error);
      console.warn = function (fn) {
        return function (msg) {
          return fn(msg);
        };
      }(console.warn);
      return;
    }
  })();
  (function checkOnClickCompatibility() {
    function ignoreIfTargetDisabled(event) {
      if (isDisabled(event.target)) {
        event.stopPropagation();
      }
    }
    function isDisabled(node) {
      return node.disabled || node.parentNode && isDisabled(node.parentNode);
    }
    if (isOpera) {
      document.addEventListener('click', ignoreIfTargetDisabled, true);
    }
  })();
  (function checkOnBlobSupport() {
    if (isIE || isIOSChrome) {
      PDFJS.disableCreateObjectURL = true;
    }
  })();
  (function checkNavigatorLanguage() {
    if (typeof navigator === 'undefined') {
      return;
    }
    if ('language' in navigator) {
      return;
    }
    PDFJS.locale = navigator.userLanguage || 'en-US';
  })();
  (function checkRangeRequests() {
    if (isSafari || isAndroidPre3 || isChromeWithRangeBug || isIOS) {
      PDFJS.disableRange = true;
      PDFJS.disableStream = true;
    }
  })();
  (function checkHistoryManipulation() {
    if (!hasDOM) {
      return;
    }
    if (!history.pushState || isAndroidPre3) {
      PDFJS.disableHistory = true;
    }
  })();
  (function checkSetPresenceInImageData() {
    if (!hasDOM) {
      return;
    }
    if (window.CanvasPixelArray) {
      if (typeof window.CanvasPixelArray.prototype.set !== 'function') {
        window.CanvasPixelArray.prototype.set = function (arr) {
          for (var i = 0, ii = this.length; i < ii; i++) {
            this[i] = arr[i];
          }
        };
      }
    } else {
      var polyfill = false,
          versionMatch;
      if (isChrome) {
        versionMatch = userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
        polyfill = versionMatch && parseInt(versionMatch[2]) < 21;
      } else if (isAndroid) {
        polyfill = isAndroidPre5;
      } else if (isSafari) {
        versionMatch = userAgent.match(/Version\/([0-9]+)\.([0-9]+)\.([0-9]+) Safari\//);
        polyfill = versionMatch && parseInt(versionMatch[1]) < 6;
      }
      if (polyfill) {
        var contextPrototype = window.CanvasRenderingContext2D.prototype;
        var createImageData = contextPrototype.createImageData;
        contextPrototype.createImageData = function (w, h) {
          var imageData = createImageData.call(this, w, h);
          imageData.data.set = function (arr) {
            for (var i = 0, ii = this.length; i < ii; i++) {
              this[i] = arr[i];
            }
          };
          return imageData;
        };
        contextPrototype = null;
      }
    }
  })();
  (function checkRequestAnimationFrame() {
    function installFakeAnimationFrameFunctions() {
      window.requestAnimationFrame = function (callback) {
        return window.setTimeout(callback, 20);
      };
      window.cancelAnimationFrame = function (timeoutID) {
        window.clearTimeout(timeoutID);
      };
    }
    if (!hasDOM) {
      return;
    }
    if (isIOS) {
      installFakeAnimationFrameFunctions();
      return;
    }
    if ('requestAnimationFrame' in window) {
      return;
    }
    window.requestAnimationFrame = window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
    if (window.requestAnimationFrame) {
      return;
    }
    installFakeAnimationFrameFunctions();
  })();
  (function checkCanvasSizeLimitation() {
    if (isIOS || isAndroid) {
      PDFJS.maxCanvasPixels = 5242880;
    }
  })();
  (function checkFullscreenSupport() {
    if (!hasDOM) {
      return;
    }
    if (isIE && window.parent !== window) {
      PDFJS.disableFullscreen = true;
    }
  })();
  (function checkCurrentScript() {
    if (!hasDOM) {
      return;
    }
    if ('currentScript' in document) {
      return;
    }
    Object.defineProperty(document, 'currentScript', {
      get: function get() {
        var scripts = document.getElementsByTagName('script');
        return scripts[scripts.length - 1];
      },
      enumerable: true,
      configurable: true
    });
  })();
  (function checkInputTypeNumberAssign() {
    if (!hasDOM) {
      return;
    }
    var el = document.createElement('input');
    try {
      el.type = 'number';
    } catch (ex) {
      var inputProto = el.constructor.prototype;
      var typeProperty = Object.getOwnPropertyDescriptor(inputProto, 'type');
      Object.defineProperty(inputProto, 'type', {
        get: function get() {
          return typeProperty.get.call(this);
        },
        set: function set(value) {
          typeProperty.set.call(this, value === 'number' ? 'text' : value);
        },
        enumerable: true,
        configurable: true
      });
    }
  })();
  (function checkDocumentReadyState() {
    if (!hasDOM) {
      return;
    }
    if (!document.attachEvent) {
      return;
    }
    var documentProto = document.constructor.prototype;
    var readyStateProto = Object.getOwnPropertyDescriptor(documentProto, 'readyState');
    Object.defineProperty(documentProto, 'readyState', {
      get: function get() {
        var value = readyStateProto.get.call(this);
        return value === 'interactive' ? 'loading' : value;
      },
      set: function set(value) {
        readyStateProto.set.call(this, value);
      },
      enumerable: true,
      configurable: true
    });
  })();
  (function checkChildNodeRemove() {
    if (!hasDOM) {
      return;
    }
    if (typeof Element.prototype.remove !== 'undefined') {
      return;
    }
    Element.prototype.remove = function () {
      if (this.parentNode) {
        this.parentNode.removeChild(this);
      }
    };
  })();
  (function checkPromise() {
    if (globalScope.Promise) {
      if (typeof globalScope.Promise.all !== 'function') {
        globalScope.Promise.all = function (iterable) {
          var count = 0,
              results = [],
              resolve,
              reject;
          var promise = new globalScope.Promise(function (resolve_, reject_) {
            resolve = resolve_;
            reject = reject_;
          });
          iterable.forEach(function (p, i) {
            count++;
            p.then(function (result) {
              results[i] = result;
              count--;
              if (count === 0) {
                resolve(results);
              }
            }, reject);
          });
          if (count === 0) {
            resolve(results);
          }
          return promise;
        };
      }
      if (typeof globalScope.Promise.resolve !== 'function') {
        globalScope.Promise.resolve = function (value) {
          return new globalScope.Promise(function (resolve) {
            resolve(value);
          });
        };
      }
      if (typeof globalScope.Promise.reject !== 'function') {
        globalScope.Promise.reject = function (reason) {
          return new globalScope.Promise(function (resolve, reject) {
            reject(reason);
          });
        };
      }
      if (typeof globalScope.Promise.prototype.catch !== 'function') {
        globalScope.Promise.prototype.catch = function (onReject) {
          return globalScope.Promise.prototype.then(undefined, onReject);
        };
      }
      return;
    }
    var STATUS_PENDING = 0;
    var STATUS_RESOLVED = 1;
    var STATUS_REJECTED = 2;
    var REJECTION_TIMEOUT = 500;
    var HandlerManager = {
      handlers: [],
      running: false,
      unhandledRejections: [],
      pendingRejectionCheck: false,
      scheduleHandlers: function scheduleHandlers(promise) {
        if (promise._status === STATUS_PENDING) {
          return;
        }
        this.handlers = this.handlers.concat(promise._handlers);
        promise._handlers = [];
        if (this.running) {
          return;
        }
        this.running = true;
        setTimeout(this.runHandlers.bind(this), 0);
      },
      runHandlers: function runHandlers() {
        var RUN_TIMEOUT = 1;
        var timeoutAt = Date.now() + RUN_TIMEOUT;
        while (this.handlers.length > 0) {
          var handler = this.handlers.shift();
          var nextStatus = handler.thisPromise._status;
          var nextValue = handler.thisPromise._value;
          try {
            if (nextStatus === STATUS_RESOLVED) {
              if (typeof handler.onResolve === 'function') {
                nextValue = handler.onResolve(nextValue);
              }
            } else if (typeof handler.onReject === 'function') {
              nextValue = handler.onReject(nextValue);
              nextStatus = STATUS_RESOLVED;
              if (handler.thisPromise._unhandledRejection) {
                this.removeUnhandeledRejection(handler.thisPromise);
              }
            }
          } catch (ex) {
            nextStatus = STATUS_REJECTED;
            nextValue = ex;
          }
          handler.nextPromise._updateStatus(nextStatus, nextValue);
          if (Date.now() >= timeoutAt) {
            break;
          }
        }
        if (this.handlers.length > 0) {
          setTimeout(this.runHandlers.bind(this), 0);
          return;
        }
        this.running = false;
      },
      addUnhandledRejection: function addUnhandledRejection(promise) {
        this.unhandledRejections.push({
          promise: promise,
          time: Date.now()
        });
        this.scheduleRejectionCheck();
      },
      removeUnhandeledRejection: function removeUnhandeledRejection(promise) {
        promise._unhandledRejection = false;
        for (var i = 0; i < this.unhandledRejections.length; i++) {
          if (this.unhandledRejections[i].promise === promise) {
            this.unhandledRejections.splice(i);
            i--;
          }
        }
      },
      scheduleRejectionCheck: function scheduleRejectionCheck() {
        if (this.pendingRejectionCheck) {
          return;
        }
        this.pendingRejectionCheck = true;
        setTimeout(function rejectionCheck() {
          this.pendingRejectionCheck = false;
          var now = Date.now();
          for (var i = 0; i < this.unhandledRejections.length; i++) {
            if (now - this.unhandledRejections[i].time > REJECTION_TIMEOUT) {
              var unhandled = this.unhandledRejections[i].promise._value;
              var msg = 'Unhandled rejection: ' + unhandled;
              if (unhandled.stack) {
                msg += '\n' + unhandled.stack;
              }
              try {
                throw new Error(msg);
              } catch (_) {
                console.warn(msg);
              }
              this.unhandledRejections.splice(i);
              i--;
            }
          }
          if (this.unhandledRejections.length) {
            this.scheduleRejectionCheck();
          }
        }.bind(this), REJECTION_TIMEOUT);
      }
    };
    var Promise = function Promise(resolver) {
      this._status = STATUS_PENDING;
      this._handlers = [];
      try {
        resolver.call(this, this._resolve.bind(this), this._reject.bind(this));
      } catch (e) {
        this._reject(e);
      }
    };
    Promise.all = function Promise_all(promises) {
      var resolveAll, rejectAll;
      var deferred = new Promise(function (resolve, reject) {
        resolveAll = resolve;
        rejectAll = reject;
      });
      var unresolved = promises.length;
      var results = [];
      if (unresolved === 0) {
        resolveAll(results);
        return deferred;
      }
      function reject(reason) {
        if (deferred._status === STATUS_REJECTED) {
          return;
        }
        results = [];
        rejectAll(reason);
      }
      for (var i = 0, ii = promises.length; i < ii; ++i) {
        var promise = promises[i];
        var resolve = function (i) {
          return function (value) {
            if (deferred._status === STATUS_REJECTED) {
              return;
            }
            results[i] = value;
            unresolved--;
            if (unresolved === 0) {
              resolveAll(results);
            }
          };
        }(i);
        if (Promise.isPromise(promise)) {
          promise.then(resolve, reject);
        } else {
          resolve(promise);
        }
      }
      return deferred;
    };
    Promise.isPromise = function Promise_isPromise(value) {
      return value && typeof value.then === 'function';
    };
    Promise.resolve = function Promise_resolve(value) {
      return new Promise(function (resolve) {
        resolve(value);
      });
    };
    Promise.reject = function Promise_reject(reason) {
      return new Promise(function (resolve, reject) {
        reject(reason);
      });
    };
    Promise.prototype = {
      _status: null,
      _value: null,
      _handlers: null,
      _unhandledRejection: null,
      _updateStatus: function Promise__updateStatus(status, value) {
        if (this._status === STATUS_RESOLVED || this._status === STATUS_REJECTED) {
          return;
        }
        if (status === STATUS_RESOLVED && Promise.isPromise(value)) {
          value.then(this._updateStatus.bind(this, STATUS_RESOLVED), this._updateStatus.bind(this, STATUS_REJECTED));
          return;
        }
        this._status = status;
        this._value = value;
        if (status === STATUS_REJECTED && this._handlers.length === 0) {
          this._unhandledRejection = true;
          HandlerManager.addUnhandledRejection(this);
        }
        HandlerManager.scheduleHandlers(this);
      },
      _resolve: function Promise_resolve(value) {
        this._updateStatus(STATUS_RESOLVED, value);
      },
      _reject: function Promise_reject(reason) {
        this._updateStatus(STATUS_REJECTED, reason);
      },
      then: function Promise_then(onResolve, onReject) {
        var nextPromise = new Promise(function (resolve, reject) {
          this.resolve = resolve;
          this.reject = reject;
        });
        this._handlers.push({
          thisPromise: this,
          onResolve: onResolve,
          onReject: onReject,
          nextPromise: nextPromise
        });
        HandlerManager.scheduleHandlers(this);
        return nextPromise;
      },
      catch: function Promise_catch(onReject) {
        return this.then(undefined, onReject);
      }
    };
    globalScope.Promise = Promise;
  })();
  (function checkWeakMap() {
    if (globalScope.WeakMap) {
      return;
    }
    var id = 0;
    function WeakMap() {
      this.id = '$weakmap' + id++;
    }
    WeakMap.prototype = {
      has: function has(obj) {
        return !!Object.getOwnPropertyDescriptor(obj, this.id);
      },
      get: function get(obj, defaultValue) {
        return this.has(obj) ? obj[this.id] : defaultValue;
      },
      set: function set(obj, value) {
        Object.defineProperty(obj, this.id, {
          value: value,
          enumerable: false,
          configurable: true
        });
      },
      delete: function _delete(obj) {
        delete obj[this.id];
      }
    };
    globalScope.WeakMap = WeakMap;
  })();
  (function checkURLConstructor() {
    var hasWorkingUrl = false;
    try {
      if (typeof URL === 'function' && _typeof(URL.prototype) === 'object' && 'origin' in URL.prototype) {
        var u = new URL('b', 'http://a');
        u.pathname = 'c%20d';
        hasWorkingUrl = u.href === 'http://a/c%20d';
      }
    } catch (e) {}
    if (hasWorkingUrl) {
      return;
    }
    var relative = Object.create(null);
    relative['ftp'] = 21;
    relative['file'] = 0;
    relative['gopher'] = 70;
    relative['http'] = 80;
    relative['https'] = 443;
    relative['ws'] = 80;
    relative['wss'] = 443;
    var relativePathDotMapping = Object.create(null);
    relativePathDotMapping['%2e'] = '.';
    relativePathDotMapping['.%2e'] = '..';
    relativePathDotMapping['%2e.'] = '..';
    relativePathDotMapping['%2e%2e'] = '..';
    function isRelativeScheme(scheme) {
      return relative[scheme] !== undefined;
    }
    function invalid() {
      clear.call(this);
      this._isInvalid = true;
    }
    function IDNAToASCII(h) {
      if (h === '') {
        invalid.call(this);
      }
      return h.toLowerCase();
    }
    function percentEscape(c) {
      var unicode = c.charCodeAt(0);
      if (unicode > 0x20 && unicode < 0x7F && [0x22, 0x23, 0x3C, 0x3E, 0x3F, 0x60].indexOf(unicode) === -1) {
        return c;
      }
      return encodeURIComponent(c);
    }
    function percentEscapeQuery(c) {
      var unicode = c.charCodeAt(0);
      if (unicode > 0x20 && unicode < 0x7F && [0x22, 0x23, 0x3C, 0x3E, 0x60].indexOf(unicode) === -1) {
        return c;
      }
      return encodeURIComponent(c);
    }
    var EOF,
        ALPHA = /[a-zA-Z]/,
        ALPHANUMERIC = /[a-zA-Z0-9\+\-\.]/;
    function parse(input, stateOverride, base) {
      function err(message) {
        errors.push(message);
      }
      var state = stateOverride || 'scheme start',
          cursor = 0,
          buffer = '',
          seenAt = false,
          seenBracket = false,
          errors = [];
      loop: while ((input[cursor - 1] !== EOF || cursor === 0) && !this._isInvalid) {
        var c = input[cursor];
        switch (state) {
          case 'scheme start':
            if (c && ALPHA.test(c)) {
              buffer += c.toLowerCase();
              state = 'scheme';
            } else if (!stateOverride) {
              buffer = '';
              state = 'no scheme';
              continue;
            } else {
              err('Invalid scheme.');
              break loop;
            }
            break;
          case 'scheme':
            if (c && ALPHANUMERIC.test(c)) {
              buffer += c.toLowerCase();
            } else if (c === ':') {
              this._scheme = buffer;
              buffer = '';
              if (stateOverride) {
                break loop;
              }
              if (isRelativeScheme(this._scheme)) {
                this._isRelative = true;
              }
              if (this._scheme === 'file') {
                state = 'relative';
              } else if (this._isRelative && base && base._scheme === this._scheme) {
                state = 'relative or authority';
              } else if (this._isRelative) {
                state = 'authority first slash';
              } else {
                state = 'scheme data';
              }
            } else if (!stateOverride) {
              buffer = '';
              cursor = 0;
              state = 'no scheme';
              continue;
            } else if (c === EOF) {
              break loop;
            } else {
              err('Code point not allowed in scheme: ' + c);
              break loop;
            }
            break;
          case 'scheme data':
            if (c === '?') {
              this._query = '?';
              state = 'query';
            } else if (c === '#') {
              this._fragment = '#';
              state = 'fragment';
            } else {
              if (c !== EOF && c !== '\t' && c !== '\n' && c !== '\r') {
                this._schemeData += percentEscape(c);
              }
            }
            break;
          case 'no scheme':
            if (!base || !isRelativeScheme(base._scheme)) {
              err('Missing scheme.');
              invalid.call(this);
            } else {
              state = 'relative';
              continue;
            }
            break;
          case 'relative or authority':
            if (c === '/' && input[cursor + 1] === '/') {
              state = 'authority ignore slashes';
            } else {
              err('Expected /, got: ' + c);
              state = 'relative';
              continue;
            }
            break;
          case 'relative':
            this._isRelative = true;
            if (this._scheme !== 'file') {
              this._scheme = base._scheme;
            }
            if (c === EOF) {
              this._host = base._host;
              this._port = base._port;
              this._path = base._path.slice();
              this._query = base._query;
              this._username = base._username;
              this._password = base._password;
              break loop;
            } else if (c === '/' || c === '\\') {
              if (c === '\\') {
                err('\\ is an invalid code point.');
              }
              state = 'relative slash';
            } else if (c === '?') {
              this._host = base._host;
              this._port = base._port;
              this._path = base._path.slice();
              this._query = '?';
              this._username = base._username;
              this._password = base._password;
              state = 'query';
            } else if (c === '#') {
              this._host = base._host;
              this._port = base._port;
              this._path = base._path.slice();
              this._query = base._query;
              this._fragment = '#';
              this._username = base._username;
              this._password = base._password;
              state = 'fragment';
            } else {
              var nextC = input[cursor + 1];
              var nextNextC = input[cursor + 2];
              if (this._scheme !== 'file' || !ALPHA.test(c) || nextC !== ':' && nextC !== '|' || nextNextC !== EOF && nextNextC !== '/' && nextNextC !== '\\' && nextNextC !== '?' && nextNextC !== '#') {
                this._host = base._host;
                this._port = base._port;
                this._username = base._username;
                this._password = base._password;
                this._path = base._path.slice();
                this._path.pop();
              }
              state = 'relative path';
              continue;
            }
            break;
          case 'relative slash':
            if (c === '/' || c === '\\') {
              if (c === '\\') {
                err('\\ is an invalid code point.');
              }
              if (this._scheme === 'file') {
                state = 'file host';
              } else {
                state = 'authority ignore slashes';
              }
            } else {
              if (this._scheme !== 'file') {
                this._host = base._host;
                this._port = base._port;
                this._username = base._username;
                this._password = base._password;
              }
              state = 'relative path';
              continue;
            }
            break;
          case 'authority first slash':
            if (c === '/') {
              state = 'authority second slash';
            } else {
              err('Expected \'/\', got: ' + c);
              state = 'authority ignore slashes';
              continue;
            }
            break;
          case 'authority second slash':
            state = 'authority ignore slashes';
            if (c !== '/') {
              err('Expected \'/\', got: ' + c);
              continue;
            }
            break;
          case 'authority ignore slashes':
            if (c !== '/' && c !== '\\') {
              state = 'authority';
              continue;
            } else {
              err('Expected authority, got: ' + c);
            }
            break;
          case 'authority':
            if (c === '@') {
              if (seenAt) {
                err('@ already seen.');
                buffer += '%40';
              }
              seenAt = true;
              for (var i = 0; i < buffer.length; i++) {
                var cp = buffer[i];
                if (cp === '\t' || cp === '\n' || cp === '\r') {
                  err('Invalid whitespace in authority.');
                  continue;
                }
                if (cp === ':' && this._password === null) {
                  this._password = '';
                  continue;
                }
                var tempC = percentEscape(cp);
                if (this._password !== null) {
                  this._password += tempC;
                } else {
                  this._username += tempC;
                }
              }
              buffer = '';
            } else if (c === EOF || c === '/' || c === '\\' || c === '?' || c === '#') {
              cursor -= buffer.length;
              buffer = '';
              state = 'host';
              continue;
            } else {
              buffer += c;
            }
            break;
          case 'file host':
            if (c === EOF || c === '/' || c === '\\' || c === '?' || c === '#') {
              if (buffer.length === 2 && ALPHA.test(buffer[0]) && (buffer[1] === ':' || buffer[1] === '|')) {
                state = 'relative path';
              } else if (buffer.length === 0) {
                state = 'relative path start';
              } else {
                this._host = IDNAToASCII.call(this, buffer);
                buffer = '';
                state = 'relative path start';
              }
              continue;
            } else if (c === '\t' || c === '\n' || c === '\r') {
              err('Invalid whitespace in file host.');
            } else {
              buffer += c;
            }
            break;
          case 'host':
          case 'hostname':
            if (c === ':' && !seenBracket) {
              this._host = IDNAToASCII.call(this, buffer);
              buffer = '';
              state = 'port';
              if (stateOverride === 'hostname') {
                break loop;
              }
            } else if (c === EOF || c === '/' || c === '\\' || c === '?' || c === '#') {
              this._host = IDNAToASCII.call(this, buffer);
              buffer = '';
              state = 'relative path start';
              if (stateOverride) {
                break loop;
              }
              continue;
            } else if (c !== '\t' && c !== '\n' && c !== '\r') {
              if (c === '[') {
                seenBracket = true;
              } else if (c === ']') {
                seenBracket = false;
              }
              buffer += c;
            } else {
              err('Invalid code point in host/hostname: ' + c);
            }
            break;
          case 'port':
            if (/[0-9]/.test(c)) {
              buffer += c;
            } else if (c === EOF || c === '/' || c === '\\' || c === '?' || c === '#' || stateOverride) {
              if (buffer !== '') {
                var temp = parseInt(buffer, 10);
                if (temp !== relative[this._scheme]) {
                  this._port = temp + '';
                }
                buffer = '';
              }
              if (stateOverride) {
                break loop;
              }
              state = 'relative path start';
              continue;
            } else if (c === '\t' || c === '\n' || c === '\r') {
              err('Invalid code point in port: ' + c);
            } else {
              invalid.call(this);
            }
            break;
          case 'relative path start':
            if (c === '\\') {
              err('\'\\\' not allowed in path.');
            }
            state = 'relative path';
            if (c !== '/' && c !== '\\') {
              continue;
            }
            break;
          case 'relative path':
            if (c === EOF || c === '/' || c === '\\' || !stateOverride && (c === '?' || c === '#')) {
              if (c === '\\') {
                err('\\ not allowed in relative path.');
              }
              var tmp;
              if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {
                buffer = tmp;
              }
              if (buffer === '..') {
                this._path.pop();
                if (c !== '/' && c !== '\\') {
                  this._path.push('');
                }
              } else if (buffer === '.' && c !== '/' && c !== '\\') {
                this._path.push('');
              } else if (buffer !== '.') {
                if (this._scheme === 'file' && this._path.length === 0 && buffer.length === 2 && ALPHA.test(buffer[0]) && buffer[1] === '|') {
                  buffer = buffer[0] + ':';
                }
                this._path.push(buffer);
              }
              buffer = '';
              if (c === '?') {
                this._query = '?';
                state = 'query';
              } else if (c === '#') {
                this._fragment = '#';
                state = 'fragment';
              }
            } else if (c !== '\t' && c !== '\n' && c !== '\r') {
              buffer += percentEscape(c);
            }
            break;
          case 'query':
            if (!stateOverride && c === '#') {
              this._fragment = '#';
              state = 'fragment';
            } else if (c !== EOF && c !== '\t' && c !== '\n' && c !== '\r') {
              this._query += percentEscapeQuery(c);
            }
            break;
          case 'fragment':
            if (c !== EOF && c !== '\t' && c !== '\n' && c !== '\r') {
              this._fragment += c;
            }
            break;
        }
        cursor++;
      }
    }
    function clear() {
      this._scheme = '';
      this._schemeData = '';
      this._username = '';
      this._password = null;
      this._host = '';
      this._port = '';
      this._path = [];
      this._query = '';
      this._fragment = '';
      this._isInvalid = false;
      this._isRelative = false;
    }
    function JURL(url, base) {
      if (base !== undefined && !(base instanceof JURL)) {
        base = new JURL(String(base));
      }
      this._url = url;
      clear.call(this);
      var input = url.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, '');
      parse.call(this, input, null, base);
    }
    JURL.prototype = {
      toString: function toString() {
        return this.href;
      },
      get href() {
        if (this._isInvalid) {
          return this._url;
        }
        var authority = '';
        if (this._username !== '' || this._password !== null) {
          authority = this._username + (this._password !== null ? ':' + this._password : '') + '@';
        }
        return this.protocol + (this._isRelative ? '//' + authority + this.host : '') + this.pathname + this._query + this._fragment;
      },
      set href(href) {
        clear.call(this);
        parse.call(this, href);
      },
      get protocol() {
        return this._scheme + ':';
      },
      set protocol(protocol) {
        if (this._isInvalid) {
          return;
        }
        parse.call(this, protocol + ':', 'scheme start');
      },
      get host() {
        return this._isInvalid ? '' : this._port ? this._host + ':' + this._port : this._host;
      },
      set host(host) {
        if (this._isInvalid || !this._isRelative) {
          return;
        }
        parse.call(this, host, 'host');
      },
      get hostname() {
        return this._host;
      },
      set hostname(hostname) {
        if (this._isInvalid || !this._isRelative) {
          return;
        }
        parse.call(this, hostname, 'hostname');
      },
      get port() {
        return this._port;
      },
      set port(port) {
        if (this._isInvalid || !this._isRelative) {
          return;
        }
        parse.call(this, port, 'port');
      },
      get pathname() {
        return this._isInvalid ? '' : this._isRelative ? '/' + this._path.join('/') : this._schemeData;
      },
      set pathname(pathname) {
        if (this._isInvalid || !this._isRelative) {
          return;
        }
        this._path = [];
        parse.call(this, pathname, 'relative path start');
      },
      get search() {
        return this._isInvalid || !this._query || this._query === '?' ? '' : this._query;
      },
      set search(search) {
        if (this._isInvalid || !this._isRelative) {
          return;
        }
        this._query = '?';
        if (search[0] === '?') {
          search = search.slice(1);
        }
        parse.call(this, search, 'query');
      },
      get hash() {
        return this._isInvalid || !this._fragment || this._fragment === '#' ? '' : this._fragment;
      },
      set hash(hash) {
        if (this._isInvalid) {
          return;
        }
        this._fragment = '#';
        if (hash[0] === '#') {
          hash = hash.slice(1);
        }
        parse.call(this, hash, 'fragment');
      },
      get origin() {
        var host;
        if (this._isInvalid || !this._scheme) {
          return '';
        }
        switch (this._scheme) {
          case 'data':
          case 'file':
          case 'javascript':
          case 'mailto':
            return 'null';
        }
        host = this.host;
        if (!host) {
          return '';
        }
        return this._scheme + '://' + host;
      }
    };
    var OriginalURL = globalScope.URL;
    if (OriginalURL) {
      JURL.createObjectURL = function (blob) {
        return OriginalURL.createObjectURL.apply(OriginalURL, arguments);
      };
      JURL.revokeObjectURL = function (url) {
        OriginalURL.revokeObjectURL(url);
      };
    }
    globalScope.URL = JURL;
  })();
}
/* WEBPACK VAR INJECTION */}.call(exports, __w_pdfjs_require__(9)))

/***/ })
/******/ ]);
});
}).call(this,require('_process'))
},{"_process":8}],4:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],5:[function(require,module,exports){

},{}],6:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (value instanceof ArrayBuffer) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (isArrayBufferView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (isArrayBufferView(string) || string instanceof ArrayBuffer) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`
function isArrayBufferView (obj) {
  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":4,"ieee754":7}],7:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],8:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}]},{},[1]);
